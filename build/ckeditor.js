!(function (t) {
  const e = (t.en = t.en || {});
  e.dictionary = Object.assign(e.dictionary || {}, {
    "%0 of %1": "%0 of %1",
    Aquamarine: "Aquamarine",
    Black: "Black",
    "Block quote": "Block quote",
    Blue: "Blue",
    Bold: "Bold",
    "Break text": "Break text",
    "Bulleted List": "Bulleted List",
    Cancel: "Cancel",
    "Centered image": "Centered image",
    "Change image text alternative": "Change image text alternative",
    "Choose heading": "Choose heading",
    Code: "Code",
    Column: "Column",
    "Decrease indent": "Decrease indent",
    "Delete column": "Delete column",
    "Delete row": "Delete row",
    "Dim grey": "Dim grey",
    "Document colors": "Document colors",
    Downloadable: "Downloadable",
    "Dropdown toolbar": "Dropdown toolbar",
    "Edit block": "Edit block",
    "Edit link": "Edit link",
    "Editor toolbar": "Editor toolbar",
    "Enter image caption": "Enter image caption",
    Find: "Find",
    "Find and replace": "Find and replace",
    "Find in text…": "Find in text…",
    "Font Background Color": "Font Background Color",
    "Font Color": "Font Color",
    "Full size image": "Full size image",
    Green: "Green",
    Grey: "Grey",
    "Header column": "Header column",
    "Header row": "Header row",
    Heading: "Heading",
    "Heading 1": "Heading 1",
    "Heading 2": "Heading 2",
    "Heading 3": "Heading 3",
    "Heading 4": "Heading 4",
    "Heading 5": "Heading 5",
    "Heading 6": "Heading 6",
    "Horizontal line": "Horizontal line",
    "HTML object": "HTML object",
    "Image toolbar": "Image toolbar",
    "image widget": "image widget",
    "In line": "In line",
    "Increase indent": "Increase indent",
    Insert: "Insert",
    "Insert code block": "Insert code block",
    "Insert column left": "Insert column left",
    "Insert column right": "Insert column right",
    "Insert image": "Insert image",
    "Insert image via URL": "Insert image via URL",
    "Insert media": "Insert media",
    "Insert paragraph after block": "Insert paragraph after block",
    "Insert paragraph before block": "Insert paragraph before block",
    "Insert row above": "Insert row above",
    "Insert row below": "Insert row below",
    "Insert table": "Insert table",
    Italic: "Italic",
    "Left aligned image": "Left aligned image",
    "Light blue": "Light blue",
    "Light green": "Light green",
    "Light grey": "Light grey",
    Link: "Link",
    "Link URL": "Link URL",
    "Match case": "Match case",
    "Media URL": "Media URL",
    "media widget": "media widget",
    "Merge cell down": "Merge cell down",
    "Merge cell left": "Merge cell left",
    "Merge cell right": "Merge cell right",
    "Merge cell up": "Merge cell up",
    "Merge cells": "Merge cells",
    Next: "Next",
    "Next result": "Next result",
    "Numbered List": "Numbered List",
    "Open in a new tab": "Open in a new tab",
    "Open link in new tab": "Open link in new tab",
    Orange: "Orange",
    Paragraph: "Paragraph",
    "Paste the media URL in the input.": "Paste the media URL in the input.",
    "Plain text": "Plain text",
    Previous: "Previous",
    "Previous result": "Previous result",
    Purple: "Purple",
    Red: "Red",
    Redo: "Redo",
    "Remove color": "Remove color",
    "Remove Format": "Remove Format",
    Replace: "Replace",
    "Replace all": "Replace all",
    "Replace with…": "Replace with…",
    "Rich Text Editor": "Rich Text Editor",
    "Rich Text Editor, %0": "Rich Text Editor, %0",
    "Right aligned image": "Right aligned image",
    Row: "Row",
    Save: "Save",
    "Select all": "Select all",
    "Select column": "Select column",
    "Select row": "Select row",
    "Show more items": "Show more items",
    "Show options": "Show options",
    "Side image": "Side image",
    Source: "Source",
    "Split cell horizontally": "Split cell horizontally",
    "Split cell vertically": "Split cell vertically",
    Strikethrough: "Strikethrough",
    Subscript: "Subscript",
    Superscript: "Superscript",
    "Table toolbar": "Table toolbar",
    "Text alternative": "Text alternative",
    "Text to find must not be empty.": "Text to find must not be empty.",
    "The URL must not be empty.": "The URL must not be empty.",
    "This link has no URL": "This link has no URL",
    "This media URL is not supported.": "This media URL is not supported.",
    "Tip: Find some text first in order to replace it.":
      "Tip: Find some text first in order to replace it.",
    "Tip: Paste the URL into the content to embed faster.":
      "Tip: Paste the URL into the content to embed faster.",
    "Toggle caption off": "Toggle caption off",
    "Toggle caption on": "Toggle caption on",
    Turquoise: "Turquoise",
    Underline: "Underline",
    Undo: "Undo",
    Unlink: "Unlink",
    Update: "Update",
    "Update image URL": "Update image URL",
    "Upload failed": "Upload failed",
    "Upload in progress": "Upload in progress",
    White: "White",
    "Whole words only": "Whole words only",
    "Widget toolbar": "Widget toolbar",
    "Wrap text": "Wrap text",
    Yellow: "Yellow",
  });
})(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {})),
  /*!
   * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md.
   */
  (function (t, e) {
    "object" == typeof exports && "object" == typeof module
      ? (module.exports = e())
      : "function" == typeof define && define.amd
      ? define([], e)
      : "object" == typeof exports
      ? (exports.ClassicEditor = e())
      : (t.ClassicEditor = e());
  })(self, () =>
    (() => {
      var t = {
          4944: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-insert-image-form{align-items:flex-end;display:flex;flex-direction:row;flex-wrap:nowrap;padding:var(--ck-spacing-large)}[dir=ltr] .ck.ck-insert-image-form>:not(:first-child),[dir=rtl] .ck.ck-insert-image-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}.ck .ck-fake-only-insert-image-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-only-insert-image-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./ckeditor5-insert-image/theme/onlyinsertimageform.css",
                ],
                names: [],
                mappings:
                  "AAAA,yBAII,oBAAqB,CADrB,YAAa,CAEb,kBAAmB,CACnB,gBAAiB,CALjB,+BAMJ,CAEA,2GACI,sCACJ,CAMA,yCACC,8CACD,CAGA,mDAEC,gDAAiD,CADjD,WAAY,CAEZ,iBAAkB,CAClB,oCACD",
                sourcesContent: [
                  '.ck.ck-insert-image-form {\n    padding: var(--ck-spacing-large);\n\n    display: flex;\n    align-items: flex-end;\n    flex-direction: row;\n    flex-wrap: nowrap;\n}\n\n[dir=ltr] .ck.ck-insert-image-form>:not(:first-child), [dir=rtl] .ck.ck-insert-image-form>:not(:last-child) {\n    margin-left: var(--ck-spacing-standard);\n}\n\n\n/*\n * Classes used by the "fake visual selection" displayed in the content when the balloon is focused.\n */\n.ck .ck-fake-only-insert-image-selection {\n\tbackground: var(--ck-color-link-fake-selection);\n}\n\n/* A collapsed fake visual selection. */\n.ck .ck-fake-only-insert-image-selection_collapsed {\n\theight: 100%;\n\tborder-right: 1px solid var(--ck-color-base-text);\n\tmargin-right: -1px;\n\toutline: solid 1px hsla(0, 0%, 100%, .5);\n}',
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          8180: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck-content code{background-color:hsla(0,0%,78%,.3);border-radius:2px;padding:.15em}.ck.ck-editor__editable .ck-code_selected{background-color:hsla(0,0%,78%,.5)}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-basic-styles/theme/code.css",
                ],
                names: [],
                mappings:
                  "AAKA,iBACC,kCAAuC,CAEvC,iBAAkB,CADlB,aAED,CAEA,0CACC,kCACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content code {\n\tbackground-color: hsla(0, 0%, 78%, 0.3);\n\tpadding: .15em;\n\tborder-radius: 2px;\n}\n\n.ck.ck-editor__editable .ck-code_selected  {\n\tbackground-color: hsla(0, 0%, 78%, 0.5);\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          636: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck-content blockquote{border-left:5px solid #ccc;font-style:italic;margin-left:0;margin-right:0;overflow:hidden;padding-left:1.5em;padding-right:1.5em}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-block-quote/theme/blockquote.css",
                ],
                names: [],
                mappings:
                  "AAKA,uBAWC,0BAAsC,CADtC,iBAAkB,CAFlB,aAAc,CACd,cAAe,CAPf,eAAgB,CAIhB,kBAAmB,CADnB,mBAOD,CAEA,gCACC,aAAc,CACd,2BACD",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content blockquote {\n\t/* See #12 */\n\toverflow: hidden;\n\n\t/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */\n\tpadding-right: 1.5em;\n\tpadding-left: 1.5em;\n\n\tmargin-left: 0;\n\tmargin-right: 0;\n\tfont-style: italic;\n\tborder-left: solid 5px hsl(0, 0%, 80%);\n}\n\n.ck-content[dir="rtl"] blockquote {\n\tborder-left: 0;\n\tborder-right: solid 5px hsl(0, 0%, 80%);\n}\n',
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          390: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}',
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-clipboard/theme/clipboard.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css",
                ],
                names: [],
                mappings:
                  "AASC,8DACC,cAAe,CAEf,mBAAoB,CADpB,iBAOD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CCzBF,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEAIC,gDAAiD,CADjD,sDAAuD,CAFvD,2DAA8D,CAI9D,gBAAiB,CAHjB,wDAqBD,CAfC,yEAWC,sFAAuF,CAEvF,kBAAmB,CADnB,qKAA0K,CAX1K,UAAW,CAIX,aAAc,CAFd,QAAS,CAIT,QAAS,CADT,iBAAkB,CAElB,wDAA2D,CAE3D,0BAA2B,CAR3B,OAYD,CA2DF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: inline;\n\t\tposition: relative;\n\t\tpointer-events: none;\n\n\t\t& span {\n\t\t\tposition: absolute;\n\t\t\twidth: 0;\n\t\t}\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\t& > .ck-widget__selection-handle {\n\t\t\tdisplay: none;\n\t\t}\n\n\t\t& > .ck-widget__type-around {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-clipboard-drop-target-dot-width: 12px;\n\t--ck-clipboard-drop-target-dot-height: 8px;\n\t--ck-clipboard-drop-target-color: var(--ck-color-focus-border)\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Vertical drop target (in text).\n\t */\n\t& .ck.ck-clipboard-drop-target-position {\n\t\t& span {\n\t\t\tbottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\ttop: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tbackground: var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-left: -1px;\n\n\t\t\t/* The triangle above the marker */\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: 50%;\n\t\t\t\ttop: calc(var(--ck-clipboard-drop-target-dot-height) * -.5);\n\n\t\t\t\ttransform: translateX(-50%);\n\t\t\t\tborder-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;\n\t\t\t\tborder-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t// Horizontal drop target (between blocks).\n\t& .ck.ck-clipboard-drop-target-position {\n\t\tdisplay: block;\n\t\tposition: relative;\n\t\twidth: 100%;\n\t\theight: 0;\n\t\tmargin: 0;\n\t\ttext-align: initial;\n\n\t\t& .ck-clipboard-drop-target__line {\n\t\t\tposition: absolute;\n\t\t\twidth: 100%;\n\t\t\theight: 0;\n\t\t\tborder: 1px solid var(--ck-clipboard-drop-target-color);\n\t\t\tmargin-top: -1px;\n\n\t\t\t&::before {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tleft: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\ttop: 0;\n\n\t\t\t\ttransform: translateY(-50%);\n\t\t\t\tborder-color: transparent transparent transparent var(--ck-clipboard-drop-target-color);\n\t\t\t\tborder-width: var(--ck-clipboard-drop-target-dot-size) 0 var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\n\t\t\t&::after {\n\t\t\t\tcontent: "";\n\t\t\t\twidth: 0;\n\t\t\t\theight: 0;\n\n\t\t\t\tdisplay: block;\n\t\t\t\tposition: absolute;\n\t\t\t\tright: calc(-1 * var(--ck-clipboard-drop-target-dot-size));\n\t\t\t\ttop: 0;\n\n\t\t\t\ttransform: translateY(-50%);\n\t\t\t\tborder-color: transparent var(--ck-clipboard-drop-target-color) transparent transparent;\n\t\t\t\tborder-width: var(--ck-clipboard-drop-target-dot-size) calc(2 * var(--ck-clipboard-drop-target-dot-size)) var(--ck-clipboard-drop-target-dot-size) 0;\n\t\t\t\tborder-style: solid;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\t/*\n\t * Styles of the widget that it a drop target.\n\t */\n\t& .ck-widget.ck-clipboard-drop-target-range {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;\n\t}\n\n\t/*\n\t * Styles of the widget being dragged (its preview).\n\t */\n\t& .ck-widget:-webkit-drag {\n\t\tzoom: 0.6;\n\t\toutline: none !important;\n\t}\n}\n',
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          9085: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck-content pre{background:hsla(0,0%,78%,.3);border:1px solid #c4c4c4;border-radius:2px;color:#353535;direction:ltr;font-style:normal;min-width:200px;padding:1em;tab-size:4;text-align:left;white-space:pre-wrap}.ck-content pre code{background:unset;border-radius:0;padding:0}.ck.ck-editor__editable pre{position:relative}.ck.ck-editor__editable pre[data-language]:after{content:attr(data-language);position:absolute}:root{--ck-color-code-block-label-background:#757575}.ck.ck-editor__editable pre[data-language]:after{background:var(--ck-color-code-block-label-background);color:#fff;font-family:var(--ck-font-face);font-size:10px;line-height:16px;padding:var(--ck-spacing-tiny) var(--ck-spacing-medium);right:10px;top:-1px;white-space:nowrap}.ck.ck-code-block-dropdown .ck-dropdown__panel{max-height:250px;overflow-x:hidden;overflow-y:auto}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-code-block/theme/codeblock.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-code-block/codeblock.css",
                ],
                names: [],
                mappings:
                  "AAKA,gBAGC,4BAAiC,CACjC,wBAAiC,CACjC,iBAAkB,CAHlB,aAAwB,CAOxB,aAAc,CAMd,iBAAkB,CAGlB,eAAgB,CAjBhB,WAAY,CAUZ,UAAW,CAHX,eAAgB,CAIhB,oBAaD,CALC,qBACC,gBAAiB,CAEjB,eAAgB,CADhB,SAED,CAGD,4BACC,iBAMD,CAJC,iDACC,2BAA4B,CAC5B,iBACD,CCjCD,MACC,8CACD,CAEA,iDAGC,sDAAuD,CAMvD,UAAuB,CAHvB,+BAAgC,CADhC,cAAe,CAEf,gBAAiB,CACjB,uDAAwD,CANxD,UAAW,CADX,QAAS,CAST,kBACD,CAEA,+CAEC,gBAAiB,CAEjB,iBAAkB,CADlB,eAED",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content pre {\n\tpadding: 1em;\n\tcolor: hsl(0, 0%, 20.8%);\n\tbackground: hsla(0, 0%, 78%, 0.3);\n\tborder: 1px solid hsl(0, 0%, 77%);\n\tborder-radius: 2px;\n\n\t/* Code block are language direction–agnostic. */\n\ttext-align: left;\n\tdirection: ltr;\n\n\ttab-size: 4;\n\twhite-space: pre-wrap;\n\n\t/* Don't inherit the style, e.g. when in a block quote. */\n\tfont-style: normal;\n\n\t/* Don't let the code be squashed e.g. when in a table cell. */\n\tmin-width: 200px;\n\n\t& code {\n\t\tbackground: unset;\n\t\tpadding: 0;\n\t\tborder-radius: 0;\n\t}\n}\n\n.ck.ck-editor__editable pre {\n\tposition: relative;\n\n\t&[data-language]::after {\n\t\tcontent: attr(data-language);\n\t\tposition: absolute;\n\t}\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-code-block-label-background: hsl(0, 0%, 46%);\n}\n\n.ck.ck-editor__editable pre[data-language]::after {\n\ttop: -1px;\n\tright: 10px;\n\tbackground: var(--ck-color-code-block-label-background);\n\n\tfont-size: 10px;\n\tfont-family: var(--ck-font-face);\n\tline-height: 16px;\n\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-medium);\n\tcolor: hsl(0, 0%, 100%);\n\twhite-space: nowrap;\n}\n\n.ck.ck-code-block-dropdown .ck-dropdown__panel {\n\t/* There could be dozens of languages available. Use scroll to prevent a 10e6px dropdown. */\n\tmax-height: 250px;\n\toverflow-y: auto;\n\toverflow-x: hidden;\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          3638: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners :is(.ck.ck-editor__top .ck-sticky-panel .ck-toolbar),.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners :is(.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar),.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners :is(.ck.ck-editor__main>.ck-editor__editable),.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-editor-classic/theme/classiceditor.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-editor-classic/classiceditor.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
                ],
                names: [],
                mappings:
                  "AAKA,cAIC,iBAMD,CAJC,2DAEC,yBACD,CCLC,gDCED,eDKC,CAPA,4ICMA,qCAAsC,CDJpC,2BAA4B,CAC5B,4BAIF,CAPA,gDAMC,qBACD,CAEA,iFACC,uBAAwB,CCR1B,eDaC,CANA,8MCHA,qCAAsC,CDOpC,eAEF,CAKF,yCAEC,0CAA2C,CCpB3C,eD8BD,CAZA,8HCdE,qCAAsC,CDmBtC,wBAAyB,CACzB,yBAMF,CAHC,0DACC,wCACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor {\n\t/* All the elements within `.ck-editor` are positioned relatively to it.\n\t If any element needs to be positioned with respect to the <body>, etc.,\n\t it must land outside of the `.ck-editor` in DOM. */\n\tposition: relative;\n\n\t& .ck-editor__top .ck-sticky-panel .ck-toolbar {\n\t\t/* https://github.com/ckeditor/ckeditor5-editor-classic/issues/62 */\n\t\tz-index: var(--ck-z-modal);\n\t}\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_rounded.css";\n\n.ck.ck-editor__top {\n\t& .ck-sticky-panel {\n\t\t& .ck-toolbar {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\n\t\t\tborder-bottom-width: 0;\n\t\t}\n\n\t\t& .ck-sticky-panel__content_sticky .ck-toolbar {\n\t\t\tborder-bottom-width: 1px;\n\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Note: Use ck-editor__main to make sure these styles don\'t apply to other editor types */\n.ck.ck-editor__main > .ck-editor__editable {\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/113 */\n\tbackground: var(--ck-color-base-background);\n\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&:not(.ck-focused) {\n\t\tborder-color: var(--ck-color-base-border);\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          8894: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text);cursor:text}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/placeholder.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css",
                ],
                names: [],
                mappings:
                  "AAMA,uCAEC,iBAWD,CATC,qDAIC,8BAA+B,CAF/B,MAAO,CAKP,mBAAoB,CANpB,iBAAkB,CAElB,OAKD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDAEC,6CAA8C,CAD9C,WAED",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder,\n.ck .ck-placeholder {\n\tposition: relative;\n\n\t&::before {\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t\tcontent: attr(data-placeholder);\n\n\t\t/* See ckeditor/ckeditor5#469. */\n\t\tpointer-events: none;\n\t}\n}\n\n/* See ckeditor/ckeditor5#1987. */\n.ck.ck-read-only .ck-placeholder {\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n\n/*\n * Rules for the `ck-placeholder` are loaded before the rules for `ck-reset_all` in the base CKEditor 5 DLL build.\n * This fix overwrites the incorrectly set `position: static` from `ck-reset_all`.\n * See https://github.com/ckeditor/ckeditor5/issues/11418.\n */\n.ck.ck-reset_all .ck-placeholder {\n\tposition: relative;\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder, .ck .ck-placeholder {\n\t&::before {\n\t\tcursor: text;\n\t\tcolor: var(--ck-color-engine-placeholder-text);\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          4401: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/renderer.css",
                ],
                names: [],
                mappings: "AAMA,qDACC,YACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Elements marked by the Renderer as hidden should be invisible in the editor. */\n.ck.ck-editor__editable span[data-ck-unsafe-element] {\n\tdisplay: none;\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          5436: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck-find-result{background:#ff0;color:var(--ck-color-text)}.ck-find-result_selected{background:#ff9633}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-find-and-replace/theme/findandreplace.css",
                ],
                names: [],
                mappings: "AAKA,gBACC,eAA8B,CAC9B,0BACD,CAEA,yBACC,kBACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-find-result {\n\tbackground: hsl(60, 100%, 50%);\n\tcolor: var(--ck-color-text);\n}\n\n.ck-find-result_selected {\n\tbackground: hsl(29, 100%, 60%);\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          9289: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-find-and-replace-form{max-width:100%}.ck.ck-find-and-replace-form fieldset{display:flex}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{position:absolute}.ck.ck-find-and-replace-form{width:400px}.ck.ck-find-and-replace-form:focus{outline:none}.ck.ck-find-and-replace-form fieldset{align-content:stretch;align-items:center;border:0;flex-direction:row;flex-wrap:nowrap;margin:0;padding:var(--ck-spacing-large)}.ck.ck-find-and-replace-form fieldset>.ck-button{flex:0 0 auto}:is([dir=ltr] :is(.ck.ck-find-and-replace-form fieldset))>*+*{margin-left:var(--ck-spacing-standard)}:is([dir=rtl] :is(.ck.ck-find-and-replace-form fieldset))>*+*{margin-right:var(--ck-spacing-standard)}.ck.ck-find-and-replace-form fieldset .ck-labeled-field-view{flex:1 1 auto}.ck.ck-find-and-replace-form fieldset .ck-labeled-field-view .ck-input{min-width:50px;width:100%}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find{align-items:flex-start}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button-find{font-weight:700}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button-find .ck-button__label{padding-left:var(--ck-spacing-large);padding-right:var(--ck-spacing-large)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button-prev>.ck-icon{transform:rotate(90deg)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button-next>.ck-icon{transform:rotate(-90deg)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{top:50%;transform:translateY(-50%)}[dir=ltr] :is(.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter){right:var(--ck-spacing-standard)}[dir=rtl] :is(.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter){left:var(--ck-spacing-standard)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{color:var(--ck-color-base-border)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace{flex-wrap:wrap;justify-content:flex-end;margin-top:calc(var(--ck-spacing-large)*-1)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-labeled-field-view{margin-bottom:var(--ck-spacing-large)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-options-dropdown{margin-left:0;margin-right:auto}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-labeled-field-view,.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-labeled-field-view .ck-input{width:100%}@media screen and (max-width:600px){.ck.ck-find-and-replace-form{width:300px}.ck.ck-find-and-replace-form fieldset{flex-wrap:wrap}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-labeled-field-view{flex:1 0 auto;margin-bottom:var(--ck-spacing-standard);width:100%}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button{text-align:center}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button:first-of-type{flex:1 1 auto}[dir=ltr] :is(.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button:first-of-type){margin-left:0}[dir=rtl] :is(.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button:first-of-type){margin-right:0}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button:first-of-type .ck-button__label{text-align:center;width:100%}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>:not(.ck-labeled-field-view){flex:1 1 auto}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-dropdown:not(.ck-labeled-field-view){flex-grow:0}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-button:not(.ck-labeled-field-view)>.ck-button__label{text-align:center;width:100%}}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-find-and-replace/theme/findandreplaceform.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-find-and-replace/findandreplaceform.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
                ],
                names: [],
                mappings:
                  "AAKA,6BACC,cAUD,CARC,sCACC,YAMD,CAHC,yFACC,iBACD,CCNF,6BACC,WAyGD,CAnGC,mCACC,YACD,CAEA,sCAIC,qBAAsB,CADtB,kBAAmB,CAInB,QAAS,CANT,kBAAmB,CACnB,gBAAiB,CAMjB,QAAS,CAFT,+BAwFD,CApFC,iDACC,aACD,CAGC,8DACC,sCACD,CAIA,8DACC,uCACD,CAGD,6DACC,aAMD,CAJC,uEAEC,cAAe,CADf,UAED,CAID,qEAEC,sBAkCD,CAhCC,qFACC,eAOD,CAJC,uGACC,oCAAqC,CACrC,qCACD,CAGD,8FACC,uBACD,CAEA,8FACC,wBACD,CAEA,yFACC,OAAQ,CACR,0BAWD,CAbA,wGAKE,gCAQF,CAbA,wGASE,+BAIF,CAbA,yFAYC,iCACD,CAID,wEACC,cAAe,CACf,wBAAyB,CACzB,2CAeD,CAbC,+FACC,qCACD,CAEA,6FAEC,aAAc,CADd,iBAED,CAEA,wMAEC,UACD,CCzGF,oCD+GA,6BACC,WAiDD,CA/CC,sCACC,cA6CD,CAzCE,4FACC,aAAc,CAEd,wCAAyC,CADzC,UAED,CAEA,gFACC,iBAkBD,CAhBC,8FACC,aAcD,CAfA,6GAIE,aAWF,CAfA,6GAQE,cAOF,CAJC,gHAEC,iBAAkB,CADlB,UAED,CAMH,qGACC,aAUD,CARC,iHACC,WACD,CAEA,iIAEC,iBAAkB,CADlB,UAED,CC5JH",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-find-and-replace-form {\n\tmax-width: 100%;\n\n\t& fieldset {\n\t\tdisplay: flex;\n\n\t\t/* The find fieldset */\n\t\t&.ck-find-and-replace-form__find .ck-results-counter {\n\t\t\tposition: absolute;\n\t\t}\n\t}\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-find-and-replace-form {\n\twidth: 400px;\n\n\t/*\n\t * The <form> needs tabindex="-1" for proper Esc handling after being clicked\n\t * but the side effect is that this creates a nasty focus outline in some browsers.\n\t */\n\t&:focus {\n\t\toutline: none;\n\t}\n\n\t& fieldset {\n\t\tflex-direction: row;\n\t\tflex-wrap: nowrap;\n\t\talign-items: center;\n\t\talign-content: stretch;\n\n\t\tpadding: var(--ck-spacing-large);\n\t\tborder: 0;\n\t\tmargin: 0;\n\n\t\t& > .ck-button {\n\t\t\tflex: 0 0 auto;\n\t\t}\n\n\t\t@mixin ck-dir ltr {\n\t\t\t& > * + * {\n\t\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t& > * + * {\n\t\t\t\tmargin-right: var(--ck-spacing-standard);\n\t\t\t}\n\t\t}\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex: 1 1 auto;\n\n\t\t\t& .ck-input {\n\t\t\t\twidth: 100%;\n\t\t\t\tmin-width: 50px;\n\t\t\t}\n\t\t}\n\n\t\t/* The find fieldset */\n\t\t&.ck-find-and-replace-form__find {\n\t\t\t/* To display all controls in line when there\'s an error under the input */\n\t\t\talign-items: flex-start;\n\n\t\t\t& > .ck-button-find {\n\t\t\t\tfont-weight: bold;\n\n\t\t\t\t/* Beef the find button up a little. It\'s the main action button in the form */\n\t\t\t\t& .ck-button__label {\n\t\t\t\t\tpadding-left: var(--ck-spacing-large);\n\t\t\t\t\tpadding-right: var(--ck-spacing-large);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t& > .ck-button-prev > .ck-icon {\n\t\t\t\ttransform: rotate(90deg);\n\t\t\t}\n\n\t\t\t& > .ck-button-next > .ck-icon {\n\t\t\t\ttransform: rotate(-90deg);\n\t\t\t}\n\n\t\t\t& .ck-results-counter {\n\t\t\t\ttop: 50%;\n\t\t\t\ttransform: translateY(-50%);\n\n\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\tright: var(--ck-spacing-standard);\n\t\t\t\t}\n\n\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\tleft: var(--ck-spacing-standard);\n\t\t\t\t}\n\n\t\t\t\tcolor: var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\n\t\t/* The replace fieldset */\n\t\t&.ck-find-and-replace-form__replace {\n\t\t\tflex-wrap: wrap;\n\t\t\tjustify-content: flex-end;\n\t\t\tmargin-top: calc( -1 * var(--ck-spacing-large) );\n\n\t\t\t& > .ck-labeled-field-view {\n\t\t\t\tmargin-bottom: var(--ck-spacing-large);\n\t\t\t}\n\n\t\t\t& > .ck-options-dropdown {\n\t\t\t\tmargin-right: auto;\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t& > .ck-labeled-field-view,\n\t\t\t& > .ck-labeled-field-view .ck-input {\n\t\t\t\twidth: 100%;\n\t\t\t}\n\t\t}\n\t}\n}\n\n@mixin ck-media-phone {\n\t.ck.ck-find-and-replace-form {\n\t\twidth: 300px;\n\n\t\t& fieldset {\n\t\t\tflex-wrap: wrap;\n\n\t\t\t/* The find fieldset */\n\t\t\t&.ck-find-and-replace-form__find {\n\t\t\t\t& .ck-labeled-field-view {\n\t\t\t\t\tflex: 1 0 auto;\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\tmargin-bottom: var(--ck-spacing-standard);\n\t\t\t\t}\n\n\t\t\t\t& > .ck-button {\n\t\t\t\t\ttext-align: center;\n\n\t\t\t\t\t&:first-of-type {\n\t\t\t\t\t\tflex: 1 1 auto;\n\n\t\t\t\t\t\t@mixin ck-dir ltr {\n\t\t\t\t\t\t\tmargin-left: 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t@mixin ck-dir rtl {\n\t\t\t\t\t\t\tmargin-right: 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t& .ck-button__label {\n\t\t\t\t\t\t\twidth: 100%;\n\t\t\t\t\t\t\ttext-align: center;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* The replace fieldset */\n\t\t\t&.ck-find-and-replace-form__replace > :not(.ck-labeled-field-view) {\n\t\t\t\tflex: 1 1 auto;\n\n\t\t\t\t&.ck-dropdown {\n\t\t\t\t\tflex-grow: 0;\n\t\t\t\t}\n\n\t\t\t\t&.ck-button > .ck-button__label {\n\t\t\t\t\twidth: 100%;\n\t\t\t\t\ttext-align: center;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          2585: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck .ck-button.ck-color-table__remove-color{align-items:center;display:flex;width:100%}label.ck.ck-color-grid__label{font-weight:unset}.ck .ck-button.ck-color-table__remove-color{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard)}.ck .ck-button.ck-color-table__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-base-border)}[dir=ltr] :is(.ck .ck-button.ck-color-table__remove-color .ck.ck-icon){margin-right:var(--ck-spacing-standard)}[dir=rtl] :is(.ck .ck-button.ck-color-table__remove-color .ck.ck-icon){margin-left:var(--ck-spacing-standard)}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-font/theme/fontcolor.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-font/fontcolor.css",
                ],
                names: [],
                mappings:
                  "AAKA,4CAEC,kBAAmB,CADnB,YAAa,CAEb,UACD,CAEA,8BACC,iBACD,CCNA,4CAEC,2BAA4B,CAC5B,4BAA6B,CAF7B,qEAiBD,CAbC,wDACC,mDACD,CAEA,uEAEE,uCAMF,CARA,uEAME,sCAEF",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-button.ck-color-table__remove-color {\n\tdisplay: flex;\n\talign-items: center;\n\twidth: 100%;\n}\n\nlabel.ck.ck-color-grid__label {\n\tfont-weight: unset;\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck .ck-button.ck-color-table__remove-color {\n\tpadding: calc(var(--ck-spacing-standard) / 2 ) var(--ck-spacing-standard);\n\tborder-bottom-left-radius: 0;\n\tborder-bottom-right-radius: 0;\n\n\t&:not(:focus) {\n\t\tborder-bottom: 1px solid var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-right: var(--ck-spacing-standard);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n}\n\n',
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          3230: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-heading/theme/heading.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css",
                ],
                names: [],
                mappings:
                  "AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-heading_heading1 {\n\tfont-size: 20px;\n}\n\n.ck.ck-heading_heading2 {\n\tfont-size: 17px;\n}\n\n.ck.ck-heading_heading3 {\n\tfont-size: 14px;\n}\n\n.ck[class*="ck-heading_heading"] {\n\tfont-weight: bold;\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Resize dropdown's button label. */\n.ck.ck-dropdown.ck-heading-dropdown {\n\t& .ck-dropdown__button .ck-button__label {\n\t\twidth: 8em;\n\t}\n\n\t& .ck-dropdown__panel .ck-list__item {\n\t\tmin-width: 18em;\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          2536: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck-editor__editable .ck-horizontal-line{display:flow-root}.ck-content hr{background:#dedede;border:0;height:4px;margin:15px 0}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-horizontal-line/theme/horizontalline.css",
                ],
                names: [],
                mappings:
                  "AAMA,yCAEC,iBACD,CAEA,eAGC,kBAA2B,CAC3B,QAAS,CAFT,UAAW,CADX,aAID",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n\n.ck-editor__editable .ck-horizontal-line {\n\t/* Necessary to render properly next to floated objects, e.g. side image case. */\n\tdisplay: flow-root;\n}\n\n.ck-content hr {\n\tmargin: 15px 0;\n\theight: 4px;\n\tbackground: hsl(0, 0%, 87%);\n\tborder: 0;\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          8468: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ":root{--ck-html-object-embed-unfocused-outline-width:1px}.ck-widget.html-object-embed{background-color:var(--ck-color-base-foreground);font-size:var(--ck-font-size-base);min-width:calc(76px + var(--ck-spacing-standard));padding:var(--ck-spacing-small);padding-top:calc(var(--ck-font-size-tiny) + var(--ck-spacing-large))}.ck-widget.html-object-embed:not(.ck-widget_selected):not(:hover){outline:var(--ck-html-object-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border)}.ck-widget.html-object-embed:before{background:#999;border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius);color:var(--ck-color-base-background);content:attr(data-html-object-embed-label);font-family:var(--ck-font-face);font-size:var(--ck-font-size-tiny);font-style:normal;font-weight:400;left:var(--ck-spacing-standard);padding:calc(var(--ck-spacing-tiny) + var(--ck-html-object-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);position:absolute;top:0;transition:background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck-widget.html-object-embed .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before{margin-left:50px}.ck-widget.html-object-embed .html-object-embed__content{pointer-events:none}div.ck-widget.html-object-embed{margin:1em auto}span.ck-widget.html-object-embed{display:inline-block}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-html-support/theme/datafilter.css",
                ],
                names: [],
                mappings:
                  "AAKA,MACC,kDACD,CAEA,6BAEC,gDAAiD,CADjD,kCAAmC,CAKnC,iDAAkD,CAHlD,+BAAgC,CAEhC,oEAgCD,CA7BC,kEACC,wGACD,CAEA,oCAOC,eAA4B,CAG5B,iEAAkE,CAClE,qCAAsC,CAPtC,0CAA2C,CAS3C,+BAAgC,CADhC,kCAAmC,CAVnC,iBAAkB,CADlB,eAAmB,CAKnB,+BAAgC,CAGhC,yIAA0I,CAN1I,iBAAkB,CAElB,KAAM,CAGN,0GAMD,CAGA,2HACC,gBACD,CAEA,yDAEC,mBACD,CAGD,gCACC,eACD,CAEA,iCACC,oBACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-html-object-embed-unfocused-outline-width: 1px;\n}\n\n.ck-widget.html-object-embed {\n\tfont-size: var(--ck-font-size-base);\n\tbackground-color: var(--ck-color-base-foreground);\n\tpadding: var(--ck-spacing-small);\n\t/* Leave space for label */\n\tpadding-top: calc(var(--ck-font-size-tiny) + var(--ck-spacing-large));\n\tmin-width: calc(76px + var(--ck-spacing-standard));\n\n\t&:not(.ck-widget_selected):not(:hover) {\n\t\toutline: var(--ck-html-object-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border);\n\t}\n\n\t&::before {\n\t\tfont-weight: normal;\n\t\tfont-style: normal;\n\t\tposition: absolute;\n\t\tcontent: attr(data-html-object-embed-label);\n\t\ttop: 0;\n\t\tleft: var(--ck-spacing-standard);\n\t\tbackground: hsl(0deg 0% 60%);\n\t\ttransition: background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\t\tpadding: calc(var(--ck-spacing-tiny) + var(--ck-html-object-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);\n\t\tborder-radius: 0 0 var(--ck-border-radius) var(--ck-border-radius);\n\t\tcolor: var(--ck-color-base-background);\n\t\tfont-size: var(--ck-font-size-tiny);\n\t\tfont-family: var(--ck-font-face);\n\t}\n\n\t/* Make space for label. */\n\t& .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before {\n\t\tmargin-left: 50px;\n\t}\n\n\t& .html-object-embed__content {\n\t\t/* Disable user interaction with embed content */\n\t\tpointer-events: none;\n\t}\n}\n\ndiv.ck-widget.html-object-embed {\n\tmargin: 1em auto;\n}\n\nspan.ck-widget.html-object-embed {\n\tdisplay: inline-block;\n}\n\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          9048: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck-content .image{clear:both;display:table;margin:.9em auto;min-width:50px;text-align:center}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{align-items:flex-start;display:inline-flex;max-width:100%}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}.ck.ck-editor__editable .image-inline.ck-widget_selected,.ck.ck-editor__editable .image.ck-widget_selected{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-image/theme/image.css",
                ],
                names: [],
                mappings:
                  "AAMC,mBAEC,UAAW,CADX,aAAc,CAOd,gBAAkB,CAGlB,cAAe,CARf,iBAuBD,CAbC,uBAEC,aAAc,CAGd,aAAc,CAGd,cAAe,CAGf,cACD,CAGD,0BAYC,sBAAuB,CANvB,mBAAoB,CAGpB,cAoBD,CAdC,kCACC,YACD,CAGA,gEAGC,WAAY,CACZ,aAAc,CAGd,cACD,CAUD,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAWA,2GACC,SAUD,CAHC,qEACC,YACD,CAOA,0FACC,cACD",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content {\n\t& .image {\n\t\tdisplay: table;\n\t\tclear: both;\n\t\ttext-align: center;\n\n\t\t/* Make sure there is some space between the content and the image. Center image by default. */\n\t\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\t \tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\t\tmargin: 0.9em auto;\n\n\t\t/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */\n\t\tmin-width: 50px;\n\n\t\t& img {\n\t\t\t/* Prevent unnecessary margins caused by line-height (see #44). */\n\t\t\tdisplay: block;\n\n\t\t\t/* Center the image if its width is smaller than the content\'s width. */\n\t\t\tmargin: 0 auto;\n\n\t\t\t/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */\n\t\t\tmax-width: 100%;\n\n\t\t\t/* Make sure the image is never smaller than the parent container (See: https://github.com/ckeditor/ckeditor5/issues/9300). */\n\t\t\tmin-width: 100%\n\t\t}\n\t}\n\n\t& .image-inline {\n\t\t/*\n\t\t * Normally, the .image-inline would have "display: inline-block" and "img { width: 100% }" (to follow the wrapper while resizing).\n\t\t * Unfortunately, together with "srcset", it gets automatically stretched up to the width of the editing root.\n\t\t * This strange behavior does not happen with inline-flex.\n\t\t */\n\t\tdisplay: inline-flex;\n\n\t\t/* While being resized, don\'t allow the image to exceed the width of the editing root. */\n\t\tmax-width: 100%;\n\n\t\t/* This is required by Safari to resize images in a sensible way. Without this, the browser breaks the ratio. */\n\t\talign-items: flex-start;\n\n\t\t/* When the picture is present it must act as a flex container to let the img resize properly */\n\t\t& picture {\n\t\t\tdisplay: flex;\n\t\t}\n\n\t\t/* When the picture is present, it must act like a resizable img. */\n\t\t& picture,\n\t\t& img {\n\t\t\t/* This is necessary for the img to span the entire .image-inline wrapper and to resize properly. */\n\t\t\tflex-grow: 1;\n\t\t\tflex-shrink: 1;\n\n\t\t\t/* Prevents overflowing the editing root boundaries when an inline image is very wide. */\n\t\t\tmax-width: 100%;\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable {\n\t/*\n\t * Inhertit the content styles padding of the <figcaption> in case the integration overrides `text-align: center`\n\t * of `.image` (e.g. to the left/right). This ensures the placeholder stays at the padding just like the native\n\t * caret does, and not at the edge of <figcaption>.\n\t */\n\t& .image > figcaption.ck-placeholder::before {\n\t\tpadding-left: inherit;\n\t\tpadding-right: inherit;\n\n\t\t/*\n\t\t * Make sure the image caption placeholder doesn\'t overflow the placeholder area.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9162.\n\t\t */\n\t\twhite-space: nowrap;\n\t\toverflow: hidden;\n\t\ttext-overflow: ellipsis;\n\t}\n\n\n\t/*\n\t * Make sure the selected inline image always stays on top of its siblings.\n\t * See https://github.com/ckeditor/ckeditor5/issues/9108.\n\t */\n\t& .image.ck-widget_selected {\n\t\tz-index: 1;\n\t}\n\n\t& .image-inline.ck-widget_selected {\n\t\tz-index: 1;\n\n\t\t/*\n\t\t * Make sure the native browser selection style is not displayed.\n\t\t * Inline image widgets have their own styles for the selected state and\n\t\t * leaving this up to the browser is asking for a visual collision.\n\t\t */\n\t\t& ::selection {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t/* The inline image nested in the table should have its original size if not resized.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9117. */\n\t& td,\n\t& th {\n\t\t& .image-inline img {\n\t\t\tmax-width: none;\n\t\t}\n\t}\n}\n',
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          8662: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ":root{--ck-color-image-caption-background:#f7f7f7;--ck-color-image-caption-text:#333;--ck-color-image-caption-highligted-background:#fd0}.ck-content .image>figcaption{background-color:var(--ck-color-image-caption-background);caption-side:bottom;color:var(--ck-color-image-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;word-break:break-word}.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:ck-image-caption-highlight .6s ease-out}@keyframes ck-image-caption-highlight{0%{background-color:var(--ck-color-image-caption-highligted-background)}to{background-color:var(--ck-color-image-caption-background)}}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imagecaption.css",
                ],
                names: [],
                mappings:
                  "AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,mDACD,CAGA,8BAKC,yDAA0D,CAH1D,mBAAoB,CAEpB,wCAAyC,CAHzC,qBAAsB,CAMtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,qBAMD,CAGA,qEACC,iDACD,CAEA,sCACC,GACC,oEACD,CAEA,GACC,yDACD,CACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-caption-background: hsl(0, 0%, 97%);\n\t--ck-color-image-caption-text: hsl(0, 0%, 20%);\n\t--ck-color-image-caption-highligted-background: hsl(52deg 100% 50%);\n}\n\n/* Content styles */\n.ck-content .image > figcaption {\n\tdisplay: table-caption;\n\tcaption-side: bottom;\n\tword-break: break-word;\n\tcolor: var(--ck-color-image-caption-text);\n\tbackground-color: var(--ck-color-image-caption-background);\n\tpadding: .6em;\n\tfont-size: .75em;\n\toutline-offset: -1px;\n}\n\n/* Editing styles */\n.ck.ck-editor__editable .image > figcaption.image__caption_highlighted {\n\tanimation: ck-image-caption-highlight .6s ease-out;\n}\n\n@keyframes ck-image-caption-highlight {\n\t0% {\n\t\tbackground-color: var(--ck-color-image-caption-highligted-background);\n\t}\n\n\t100% {\n\t\tbackground-color: var(--ck-color-image-caption-background);\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          9292: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-image-insert__panel{padding:var(--ck-spacing-large)}.ck.ck-image-insert__ck-finder-button{border:1px solid #ccc;border-radius:var(--ck-border-radius);display:block;margin:var(--ck-spacing-standard) auto;width:100%}.ck.ck-splitbutton>.ck-file-dialog-button.ck-button{border:none;margin:0;padding:0}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageinsert.css",
                ],
                names: [],
                mappings:
                  "AAKA,2BACC,+BACD,CAEA,sCAIC,qBAAiC,CACjC,qCAAsC,CAJtC,aAAc,CAEd,sCAAuC,CADvC,UAID,CAGA,oDAGC,WAAY,CADZ,QAAS,CADT,SAGD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-image-insert__panel {\n\tpadding: var(--ck-spacing-large);\n}\n\n.ck.ck-image-insert__ck-finder-button {\n\tdisplay: block;\n\twidth: 100%;\n\tmargin: var(--ck-spacing-standard) auto;\n\tborder: 1px solid hsl(0, 0%, 80%);\n\tborder-radius: var(--ck-border-radius);\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/7986 */\n.ck.ck-splitbutton > .ck-file-dialog-button.ck-button {\n\tpadding: 0;\n\tmargin: 0;\n\tborder: none;\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          5150: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-image-insert-form:focus{outline:none}.ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-image-insert-form__action-row{margin-top:var(--ck-spacing-standard)}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageinsertformrowview.css",
                ],
                names: [],
                mappings:
                  "AAMC,+BAEC,YACD,CAGD,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAmBD,CAhBC,iCACC,WACD,CAEA,kDACC,qCAUD,CARC,sIAEC,sBACD,CAEA,+EACC,0BACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-image-insert-form {\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n}\n\n.ck.ck-form__row {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\tjustify-content: space-between;\n\n\t/* Ignore labels that work as fieldset legends */\n\t& > *:not(.ck-label) {\n\t\tflex-grow: 1;\n\t}\n\n\t&.ck-image-insert-form__action-row {\n\t\tmargin-top: var(--ck-spacing-standard);\n\n\t\t& .ck-button-save,\n\t\t& .ck-button-cancel {\n\t\t\tjustify-content: center;\n\t\t}\n\n\t\t& .ck-button .ck-button__label {\n\t\t\tcolor: var(--ck-color-text);\n\t\t}\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          4622: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ":root{--ck-image-style-spacing:1.5em;--ck-inline-image-style-spacing:calc(var(--ck-image-style-spacing)/2)}.ck-content .image-style-block-align-left,.ck-content .image-style-block-align-right{max-width:calc(100% - var(--ck-image-style-spacing))}.ck-content .image-style-align-left,.ck-content .image-style-align-right{clear:none}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-block-align-right{margin-left:auto;margin-right:0}.ck-content .image-style-block-align-left{margin-left:0;margin-right:auto}.ck-content p+.image-style-align-left,.ck-content p+.image-style-align-right,.ck-content p+.image-style-side{margin-top:0}.ck-content .image-inline.image-style-align-left,.ck-content .image-inline.image-style-align-right{margin-bottom:var(--ck-inline-image-style-spacing);margin-top:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-left{margin-right:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-right{margin-left:var(--ck-inline-image-style-spacing)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-background)}:is(.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not:not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not:not):after{display:none}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-hover-background)}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imagestyle.css",
                ],
                names: [],
                mappings:
                  "AAKA,MACC,8BAA+B,CAC/B,qEACD,CAMC,qFAEC,oDACD,CAIA,yEAEC,UACD,CAEA,8BACC,WAAY,CACZ,yCAA0C,CAC1C,aACD,CAEA,oCACC,UAAW,CACX,0CACD,CAEA,sCACC,gBAAiB,CACjB,iBACD,CAEA,qCACC,WAAY,CACZ,yCACD,CAEA,2CAEC,gBAAiB,CADjB,cAED,CAEA,0CACC,aAAc,CACd,iBACD,CAGA,6GAGC,YACD,CAGC,mGAGC,kDAAmD,CADnD,+CAED,CAEA,iDACC,iDACD,CAEA,kDACC,gDACD,CAUC,0lBAGC,qDAKD,CAHC,uhBACC,YACD,CAKD,oVAGC,2DACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-image-style-spacing: 1.5em;\n\t--ck-inline-image-style-spacing: calc(var(--ck-image-style-spacing) / 2);\n}\n\n.ck-content {\n\t/* Provides a minimal side margin for the left and right aligned images, so that the user has a visual feedback\n\tconfirming successful application of the style if image width exceeds the editor's size.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9342 */\n\t& .image-style-block-align-left,\n\t& .image-style-block-align-right {\n\t\tmax-width: calc(100% - var(--ck-image-style-spacing));\n\t}\n\n\t/* Allows displaying multiple floating images in the same line.\n\tSee https://github.com/ckeditor/ckeditor5/issues/9183#issuecomment-804988132 */\n\t& .image-style-align-left,\n\t& .image-style-align-right {\n\t\tclear: none;\n\t}\n\n\t& .image-style-side {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t\tmax-width: 50%;\n\t}\n\n\t& .image-style-align-left {\n\t\tfloat: left;\n\t\tmargin-right: var(--ck-image-style-spacing);\n\t}\n\n\t& .image-style-align-center {\n\t\tmargin-left: auto;\n\t\tmargin-right: auto;\n\t}\n\n\t& .image-style-align-right {\n\t\tfloat: right;\n\t\tmargin-left: var(--ck-image-style-spacing);\n\t}\n\n\t& .image-style-block-align-right {\n\t\tmargin-right: 0;\n\t\tmargin-left: auto;\n\t}\n\n\t& .image-style-block-align-left {\n\t\tmargin-left: 0;\n\t\tmargin-right: auto;\n\t}\n\n\t/* Simulates margin collapsing with the preceding paragraph, which does not work for the floating elements. */\n\t& p + .image-style-align-left,\n\t& p + .image-style-align-right,\n\t& p + .image-style-side {\n\t\tmargin-top: 0;\n\t}\n\n\t& .image-inline {\n\t\t&.image-style-align-left,\n\t\t&.image-style-align-right {\n\t\t\tmargin-top: var(--ck-inline-image-style-spacing);\n\t\t\tmargin-bottom: var(--ck-inline-image-style-spacing);\n\t\t}\n\n\t\t&.image-style-align-left {\n\t\t\tmargin-right: var(--ck-inline-image-style-spacing);\n\t\t}\n\n\t\t&.image-style-align-right {\n\t\t\tmargin-left: var(--ck-inline-image-style-spacing);\n\t\t}\n\t}\n}\n\n.ck.ck-splitbutton {\n\t/* The button should display as a regular drop-down if the action button\n\tis forced to fire the same action as the arrow button. */\n\t&.ck-splitbutton_flatten {\n\t\t&:hover,\n\t\t&.ck-splitbutton_open {\n\t\t\t& > .ck-splitbutton__action:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n\t\t\t\tbackground-color: var(--ck-color-button-on-background);\n\n\t\t\t\t&::after {\n\t\t\t\t\tdisplay: none;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t&.ck-splitbutton_open:hover {\n\t\t\t& > .ck-splitbutton__action:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled),\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n\t\t\t\tbackground-color: var(--ck-color-button-on-hover-background);\n\t\t\t}\n\t\t}\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          9899: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              '.ck-image-upload-complete-icon{border-radius:50%;display:block;position:absolute;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);z-index:1}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20;--ck-image-upload-icon-width:2px;--ck-image-upload-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck-image-upload-complete-icon{animation-delay:0ms,3s;animation-duration:.5s,.5s;animation-fill-mode:forwards,forwards;animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;background:var(--ck-color-image-upload-icon-background);font-size:calc(1px*var(--ck-image-upload-icon-size));height:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size));opacity:0;overflow:hidden;width:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size))}.ck-image-upload-complete-icon:after{animation-delay:.5s;animation-duration:.5s;animation-fill-mode:forwards;animation-name:ck-upload-complete-icon-check;border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);box-sizing:border-box;height:0;left:25%;opacity:0;top:50%;transform:scaleX(-1) rotate(135deg);transform-origin:left top;width:0}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{height:0;opacity:1;width:0}33%{height:0;width:.3em}to{height:.45em;opacity:1;width:.3em}}',
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadicon.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css",
                ],
                names: [],
                mappings:
                  "AAKA,+BAUC,iBAAkB,CATlB,aAAc,CACd,iBAAkB,CAOlB,sCAAwC,CADxC,oCAAsC,CAGtC,SAMD,CAJC,qCACC,UAAW,CACX,iBACD,CChBD,MACC,iCAA8C,CAC9C,+CAA4D,CAG5D,8BAA+B,CAC/B,gCAAiC,CACjC,4DACD,CAEA,+BAWC,sBAA4B,CAN5B,0BAAgC,CADhC,qCAAuC,CADvC,wEAA0E,CAD1E,uDAAwD,CAMxD,oDAAuD,CAWvD,oFAAuF,CAlBvF,SAAU,CAgBV,eAAgB,CAChB,mFA0BD,CAtBC,qCAgBC,mBAAsB,CADtB,sBAAyB,CAEzB,4BAA6B,CAH7B,4CAA6C,CAF7C,sFAAuF,CADvF,oFAAqF,CASrF,qBAAsB,CAdtB,QAAS,CAJT,QAAS,CAGT,SAAU,CADV,OAAQ,CAKR,mCAAoC,CACpC,yBAA0B,CAH1B,OAcD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GAGC,QAAS,CAFT,SAAU,CACV,OAED,CACA,IAEC,QAAS,CADT,UAED,CACA,GAGC,YAAc,CAFd,SAAU,CACV,UAED,CACD",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-image-upload-complete-icon {\n\tdisplay: block;\n\tposition: absolute;\n\n\t/*\n\t * Smaller images should have the icon closer to the border.\n\t * Match the icon position with the linked image indicator brought by the link image feature.\n\t */\n\ttop: min(var(--ck-spacing-medium), 6%);\n\tright: min(var(--ck-spacing-medium), 6%);\n\tborder-radius: 50%;\n\tz-index: 1;\n\n\t&::after {\n\t\tcontent: "";\n\t\tposition: absolute;\n\t}\n}\n',
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-upload-icon: hsl(0, 0%, 100%);\n\t--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);\n\n\t/* Match the icon size with the linked image indicator brought by the link image feature. */\n\t--ck-image-upload-icon-size: 20;\n\t--ck-image-upload-icon-width: 2px;\n\t--ck-image-upload-icon-is-visible: clamp(0px, 100% - 50px, 1px);\n}\n\n.ck-image-upload-complete-icon {\n\topacity: 0;\n\tbackground: var(--ck-color-image-upload-icon-background);\n\tanimation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;\n\tanimation-fill-mode: forwards, forwards;\n\tanimation-duration: 500ms, 500ms;\n\n\t/* To make animation scalable. */\n\tfont-size: calc(1px * var(--ck-image-upload-icon-size));\n\n\t/* Hide completed upload icon after 3 seconds. */\n\tanimation-delay: 0ms, 3000ms;\n\n\t/*\n\t * Use CSS math to simulate container queries.\n\t * https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things\n\t */\n\toverflow: hidden;\n\twidth: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\theight: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\n\t/* This is check icon element made from border-width mixed with animations. */\n\t&::after {\n\t\t/* Because of border transformation we need to "hard code" left position. */\n\t\tleft: 25%;\n\n\t\ttop: 50%;\n\t\topacity: 0;\n\t\theight: 0;\n\t\twidth: 0;\n\n\t\ttransform: scaleX(-1) rotate(135deg);\n\t\ttransform-origin: left top;\n\t\tborder-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\t\tborder-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\n\t\tanimation-name: ck-upload-complete-icon-check;\n\t\tanimation-duration: 500ms;\n\t\tanimation-delay: 500ms;\n\t\tanimation-fill-mode: forwards;\n\n\t\t/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */\n\t\tbox-sizing: border-box;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-show {\n\tfrom {\n\t\topacity: 0;\n\t}\n\n\tto {\n\t\topacity: 1;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-hide {\n\tfrom {\n\t\topacity: 1;\n\t}\n\n\tto {\n\t\topacity: 0;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-check {\n\t0% {\n\t\topacity: 1;\n\t\twidth: 0;\n\t\theight: 0;\n\t}\n\t33% {\n\t\twidth: 0.3em;\n\t\theight: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t\twidth: 0.3em;\n\t\theight: 0.45em;\n\t}\n}\n',
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          9825: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              '.ck .ck-upload-placeholder-loader{align-items:center;display:flex;justify-content:center;left:0;position:absolute;top:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px;--ck-upload-placeholder-image-aspect-ratio:2.8}.ck .ck-image-upload-placeholder{margin:0;width:100%}.ck .ck-image-upload-placeholder.image-inline{width:calc(var(--ck-upload-placeholder-loader-size)*2*var(--ck-upload-placeholder-image-aspect-ratio))}.ck .ck-image-upload-placeholder img{aspect-ratio:var(--ck-upload-placeholder-image-aspect-ratio)}.ck .ck-upload-placeholder-loader{height:100%;width:100%}.ck .ck-upload-placeholder-loader:before{animation:ck-upload-placeholder-loader 1s linear infinite;border-radius:50%;border-right:2px solid transparent;border-top:3px solid var(--ck-color-upload-placeholder-loader);height:var(--ck-upload-placeholder-loader-size);width:var(--ck-upload-placeholder-loader-size)}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}',
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadloader.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css",
                ],
                names: [],
                mappings:
                  "AAKA,kCAGC,kBAAmB,CADnB,YAAa,CAEb,sBAAuB,CAEvB,MAAO,CALP,iBAAkB,CAIlB,KAOD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCAAyC,CACzC,8CACD,CAEA,iCAGC,QAAS,CADT,UAgBD,CAbC,8CACC,sGACD,CAEA,qCAOC,4DACD,CAGD,kCAEC,WAAY,CADZ,UAWD,CARC,yCAMC,yDAA0D,CAH1D,iBAAkB,CAElB,kCAAmC,CADnC,8DAA+D,CAF/D,+CAAgD,CADhD,8CAMD,CAGD,wCACC,GACC,uBACD,CACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-upload-placeholder-loader {\n\tposition: absolute;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\ttop: 0;\n\tleft: 0;\n\n\t&::before {\n\t\tcontent: '';\n\t\tposition: relative;\n\t}\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);\n\t--ck-upload-placeholder-loader-size: 32px;\n\t--ck-upload-placeholder-image-aspect-ratio: 2.8;\n}\n\n.ck .ck-image-upload-placeholder {\n\t/* We need to control the full width of the SVG gray background. */\n\twidth: 100%;\n\tmargin: 0;\n\n\t&.image-inline {\n\t\twidth: calc( 2 * var(--ck-upload-placeholder-loader-size) * var(--ck-upload-placeholder-image-aspect-ratio) );\n\t}\n\n\t& img {\n\t\t/*\n\t\t * This is an arbitrary aspect for a 1x1 px GIF to display to the user. Not too tall, not too short.\n\t\t * There's nothing special about this number except that it should make the image placeholder look like\n\t\t * a real image during this short period after the upload started and before the image was read from the\n\t\t * file system (and a rich preview was loaded).\n\t\t */\n\t\taspect-ratio: var(--ck-upload-placeholder-image-aspect-ratio);\n\t}\n}\n\n.ck .ck-upload-placeholder-loader {\n\twidth: 100%;\n\theight: 100%;\n\n\t&::before {\n\t\twidth: var(--ck-upload-placeholder-loader-size);\n\t\theight: var(--ck-upload-placeholder-loader-size);\n\t\tborder-radius: 50%;\n\t\tborder-top: 3px solid var(--ck-color-upload-placeholder-loader);\n\t\tborder-right: 2px solid transparent;\n\t\tanimation: ck-upload-placeholder-loader 1s linear infinite;\n\t}\n}\n\n@keyframes ck-upload-placeholder-loader {\n\tto {\n\t\ttransform: rotate( 360deg );\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          5870: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-editor__editable .image,.ck.ck-editor__editable .image-inline{position:relative}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{left:0;position:absolute;top:0}.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{background:var(--ck-color-upload-bar-background);height:2px;transition:width .1s;width:0}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadprogress.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css",
                ],
                names: [],
                mappings:
                  "AAMC,qEAEC,iBACD,CAGA,uGAIC,MAAO,CAFP,iBAAkB,CAClB,KAED,CCRC,yFACC,oBACD,CAID,uGAIC,gDAAiD,CAFjD,UAAW,CAGX,oBAAuB,CAFvB,OAGD,CAGD,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t& .image,\n\t& .image-inline {\n\t\tposition: relative;\n\t}\n\n\t/* Upload progress bar. */\n\t& .image .ck-progress-bar,\n\t& .image-inline .ck-progress-bar {\n\t\tposition: absolute;\n\t\ttop: 0;\n\t\tleft: 0;\n\t}\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n\t& .image,\n\t& .image-inline {\n\t\t/* Showing animation. */\n\t\t&.ck-appear {\n\t\t\tanimation: fadeIn 700ms;\n\t\t}\n\t}\n\n\t/* Upload progress bar. */\n\t& .image .ck-progress-bar,\n\t& .image-inline .ck-progress-bar {\n\t\theight: 2px;\n\t\twidth: 0;\n\t\tbackground: var(--ck-color-upload-bar-background);\n\t\ttransition: width 100ms;\n\t}\n}\n\n@keyframes fadeIn {\n\tfrom { opacity: 0; }\n\tto   { opacity: 1; }\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          6831: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-image/theme/textalternativeform.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
                ],
                names: [],
                mappings:
                  "AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-text-alternative-form {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          399: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/link.css",
                ],
                names: [],
                mappings:
                  "AAMA,sBACC,mDAMD,CAHC,wCACC,yFACD,CAOD,4BACC,8CACD,CAGA,sCAEC,gDAAiD,CADjD,WAAY,CAEZ,iBAAkB,CAClB,oCACD",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Class added to span element surrounding currently selected link. */\n.ck .ck-link_selected {\n\tbackground: var(--ck-color-link-selected-background);\n\n\t/* Give linked inline images some outline to let the user know they are also part of the link. */\n\t& span.image-inline {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background);\n\t}\n}\n\n/*\n * Classes used by the "fake visual selection" displayed in the content when an input\n * in the link UI has focus (the browser does not render the native selection in this state).\n */\n.ck .ck-fake-link-selection {\n\tbackground: var(--ck-color-link-fake-selection);\n}\n\n/* A collapsed fake visual selection. */\n.ck .ck-fake-link-selection_collapsed {\n\theight: 100%;\n\tborder-right: 1px solid var(--ck-color-base-text);\n\tmargin-right: -1px;\n\toutline: solid 1px hsla(0, 0%, 100%, .5);\n}\n',
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          9465: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{color:var(--ck-color-link-default);cursor:pointer;max-width:var(--ck-input-width);min-width:3em;padding:0 var(--ck-spacing-medium);text-align:center;text-overflow:ellipsis}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{max-width:100%;min-width:0}[dir=ltr] :is(.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview)){margin-left:0}[dir=rtl] :is(.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview)){margin-left:0}}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkactions.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css",
                ],
                names: [],
                mappings:
                  "AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCKA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EAEC,kCAAmC,CAEnC,cAAe,CAIf,+BAAgC,CAChC,aAAc,CARd,kCAAmC,CASnC,iBAAkB,CAPlB,sBAYD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDvDD,oCC2DC,wDACC,8DAMD,CAJC,0EAEC,cAAe,CADf,WAED,CAGD,6EAEE,aAMF,CARA,6EAME,aAEF,CD1ED",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-link-actions__preview {\n\t\tdisplay: inline-block;\n\n\t\t& .ck-button__label {\n\t\t\toverflow: hidden;\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-link-actions__preview {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\t& .ck-button.ck-link-actions__preview {\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\n\t\t& .ck-button__label {\n\t\t\tpadding: 0 var(--ck-spacing-medium);\n\t\t\tcolor: var(--ck-color-link-default);\n\t\t\ttext-overflow: ellipsis;\n\t\t\tcursor: pointer;\n\n\t\t\t/* Match the box model of the link editor form\'s input so the balloon\n\t\t\tdoes not change width when moving between actions and the form. */\n\t\t\tmax-width: var(--ck-input-width);\n\t\t\tmin-width: 3em;\n\t\t\ttext-align: center;\n\n\t\t\t&:hover {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\n\t\t&,\n\t\t&:hover,\n\t\t&:focus,\n\t\t&:active {\n\t\t\tbackground: none;\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&:focus {\n\t\t\t& .ck-button__label {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-button:not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-button:not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\t& .ck-button.ck-link-actions__preview {\n\t\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\n\n\t\t\t& .ck-button__label {\n\t\t\t\tmin-width: 0;\n\t\t\t\tmax-width: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          4827: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{min-width:var(--ck-input-width);padding:0}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical .ck-button{border:0;border-radius:0;border-top:1px solid var(--ck-color-base-border);margin:0;padding:var(--ck-spacing-standard);width:50%}[dir=ltr] :is(.ck.ck-link-form_layout-vertical .ck-button){margin-left:0}[dir=rtl] :is(.ck.ck-link-form_layout-vertical .ck-button){margin-left:0}[dir=rtl] :is(.ck.ck-link-form_layout-vertical .ck-button):last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{border:0;padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkform.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css",
                ],
                names: [],
                mappings:
                  "AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAYD,CALE,wHAEC,mCACD,CE/BF,iCAEC,+BAAgC,CADhC,SA+CD,CA5CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CAIC,QAAS,CADT,eAAgB,CAEhB,gDAAiD,CAHjD,QAAS,CADT,kCAAmC,CAKnC,SAaD,CAnBA,2DASE,aAUF,CAnBA,2DAaE,aAMF,CAJE,wEACC,kDACD,CAKF,6CACC,yDAWD,CATC,wEACC,QAAS,CACT,SAAU,CACV,UAKD,CAHC,8EACC,eACD",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-form {\n\tdisplay: flex;\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tdisplay: block;\n\n\t/*\n\t * Whether the form is in the responsive mode or not, if there are decorator buttons\n\t * keep the top margin of action buttons medium.\n\t */\n\t& .ck-button {\n\t\t&.ck-button-save,\n\t\t&.ck-button-cancel {\n\t\t\tmargin-top: var(--ck-spacing-medium);\n\t\t}\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tpadding: 0;\n\tmin-width: var(--ck-input-width);\n\n\t& .ck-labeled-field-view {\n\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);\n\n\t\t& .ck-input-text {\n\t\t\tmin-width: 0;\n\t\t\twidth: 100%;\n\t\t}\n\t}\n\n\t& .ck-button {\n\t\tpadding: var(--ck-spacing-standard);\n\t\tmargin: 0;\n\t\tborder-radius: 0;\n\t\tborder: 0;\n\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\twidth: 50%;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: 0;\n\n\t\t\t&:last-of-type {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Using additional `.ck` class for stronger CSS specificity than `.ck.ck-link-form > :not(:first-child)`. */\n\t& .ck.ck-list {\n\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-large);\n\n\t\t& .ck-button.ck-switchbutton {\n\t\t\tborder: 0;\n\t\t\tpadding: 0;\n\t\t\twidth: 100%;\n\n\t\t\t&:hover {\n\t\t\t\tbackground: none;\n\t\t\t}\n\t\t}\n\t}\n}\n',
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          5777: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck-content .media{clear:both;display:block;margin:.9em 0;min-width:15em}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaembed.css",
                ],
                names: [],
                mappings: "AAKA,mBAGC,UAAW,CASX,aAAc,CAJd,aAAe,CAQf,cACD",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .media {\n\t/* Don\'t allow floated content overlap the media.\n\thttps://github.com/ckeditor/ckeditor5-media-embed/issues/53 */\n\tclear: both;\n\n\t/* Make sure there is some space between the content and the media. */\n\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\tmargin: 0.9em 0;\n\n\t/* Make sure media is not overriden with Bootstrap default `flex` value.\n\tSee: https://github.com/ckeditor/ckeditor5/issues/1373. */\n\tdisplay: block;\n\n\t/* Give the media some minimal width in the content to prevent them\n\tfrom being "squashed" in tight spaces, e.g. in table cells (#44) */\n\tmin-width: 15em;\n}\n',
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          952: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              '.ck-media__wrapper .ck-media__placeholder{align-items:center;display:flex;flex-direction:column}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-tooltip{display:block}@media (hover:none){.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-tooltip{display:none}}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url{max-width:100%;position:relative}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url:hover .ck-tooltip{opacity:1;visibility:visible}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-media__placeholder__url__text{display:block;overflow:hidden}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck-media__placeholder__icon *{display:none}.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper>:not(.ck-media__placeholder),.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder{pointer-events:none}:root{--ck-media-embed-placeholder-icon-size:3em;--ck-color-media-embed-placeholder-url-text:#757575;--ck-color-media-embed-placeholder-url-text-hover:var(--ck-color-base-text)}.ck-media__wrapper{margin:0 auto}.ck-media__wrapper .ck-media__placeholder{background:var(--ck-color-base-foreground);padding:calc(var(--ck-spacing-standard)*3)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon{background-position:50%;background-size:cover;height:var(--ck-media-embed-placeholder-icon-size);margin-bottom:var(--ck-spacing-large);min-width:var(--ck-media-embed-placeholder-icon-size)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon .ck-icon{height:100%;width:100%}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text{color:var(--ck-color-media-embed-placeholder-url-text);font-style:italic;text-align:center;text-overflow:ellipsis;white-space:nowrap}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:var(--ck-color-media-embed-placeholder-url-text-hover);cursor:pointer;text-decoration:underline}.ck-media__wrapper[data-oembed-url*="open.spotify.com"]{max-height:380px;max-width:300px}.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Im0yMDYuNDc3IDI2MC45LTI4Ljk4NyAyOC45ODdhNS4yMTggNS4yMTggMCAwIDAgMy43OCAxLjYxaDQ5LjYyMWMxLjY5NCAwIDMuMTktLjc5OCA0LjE0Ni0yLjAzN3oiIGZpbGw9IiM1Yzg4YzUiLz48cGF0aCBkPSJNMjI2Ljc0MiAyMjIuOTg4Yy05LjI2NiAwLTE2Ljc3NyA3LjE3LTE2Ljc3NyAxNi4wMTQuMDA3IDIuNzYyLjY2MyA1LjQ3NCAyLjA5MyA3Ljg3NS40My43MDMuODMgMS40MDggMS4xOSAyLjEwNy4zMzMuNTAyLjY1IDEuMDA1Ljk1IDEuNTA4LjM0My40NzcuNjczLjk1Ny45ODggMS40NCAxLjMxIDEuNzY5IDIuNSAzLjUwMiAzLjYzNyA1LjE2OC43OTMgMS4yNzUgMS42ODMgMi42NCAyLjQ2NiAzLjk5IDIuMzYzIDQuMDk0IDQuMDA3IDguMDkyIDQuNiAxMy45MTR2LjAxMmMuMTgyLjQxMi41MTYuNjY2Ljg3OS42NjcuNDAzLS4wMDEuNzY4LS4zMTQuOTMtLjc5OS42MDMtNS43NTYgMi4yMzgtOS43MjkgNC41ODUtMTMuNzk0Ljc4Mi0xLjM1IDEuNjczLTIuNzE1IDIuNDY1LTMuOTkgMS4xMzctMS42NjYgMi4zMjgtMy40IDMuNjM4LTUuMTY5LjMxNS0uNDgyLjY0NS0uOTYyLjk4OC0xLjQzOS4zLS41MDMuNjE3LTEuMDA2Ljk1LTEuNTA4LjM1OS0uNy43Ni0xLjQwNCAxLjE5LTIuMTA3IDEuNDI2LTIuNDAyIDItNS4xMTQgMi4wMDQtNy44NzUgMC04Ljg0NC03LjUxMS0xNi4wMTQtMTYuNzc2LTE2LjAxNHoiIGZpbGw9IiNkZDRiM2UiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PGVsbGlwc2Ugcnk9IjUuNTY0IiByeD0iNS44MjgiIGN5PSIyMzkuMDAyIiBjeD0iMjI2Ljc0MiIgZmlsbD0iIzgwMmQyNyIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMTkwLjMwMSAyMzcuMjgzYy00LjY3IDAtOC40NTcgMy44NTMtOC40NTcgOC42MDZzMy43ODYgOC42MDcgOC40NTcgOC42MDdjMy4wNDMgMCA0LjgwNi0uOTU4IDYuMzM3LTIuNTE2IDEuNTMtMS41NTcgMi4wODctMy45MTMgMi4wODctNi4yOSAwLS4zNjItLjAyMy0uNzIyLS4wNjQtMS4wNzloLTguMjU3djMuMDQzaDQuODVjLS4xOTcuNzU5LS41MzEgMS40NS0xLjA1OCAxLjk4Ni0uOTQyLjk1OC0yLjAyOCAxLjU0OC0zLjkwMSAxLjU0OC0yLjg3NiAwLTUuMjA4LTIuMzcyLTUuMjA4LTUuMjk5IDAtMi45MjYgMi4zMzItNS4yOTkgNS4yMDgtNS4yOTkgMS4zOTkgMCAyLjYxOC40MDcgMy41ODQgMS4yOTNsMi4zODEtMi4zOGMwLS4wMDItLjAwMy0uMDA0LS4wMDQtLjAwNS0xLjU4OC0xLjUyNC0zLjYyLTIuMjE1LTUuOTU1LTIuMjE1em00LjQzIDUuNjYuMDAzLjAwNnYtLjAwM3oiIGZpbGw9IiNmZmYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0ibTIxNS4xODQgMjUxLjkyOS03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVhNS4yMzMgNS4yMzMgMCAwIDAgLjQ0OS0yLjEyM3YtMzEuMTY1Yy0uNDY5LjY3NS0uOTM0IDEuMzQ5LTEuMzgyIDIuMDA1LS43OTIgMS4yNzUtMS42ODIgMi42NC0yLjQ2NSAzLjk5LTIuMzQ3IDQuMDY1LTMuOTgyIDguMDM4LTQuNTg1IDEzLjc5NC0uMTYyLjQ4NS0uNTI3Ljc5OC0uOTMuNzk5LS4zNjMtLjAwMS0uNjk3LS4yNTUtLjg3OS0uNjY3di0uMDEyYy0uNTkzLTUuODIyLTIuMjM3LTkuODItNC42LTEzLjkxNC0uNzgzLTEuMzUtMS42NzMtMi43MTUtMi40NjYtMy45OS0xLjEzNy0xLjY2Ni0yLjMyNy0zLjQtMy42MzctNS4xNjlsLS4wMDItLjAwM3oiIGZpbGw9IiNjM2MzYzMiLz48cGF0aCBkPSJtMjEyLjk4MyAyNDguNDk1LTM2Ljk1MiAzNi45NTN2LjgxMmE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOCA1LjIzOGgxLjAxNWwzNS42NjYtMzUuNjY2YTEzNi4yNzUgMTM2LjI3NSAwIDAgMC0yLjc2NC0zLjkgMzcuNTc1IDM3LjU3NSAwIDAgMC0uOTg5LTEuNDQgMzUuMTI3IDM1LjEyNyAwIDAgMC0uOTUtMS41MDhjLS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJtMjExLjk5OCAyNjEuMDgzLTYuMTUyIDYuMTUxIDI0LjI2NCAyNC4yNjRoLjc4MWE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOS01LjIzOHYtMS4wNDV6IiBmaWxsPSIjZmZmIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjwvZz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder{background:#4268b3}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik05NjcuNDg0IDBINTYuNTE3QzI1LjMwNCAwIDAgMjUuMzA0IDAgNTYuNTE3djkxMC45NjZDMCA5OTguNjk0IDI1LjI5NyAxMDI0IDU2LjUyMiAxMDI0SDU0N1Y2MjhINDE0VjQ3M2gxMzNWMzU5LjAyOWMwLTEzMi4yNjIgODAuNzczLTIwNC4yODIgMTk4Ljc1Ni0yMDQuMjgyIDU2LjUxMyAwIDEwNS4wODYgNC4yMDggMTE5LjI0NCA2LjA4OVYyOTlsLTgxLjYxNi4wMzdjLTYzLjk5MyAwLTc2LjM4NCAzMC40OTItNzYuMzg0IDc1LjIzNlY0NzNoMTUzLjQ4N2wtMTkuOTg2IDE1NUg3MDd2Mzk2aDI2MC40ODRjMzEuMjEzIDAgNTYuNTE2LTI1LjMwMyA1Ni41MTYtNTYuNTE2VjU2LjUxNUMxMDI0IDI1LjMwMyA5OTguNjk3IDAgOTY3LjQ4NCAwIiBmaWxsPSIjRkZGRkZFIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#cdf}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder{background:linear-gradient(-135deg,#1400c7,#b800b1,#f50000)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTA0IiBoZWlnaHQ9IjUwNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIC4xNTloNTAzLjg0MVY1MDMuOTRIMHoiLz48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48bWFzayBpZD0iYiIgZmlsbD0iI2ZmZiI+PHVzZSB4bGluazpocmVmPSIjYSIvPjwvbWFzaz48cGF0aCBkPSJNMjUxLjkyMS4xNTljLTY4LjQxOCAwLTc2Ljk5Ny4yOS0xMDMuODY3IDEuNTE2LTI2LjgxNCAxLjIyMy00NS4xMjcgNS40ODItNjEuMTUxIDExLjcxLTE2LjU2NiA2LjQzNy0zMC42MTUgMTUuMDUxLTQ0LjYyMSAyOS4wNTYtMTQuMDA1IDE0LjAwNi0yMi42MTkgMjguMDU1LTI5LjA1NiA0NC42MjEtNi4yMjggMTYuMDI0LTEwLjQ4NyAzNC4zMzctMTEuNzEgNjEuMTUxQy4yOSAxNzUuMDgzIDAgMTgzLjY2MiAwIDI1Mi4wOGMwIDY4LjQxNy4yOSA3Ni45OTYgMS41MTYgMTAzLjg2NiAxLjIyMyAyNi44MTQgNS40ODIgNDUuMTI3IDExLjcxIDYxLjE1MSA2LjQzNyAxNi41NjYgMTUuMDUxIDMwLjYxNSAyOS4wNTYgNDQuNjIxIDE0LjAwNiAxNC4wMDUgMjguMDU1IDIyLjYxOSA0NC42MjEgMjkuMDU3IDE2LjAyNCA2LjIyNyAzNC4zMzcgMTAuNDg2IDYxLjE1MSAxMS43MDkgMjYuODcgMS4yMjYgMzUuNDQ5IDEuNTE2IDEwMy44NjcgMS41MTYgNjguNDE3IDAgNzYuOTk2LS4yOSAxMDMuODY2LTEuNTE2IDI2LjgxNC0xLjIyMyA0NS4xMjctNS40ODIgNjEuMTUxLTExLjcwOSAxNi41NjYtNi40MzggMzAuNjE1LTE1LjA1MiA0NC42MjEtMjkuMDU3IDE0LjAwNS0xNC4wMDYgMjIuNjE5LTI4LjA1NSAyOS4wNTctNDQuNjIxIDYuMjI3LTE2LjAyNCAxMC40ODYtMzQuMzM3IDExLjcwOS02MS4xNTEgMS4yMjYtMjYuODcgMS41MTYtMzUuNDQ5IDEuNTE2LTEwMy44NjYgMC02OC40MTgtLjI5LTc2Ljk5Ny0xLjUxNi0xMDMuODY3LTEuMjIzLTI2LjgxNC01LjQ4Mi00NS4xMjctMTEuNzA5LTYxLjE1MS02LjQzOC0xNi41NjYtMTUuMDUyLTMwLjYxNS0yOS4wNTctNDQuNjIxLTE0LjAwNi0xNC4wMDUtMjguMDU1LTIyLjYxOS00NC42MjEtMjkuMDU2LTE2LjAyNC02LjIyOC0zNC4zMzctMTAuNDg3LTYxLjE1MS0xMS43MUMzMjguOTE3LjQ0OSAzMjAuMzM4LjE1OSAyNTEuOTIxLjE1OVptMCA0NS4zOTFjNjcuMjY1IDAgNzUuMjMzLjI1NyAxMDEuNzk3IDEuNDY5IDI0LjU2MiAxLjEyIDM3LjkwMSA1LjIyNCA0Ni43NzggOC42NzQgMTEuNzU5IDQuNTcgMjAuMTUxIDEwLjAyOSAyOC45NjYgMTguODQ1IDguODE2IDguODE1IDE0LjI3NSAxNy4yMDcgMTguODQ1IDI4Ljk2NiAzLjQ1IDguODc3IDcuNTU0IDIyLjIxNiA4LjY3NCA0Ni43NzggMS4yMTIgMjYuNTY0IDEuNDY5IDM0LjUzMiAxLjQ2OSAxMDEuNzk4IDAgNjcuMjY1LS4yNTcgNzUuMjMzLTEuNDY5IDEwMS43OTctMS4xMiAyNC41NjItNS4yMjQgMzcuOTAxLTguNjc0IDQ2Ljc3OC00LjU3IDExLjc1OS0xMC4wMjkgMjAuMTUxLTE4Ljg0NSAyOC45NjYtOC44MTUgOC44MTYtMTcuMjA3IDE0LjI3NS0yOC45NjYgMTguODQ1LTguODc3IDMuNDUtMjIuMjE2IDcuNTU0LTQ2Ljc3OCA4LjY3NC0yNi41NiAxLjIxMi0zNC41MjcgMS40NjktMTAxLjc5NyAxLjQ2OS02Ny4yNzEgMC03NS4yMzctLjI1Ny0xMDEuNzk4LTEuNDY5LTI0LjU2Mi0xLjEyLTM3LjkwMS01LjIyNC00Ni43NzgtOC42NzQtMTEuNzU5LTQuNTctMjAuMTUxLTEwLjAyOS0yOC45NjYtMTguODQ1LTguODE1LTguODE1LTE0LjI3NS0xNy4yMDctMTguODQ1LTI4Ljk2Ni0zLjQ1LTguODc3LTcuNTU0LTIyLjIxNi04LjY3NC00Ni43NzgtMS4yMTItMjYuNTY0LTEuNDY5LTM0LjUzMi0xLjQ2OS0xMDEuNzk3IDAtNjcuMjY2LjI1Ny03NS4yMzQgMS40NjktMTAxLjc5OCAxLjEyLTI0LjU2MiA1LjIyNC0zNy45MDEgOC42NzQtNDYuNzc4IDQuNTctMTEuNzU5IDEwLjAyOS0yMC4xNTEgMTguODQ1LTI4Ljk2NiA4LjgxNS04LjgxNiAxNy4yMDctMTQuMjc1IDI4Ljk2Ni0xOC44NDUgOC44NzctMy40NSAyMi4yMTYtNy41NTQgNDYuNzc4LTguNjc0IDI2LjU2NC0xLjIxMiAzNC41MzItMS40NjkgMTAxLjc5OC0xLjQ2OVoiIGZpbGw9IiNGRkYiIG1hc2s9InVybCgjYikiLz48cGF0aCBkPSJNMjUxLjkyMSAzMzYuMDUzYy00Ni4zNzggMC04My45NzQtMzcuNTk2LTgzLjk3NC04My45NzMgMC00Ni4zNzggMzcuNTk2LTgzLjk3NCA4My45NzQtODMuOTc0IDQ2LjM3NyAwIDgzLjk3MyAzNy41OTYgODMuOTczIDgzLjk3NCAwIDQ2LjM3Ny0zNy41OTYgODMuOTczLTgzLjk3MyA4My45NzNabTAtMjEzLjMzOGMtNzEuNDQ3IDAtMTI5LjM2NSA1Ny45MTgtMTI5LjM2NSAxMjkuMzY1IDAgNzEuNDQ2IDU3LjkxOCAxMjkuMzY0IDEyOS4zNjUgMTI5LjM2NCA3MS40NDYgMCAxMjkuMzY0LTU3LjkxOCAxMjkuMzY0LTEyOS4zNjQgMC03MS40NDctNTcuOTE4LTEyOS4zNjUtMTI5LjM2NC0xMjkuMzY1Wk00MTYuNjI3IDExNy42MDRjMCAxNi42OTYtMTMuNTM1IDMwLjIzLTMwLjIzMSAzMC4yMy0xNi42OTUgMC0zMC4yMy0xMy41MzQtMzAuMjMtMzAuMjMgMC0xNi42OTYgMTMuNTM1LTMwLjIzMSAzMC4yMy0zMC4yMzEgMTYuNjk2IDAgMzAuMjMxIDEzLjUzNSAzMC4yMzEgMzAuMjMxIiBmaWxsPSIjRkZGIi8+PC9nPjwvc3ZnPg==)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#ffe0fe}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder{background:linear-gradient(90deg,#71c6f4,#0d70a5)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0MDAgNDAwIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJNNDAwIDIwMGMwIDExMC41LTg5LjUgMjAwLTIwMCAyMDBTMCAzMTAuNSAwIDIwMCA4OS41IDAgMjAwIDBzMjAwIDg5LjUgMjAwIDIwMHpNMTYzLjQgMzA1LjVjODguNyAwIDEzNy4yLTczLjUgMTM3LjItMTM3LjIgMC0yLjEgMC00LjItLjEtNi4yIDkuNC02LjggMTcuNi0xNS4zIDI0LjEtMjUtOC42IDMuOC0xNy45IDYuNC0yNy43IDcuNiAxMC02IDE3LjYtMTUuNCAyMS4yLTI2LjctOS4zIDUuNS0xOS42IDkuNS0zMC42IDExLjctOC44LTkuNC0yMS4zLTE1LjItMzUuMi0xNS4yLTI2LjYgMC00OC4yIDIxLjYtNDguMiA0OC4yIDAgMy44LjQgNy41IDEuMyAxMS00MC4xLTItNzUuNi0yMS4yLTk5LjQtNTAuNC00LjEgNy4xLTYuNSAxNS40LTYuNSAyNC4yIDAgMTYuNyA4LjUgMzEuNSAyMS41IDQwLjEtNy45LS4yLTE1LjMtMi40LTIxLjgtNnYuNmMwIDIzLjQgMTYuNiA0Mi44IDM4LjcgNDcuMy00IDEuMS04LjMgMS43LTEyLjcgMS43LTMuMSAwLTYuMS0uMy05LjEtLjkgNi4xIDE5LjIgMjMuOSAzMy4xIDQ1IDMzLjUtMTYuNSAxMi45LTM3LjMgMjAuNi01OS45IDIwLjYtMy45IDAtNy43LS4yLTExLjUtLjcgMjEuMSAxMy44IDQ2LjUgMjEuOCA3My43IDIxLjgiIHN0eWxlPSJmaWxsOiNmZmYiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text{color:#b8e6ff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}',
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaembedediting.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-media-embed/mediaembedediting.css",
                ],
                names: [],
                mappings:
                  "AAQC,0CAGC,kBAAmB,CAFnB,YAAa,CACb,qBAoBD,CCpBA,kFACC,aAqBD,CAHC,oBAnBD,kFAoBE,YAEF,CADC,CDlBA,sEAIC,cAAe,CAEf,iBAUD,CCoBD,wFAEC,SAAU,CADV,kBAED,CD3BE,wGAEC,aAAc,CADd,eAED,CAWD,6kBACC,YACD,CAYF,2LACC,mBACD,CElDA,MACC,0CAA2C,CAE3C,mDAA4D,CAC5D,2EACD,CAEA,mBACC,aA+FD,CA7FC,0CAEC,0CAA2C,CAD3C,0CA6BD,CA1BC,uEAIC,uBAA2B,CAC3B,qBAAsB,CAHtB,kDAAmD,CACnD,qCAAsC,CAFtC,qDAUD,CAJC,gFAEC,WAAY,CADZ,UAED,CAGD,4EACC,sDAAuD,CAGvD,iBAAkB,CADlB,iBAAkB,CAElB,sBAAuB,CAHvB,kBAUD,CALC,kFACC,4DAA6D,CAC7D,cAAe,CACf,yBACD,CAIF,wDAEC,gBAAiB,CADjB,eAED,CAEA,4UAIC,wvGACD,CAEA,2EACC,kBAaD,CAXC,wGACC,orBACD,CAEA,6GACC,UAKD,CAHC,mHACC,UACD,CAIF,4EACC,2DAcD,CAZC,yGACC,4jHACD,CAGA,8GACC,aAKD,CAHC,oHACC,UACD,CAIF,6EAEC,iDAaD,CAXC,0GACC,wiCACD,CAEA,+GACC,aAKD,CAHC,qHACC,UACD",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css";\n\n.ck-media__wrapper {\n\t& .ck-media__placeholder {\n\t\tdisplay: flex;\n\t\tflex-direction: column;\n\t\talign-items: center;\n\n\t\t& .ck-media__placeholder__url {\n\t\t\t@mixin ck-tooltip_enabled;\n\n\t\t\t/* Otherwise the URL will overflow when the content is very narrow. */\n\t\t\tmax-width: 100%;\n\n\t\t\tposition: relative;\n\n\t\t\t&:hover {\n\t\t\t\t@mixin ck-tooltip_visible;\n\t\t\t}\n\n\t\t\t& .ck-media__placeholder__url__text {\n\t\t\t\toverflow: hidden;\n\t\t\t\tdisplay: block;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="twitter.com"],\n\t&[data-oembed-url*="google.com/maps"],\n\t&[data-oembed-url*="goo.gl/maps"],\n\t&[data-oembed-url*="maps.google.com"],\n\t&[data-oembed-url*="maps.app.goo.gl"],\n\t&[data-oembed-url*="facebook.com"],\n\t&[data-oembed-url*="instagram.com"] {\n\t\t& .ck-media__placeholder__icon * {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/* Disable all mouse interaction as long as the editor is not read–only.\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/58 */\n.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper > *:not(.ck-media__placeholder) {\n\tpointer-events: none;\n}\n\n/* Disable all mouse interaction when the widget is not selected (e.g. to avoid opening links by accident).\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/18 */\n.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder {\n\tpointer-events: none;\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n\t& .ck-tooltip {\n\t\tdisplay: block;\n\n\t\t/*\n\t\t * Don't display tooltips in devices which don't support :hover.\n\t\t * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n\t\t * the primary action, when tooltips are enabled.\n\t\t *\n\t\t * Q: OK, but why not the following query?\n\t\t *\n\t\t *   @media (hover) {\n\t\t *       display: block;\n\t\t *   }\n\t\t *\n\t\t * A: Because FF does not support it and it would completely disable tooltips\n\t\t * in that browser.\n\t\t *\n\t\t * More in https://github.com/ckeditor/ckeditor5/issues/920.\n\t\t */\n\t\t@media (hover:none) {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n\t& .ck-tooltip {\n\t\tdisplay: none;\n\t}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n\t& .ck-tooltip {\n\t\tvisibility: visible;\n\t\topacity: 1;\n\t}\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-media-embed-placeholder-icon-size: 3em;\n\n\t--ck-color-media-embed-placeholder-url-text: hsl(0, 0%, 46%);\n\t--ck-color-media-embed-placeholder-url-text-hover: var(--ck-color-base-text);\n}\n\n.ck-media__wrapper {\n\tmargin: 0 auto;\n\n\t& .ck-media__placeholder {\n\t\tpadding: calc( 3 * var(--ck-spacing-standard) );\n\t\tbackground: var(--ck-color-base-foreground);\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tmin-width: var(--ck-media-embed-placeholder-icon-size);\n\t\t\theight: var(--ck-media-embed-placeholder-icon-size);\n\t\t\tmargin-bottom: var(--ck-spacing-large);\n\t\t\tbackground-position: center;\n\t\t\tbackground-size: cover;\n\n\t\t\t& .ck-icon {\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: var(--ck-color-media-embed-placeholder-url-text);\n\t\t\twhite-space: nowrap;\n\t\t\ttext-align: center;\n\t\t\tfont-style: italic;\n\t\t\ttext-overflow: ellipsis;\n\n\t\t\t&:hover {\n\t\t\t\tcolor: var(--ck-color-media-embed-placeholder-url-text-hover);\n\t\t\t\tcursor: pointer;\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="open.spotify.com"] {\n\t\tmax-width: 300px;\n\t\tmax-height: 380px;\n\t}\n\n\t&[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,\n\t&[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,\n\t&[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon,\n\t&[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon {\n\t\tbackground-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0yMDYuNDc3IDI2MC45bC0yOC45ODcgMjguOTg3YTUuMjE4IDUuMjE4IDAgMCAwIDMuNzggMS42MWg0OS42MjFjMS42OTQgMCAzLjE5LS43OTggNC4xNDYtMi4wMzd6IiBmaWxsPSIjNWM4OGM1Ii8+PHBhdGggZD0iTTIyNi43NDIgMjIyLjk4OGMtOS4yNjYgMC0xNi43NzcgNy4xNy0xNi43NzcgMTYuMDE0LjAwNyAyLjc2Mi42NjMgNS40NzQgMi4wOTMgNy44NzUuNDMuNzAzLjgzIDEuNDA4IDEuMTkgMi4xMDcuMzMzLjUwMi42NSAxLjAwNS45NSAxLjUwOC4zNDMuNDc3LjY3My45NTcuOTg4IDEuNDQgMS4zMSAxLjc2OSAyLjUgMy41MDIgMy42MzcgNS4xNjguNzkzIDEuMjc1IDEuNjgzIDIuNjQgMi40NjYgMy45OSAyLjM2MyA0LjA5NCA0LjAwNyA4LjA5MiA0LjYgMTMuOTE0di4wMTJjLjE4Mi40MTIuNTE2LjY2Ni44NzkuNjY3LjQwMy0uMDAxLjc2OC0uMzE0LjkzLS43OTkuNjAzLTUuNzU2IDIuMjM4LTkuNzI5IDQuNTg1LTEzLjc5NC43ODItMS4zNSAxLjY3My0yLjcxNSAyLjQ2NS0zLjk5IDEuMTM3LTEuNjY2IDIuMzI4LTMuNCAzLjYzOC01LjE2OS4zMTUtLjQ4Mi42NDUtLjk2Mi45ODgtMS40MzkuMy0uNTAzLjYxNy0xLjAwNi45NS0xLjUwOC4zNTktLjcuNzYtMS40MDQgMS4xOS0yLjEwNyAxLjQyNi0yLjQwMiAyLTUuMTE0IDIuMDA0LTcuODc1IDAtOC44NDQtNy41MTEtMTYuMDE0LTE2Ljc3Ni0xNi4wMTR6IiBmaWxsPSIjZGQ0YjNlIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxlbGxpcHNlIHJ5PSI1LjU2NCIgcng9IjUuODI4IiBjeT0iMjM5LjAwMiIgY3g9IjIyNi43NDIiIGZpbGw9IiM4MDJkMjciIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTE5MC4zMDEgMjM3LjI4M2MtNC42NyAwLTguNDU3IDMuODUzLTguNDU3IDguNjA2czMuNzg2IDguNjA3IDguNDU3IDguNjA3YzMuMDQzIDAgNC44MDYtLjk1OCA2LjMzNy0yLjUxNiAxLjUzLTEuNTU3IDIuMDg3LTMuOTEzIDIuMDg3LTYuMjkgMC0uMzYyLS4wMjMtLjcyMi0uMDY0LTEuMDc5aC04LjI1N3YzLjA0M2g0Ljg1Yy0uMTk3Ljc1OS0uNTMxIDEuNDUtMS4wNTggMS45ODYtLjk0Mi45NTgtMi4wMjggMS41NDgtMy45MDEgMS41NDgtMi44NzYgMC01LjIwOC0yLjM3Mi01LjIwOC01LjI5OSAwLTIuOTI2IDIuMzMyLTUuMjk5IDUuMjA4LTUuMjk5IDEuMzk5IDAgMi42MTguNDA3IDMuNTg0IDEuMjkzbDIuMzgxLTIuMzhjMC0uMDAyLS4wMDMtLjAwNC0uMDA0LS4wMDUtMS41ODgtMS41MjQtMy42Mi0yLjIxNS01Ljk1NS0yLjIxNXptNC40MyA1LjY2bC4wMDMuMDA2di0uMDAzeiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjE1LjE4NCAyNTEuOTI5bC03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVjLjI4Ny0uNjQ5LjQ0OS0xLjM2Ni40NDktMi4xMjN2LTMxLjE2NWMtLjQ2OS42NzUtLjkzNCAxLjM0OS0xLjM4MiAyLjAwNS0uNzkyIDEuMjc1LTEuNjgyIDIuNjQtMi40NjUgMy45OS0yLjM0NyA0LjA2NS0zLjk4MiA4LjAzOC00LjU4NSAxMy43OTQtLjE2Mi40ODUtLjUyNy43OTgtLjkzLjc5OS0uMzYzLS4wMDEtLjY5Ny0uMjU1LS44NzktLjY2N3YtLjAxMmMtLjU5My01LjgyMi0yLjIzNy05LjgyLTQuNi0xMy45MTQtLjc4My0xLjM1LTEuNjczLTIuNzE1LTIuNDY2LTMuOTktMS4xMzctMS42NjYtMi4zMjctMy40LTMuNjM3LTUuMTY5bC0uMDAyLS4wMDN6IiBmaWxsPSIjYzNjM2MzIi8+PHBhdGggZD0iTTIxMi45ODMgMjQ4LjQ5NWwtMzYuOTUyIDM2Ljk1M3YuODEyYTUuMjI3IDUuMjI3IDAgMCAwIDUuMjM4IDUuMjM4aDEuMDE1bDM1LjY2Ni0zNS42NjZhMTM2LjI3NSAxMzYuMjc1IDAgMCAwLTIuNzY0LTMuOSAzNy41NzUgMzcuNTc1IDAgMCAwLS45ODktMS40NGMtLjI5OS0uNTAzLS42MTYtMS4wMDYtLjk1LTEuNTA4LS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjExLjk5OCAyNjEuMDgzbC02LjE1MiA2LjE1MSAyNC4yNjQgMjQuMjY0aC43ODFhNS4yMjcgNS4yMjcgMCAwIDAgNS4yMzktNS4yMzh2LTEuMDQ1eiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48L2c+PC9zdmc+);\n\t}\n\n\t&[data-oembed-url*="facebook.com"] .ck-media__placeholder {\n\t\tbackground: hsl(220, 46%, 48%);\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSIxMDI0cHgiIGhlaWdodD0iMTAyNHB4IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPiAgICAgICAgPHRpdGxlPkZpbGwgMTwvdGl0bGU+ICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPiAgICA8ZGVmcz48L2RlZnM+ICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgICAgICAgPGcgaWQ9ImZMb2dvX1doaXRlIiBmaWxsPSIjRkZGRkZFIj4gICAgICAgICAgICA8cGF0aCBkPSJNOTY3LjQ4NCwwIEw1Ni41MTcsMCBDMjUuMzA0LDAgMCwyNS4zMDQgMCw1Ni41MTcgTDAsOTY3LjQ4MyBDMCw5OTguNjk0IDI1LjI5NywxMDI0IDU2LjUyMiwxMDI0IEw1NDcsMTAyNCBMNTQ3LDYyOCBMNDE0LDYyOCBMNDE0LDQ3MyBMNTQ3LDQ3MyBMNTQ3LDM1OS4wMjkgQzU0NywyMjYuNzY3IDYyNy43NzMsMTU0Ljc0NyA3NDUuNzU2LDE1NC43NDcgQzgwMi4yNjksMTU0Ljc0NyA4NTAuODQyLDE1OC45NTUgODY1LDE2MC44MzYgTDg2NSwyOTkgTDc4My4zODQsMjk5LjAzNyBDNzE5LjM5MSwyOTkuMDM3IDcwNywzMjkuNTI5IDcwNywzNzQuMjczIEw3MDcsNDczIEw4NjAuNDg3LDQ3MyBMODQwLjUwMSw2MjggTDcwNyw2MjggTDcwNywxMDI0IEw5NjcuNDg0LDEwMjQgQzk5OC42OTcsMTAyNCAxMDI0LDk5OC42OTcgMTAyNCw5NjcuNDg0IEwxMDI0LDU2LjUxNSBDMTAyNCwyNS4zMDMgOTk4LjY5NywwIDk2Ny40ODQsMCIgaWQ9IkZpbGwtMSI+PC9wYXRoPiAgICAgICAgPC9nPiAgICA8L2c+PC9zdmc+);\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(220, 100%, 90%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="instagram.com"] .ck-media__placeholder {\n\t\tbackground: linear-gradient(-135deg,hsl(246, 100%, 39%),hsl(302, 100%, 36%),hsl(0, 100%, 48%));\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSI1MDRweCIgaGVpZ2h0PSI1MDRweCIgdmlld0JveD0iMCAwIDUwNCA1MDQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+ICAgICAgICA8dGl0bGU+Z2x5cGgtbG9nb19NYXkyMDE2PC90aXRsZT4gICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+ICAgIDxkZWZzPiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMSIgcG9pbnRzPSIwIDAuMTU5IDUwMy44NDEgMC4xNTkgNTAzLjg0MSA1MDMuOTQgMCA1MDMuOTQiPjwvcG9seWdvbj4gICAgPC9kZWZzPiAgICA8ZyBpZD0iZ2x5cGgtbG9nb19NYXkyMDE2IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4gICAgICAgIDxnIGlkPSJHcm91cC0zIj4gICAgICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBmaWxsPSJ3aGl0ZSI+ICAgICAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+ICAgICAgICAgICAgPC9tYXNrPiAgICAgICAgICAgIDxnIGlkPSJDbGlwLTIiPjwvZz4gICAgICAgICAgICA8cGF0aCBkPSJNMjUxLjkyMSwwLjE1OSBDMTgzLjUwMywwLjE1OSAxNzQuOTI0LDAuNDQ5IDE0OC4wNTQsMS42NzUgQzEyMS4yNCwyLjg5OCAxMDIuOTI3LDcuMTU3IDg2LjkwMywxMy4zODUgQzcwLjMzNywxOS44MjIgNTYuMjg4LDI4LjQzNiA0Mi4yODIsNDIuNDQxIEMyOC4yNzcsNTYuNDQ3IDE5LjY2Myw3MC40OTYgMTMuMjI2LDg3LjA2MiBDNi45OTgsMTAzLjA4NiAyLjczOSwxMjEuMzk5IDEuNTE2LDE0OC4yMTMgQzAuMjksMTc1LjA4MyAwLDE4My42NjIgMCwyNTIuMDggQzAsMzIwLjQ5NyAwLjI5LDMyOS4wNzYgMS41MTYsMzU1Ljk0NiBDMi43MzksMzgyLjc2IDYuOTk4LDQwMS4wNzMgMTMuMjI2LDQxNy4wOTcgQzE5LjY2Myw0MzMuNjYzIDI4LjI3Nyw0NDcuNzEyIDQyLjI4Miw0NjEuNzE4IEM1Ni4yODgsNDc1LjcyMyA3MC4zMzcsNDg0LjMzNyA4Ni45MDMsNDkwLjc3NSBDMTAyLjkyNyw0OTcuMDAyIDEyMS4yNCw1MDEuMjYxIDE0OC4wNTQsNTAyLjQ4NCBDMTc0LjkyNCw1MDMuNzEgMTgzLjUwMyw1MDQgMjUxLjkyMSw1MDQgQzMyMC4zMzgsNTA0IDMyOC45MTcsNTAzLjcxIDM1NS43ODcsNTAyLjQ4NCBDMzgyLjYwMSw1MDEuMjYxIDQwMC45MTQsNDk3LjAwMiA0MTYuOTM4LDQ5MC43NzUgQzQzMy41MDQsNDg0LjMzNyA0NDcuNTUzLDQ3NS43MjMgNDYxLjU1OSw0NjEuNzE4IEM0NzUuNTY0LDQ0Ny43MTIgNDg0LjE3OCw0MzMuNjYzIDQ5MC42MTYsNDE3LjA5NyBDNDk2Ljg0Myw0MDEuMDczIDUwMS4xMDIsMzgyLjc2IDUwMi4zMjUsMzU1Ljk0NiBDNTAzLjU1MSwzMjkuMDc2IDUwMy44NDEsMzIwLjQ5NyA1MDMuODQxLDI1Mi4wOCBDNTAzLjg0MSwxODMuNjYyIDUwMy41NTEsMTc1LjA4MyA1MDIuMzI1LDE0OC4yMTMgQzUwMS4xMDIsMTIxLjM5OSA0OTYuODQzLDEwMy4wODYgNDkwLjYxNiw4Ny4wNjIgQzQ4NC4xNzgsNzAuNDk2IDQ3NS41NjQsNTYuNDQ3IDQ2MS41NTksNDIuNDQxIEM0NDcuNTUzLDI4LjQzNiA0MzMuNTA0LDE5LjgyMiA0MTYuOTM4LDEzLjM4NSBDNDAwLjkxNCw3LjE1NyAzODIuNjAxLDIuODk4IDM1NS43ODcsMS42NzUgQzMyOC45MTcsMC40NDkgMzIwLjMzOCwwLjE1OSAyNTEuOTIxLDAuMTU5IFogTTI1MS45MjEsNDUuNTUgQzMxOS4xODYsNDUuNTUgMzI3LjE1NCw0NS44MDcgMzUzLjcxOCw0Ny4wMTkgQzM3OC4yOCw0OC4xMzkgMzkxLjYxOSw1Mi4yNDMgNDAwLjQ5Niw1NS42OTMgQzQxMi4yNTUsNjAuMjYzIDQyMC42NDcsNjUuNzIyIDQyOS40NjIsNzQuNTM4IEM0MzguMjc4LDgzLjM1MyA0NDMuNzM3LDkxLjc0NSA0NDguMzA3LDEwMy41MDQgQzQ1MS43NTcsMTEyLjM4MSA0NTUuODYxLDEyNS43MiA0NTYuOTgxLDE1MC4yODIgQzQ1OC4xOTMsMTc2Ljg0NiA0NTguNDUsMTg0LjgxNCA0NTguNDUsMjUyLjA4IEM0NTguNDUsMzE5LjM0NSA0NTguMTkzLDMyNy4zMTMgNDU2Ljk4MSwzNTMuODc3IEM0NTUuODYxLDM3OC40MzkgNDUxLjc1NywzOTEuNzc4IDQ0OC4zMDcsNDAwLjY1NSBDNDQzLjczNyw0MTIuNDE0IDQzOC4yNzgsNDIwLjgwNiA0MjkuNDYyLDQyOS42MjEgQzQyMC42NDcsNDM4LjQzNyA0MTIuMjU1LDQ0My44OTYgNDAwLjQ5Niw0NDguNDY2IEMzOTEuNjE5LDQ1MS45MTYgMzc4LjI4LDQ1Ni4wMiAzNTMuNzE4LDQ1Ny4xNCBDMzI3LjE1OCw0NTguMzUyIDMxOS4xOTEsNDU4LjYwOSAyNTEuOTIxLDQ1OC42MDkgQzE4NC42NSw0NTguNjA5IDE3Ni42ODQsNDU4LjM1MiAxNTAuMTIzLDQ1Ny4xNCBDMTI1LjU2MSw0NTYuMDIgMTEyLjIyMiw0NTEuOTE2IDEwMy4zNDUsNDQ4LjQ2NiBDOTEuNTg2LDQ0My44OTYgODMuMTk0LDQzOC40MzcgNzQuMzc5LDQyOS42MjEgQzY1LjU2NCw0MjAuODA2IDYwLjEwNCw0MTIuNDE0IDU1LjUzNCw0MDAuNjU1IEM1Mi4wODQsMzkxLjc3OCA0Ny45OCwzNzguNDM5IDQ2Ljg2LDM1My44NzcgQzQ1LjY0OCwzMjcuMzEzIDQ1LjM5MSwzMTkuMzQ1IDQ1LjM5MSwyNTIuMDggQzQ1LjM5MSwxODQuODE0IDQ1LjY0OCwxNzYuODQ2IDQ2Ljg2LDE1MC4yODIgQzQ3Ljk4LDEyNS43MiA1Mi4wODQsMTEyLjM4MSA1NS41MzQsMTAzLjUwNCBDNjAuMTA0LDkxLjc0NSA2NS41NjMsODMuMzUzIDc0LjM3OSw3NC41MzggQzgzLjE5NCw2NS43MjIgOTEuNTg2LDYwLjI2MyAxMDMuMzQ1LDU1LjY5MyBDMTEyLjIyMiw1Mi4yNDMgMTI1LjU2MSw0OC4xMzkgMTUwLjEyMyw0Ny4wMTkgQzE3Ni42ODcsNDUuODA3IDE4NC42NTUsNDUuNTUgMjUxLjkyMSw0NS41NSBaIiBpZD0iRmlsbC0xIiBmaWxsPSIjRkZGRkZGIiBtYXNrPSJ1cmwoI21hc2stMikiPjwvcGF0aD4gICAgICAgIDwvZz4gICAgICAgIDxwYXRoIGQ9Ik0yNTEuOTIxLDMzNi4wNTMgQzIwNS41NDMsMzM2LjA1MyAxNjcuOTQ3LDI5OC40NTcgMTY3Ljk0NywyNTIuMDggQzE2Ny45NDcsMjA1LjcwMiAyMDUuNTQzLDE2OC4xMDYgMjUxLjkyMSwxNjguMTA2IEMyOTguMjk4LDE2OC4xMDYgMzM1Ljg5NCwyMDUuNzAyIDMzNS44OTQsMjUyLjA4IEMzMzUuODk0LDI5OC40NTcgMjk4LjI5OCwzMzYuMDUzIDI1MS45MjEsMzM2LjA1MyBaIE0yNTEuOTIxLDEyMi43MTUgQzE4MC40NzQsMTIyLjcxNSAxMjIuNTU2LDE4MC42MzMgMTIyLjU1NiwyNTIuMDggQzEyMi41NTYsMzIzLjUyNiAxODAuNDc0LDM4MS40NDQgMjUxLjkyMSwzODEuNDQ0IEMzMjMuMzY3LDM4MS40NDQgMzgxLjI4NSwzMjMuNTI2IDM4MS4yODUsMjUyLjA4IEMzODEuMjg1LDE4MC42MzMgMzIzLjM2NywxMjIuNzE1IDI1MS45MjEsMTIyLjcxNSBaIiBpZD0iRmlsbC00IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgICAgICA8cGF0aCBkPSJNNDE2LjYyNywxMTcuNjA0IEM0MTYuNjI3LDEzNC4zIDQwMy4wOTIsMTQ3LjgzNCAzODYuMzk2LDE0Ny44MzQgQzM2OS43MDEsMTQ3LjgzNCAzNTYuMTY2LDEzNC4zIDM1Ni4xNjYsMTE3LjYwNCBDMzU2LjE2NiwxMDAuOTA4IDM2OS43MDEsODcuMzczIDM4Ni4zOTYsODcuMzczIEM0MDMuMDkyLDg3LjM3MyA0MTYuNjI3LDEwMC45MDggNDE2LjYyNywxMTcuNjA0IiBpZD0iRmlsbC01IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgIDwvZz48L3N2Zz4=);\n\t\t}\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(302, 100%, 94%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n\n\t&[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder {\n\t\t/* Use gradient to contrast with focused widget (ckeditor/ckeditor5-media-embed#22). */\n\t\tbackground: linear-gradient( to right, hsl(201, 85%, 70%), hsl(201, 85%, 35%) );\n\n\t\t& .ck-media__placeholder__icon {\n\t\t\tbackground-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IldoaXRlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDQwMCA0MDA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj48c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7ZmlsbDojRkZGRkZGO308L3N0eWxlPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MDAsMjAwYzAsMTEwLjUtODkuNSwyMDAtMjAwLDIwMFMwLDMxMC41LDAsMjAwUzg5LjUsMCwyMDAsMFM0MDAsODkuNSw0MDAsMjAweiBNMTYzLjQsMzA1LjVjODguNywwLDEzNy4yLTczLjUsMTM3LjItMTM3LjJjMC0yLjEsMC00LjItMC4xLTYuMmM5LjQtNi44LDE3LjYtMTUuMywyNC4xLTI1Yy04LjYsMy44LTE3LjksNi40LTI3LjcsNy42YzEwLTYsMTcuNi0xNS40LDIxLjItMjYuN2MtOS4zLDUuNS0xOS42LDkuNS0zMC42LDExLjdjLTguOC05LjQtMjEuMy0xNS4yLTM1LjItMTUuMmMtMjYuNiwwLTQ4LjIsMjEuNi00OC4yLDQ4LjJjMCwzLjgsMC40LDcuNSwxLjMsMTFjLTQwLjEtMi03NS42LTIxLjItOTkuNC01MC40Yy00LjEsNy4xLTYuNSwxNS40LTYuNSwyNC4yYzAsMTYuNyw4LjUsMzEuNSwyMS41LDQwLjFjLTcuOS0wLjItMTUuMy0yLjQtMjEuOC02YzAsMC4yLDAsMC40LDAsMC42YzAsMjMuNCwxNi42LDQyLjgsMzguNyw0Ny4zYy00LDEuMS04LjMsMS43LTEyLjcsMS43Yy0zLjEsMC02LjEtMC4zLTkuMS0wLjljNi4xLDE5LjIsMjMuOSwzMy4xLDQ1LDMzLjVjLTE2LjUsMTIuOS0zNy4zLDIwLjYtNTkuOSwyMC42Yy0zLjksMC03LjctMC4yLTExLjUtMC43QzExMC44LDI5Ny41LDEzNi4yLDMwNS41LDE2My40LDMwNS41Ii8+PC9zdmc+);\n\t\t}\n\n\t\t& .ck-media__placeholder__url__text {\n\t\t\tcolor: hsl(201, 100%, 86%);\n\n\t\t\t&:hover {\n\t\t\t\tcolor: hsl(0, 0%, 100%);\n\t\t\t}\n\t\t}\n\t}\n}\n',
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          3525: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-media-form{align-items:flex-start;display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-media-form .ck-labeled-field-view{display:inline-block}.ck.ck-media-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-media-form{flex-wrap:wrap}.ck.ck-media-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-media-form .ck-button{flex-basis:50%}}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaform.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
                ],
                names: [],
                mappings:
                  "AAOA,kBAEC,sBAAuB,CADvB,YAAa,CAEb,kBAAmB,CACnB,gBAqBD,CAnBC,yCACC,oBACD,CAEA,4BACC,YACD,CCbA,oCDCD,kBAeE,cAUF,CARE,yCACC,eACD,CAEA,6BACC,cACD,CCtBD",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-media-form {\n\tdisplay: flex;\n\talign-items: flex-start;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          671: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              '.ck-source-editing-area{overflow:hidden;position:relative}.ck-source-editing-area textarea,.ck-source-editing-area:after{border:1px solid transparent;font-family:monospace;font-size:var(--ck-font-size-normal);line-height:var(--ck-line-height-base);margin:0;padding:var(--ck-spacing-large);white-space:pre-wrap}.ck-source-editing-area:after{content:attr(data-value) " ";display:block;visibility:hidden}.ck-source-editing-area textarea{border-color:var(--ck-color-base-border);border-radius:0;box-sizing:border-box;height:100%;outline:none;overflow:hidden;position:absolute;resize:none;width:100%}.ck-rounded-corners :is(.ck-source-editing-area textarea),.ck-source-editing-area textarea.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck-source-editing-area textarea:not([readonly]):focus{border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}',
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-source-editing/theme/sourceediting.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
                ],
                names: [],
                mappings:
                  "AASA,wBAEC,eAAgB,CADhB,iBAED,CAEA,+DAIC,4BAA6B,CAG7B,qBAAsB,CADtB,oCAAqC,CADrC,sCAAuC,CAFvC,QAAS,CADT,+BAAgC,CAMhC,oBACD,CAEA,8BACC,4BAA6B,CAE7B,aAAc,CADd,iBAED,CAEA,iCASC,wCAAyC,CC7BzC,eAAgB,CD2BhB,qBAAsB,CAJtB,WAAY,CAEZ,YAAa,CACb,eAAgB,CALhB,iBAAkB,CAGlB,WAAY,CAFZ,UAkBD,CApBA,8GChBE,qCAAsC,CD4BtC,wBAAyB,CACzB,yBAOF,CAJC,uDEpCA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFwCA",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css";\n@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css";\n\n.ck-source-editing-area {\n\tposition: relative;\n\toverflow: hidden;\n}\n\n.ck-source-editing-area::after,\n.ck-source-editing-area textarea {\n\tpadding: var(--ck-spacing-large);\n\tmargin: 0;\n\tborder: 1px solid transparent;\n\tline-height: var(--ck-line-height-base);\n\tfont-size: var(--ck-font-size-normal);\n\tfont-family: monospace;\n\twhite-space: pre-wrap;\n}\n\n.ck-source-editing-area::after {\n\tcontent: attr(data-value) " ";\n\tvisibility: hidden;\n\tdisplay: block;\n}\n\n.ck-source-editing-area textarea {\n\tposition: absolute;\n\twidth: 100%;\n\theight: 100%;\n\tresize: none;\n\toutline: none;\n\toverflow: hidden;\n\tbox-sizing: border-box;\n\n\tborder-color: var(--ck-color-base-border);\n\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&:not([readonly]):focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          8085: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2)}.ck .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{border:1px solid var(--ck-color-base-border);border-radius:1px;height:var(--ck-insert-table-dropdown-box-height);margin:var(--ck-insert-table-dropdown-box-margin);width:var(--ck-insert-table-dropdown-box-width)}.ck .ck-insert-table-dropdown-grid-box.ck-on{background:var(--ck-color-focus-outer-shadow);border-color:var(--ck-color-focus-border)}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-table/theme/inserttable.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/inserttable.css",
                ],
                names: [],
                mappings:
                  "AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,cACD,CCJA,MACC,uCAAwC,CACxC,0CAA2C,CAC3C,yCAA0C,CAC1C,yCACD,CAEA,oCAGC,yFAA0F,CAD1F,oJAED,CAEA,qCACC,iBACD,CAEA,uCAIC,4CAA6C,CAC7C,iBAAkB,CAHlB,iDAAkD,CAClD,iDAAkD,CAFlD,+CAUD,CAJC,6CAEC,6CAA8C,CAD9C,yCAED",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-insert-table-dropdown__grid {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: wrap;\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-insert-table-dropdown-padding: 10px;\n\t--ck-insert-table-dropdown-box-height: 11px;\n\t--ck-insert-table-dropdown-box-width: 12px;\n\t--ck-insert-table-dropdown-box-margin: 1px;\n}\n\n.ck .ck-insert-table-dropdown__grid {\n\t/* The width of a container should match 10 items in a row so there will be a 10x10 grid. */\n\twidth: calc(var(--ck-insert-table-dropdown-box-width) * 10 + var(--ck-insert-table-dropdown-box-margin) * 20 + var(--ck-insert-table-dropdown-padding) * 2);\n\tpadding: var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;\n}\n\n.ck .ck-insert-table-dropdown__label {\n\ttext-align: center;\n}\n\n.ck .ck-insert-table-dropdown-grid-box {\n\twidth: var(--ck-insert-table-dropdown-box-width);\n\theight: var(--ck-insert-table-dropdown-box-height);\n\tmargin: var(--ck-insert-table-dropdown-box-margin);\n\tborder: 1px solid var(--ck-color-base-border);\n\tborder-radius: 1px;\n\n\t&.ck-on {\n\t\tborder-color: var(--ck-color-focus-border);\n\t\tbackground: var(--ck-color-focus-outer-shadow);\n\t}\n}\n\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          4104: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck-content .table{display:table;margin:.9em auto}.ck-content .table table{border:1px double #b3b3b3;border-collapse:collapse;border-spacing:0;height:100%;width:100%}.ck-content .table table td,.ck-content .table table th{border:1px solid #bfbfbf;min-width:2em;padding:.4em}.ck-content .table table th{background:rgba(0,0,0,.05);font-weight:700}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}.ck-editor__editable .ck-table-bogus-paragraph{display:inline-block;width:100%}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-table/theme/table.css",
                ],
                names: [],
                mappings:
                  "AAKA,mBAKC,aAAc,CADd,gBAiCD,CA9BC,yBAYC,yBAAkC,CAVlC,wBAAyB,CACzB,gBAAiB,CAKjB,WAAY,CADZ,UAsBD,CAfC,wDAQC,wBAAiC,CANjC,aAAc,CACd,YAMD,CAEA,4BAEC,0BAA+B,CAD/B,eAED,CAMF,+BACC,gBACD,CAEA,+BACC,eACD,CAEA,+CAKC,oBAAqB,CAMrB,UACD",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .table {\n\t/* Give the table widget some air and center it horizontally */\n\t/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n\tto avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n\tmargin: 0.9em auto;\n\tdisplay: table;\n\n\t& table {\n\t\t/* The table cells should have slight borders */\n\t\tborder-collapse: collapse;\n\t\tborder-spacing: 0;\n\n\t\t/* Table width and height are set on the parent <figure>. Make sure the table inside stretches\n\t\tto the full dimensions of the container (https://github.com/ckeditor/ckeditor5/issues/6186). */\n\t\twidth: 100%;\n\t\theight: 100%;\n\n\t\t/* The outer border of the table should be slightly darker than the inner lines.\n\t\tAlso see https://github.com/ckeditor/ckeditor5-table/issues/50. */\n\t\tborder: 1px double hsl(0, 0%, 70%);\n\n\t\t& td,\n\t\t& th {\n\t\t\tmin-width: 2em;\n\t\t\tpadding: .4em;\n\n\t\t\t/* The border is inherited from .ck-editor__nested-editable styles, so theoretically it\'s not necessary here.\n\t\t\tHowever, the border is a content style, so it should use .ck-content (so it works outside the editor).\n\t\t\tHence, the duplication. See https://github.com/ckeditor/ckeditor5/issues/6314 */\n\t\t\tborder: 1px solid hsl(0, 0%, 75%);\n\t\t}\n\n\t\t& th {\n\t\t\tfont-weight: bold;\n\t\t\tbackground: hsla(0, 0%, 0%, 5%);\n\t\t}\n\t}\n}\n\n/* Text alignment of the table header should match the editor settings and override the native browser styling,\nwhen content is available outside the editor. See https://github.com/ckeditor/ckeditor5/issues/6638 */\n.ck-content[dir="rtl"] .table th {\n\ttext-align: right;\n}\n\n.ck-content[dir="ltr"] .table th {\n\ttext-align: left;\n}\n\n.ck-editor__editable .ck-table-bogus-paragraph {\n\t/*\n\t * Use display:inline-block to force Chrome/Safari to limit text mutations to this element.\n\t * See https://github.com/ckeditor/ckeditor5/issues/6062.\n\t */\n\tdisplay: inline-block;\n\n\t/*\n\t * Inline HTML elements nested in the span should always be dimensioned in relation to the whole cell width.\n\t * See https://github.com/ckeditor/ckeditor5/issues/9117.\n\t */\n\twidth: 100%;\n}\n',
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          4777: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ":root{--ck-color-table-focused-cell-background:rgba(158,207,250,.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-table-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableediting.css",
                ],
                names: [],
                mappings:
                  "AAKA,MACC,6DACD,CAKE,8QAGC,wDAAyD,CAKzD,iBAAkB,CAClB,8CAA+C,CAC/C,mBACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-table-focused-cell-background: hsla(208, 90%, 80%, .3);\n}\n\n.ck-widget.table {\n\t& td,\n\t& th {\n\t\t&.ck-editor__nested-editable.ck-editor__nested-editable_focused,\n\t\t&.ck-editor__nested-editable:focus {\n\t\t\t/* A very slight background to highlight the focused cell */\n\t\t\tbackground: var(--ck-color-table-focused-cell-background);\n\n\t\t\t/* Fixes the problem where surrounding cells cover the focused cell's border.\n\t\t\tIt does not fix the problem in all places but the UX is improved.\n\t\t\tSee https://github.com/ckeditor/ckeditor5-table/issues/29. */\n\t\t\tborder-style: none;\n\t\t\toutline: 1px solid var(--ck-color-focus-border);\n\t\t\toutline-offset: -1px; /* progressive enhancement - no IE support */\n\t\t}\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          5593: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ':root{--ck-table-selected-cell-background:rgba(158,207,250,.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{box-shadow:unset;caret-color:transparent;outline:unset;position:relative}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{background-color:var(--ck-table-selected-cell-background);bottom:0;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget{outline:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle{display:none}',
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableselection.css",
                ],
                names: [],
                mappings:
                  "AAKA,MACC,wDACD,CAGC,0IAKC,gBAAiB,CAFjB,uBAAwB,CACxB,aAAc,CAFd,iBAiCD,CA3BC,sJAGC,yDAA0D,CAK1D,QAAS,CAPT,UAAW,CAKX,MAAO,CAJP,mBAAoB,CAEpB,iBAAkB,CAGlB,OAAQ,CAFR,KAID,CAEA,wTAEC,4BACD,CAMA,gKACC,aAKD,CAHC,0NACC,YACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-table-selected-cell-background: hsla(208, 90%, 80%, .3);\n}\n\n.ck.ck-editor__editable .table table {\n\t& td.ck-editor__editable_selected,\n\t& th.ck-editor__editable_selected {\n\t\tposition: relative;\n\t\tcaret-color: transparent;\n\t\toutline: unset;\n\t\tbox-shadow: unset;\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/6446 */\n\t\t&:after {\n\t\t\tcontent: '';\n\t\t\tpointer-events: none;\n\t\t\tbackground-color: var(--ck-table-selected-cell-background);\n\t\t\tposition: absolute;\n\t\t\ttop: 0;\n\t\t\tleft: 0;\n\t\t\tright: 0;\n\t\t\tbottom: 0;\n\t\t}\n\n\t\t& ::selection,\n\t\t&:focus {\n\t\t\tbackground-color: transparent;\n\t\t}\n\n\t\t/*\n\t\t * To reduce the amount of noise, all widgets in the table selection have no outline and no selection handle.\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/9491.\n\t\t */\n\t\t& .ck-widget {\n\t\t\toutline: unset;\n\n\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\tdisplay: none;\n\t\t\t}\n\t\t}\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          4499: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-button,a.ck.ck-button{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}:is(.ck.ck-button,a.ck.ck-button) .ck-tooltip{display:block}@media (hover:none){:is(.ck.ck-button,a.ck.ck-button) .ck-tooltip{display:none}}.ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;justify-content:left;position:relative}:is(.ck.ck-button,a.ck.ck-button) .ck-button__label{display:none}.ck-button_with-text:is(.ck.ck-button,a.ck.ck-button) .ck-button__label{display:inline-block}:is(.ck.ck-button,a.ck.ck-button):not(.ck-button_with-text){justify-content:center}:is(.ck.ck-button,a.ck.ck-button):focus .ck-tooltip,:is(.ck.ck-button,a.ck.ck-button):hover .ck-tooltip{opacity:1;visibility:visible}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}:is(.ck.ck-button,a.ck.ck-button):not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}:is(.ck.ck-button,a.ck.ck-button):not(.ck-disabled):active{background:var(--ck-color-button-default-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-default-active-shadow)}.ck-disabled:is(.ck.ck-button,a.ck.ck-button){background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners :is(.ck.ck-button,a.ck.ck-button),.ck-rounded-corners:is(.ck.ck-button,a.ck.ck-button){border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;border:1px solid transparent;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}:is(.ck.ck-button,a.ck.ck-button):active,:is(.ck.ck-button,a.ck.ck-button):focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}:is(.ck.ck-button,a.ck.ck-button) .ck-button__icon use,:is(.ck.ck-button,a.ck.ck-button) .ck-button__icon use *{color:inherit}:is(.ck.ck-button,a.ck.ck-button) .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] :is(:is(.ck.ck-button,a.ck.ck-button) .ck-button__label){text-align:left}[dir=rtl] :is(:is(.ck.ck-button,a.ck.ck-button) .ck-button__label){text-align:right}:is(.ck.ck-button,a.ck.ck-button) .ck-button__keystroke{color:inherit}[dir=ltr] :is(:is(.ck.ck-button,a.ck.ck-button) .ck-button__keystroke){margin-left:var(--ck-spacing-large)}[dir=rtl] :is(:is(.ck.ck-button,a.ck.ck-button) .ck-button__keystroke){margin-right:var(--ck-spacing-large)}:is(.ck.ck-button,a.ck.ck-button) .ck-button__keystroke{font-weight:700;opacity:.7}.ck-disabled:is(.ck.ck-button,a.ck.ck-button):active,.ck-disabled:is(.ck.ck-button,a.ck.ck-button):focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck-disabled:is(.ck.ck-button,a.ck.ck-button) .ck-button__icon{opacity:var(--ck-disabled-opacity)}.ck-disabled:is(.ck.ck-button,a.ck.ck-button) .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck-disabled:is(.ck.ck-button,a.ck.ck-button) .ck-button__keystroke{opacity:.3}.ck-button_with-text:is(.ck.ck-button,a.ck.ck-button){padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] :is(.ck-button_with-text:is(.ck.ck-button,a.ck.ck-button) .ck-button__icon){margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] :is(.ck-button_with-text:is(.ck.ck-button,a.ck.ck-button) .ck-button__icon){margin-left:var(--ck-spacing-small);margin-right:calc(var(--ck-spacing-small)*-1)}.ck-button_with-keystroke:is(.ck.ck-button,a.ck.ck-button) .ck-button__label{flex-grow:1}.ck-on:is(.ck.ck-button,a.ck.ck-button){background:var(--ck-color-button-on-background)}.ck-on:is(.ck.ck-button,a.ck.ck-button):not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck-on:is(.ck.ck-button,a.ck.ck-button):not(.ck-disabled):active{background:var(--ck-color-button-on-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-on-active-shadow)}.ck-on.ck-disabled:is(.ck.ck-button,a.ck.ck-button){background:var(--ck-color-button-on-disabled-background)}.ck-button-save:is(.ck.ck-button,a.ck.ck-button){color:var(--ck-color-button-save)}.ck-button-cancel:is(.ck.ck-button,a.ck.ck-button){color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}:is(.ck.ck-button-action,a.ck.ck-button-action):not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}:is(.ck.ck-button-action,a.ck.ck-button-action):not(.ck-disabled):active{background:var(--ck-color-button-action-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-action-active-shadow)}.ck-disabled:is(.ck.ck-button-action,a.ck.ck-button-action){background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css",
                ],
                names: [],
                mappings:
                  "AAQA,6BCCC,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD0BD,CE5BC,8CACC,aAqBD,CAHC,oBAnBD,8CAoBE,YAEF,CADC,CFvBF,6BAOC,kBAAmB,CADnB,mBAAoB,CAEpB,oBAAqB,CAHrB,iBAyBD,CApBC,oDACC,YACD,CAGC,wEACC,oBACD,CAID,4DACC,sBACD,CEkBA,wGAEC,SAAU,CADV,kBAED,CCxCD,6BCAC,oDD0ID,CCvIE,0DACC,0DACD,CAEA,2DACC,2DAA4C,CAC5C,uEACD,CAID,8CACC,6DACD,CDhBD,6BEDC,eF2ID,CA1IA,2GEGE,qCFuIF,CA1IA,6BA6BC,uBAAwB,CANxB,4BAA6B,CAjB7B,cAAe,CAcf,iBAAkB,CAHlB,aAAc,CAJd,4CAA6C,CAD7C,2CAA4C,CAJ5C,8BAA+B,CAC/B,iBAAkB,CAiBlB,4DAA8D,CAnB9D,qBAAsB,CAFtB,kBAqID,CA3GC,iFGhCA,2BAA2B,CCF3B,2CAA8B,CDC9B,YHqCA,CAIC,gHAEC,aACD,CAGD,oDAIC,aAAc,CACd,cAAe,CAHf,iBAAkB,CAClB,mBAAoB,CAMpB,qBASD,CAlBA,mEAYE,eAMF,CAlBA,mEAgBE,gBAEF,CAEA,wDACC,aAYD,CAbA,uEAIE,mCASF,CAbA,uEAQE,oCAKF,CAbA,wDAWC,eAAiB,CACjB,UACD,CAIC,yGIrFD,oDJyFC,CAEA,+DK3FD,kCL6FC,CAGA,gEKhGD,kCLkGC,CAEA,oEACC,UACD,CAGD,sDACC,yDAcD,CAXC,sFAEE,4CAA+C,CAC/C,oCAOF,CAVA,sFAQE,mCAAoC,CADpC,6CAGF,CAKA,6EACC,WACD,CAID,wCC/HA,+CDiIA,CC9HC,gEACC,qDACD,CAEA,iEACC,sDAA4C,CAC5C,kEACD,CAID,oDACC,wDACD,CDmHA,iDACC,iCACD,CAEA,mDACC,mCACD,CAID,2CC7IC,mDDkJD,CC/IE,wEACC,yDACD,CAEA,yEACC,0DAA4C,CAC5C,sEACD,CAID,4DACC,4DACD,CD6HD,2CAIC,wCACD,CAEA,uCAEC,eACD",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n@import "../tooltip/mixins/_tooltip.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-unselectable;\n\t@mixin ck-tooltip_enabled;\n\n\tposition: relative;\n\tdisplay: inline-flex;\n\talign-items: center;\n\tjustify-content: left;\n\n\t& .ck-button__label {\n\t\tdisplay: none;\n\t}\n\n\t&.ck-button_with-text {\n\t\t& .ck-button__label {\n\t\t\tdisplay: inline-block;\n\t\t}\n\t}\n\n\t/* Center the icon horizontally in a button without text. */\n\t&:not(.ck-button_with-text)  {\n\t\tjustify-content: center;\n\t}\n\n\t&:hover,\n\t/* Enable toolbar button tooltips for keyboard users too. See https://github.com/ckeditor/ckeditor5/issues/5581. */\n\t&:focus {\n\t\t@mixin ck-tooltip_visible;\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n\t& .ck-tooltip {\n\t\tdisplay: block;\n\n\t\t/*\n\t\t * Don't display tooltips in devices which don't support :hover.\n\t\t * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n\t\t * the primary action, when tooltips are enabled.\n\t\t *\n\t\t * Q: OK, but why not the following query?\n\t\t *\n\t\t *   @media (hover) {\n\t\t *       display: block;\n\t\t *   }\n\t\t *\n\t\t * A: Because FF does not support it and it would completely disable tooltips\n\t\t * in that browser.\n\t\t *\n\t\t * More in https://github.com/ckeditor/ckeditor5/issues/920.\n\t\t */\n\t\t@media (hover:none) {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n\t& .ck-tooltip {\n\t\tdisplay: none;\n\t}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n\t& .ck-tooltip {\n\t\tvisibility: visible;\n\t\topacity: 1;\n\t}\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../mixins/_button.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-button-colors --ck-color-button-default;\n\t@mixin ck-rounded-corners;\n\n\twhite-space: nowrap;\n\tcursor: default;\n\tvertical-align: middle;\n\tpadding: var(--ck-spacing-tiny);\n\ttext-align: center;\n\n\t/* A very important piece of styling. Go to variable declaration to learn more. */\n\tmin-width: var(--ck-ui-component-min-height);\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Normalize the height of the line. Removing this will break consistent height\n\tamong text and text-less buttons (with icons). */\n\tline-height: 1;\n\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t/* Avoid flickering when the foucs border shows up. */\n\tborder: 1px solid transparent;\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .2s ease-in-out, border .2s ease-in-out;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */\n\t-webkit-appearance: none;\n\n\t&:active,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t/* Allow icon coloring using the text "color" property. */\n\t& .ck-button__icon {\n\t\t& use,\n\t\t& use * {\n\t\t\tcolor: inherit;\n\t\t}\n\t}\n\n\t& .ck-button__label {\n\t\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\t\tfont-size: inherit;\n\t\tfont-weight: inherit;\n\t\tcolor: inherit;\n\t\tcursor: inherit;\n\n\t\t/* Must be consistent with .ck-icon\'s vertical align. Otherwise, buttons with and\n\t\twithout labels (but with icons) have different sizes in Chrome */\n\t\tvertical-align: middle;\n\n\t\t@mixin ck-dir ltr {\n\t\t\ttext-align: left;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttext-align: right;\n\t\t}\n\t}\n\n\t& .ck-button__keystroke {\n\t\tcolor: inherit;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t}\n\n\t\tfont-weight: bold;\n\t\topacity: .7;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t&.ck-disabled {\n\t\t&:active,\n\t\t&:focus {\n\t\t\t/* The disabled button should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t\t& .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t& .ck-button__keystroke {\n\t\t\topacity: .3;\n\t\t}\n\t}\n\n\t&.ck-button_with-text {\n\t\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-standard);\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-button_with-keystroke {\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__label {\n\t\t\tflex-grow: 1;\n\t\t}\n\t}\n\n\t/* A style of the button which is currently on, e.g. its feature is active. */\n\t&.ck-on {\n\t\t@mixin ck-button-colors --ck-color-button-on;\n\t}\n\n\t&.ck-button-save {\n\t\tcolor: var(--ck-color-button-save);\n\t}\n\n\t&.ck-button-cancel {\n\t\tcolor: var(--ck-color-button-cancel);\n\t}\n}\n\n/* A style of the button which handles the primary action. */\n.ck.ck-button-action,\na.ck.ck-button-action {\n\t@mixin ck-button-colors --ck-color-button-action;\n\n\tcolor: var(--ck-color-button-action-text);\n}\n\n.ck.ck-button-bold,\na.ck.ck-button-bold {\n\tfont-weight: bold;\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements a button of given background color.\n *\n * @param {String} $background - Background color of the button.\n * @param {String} $border - Border color of the button.\n */\n@define-mixin ck-button-colors $prefix {\n\tbackground: var($(prefix)-background);\n\n\t&:not(.ck-disabled) {\n\t\t&:hover {\n\t\t\tbackground: var($(prefix)-hover-background);\n\t\t}\n\n\t\t&:active {\n\t\t\tbackground: var($(prefix)-active-background);\n\t\t\tbox-shadow: inset 0 2px 2px var($(prefix)-active-shadow);\n\t\t}\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t&.ck-disabled {\n\t\tbackground: var($(prefix)-disabled-background);\n\t}\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          9681: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:1.0769230769em;--ck-switch-button-toggle-spacing:1px;--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - var(--ck-switch-button-toggle-spacing)*2)}[dir=ltr] :is(.ck.ck-button.ck-switchbutton .ck-button__label){margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] :is(.ck.ck-button.ck-switchbutton .ck-button__label){margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners :is(.ck.ck-button.ck-switchbutton .ck-button__toggle),.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] :is(.ck.ck-button.ck-switchbutton .ck-button__toggle){margin-left:auto}[dir=rtl] :is(.ck.ck-button.ck-switchbutton .ck-button__toggle){margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);transition:background .4s ease;width:var(--ck-switch-button-toggle-width)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners :is(.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner),.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);height:var(--ck-switch-button-toggle-inner-size);margin:var(--ck-switch-button-toggle-spacing);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] :is(.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner){transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] :is(.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner){transform:translateX(calc(var( --ck-switch-button-translation )*-1))}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/switchbutton.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css",
                ],
                names: [],
                mappings:
                  "AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,mDAAoD,CACpD,qCAAsC,CACtC,gKAKD,CAGC,+DAGE,4CAOF,CAVA,+DAQE,2CAEF,CAEA,iDC3BA,eDoEA,CAzCA,8ICvBC,qCDgED,CAzCA,gEAKE,gBAoCF,CAzCA,gEAUE,iBA+BF,CAzCA,iDAiBC,uDAAwD,CAHxD,8BAAiC,CAEjC,0CAyBD,CAtBC,2EC9CD,eD2DC,CAbA,kMC1CA,qCAAsC,CD4CpC,8CAWF,CAbA,2EASC,yDAA0D,CAD1D,gDAAiD,CAFjD,6CAA8C,CAM9C,uBAA0B,CAL1B,+CAMD,CAEA,uDACC,6DAKD,CAHC,iFACC,+DACD,CAIF,6DExEA,kCF0EA,CAEA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,gGAKE,2DAMF,CAXA,gGASE,oEAEF",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__toggle {\n\t\tdisplay: block;\n\n\t\t& .ck-button__toggle__inner {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\nof the component, floating–point numbers have been used which, for the default font size\n(see: --ck-font-size-base), will generate simple integers. */\n:root {\n\t/* 34px at 13px font-size */\n\t--ck-switch-button-toggle-width: 2.6153846154em;\n\t/* 14px at 13px font-size */\n\t--ck-switch-button-toggle-inner-size: 1.0769230769em;\n\t--ck-switch-button-toggle-spacing: 1px;\n\t--ck-switch-button-translation: calc(\n\t\tvar(--ck-switch-button-toggle-width) -\n\t\tvar(--ck-switch-button-toggle-inner-size) -\n\t\t2 * var(--ck-switch-button-toggle-spacing)\n\t);\n}\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__label {\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-right: calc(2 * var(--ck-spacing-large));\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-left: calc(2 * var(--ck-spacing-large));\n\t\t}\n\t}\n\n\t& .ck-button__toggle {\n\t\t@mixin ck-rounded-corners;\n\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Make sure the toggle is always to the right as far as possible. */\n\t\t\tmargin-left: auto;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Make sure the toggle is always to the left as far as possible. */\n\t\t\tmargin-right: auto;\n\t\t}\n\n\t\t/* Gently animate the background color of the toggle switch */\n\t\ttransition: background 400ms ease;\n\n\t\twidth: var(--ck-switch-button-toggle-width);\n\t\tbackground: var(--ck-color-switch-button-off-background);\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: calc(.5 * var(--ck-border-radius));\n\t\t\t}\n\n\t\t\t/* Leave some tiny bit of space around the inner part of the switch */\n\t\t\tmargin: var(--ck-switch-button-toggle-spacing);\n\t\t\twidth: var(--ck-switch-button-toggle-inner-size);\n\t\t\theight: var(--ck-switch-button-toggle-inner-size);\n\t\t\tbackground: var(--ck-color-switch-button-inner-background);\n\n\t\t\t/* Gently animate the inner part of the toggle switch */\n\t\t\ttransition: all 300ms ease;\n\t\t}\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-off-hover-background);\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\tbox-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-button__toggle {\n\t\t@mixin ck-disabled;\n\t}\n\n\t&.ck-on .ck-button__toggle {\n\t\tbackground: var(--ck-color-switch-button-on-background);\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-on-hover-background);\n\t\t}\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t/*\n\t\t\t * Move the toggle switch to the right. It will be animated.\n\t\t\t */\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\ttransform: translateX( var( --ck-switch-button-translation ) );\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\ttransform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\n\t\t\t}\n\t\t}\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          4923: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#000}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-table__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorgrid/colorgrid.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css",
                ],
                names: [],
                mappings:
                  "AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,qCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBAOC,QAAS,CALT,qCAAsC,CAEtC,yCAA0C,CAD1C,wCAAyC,CAEzC,SAAU,CACV,8BAA+B,CAL/B,oCAyCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,4DACC,gDACD,CAEA,oCAEC,2CAA4C,CAD5C,YAED,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-color-grid {\n\tdisplay: grid;\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-grid-tile-size: 24px;\n\n\t/* Not using global colors here because these may change but some colors in a pallette\n\t * require special treatment. For instance, this ensures no matter what the UI text color is,\n\t * the check icon will look good on the black color tile. */\n\t--ck-color-color-grid-check-icon: hsl(0, 0%, 0%);\n}\n\n.ck.ck-color-grid {\n\tgrid-gap: 5px;\n\tpadding: 8px;\n}\n\n.ck.ck-color-grid__tile {\n\twidth: var(--ck-color-grid-tile-size);\n\theight: var(--ck-color-grid-tile-size);\n\tmin-width: var(--ck-color-grid-tile-size);\n\tmin-height: var(--ck-color-grid-tile-size);\n\tpadding: 0;\n\ttransition: .2s ease box-shadow;\n\tborder: 0;\n\n\t&.ck-disabled {\n\t\tcursor: unset;\n\t\ttransition: unset;\n\t}\n\n\t&.ck-color-table__color-tile_bordered {\n\t\tbox-shadow: 0 0 0 1px var(--ck-color-base-border);\n\t}\n\n\t& .ck.ck-icon {\n\t\tdisplay: none;\n\t\tcolor: var(--ck-color-color-grid-check-icon);\n\t}\n\n\t&.ck-on {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);\n\n\t\t& .ck.ck-icon {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t&.ck-on,\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\t/* Disable the default .ck-button\'s border ring. */\n\t\tborder: 0;\n\t}\n\n\t&:focus:not( .ck-disabled ),\n\t&:hover:not( .ck-disabled ) {\n\t\tbox-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);\n\t}\n}\n\n.ck.ck-color-grid__label {\n\tpadding: 0 var(--ck-spacing-standard);\n}\n',
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          3488: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ":root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on .ck-tooltip{display:none}.ck.ck-dropdown .ck-dropdown__panel{-webkit-backface-visibility:hidden;display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-modal)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] :is(.ck.ck-dropdown .ck-button.ck-dropdown__button):not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] :is(.ck.ck-dropdown .ck-button.ck-dropdown__button):not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/dropdown.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
                ],
                names: [],
                mappings:
                  "AAOA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBAqFD,CAnFC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UAOD,CCUA,iEACC,YACD,CDVA,oCAGC,kCAAmC,CAEnC,YAAa,CAEb,sCAAuC,CAEvC,iBAAkB,CAHlB,yBA4DD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSAUC,WAAY,CADZ,QAED,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CEhGA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CAIC,sCAAuC,CAHvC,gCAID,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,wFAEC,oCACD,CAIA,wFAEC,qCACD,CAID,iEAEC,eAAgB,CAChB,sBAAuB,CAFvB,SAGD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eH8GD,CA5BA,qFG9EE,qCH0GF,CA5BA,uBAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CE1FT,oCAA8B,CF6F9B,cAmBD,CAfC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import \"../tooltip/mixins/_tooltip.css\";\n\n:root {\n\t--ck-dropdown-max-width: 75vw;\n}\n\n.ck.ck-dropdown {\n\tdisplay: inline-block;\n\tposition: relative;\n\n\t& .ck-dropdown__arrow {\n\t\tpointer-events: none;\n\t\tz-index: var(--ck-z-default);\n\t}\n\n\t/* Dropdown button should span horizontally, e.g. in vertical toolbars */\n\t& .ck-button.ck-dropdown__button {\n\t\twidth: 100%;\n\n\t\t/* Disable main button's tooltip when the dropdown is open. Otherwise the panel may\n\t\tpartially cover the tooltip */\n\t\t&.ck-on {\n\t\t\t@mixin ck-tooltip_disabled;\n\t\t}\n\t}\n\n\t& .ck-dropdown__panel {\n\t\t/* This is to get rid of flickering when the tooltip is shown under the panel,\n\t\twhich looks like the panel moves vertically a pixel down and up. */\n\t\t-webkit-backface-visibility: hidden;\n\n\t\tdisplay: none;\n\t\tz-index: var(--ck-z-modal);\n\t\tmax-width: var(--ck-dropdown-max-width);\n\n\t\tposition: absolute;\n\n\t\t&.ck-dropdown__panel-visible {\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_n,\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_nme {\n\t\t\tbottom: 100%;\n\t\t}\n\n\t\t&.ck-dropdown__panel_se,\n\t\t&.ck-dropdown__panel_sw,\n\t\t&.ck-dropdown__panel_smw,\n\t\t&.ck-dropdown__panel_sme,\n\t\t&.ck-dropdown__panel_s {\n\t\t\t/*\n\t\t\t * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.\n\t\t\t * See https://github.com/ckeditor/ckeditor5/issues/1053.\n\t\t\t */\n\t\t\ttop: 100%;\n\t\t\tbottom: auto;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_se {\n\t\t\tleft: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_sw {\n\t\t\tright: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_s,\n\t\t&.ck-dropdown__panel_n {\n\t\t\t/* Positioning panels relative to the center of the button */\n\t\t\tleft: 50%;\n\t\t\ttransform: translateX(-50%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nmw,\n\t\t&.ck-dropdown__panel_smw {\n\t\t\t/* Positioning panels relative to the middle-west of the button */\n\t\t\tleft: 75%;\n\t\t\ttransform: translateX(-75%);\n\t\t}\n\n\t\t&.ck-dropdown__panel_nme,\n\t\t&.ck-dropdown__panel_sme {\n\t\t\t/* Positioning panels relative to the middle-east of the button */\n\t\t\tleft: 25%;\n\t\t\ttransform: translateX(-25%);\n\t\t}\n\t}\n}\n\n/*\n * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.\n * See https://github.com/ckeditor/ckeditor5/issues/7874\n */\n.ck.ck-toolbar .ck-dropdown__panel {\n\tz-index: calc( var(--ck-z-modal) + 1 );\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n\t& .ck-tooltip {\n\t\tdisplay: block;\n\n\t\t/*\n\t\t * Don't display tooltips in devices which don't support :hover.\n\t\t * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n\t\t * the primary action, when tooltips are enabled.\n\t\t *\n\t\t * Q: OK, but why not the following query?\n\t\t *\n\t\t *   @media (hover) {\n\t\t *       display: block;\n\t\t *   }\n\t\t *\n\t\t * A: Because FF does not support it and it would completely disable tooltips\n\t\t * in that browser.\n\t\t *\n\t\t * More in https://github.com/ckeditor/ckeditor5/issues/920.\n\t\t */\n\t\t@media (hover:none) {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n\t& .ck-tooltip {\n\t\tdisplay: none;\n\t}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n\t& .ck-tooltip {\n\t\tvisibility: visible;\n\t\topacity: 1;\n\t}\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n\t--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-dropdown {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-dropdown__arrow {\n\t\twidth: var(--ck-dropdown-arrow-size);\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-dropdown__arrow {\n\t\t\tright: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-dropdown__arrow {\n\t\t\tleft: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-dropdown__arrow {\n\t\t@mixin ck-disabled;\n\t}\n\n\t& .ck-button.ck-dropdown__button {\n\t\t@mixin ck-dir ltr {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-right: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t/* #23 */\n\t\t& .ck-button__label {\n\t\t\twidth: 7em;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t\t&.ck-disabled .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/816 */\n\t\t&.ck-on {\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t&.ck-dropdown__button_label-width_auto .ck-button__label {\n\t\t\twidth: auto;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/8699 */\n\t\t&.ck-off:active,\n\t\t&.ck-on:active {\n\t\t\tbox-shadow: none;\n\t\t\t\n\t\t\t&:focus {\n\t\t\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-dropdown__panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tbackground: var(--ck-color-dropdown-panel-background);\n\tborder: 1px solid var(--ck-color-dropdown-panel-border);\n\tbottom: 0;\n\n\t/* Make sure the panel is at least as wide as the drop-down\'s button. */\n\tmin-width: 100%;\n\n\t/* Disabled corner border radius to be consistent with the .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-dropdown__panel_se {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_sw {\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_ne {\n\t\tborder-bottom-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_nw {\n\t\tborder-bottom-right-radius: 0;\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          6875: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners :is(.ck.ck-dropdown .ck-dropdown__panel .ck-list),.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners :is(.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button),.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners :is(.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button),.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
                ],
                names: [],
                mappings:
                  "AAOA,6CCIC,eDqBD,CAzBA,sICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,kNCFA,qCAAsC,CDKpC,2BAA4B,CAC5B,4BAA6B,CAF7B,wBAIF,CAEA,kFCdD,eDmBC,CALA,gNCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\n\t/* Disabled radius of top-left border to be consistent with .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t/* Make sure the button belonging to the first/last child of the list goes well with the\n\tborder radius of the entire panel. */\n\t& .ck-list__item {\n\t\t&:first-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\n\t\t&:last-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          66: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button .ck-tooltip{display:none}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] :is(.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action),[dir=ltr] :is(.ck.ck-splitbutton:hover>.ck-splitbutton__action){border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] :is(.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action),[dir=rtl] :is(.ck.ck-splitbutton:hover>.ck-splitbutton__action){border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] :is(.ck.ck-splitbutton>.ck-splitbutton__arrow){border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] :is(.ck.ck-splitbutton>.ck-splitbutton__arrow){border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}',
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/splitbutton.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
                ],
                names: [],
                mappings:
                  "AAOA,mBAEC,iBAUD,CARC,iDACC,qCACD,CC0BA,8DACC,YACD,CClCD,MACC,gDAAyD,CACzD,4CACD,CAMC,8IAKE,gCAAiC,CADjC,6BASF,CAbA,8IAWE,+BAAgC,CADhC,4BAGF,CAEA,0CAGC,eAiBD,CApBA,yDAQE,+BAAgC,CADhC,4BAaF,CApBA,yDAcE,gCAAiC,CADjC,6BAOF,CAHC,8CACC,mCACD,CASA,0KACC,wDACD,CAIA,8JAKC,0DAA2D,CAJ3D,UAAW,CAGX,WAAY,CAFZ,iBAAkB,CAClB,SAGD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCC7EA,eDuFA,CAVA,qHCzEC,qCDmFD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../tooltip/mixins/_tooltip.css";\n\n.ck.ck-splitbutton {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-splitbutton__action:focus {\n\t\tz-index: calc(var(--ck-z-default) + 1);\n\t}\n\n\t/* Disable tooltips for the buttons when the button is "open" */\n\t&.ck-splitbutton_open > .ck-button {\n\t\t@mixin ck-tooltip_disabled;\n\t}\n}\n\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n\t& .ck-tooltip {\n\t\tdisplay: block;\n\n\t\t/*\n\t\t * Don't display tooltips in devices which don't support :hover.\n\t\t * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n\t\t * the primary action, when tooltips are enabled.\n\t\t *\n\t\t * Q: OK, but why not the following query?\n\t\t *\n\t\t *   @media (hover) {\n\t\t *       display: block;\n\t\t *   }\n\t\t *\n\t\t * A: Because FF does not support it and it would completely disable tooltips\n\t\t * in that browser.\n\t\t *\n\t\t * More in https://github.com/ckeditor/ckeditor5/issues/920.\n\t\t */\n\t\t@media (hover:none) {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n\t& .ck-tooltip {\n\t\tdisplay: none;\n\t}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n\t& .ck-tooltip {\n\t\tvisibility: visible;\n\t\topacity: 1;\n\t}\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-color-split-button-hover-background: hsl(0, 0%, 92%);\n\t--ck-color-split-button-hover-border: hsl(0, 0%, 70%);\n}\n\n.ck.ck-splitbutton {\n\t/*\n\t * Note: ck-rounded and ck-dir mixins don\'t go together (because they both use @nest).\n\t */\n\t&:hover > .ck-splitbutton__action,\n\t&.ck-splitbutton_open > .ck-splitbutton__action {\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the action button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the action button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\t}\n\n\t& > .ck-splitbutton__arrow {\n\t\t/* It\'s a text-less button and since the icon is positioned absolutely in such situation,\n\t\tit must get some arbitrary min-width. */\n\t\tmin-width: unset;\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t/* Don\'t round the arrow button on the left side */\n\t\t\tborder-top-left-radius: unset;\n\t\t\tborder-bottom-left-radius: unset;\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t/* Don\'t round the arrow button on the right side */\n\t\t\tborder-top-right-radius: unset;\n\t\t\tborder-bottom-right-radius: unset;\n\t\t}\n\n\t\t& svg {\n\t\t\twidth: var(--ck-dropdown-arrow-size);\n\t\t}\n\t}\n\n\t/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling\n\tas a whole. The background of both buttons should stand out and there should be a visual\n\tseparation between both buttons. */\n\t&.ck-splitbutton_open,\n\t&:hover {\n\t\t/* When the split button hovered as a whole, not as individual buttons. */\n\t\t& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {\n\t\t\tbackground: var(--ck-color-split-button-hover-background);\n\t\t}\n\n\t\t/* Splitbutton separator needs to be set with the ::after pseudoselector\n\t\tto display properly the borders on focus */\n\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\tcontent: \'\';\n\t\t\tposition: absolute;\n\t\t\twidth: 1px;\n\t\t\theight: 100%;\n\t\t\tbackground-color: var(--ck-color-split-button-hover-border);\n\t\t}\n\n\t\t@nest [dir="ltr"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tleft: -1px;\n\t\t\t}\n\t\t}\n\n\t\t@nest [dir="rtl"] & {\n\t\t\t& > .ck-splitbutton__arrow:not(.ck-disabled)::after {\n\t\t\t\tright: -1px;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Don\'t round the bottom left and right corners of the buttons when "open"\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-splitbutton_open {\n\t\t@mixin ck-rounded-corners {\n\t\t\t& > .ck-splitbutton__action {\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t}\n\n\t\t\t& > .ck-splitbutton__arrow {\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          5075: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/toolbardropdown.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css",
                ],
                names: [],
                mappings:
                  "AAKA,MACC,oCACD,CAEA,4CAGC,8CAA+C,CAD/C,iBAQD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-toolbar-dropdown-max-width: 60vw;\n}\n\n.ck.ck-toolbar-dropdown > .ck-dropdown__panel {\n\t/* https://github.com/ckeditor/ckeditor5/issues/5586 */\n\twidth: max-content;\n\tmax-width: var(--ck-toolbar-dropdown-max-width);\n\n\t& .ck-button {\n\t\t&:focus {\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown .ck-toolbar {\n\tborder: 0;\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          4547: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
                ],
                names: [],
                mappings:
                  "AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEEPA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFWA,CAGD,+BAGC,4BAA6B,CAF7B,aAAc,CACd,oCA6BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,mDACD,CAIA,gEACC,gDACD",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_focus.css";\n@import "../../mixins/_button.css";\n\n:root {\n\t--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\n}\n\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\n\t@mixin ck-rounded-corners;\n\n\t&.ck-focused {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\t}\n}\n\n.ck.ck-editor__editable_inline {\n\toverflow: auto;\n\tpadding: 0 var(--ck-spacing-standard);\n\tborder: 1px solid transparent;\n\n\t&[dir="ltr"] {\n\t\ttext-align: left;\n\t}\n\n\t&[dir="rtl"] {\n\t\ttext-align: right;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\n\t& > *:first-child {\n\t\tmargin-top: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/847 */\n\t& > *:last-child {\n\t\t/*\n\t\t * This value should match with the default margins of the block elements (like .media or .image)\n\t\t * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).\n\t\t */\n\t\tmargin-bottom: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/6517 */\n\t&.ck-blurred ::selection {\n\t\tbackground: var(--ck-color-editable-blur-selection);\n\t}\n}\n\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\n\t&::after {\n\t\tborder-bottom-color: var(--ck-color-base-foreground);\n\t}\n}\n\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\n\t&::after {\n\t\tborder-top-color: var(--ck-color-base-foreground);\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          5523: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}:root{--ck-form-header-height:38px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-form__header .ck-form__header__label{font-weight:700}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/formheader/formheader.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css",
                ],
                names: [],
                mappings:
                  "AAKA,oBAIC,kBAAmB,CAHnB,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CAEjB,6BACD,CCNA,MACC,4BACD,CAEA,oBAIC,mDAAoD,CAFpD,mCAAoC,CACpC,wCAAyC,CAFzC,uDAQD,CAHC,4CACC,eACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__header {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\talign-items: center;\n\tjustify-content: space-between;\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-form-header-height: 38px;\n}\n\n.ck.ck-form__header {\n\tpadding: var(--ck-spacing-small) var(--ck-spacing-large);\n\theight: var(--ck-form-header-height);\n\tline-height: var(--ck-form-header-height);\n\tborder-bottom: 1px solid var(--ck-color-base-border);\n\n\t& .ck-form__header__label {\n\t\tfont-weight: bold;\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          1174: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{font-size:.8333350694em;height:var(--ck-icon-size);width:var(--ck-icon-size);will-change:transform}.ck.ck-icon,.ck.ck-icon *{color:inherit;cursor:inherit}.ck.ck-icon :not([fill]){fill:currentColor}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css",
                ],
                names: [],
                mappings:
                  "AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YAKC,uBAAwB,CAHxB,0BAA2B,CAD3B,yBAA0B,CAY1B,qBAcD,CAZC,0BARA,aAAc,CAGd,cAgBA,CAJC,yBAEC,iBACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-icon {\n\tvertical-align: middle;\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\n}\n\n.ck.ck-icon {\n\twidth: var(--ck-icon-size);\n\theight: var(--ck-icon-size);\n\n\t/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\n\tfont-size: .8333350694em;\n\n\tcolor: inherit;\n\n\t/* Inherit cursor style (#5). */\n\tcursor: inherit;\n\n\t/* This will prevent blurry icons on Firefox. See #340. */\n\twill-change: transform;\n\n\t& * {\n\t\t/* Inherit cursor style (#5). */\n\t\tcursor: inherit;\n\n\t\t/* Allows dynamic coloring of the icons. */\n\t\tcolor: inherit;\n\n\t\t&:not([fill]) {\n\t\t\t/* Needed by FF. */\n\t\t\tfill: currentColor;\n\t\t}\n\t}\n}\n',
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          6985: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ":root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
                ],
                names: [],
                mappings:
                  "AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAK9C,4CAA6C,CAH7C,+BAAgC,CADhC,6DAA8D,CAO9D,4DA0BD,CAxBC,mBEnBA,2BAA2B,CCF3B,2CAA8B,CDC9B,YFuBA,CAEA,uBAEC,oDAAqD,CADrD,sDAAuD,CAEvD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBAEC,sCAAuC,CADvC,+CAMD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-input-width: 18em;\n\n\t/* Backward compatibility. */\n\t--ck-input-text-width: var(--ck-input-width);\n}\n\n.ck.ck-input {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-input-background);\n\tborder: 1px solid var(--ck-color-input-border);\n\tpadding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\n\tmin-width: var(--ck-input-width);\n\n\t/* This is important to stay of the same height as surrounding buttons */\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .1s ease-in-out, border .1s ease-in-out;\n\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t&[readonly] {\n\t\tborder: 1px solid var(--ck-color-input-disabled-border);\n\t\tbackground: var(--ck-color-input-disabled-background);\n\t\tcolor: var(--ck-color-input-disabled-text);\n\n\t\t&:focus {\n\t\t\t/* The read-only input should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\tborder-color: var(--ck-color-input-error-border);\n\t\tanimation: ck-input-shake .3s ease both;\n\n\t\t&:focus {\n\t\t\t@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);\n\t\t}\n\t}\n}\n\n@keyframes ck-input-shake {\n\t20% {\n\t\ttransform: translateX(-2px);\n\t}\n\n\t40% {\n\t\ttransform: translateX(2px);\n\t}\n\n\t60% {\n\t\ttransform: translateX(-1px);\n\t}\n\n\t80% {\n\t\ttransform: translateX(1px);\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          2751: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/label/label.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css",
                ],
                names: [],
                mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tdisplay: block;\n}\n\n.ck.ck-voice-label {\n\tdisplay: none;\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tfont-weight: bold;\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          8111: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] :is(.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label){left:0}[dir=rtl] :is(.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label){right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] :is(.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label){transform:translate(var(--ck-spacing-medium),calc(var(--ck-font-size-base)*.6)) scale(1)}[dir=rtl] :is(.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label){transform:translate(calc(var(--ck-spacing-medium)*-1),calc(var(--ck-font-size-base)*.6)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
                ],
                names: [],
                mappings:
                  "AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,yEACD,CAEA,0BCHC,eD4GD,CAzGA,2FCCE,qCDwGF,CAtGC,mEACC,UAmCD,CAjCC,gFACC,KA+BD,CAhCA,+FAIE,MA4BF,CAhCA,+FAQE,OAwBF,CAhCA,gFAiBC,yDAA0D,CAG1D,eAAmB,CADnB,kBAAoB,CAOpB,cAAe,CAFf,eAAgB,CANhB,2CAA8C,CAP9C,mBAAoB,CAYpB,sBAAuB,CARvB,6DAA+D,CAH/D,oBAAqB,CAgBrB,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,+TAGE,wFAYF,CAfA,+TAOE,iGAQF,CAfA,gTAaC,sBAAuB,CAFvB,iEAAkE,CAGlE,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-labeled-field-view {\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\tdisplay: flex;\n\t\tposition: relative;\n\t}\n\n\t& .ck.ck-label {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t}\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);\n\t--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);\n\t--ck-color-labeled-field-label-background: var(--ck-color-base-background);\n}\n\n.ck.ck-labeled-field-view {\n\t@mixin ck-rounded-corners;\n\n\t& > .ck.ck-labeled-field-view__input-wrapper {\n\t\twidth: 100%;\n\n\t\t& > .ck.ck-label {\n\t\t\ttop: 0px;\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tleft: 0px;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tright: 0px;\n\t\t\t}\n\n\t\t\tpointer-events: none;\n\t\t\ttransform-origin: 0 0;\n\n\t\t\t/* By default, display the label scaled down above the field. */\n\t\t\ttransform: translate(var(--ck-spacing-medium), -6px) scale(.75);\n\n\t\t\tbackground: var(--ck-color-labeled-field-label-background);\n\t\t\tpadding: 0 calc(.5 * var(--ck-font-size-tiny));\n\t\t\tline-height: initial;\n\t\t\tfont-weight: normal;\n\n\t\t\t/* Prevent overflow when the label is longer than the input */\n\t\t\ttext-overflow: ellipsis;\n\t\t\toverflow: hidden;\n\n\t\t\tmax-width: 100%;\n\n\t\t\ttransition:\n\t\t\t\ttransform var(--ck-labeled-field-view-transition),\n\t\t\t\tpadding var(--ck-labeled-field-view-transition),\n\t\t\t\tbackground var(--ck-labeled-field-view-transition);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\t& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\n\t\t& .ck-input:not([readonly]) + .ck.ck-label {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t& .ck-labeled-field-view__status {\n\t\tfont-size: var(--ck-font-size-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\n\t\t/* Let the info wrap to the next line to avoid stretching the layout horizontally.\n\t\tThe status could be very long. */\n\t\twhite-space: normal;\n\n\t\t&.ck-labeled-field-view__status_error {\n\t\t\tcolor: var(--ck-color-base-error);\n\t\t}\n\t}\n\n\t/* Disabled fields and fields that have no focus should fade out. */\n\t&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\tcolor: var(--ck-color-input-disabled-text);\n\t}\n\n\t/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */\n\t/* stylelint-disable-next-line no-descending-specificity */\n\t&.ck-disabled.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {\n\t\t@mixin ck-dir ltr {\n\t\t\ttransform: translate(var(--ck-spacing-medium), calc(0.6 * var(--ck-font-size-base))) scale(1);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttransform: translate(calc(-1 * var(--ck-spacing-medium)), calc(0.6 * var(--ck-font-size-base))) scale(1);\n\t\t}\n\n\t\t/* Compensate for the default translate position. */\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));\n\n\t\tbackground: transparent;\n\t\tpadding: 0;\n\t}\n\n\t/*------ DropdownView integration ----------------------------------------------------------------------------------- */\n\n\t/* Make sure dropdown\' background color in any of dropdown\'s state does not collide with labeled field. */\n\t& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {\n\t\tbackground: transparent;\n\t}\n\n\t/* When the dropdown is "empty", the labeled field label replaces its label. */\n\t&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {\n\t\topacity: 0;\n\t}\n\n\t/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */\n\t&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {\n\t\tmax-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          1162: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{background:var(--ck-color-list-background);list-style-type:none}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{border-radius:0;min-height:unset;padding:calc(var(--ck-line-height-base)*.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*.4*var(--ck-font-size-base));text-align:left;width:100%}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;width:100%}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/list/list.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
                ],
                names: [],
                mappings:
                  "AAOA,YAGC,YAAa,CACb,qBAAsB,CCFtB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDaD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAIC,0CAA2C,CAD3C,oBAED,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BAIC,eAAgB,CAHhB,gBAAiB,CAQjB,iIAEiE,CARjE,eAAgB,CADhB,UAwCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,2DACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,uBAGC,sCAAuC,CAFvC,UAAW,CACX,UAED",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-list {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-direction: column;\n\n\t& .ck-list__item,\n\t& .ck-list__separator {\n\t\tdisplay: block;\n\t}\n\n\t/* Make sure that whatever child of the list item gets focus, it remains on the\n\ttop. Thanks to that, styles like box-shadow, outline, etc. are not masked by\n\tadjacent list items. */\n\t& .ck-list__item > *:focus {\n\t\tposition: relative;\n\t\tz-index: var(--ck-z-default);\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-list {\n\t@mixin ck-rounded-corners;\n\n\tlist-style-type: none;\n\tbackground: var(--ck-color-list-background);\n}\n\n.ck.ck-list__item {\n\tcursor: default;\n\tmin-width: 12em;\n\n\t& .ck-button {\n\t\tmin-height: unset;\n\t\twidth: 100%;\n\t\ttext-align: left;\n\t\tborder-radius: 0;\n\n\t\t/* List items should have the same height. Use absolute units to make sure it is so\n\t\t   because e.g. different heading styles may have different height\n\t\t   https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\tpadding:\n\t\t\tcalc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))\n\t\t\tcalc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\n\t\t& .ck-button__label {\n\t\t\t/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\t\tline-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-button-on-background);\n\t\t\tcolor: var(--ck-color-list-button-on-text);\n\n\t\t\t&:active {\n\t\t\t\tbox-shadow: none;\n\t\t\t}\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-on-background-focus);\n\t\t\t}\n\n\t\t\t&:focus:not(.ck-disabled) {\n\t\t\t\tborder-color: var(--ck-color-base-background);\n\t\t\t}\n\t\t}\n\n\t\t&:hover:not(.ck-disabled) {\n\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t}\n\t}\n\n\t/* It\'s unnecessary to change the background/text of a switch toggle; it has different ways\n\tof conveying its state (like the switcher) */\n\t& .ck-switchbutton {\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-background);\n\t\t\tcolor: inherit;\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t\t\tcolor: inherit;\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-list__separator {\n\theight: 1px;\n\twidth: 100%;\n\tbackground: var(--ck-color-base-border);\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          8245: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);box-shadow:var(--ck-drop-shadow),0 0;min-height:15px}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow))}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}',
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonpanel.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
                ],
                names: [],
                mappings:
                  "AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCJC,eD4ID,CAxIA,iFCAE,qCDwIF,CAxIA,qBAMC,2CAA4C,CAC5C,6CAA8C,CEb9C,oCAA8B,CFU9B,eAoID,CA9HE,+GAIC,kBAAmB,CADnB,QAAS,CADT,OAGD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EACD,CAEA,2CACC,iFAAkF,CAClF,yCACD,CAIA,uFAEC,mHACD,CAEA,4CACC,iEAAkE,CAClE,uDACD,CAEA,2CACC,iFAAkF,CAClF,4CACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAIC,8CAAiD,CAFjD,QAAS,CACT,uDAED,CAIA,2GAGC,8CAAiD,CADjD,+CAED,CAIA,2GAGC,8CAAiD,CADjD,gDAED,CAIA,6GAIC,8CAAiD,CADjD,uDAA0D,CAD1D,SAGD,CAIA,6GAIC,8CAAiD,CAFjD,QAAS,CACT,sDAED,CAIA,6GAGC,uDAA0D,CAD1D,SAAU,CAEV,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Make sure the balloon arrow does not float over its children. */\n\t--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\n}\n\n.ck.ck-balloon-panel {\n\tdisplay: none;\n\tposition: absolute;\n\n\tz-index: var(--ck-z-modal);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tposition: absolute;\n\t\t}\n\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_visible {\n\t\tdisplay: block;\n\t}\n}\n',
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-arrow-offset: 2px;\n\t--ck-balloon-arrow-height: 10px;\n\t--ck-balloon-arrow-half-width: 8px;\n\t--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\n}\n\n.ck.ck-balloon-panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t\tborder-style: solid;\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-border) transparent;\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-background) transparent;\n\t\t\tmargin-top: var(--ck-balloon-arrow-offset);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: var(--ck-color-panel-border) transparent transparent;\n\t\t\tfilter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: var(--ck-color-panel-background) transparent transparent transparent;\n\t\t\tmargin-bottom: var(--ck-balloon-arrow-offset);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_n {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_ne {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_s {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_se {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_smw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nmw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          1757: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonrotator.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css",
                ],
                names: [],
                mappings:
                  "AAKA,oCAEC,kBAAmB,CADnB,YAAa,CAEb,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCAGC,qCAAsC,CAFtC,oCAAqC,CACrC,kCAED,CAGA,iEAIC,mCAAoC,CAHpC,uCAID,CAMA,2DACC,eACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\n */\n.ck .ck-balloon-rotator__content .ck-toolbar {\n\tjustify-content: center;\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tbackground: var(--ck-color-toolbar-background);\n\tborder-bottom: 1px solid var(--ck-color-toolbar-border);\n\tpadding: 0 var(--ck-spacing-small);\n\n\t/* Let's keep similar appearance to `ck-toolbar`. */\n\t& > * {\n\t\tmargin-right: var(--ck-spacing-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t/* Gives counter more breath than buttons. */\n\t& .ck-balloon-rotator__counter {\n\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t/* We need to use smaller margin because of previous button's right margin. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n.ck .ck-balloon-rotator__content {\n\n\t/* Disable default annotation shadow inside rotator with fake panels. */\n\t& .ck.ck-annotation-wrapper {\n\t\tbox-shadow: none;\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          3553: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/fakepanel.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
                ],
                names: [],
                mappings:
                  "AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBAKC,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CCXtC,oCAA8B,CDc9B,WAAY,CAPZ,eAAgB,CAMhB,UAED,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-fake-panel {\n\tposition: absolute;\n\n\t/* Fake panels should be placed under main balloon content. */\n\tz-index: calc(var(--ck-z-modal) - 1);\n}\n\n.ck .ck-fake-panel div {\n\tposition: absolute;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tz-index: 2;\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tz-index: 1;\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-fake-panel-offset-horizontal: 6px;\n\t--ck-balloon-fake-panel-offset-vertical: 6px;\n}\n\n/* Let\'s use `.ck-balloon-panel` appearance. See: balloonpanel.css. */\n.ck .ck-fake-panel div {\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\tborder-radius: var(--ck-border-radius);\n\n\twidth: 100%;\n\theight: 100%;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tmargin-left: var(--ck-balloon-fake-panel-offset-horizontal);\n\tmargin-top: var(--ck-balloon-fake-panel-offset-vertical);\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\n}\n.ck .ck-fake-panel div:nth-child( 3 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\n}\n\n/* If balloon is positioned above element, we need to move fake panel to the top. */\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\n\t--ck-balloon-fake-panel-offset-vertical: -6px;\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          3609: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-modal)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/stickypanel.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
                ],
                names: [],
                mappings:
                  "AAMC,qDAEC,cAAe,CACf,KAAM,CAFN,yBAGD,CAEA,kEAEC,iBAAkB,CADlB,QAED,CCPA,qDAIC,wBAAyB,CACzB,yBAA0B,CAF1B,sBAAuB,CCFxB,oCDKA",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\tz-index: var(--ck-z-modal); /* #315 */\n\t\tposition: fixed;\n\t\ttop: 0;\n\t}\n\n\t& .ck-sticky-panel__content_sticky_bottom-limit {\n\t\ttop: auto;\n\t\tposition: absolute;\n\t}\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-sticky-panel {\n\t& .ck-sticky-panel__content_sticky {\n\t\t@mixin ck-drop-shadow;\n\n\t\tborder-width: 0 1px 1px;\n\t\tborder-top-left-radius: 0;\n\t\tborder-top-right-radius: 0;\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          1590: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              '.ck-vertical-form .ck-button:after{bottom:var(--ck-spacing-small);content:"";position:absolute;right:-1px;top:var(--ck-spacing-small);width:0;z-index:1}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{bottom:var(--ck-spacing-small);content:"";position:absolute;right:-1px;top:var(--ck-spacing-small);width:0;z-index:1}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-width)*.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){border:0;border-radius:0;border-top:1px solid var(--ck-color-base-border);margin-top:var(--ck-spacing-large);padding:var(--ck-spacing-standard)}[dir=ltr] :is(.ck.ck-responsive-form>.ck-button:last-child),[dir=ltr] :is(.ck.ck-responsive-form>.ck-button:nth-last-child(2)){margin-left:0}[dir=rtl] :is(.ck.ck-responsive-form>.ck-button:last-child),[dir=rtl] :is(.ck.ck-responsive-form>.ck-button:nth-last-child(2)){margin-left:0}[dir=rtl] :is(.ck.ck-responsive-form>.ck-button:last-child):last-of-type,[dir=rtl] :is(.ck.ck-responsive-form>.ck-button:nth-last-child(2)):last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}}',
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/responsive-form/responsiveform.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css",
                ],
                names: [],
                mappings:
                  "AAOA,mCAMC,8BAA+B,CAL/B,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,2BAA4B,CAH5B,OAAQ,CAKR,SACD,CCTC,oCDaC,wCAMC,8BAA+B,CAL/B,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,2BAA4B,CAH5B,OAAQ,CAKR,SACD,CCnBD,CCAD,qDACC,kDACD,CAEA,uBACC,+BAkED,CAhEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,oCA6CF,CA3CE,8CACC,wDAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAID,iGAMC,QAAS,CADT,eAAgB,CAEhB,gDAAiD,CAJjD,kCAAmC,CADnC,kCAkBD,CApBA,+HAUE,aAUF,CApBA,+HAcE,aAMF,CAJE,yJACC,kDACD,CAKD,0DACC,kDACD,CDpEF",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck-vertical-form .ck-button::after {\n\tcontent: "";\n\twidth: 0;\n\tposition: absolute;\n\tright: -1px;\n\ttop: var(--ck-spacing-small);\n\tbottom: var(--ck-spacing-small);\n\tz-index: 1;\n}\n\n.ck.ck-responsive-form {\n\t@mixin ck-media-phone {\n\t\t& .ck-button::after {\n\t\t\tcontent: "";\n\t\t\twidth: 0;\n\t\t\tposition: absolute;\n\t\t\tright: -1px;\n\t\t\ttop: var(--ck-spacing-small);\n\t\t\tbottom: var(--ck-spacing-small);\n\t\t\tz-index: 1;\n\t\t}\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck-vertical-form > .ck-button:nth-last-child(2)::after {\n\tborder-right: 1px solid var(--ck-color-base-border);\n}\n\n.ck.ck-responsive-form {\n\tpadding: var(--ck-spacing-large);\n\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& > :not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& > :not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tpadding: 0;\n\t\twidth: calc(.8 * var(--ck-input-width));\n\n\t\t& .ck-labeled-field-view {\n\t\t\tmargin: var(--ck-spacing-large) var(--ck-spacing-large) 0;\n\n\t\t\t& .ck-input-text {\n\t\t\t\tmin-width: 0;\n\t\t\t\twidth: 100%;\n\t\t\t}\n\n\t\t\t/* Let the long error messages wrap in the narrow form. */\n\t\t\t& .ck-labeled-field-view__error {\n\t\t\t\twhite-space: normal;\n\t\t\t}\n\t\t}\n\n\t\t/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */\n\t\t& > .ck-button:nth-last-child(1),\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\tpadding: var(--ck-spacing-standard);\n\t\t\tmargin-top: var(--ck-spacing-large);\n\n\t\t\tborder-radius: 0;\n\t\t\tborder: 0;\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\n\t\t\t\t&:last-of-type {\n\t\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\t&::after {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\t}\n}\n',
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          6706: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/blocktoolbar.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css",
                ],
                names: [],
                mappings:
                  "AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-block-toolbar-button {\n\tposition: absolute;\n\tz-index: var(--ck-z-default);\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-block-toolbar-button: var(--ck-color-text);\n\t--ck-block-toolbar-button-size: var(--ck-font-size-normal);\n}\n\n.ck.ck-block-toolbar-button {\n\tcolor: var(--ck-color-block-toolbar-button);\n\tfont-size: var(--ck-block-toolbar-size);\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          5571: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;background:var(--ck-color-toolbar-border);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}:is(.ck.ck-toolbar>.ck-toolbar__items):empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border:0;border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/toolbar.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
                ],
                names: [],
                mappings:
                  "AAOA,eAKC,kBAAmB,CAFnB,YAAa,CACb,oBAAqB,CCFrB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6CD,CA3CC,kCAGC,kBAAmB,CAFnB,YAAa,CACb,kBAAmB,CAEnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eD0FD,CA7FA,qECOE,qCDsFF,CA7FA,eAGC,6CAA8C,CAE9C,+CAAgD,CADhD,iCAyFD,CAtFC,yCACC,kBAAmB,CAGnB,yCAA0C,CAO1C,qCAAsC,CADtC,kCAAmC,CAPnC,aAAc,CADd,SAUD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,uEACC,YACD,CAGD,gHAIC,qCAAsC,CADtC,kCAED,CAEA,mCAEC,SAgBD,CAbC,0DAWC,QAAS,CAHT,eAAgB,CAHhB,QAAS,CAHT,UAUD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAvFF,qCA2FE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JAEC,2BAA4B,CAD5B,wBAED,CAGA,2JAEC,4BAA6B,CAD7B,yBAED,CASD,8RACC,mCACD,CAWA,qHACC,cACD,CAIC,6JAEC,4BAA6B,CAD7B,yBAED,CAGA,2JAEC,2BAA4B,CAD5B,wBAED,CASD,8RACC,oCACD",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-flow: row nowrap;\n\talign-items: center;\n\n\t& > .ck-toolbar__items {\n\t\tdisplay: flex;\n\t\tflex-flow: row wrap;\n\t\talign-items: center;\n\t\tflex-grow: 1;\n\n\t}\n\n\t& .ck.ck-toolbar__separator {\n\t\tdisplay: inline-block;\n\n\t\t/*\n\t\t * A leading or trailing separator makes no sense (separates from nothing on one side).\n\t\t * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\n\t\t * moved to another toolbar in the dropdown.\n\t\t */\n\t\t&:first-child,\n\t\t&:last-child {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\tflex-basis: 100%;\n\t}\n\n\t&.ck-toolbar_grouping > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t&.ck-toolbar_vertical > .ck-toolbar__items {\n\t\tflex-direction: column;\n\t}\n\n\t&.ck-toolbar_floating > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t& > .ck-dropdown__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-toolbar-background);\n\tpadding: 0 var(--ck-spacing-small);\n\tborder: 1px solid var(--ck-color-toolbar-border);\n\n\t& .ck.ck-toolbar__separator {\n\t\talign-self: stretch;\n\t\twidth: 1px;\n\t\tmin-width: 1px;\n\t\tbackground: var(--ck-color-toolbar-border);\n\n\t\t/*\n\t\t * These margins make the separators look better in balloon toolbars (when aligned with the "tip").\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/7493.\n\t\t */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t& .ck-toolbar__line-break {\n\t\theight: 0;\n\t}\n\n\t& > .ck-toolbar__items {\n\t\t& > *:not(.ck-toolbar__line-break) {\n\t\t\t/* (#11) Separate toolbar items. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\n\t\t/* Don\'t display a separator after an empty items container, for instance,\n\t\twhen all items were grouped */\n\t\t&:empty + .ck.ck-toolbar__separator {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/* Make sure items wrapped to the next line have v-spacing */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t&.ck-toolbar_vertical {\n\t\t/* Items in a vertical toolbar span the entire width. */\n\t\tpadding: 0;\n\n\t\t/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */\n\t\t& > .ck-toolbar__items > .ck {\n\t\t\t/* Items in a vertical toolbar should span the horizontal space. */\n\t\t\twidth: 100%;\n\n\t\t\t/* Items in a vertical toolbar should have no margin. */\n\t\t\tmargin: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */\n\t\t\tborder-radius: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so any border is pointless. */\n\t\t\tborder: 0;\n\t\t}\n\t}\n\n\t&.ck-toolbar_compact {\n\t\t/* No spacing around items. */\n\t\tpadding: 0;\n\n\t\t& > .ck-toolbar__items > * {\n\t\t\t/* Compact toolbar items have no spacing between them. */\n\t\t\tmargin: 0;\n\n\t\t\t/* "Middle" children should have no rounded corners. */\n\t\t\t&:not(:first-child):not(:last-child) {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/*\n\t\t * Dropdown button has asymmetric padding to fit the arrow.\n\t\t * This button has no arrow so let\'s revert that padding back to normal.\n\t\t */\n\t\t& > .ck.ck-button.ck-dropdown__button {\n\t\t\tpadding-left: var(--ck-spacing-tiny);\n\t\t}\n\t}\n\n\t@nest .ck-toolbar-container & {\n\t\tborder: 0;\n\t}\n}\n\n/* stylelint-disable */\n\n/*\n * Styles for RTL toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="rtl"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="rtl"] {\n\t& > .ck-toolbar__items > .ck {\n\t\tmargin-right: 0;\n\t}\n\n\t&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {\n\t\t/* (#11) Separate toolbar items. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-left: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n/*\n * Styles for LTR toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="ltr"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="ltr"] {\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-right: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n}\n\n/* stylelint-enable */\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          9948: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              '.ck.ck-tooltip,.ck.ck-tooltip .ck-tooltip__text:after{-webkit-backface-visibility:hidden;pointer-events:none;position:absolute}.ck.ck-tooltip{display:none;opacity:0;visibility:hidden;z-index:var(--ck-z-modal)}.ck.ck-tooltip .ck-tooltip__text{display:inline-block}.ck.ck-tooltip .ck-tooltip__text:after{content:"";height:0;width:0}:root{--ck-tooltip-arrow-size:5px}.ck.ck-tooltip{left:50%;top:0;transition:opacity .2s ease-in-out .2s}.ck.ck-tooltip .ck-tooltip__text{border-radius:0}.ck-rounded-corners :is(.ck.ck-tooltip .ck-tooltip__text),.ck.ck-tooltip .ck-tooltip__text.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-tooltip .ck-tooltip__text{background:var(--ck-color-tooltip-background);color:var(--ck-color-tooltip-text);font-size:.9em;left:-50%;line-height:1.5;padding:var(--ck-spacing-small) var(--ck-spacing-medium);position:relative}.ck.ck-tooltip .ck-tooltip__text:after{border-style:solid;left:50%;transition:opacity .2s ease-in-out .2s}.ck.ck-tooltip.ck-tooltip_s,.ck.ck-tooltip.ck-tooltip_se,.ck.ck-tooltip.ck-tooltip_sw{bottom:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateY(100%)}.ck.ck-tooltip.ck-tooltip_s .ck-tooltip__text:after,.ck.ck-tooltip.ck-tooltip_se .ck-tooltip__text:after,.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text:after{border-color:transparent transparent var(--ck-color-tooltip-background) transparent;border-width:0 var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size);top:calc(var(--ck-tooltip-arrow-size)*-1 + 1px);transform:translateX(-50%)}.ck.ck-tooltip.ck-tooltip_sw{left:auto;right:50%}.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text{left:auto;right:calc(var(--ck-tooltip-arrow-size)*-2)}.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text:after{left:auto;right:0}.ck.ck-tooltip.ck-tooltip_se{left:50%;right:auto}.ck.ck-tooltip.ck-tooltip_se .ck-tooltip__text{left:calc(var(--ck-tooltip-arrow-size)*-2);right:auto}.ck.ck-tooltip.ck-tooltip_se .ck-tooltip__text:after{left:0;right:auto;transform:translateX(50%)}.ck.ck-tooltip.ck-tooltip_n{top:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateY(-100%)}.ck.ck-tooltip.ck-tooltip_n .ck-tooltip__text:after{border-color:var(--ck-color-tooltip-background) transparent transparent transparent;border-width:var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) 0 var(--ck-tooltip-arrow-size);bottom:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateX(-50%)}.ck.ck-tooltip.ck-tooltip_e{left:calc(100% + var(--ck-tooltip-arrow-size));top:50%}.ck.ck-tooltip.ck-tooltip_e .ck-tooltip__text{left:0;transform:translateY(-50%)}.ck.ck-tooltip.ck-tooltip_e .ck-tooltip__text:after{border-color:transparent var(--ck-color-tooltip-background) transparent transparent;border-width:var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) 0;left:calc(var(--ck-tooltip-arrow-size)*-1);top:calc(50% - var(--ck-tooltip-arrow-size)*1)}.ck.ck-tooltip.ck-tooltip_w{left:auto;right:calc(100% + var(--ck-tooltip-arrow-size));top:50%}.ck.ck-tooltip.ck-tooltip_w .ck-tooltip__text{left:0;transform:translateY(-50%)}.ck.ck-tooltip.ck-tooltip_w .ck-tooltip__text:after{border-color:transparent transparent transparent var(--ck-color-tooltip-background);border-width:var(--ck-tooltip-arrow-size) 0 var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size);left:100%;top:calc(50% - var(--ck-tooltip-arrow-size)*1)}',
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/tooltip.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
                ],
                names: [],
                mappings:
                  "AAKA,sDASC,kCAAmC,CAJnC,mBAAoB,CAHpB,iBAQD,CAEA,eAIC,YAAa,CADb,SAAU,CADV,iBAAkB,CAGlB,yBAWD,CATC,iCACC,oBAOD,CALC,uCACC,UAAW,CAEX,QAAS,CADT,OAED,CCxBF,MACC,2BACD,CAEA,eACC,QAAS,CAMT,KAAM,CAON,sCAwKD,CAtKC,iCChBA,eDqCA,CArBA,8GCZC,qCDiCD,CArBA,iCAOC,6CAA8C,CAF9C,kCAAmC,CAFnC,cAAe,CAMf,SAAU,CALV,eAAgB,CAEhB,wDAAyD,CAEzD,iBAaD,CAVC,uCAOC,kBAAmB,CACnB,QAAS,CAFT,sCAGD,CAYD,sFAGC,4CAA+C,CAC/C,0BASD,CAPC,8JAIC,mFAAoF,CACpF,qGAAsG,CAHtG,+CAAkD,CAClD,0BAGD,CAaD,6BAEC,SAAU,CADV,SAYD,CATC,+CACC,SAAU,CACV,2CACD,CAEA,qDACC,SAAU,CACV,OACD,CAYD,6BACC,QAAS,CACT,UAYD,CAVC,+CAEC,0CAA8C,CAD9C,UAED,CAEA,qDAEC,MAAO,CADP,UAAW,CAEX,yBACD,CAYD,4BACC,yCAA4C,CAC5C,2BAQD,CANC,oDAGC,mFAAoF,CACpF,qGAAsG,CAHtG,4CAA+C,CAC/C,0BAGD,CAUD,4BACC,8CAA+C,CAC/C,OAaD,CAXC,8CACC,MAAO,CACP,0BAQD,CANC,oDAGC,mFAAoF,CACpF,qGAAsG,CAHtG,0CAA6C,CAC7C,8CAGD,CAWF,4BAEC,SAAU,CADV,+CAAgD,CAEhD,OAaD,CAXC,8CACC,MAAO,CACP,0BAQD,CANC,oDAGC,mFAAoF,CACpF,qGAAsG,CAHtG,SAAU,CACV,8CAGD",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-tooltip,\n.ck.ck-tooltip .ck-tooltip__text::after {\n\tposition: absolute;\n\n\t/* Without this, hovering the tooltip could keep it visible. */\n\tpointer-events: none;\n\n\t/* This is to get rid of flickering when transitioning opacity in Chrome.\n\tIt\'s weird but it works. */\n\t-webkit-backface-visibility: hidden;\n}\n\n.ck.ck-tooltip {\n\t/* Tooltip is hidden by default. */\n\tvisibility: hidden;\n\topacity: 0;\n\tdisplay: none;\n\tz-index: var(--ck-z-modal);\n\n\t& .ck-tooltip__text {\n\t\tdisplay: inline-block;\n\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t}\n\t}\n}\n',
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-tooltip-arrow-size: 5px;\n}\n\n.ck.ck-tooltip {\n\tleft: 50%;\n\n\t/*\n\t * Prevent blurry tooltips in LoDPI environments.\n\t * See https://github.com/ckeditor/ckeditor5/issues/1802.\n\t */\n\ttop: 0;\n\n\t/*\n\t * For the transition to work, the tooltip must be controlled\n\t * using visibility+opacity. A delay prevents a "tooltip avalanche"\n\t * i.e. when scanning the toolbar with mouse cursor.\n\t */\n\ttransition: opacity .2s ease-in-out .2s;\n\n\t& .ck-tooltip__text {\n\t\t@mixin ck-rounded-corners;\n\n\t\tfont-size: .9em;\n\t\tline-height: 1.5;\n\t\tcolor: var(--ck-color-tooltip-text);\n\t\tpadding: var(--ck-spacing-small) var(--ck-spacing-medium);\n\t\tbackground: var(--ck-color-tooltip-background);\n\t\tposition: relative;\n\t\tleft: -50%;\n\n\t\t&::after {\n\t\t\t/*\n\t\t\t * For the transition to work, the tooltip must be controlled\n\t\t\t * using visibility+opacity. A delay prevents a "tooltip avalanche"\n\t\t\t * i.e. when scanning the toolbar with mouse cursor.\n\t\t\t */\n\t\t\ttransition: opacity .2s ease-in-out .2s;\n\t\t\tborder-style: solid;\n\t\t\tleft: 50%;\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip south of the element.\n\t *\n\t *       [element]\n\t *           ^\n\t *     +-----------+\n\t *     |  Tooltip  |\n\t *     +-----------+\n\t */\n\t&.ck-tooltip_s,\n\t&.ck-tooltip_sw,\n\t&.ck-tooltip_se {\n\t\tbottom: calc(-1 * var(--ck-tooltip-arrow-size));\n\t\ttransform: translateY( 100% );\n\n\t\t& .ck-tooltip__text::after {\n\t\t\t/* 1px addresses gliches in rendering causing gap between the triangle and the text */\n\t\t\ttop: calc(-1 * var(--ck-tooltip-arrow-size) + 1px);\n\t\t\ttransform: translateX( -50% );\n\t\t\tborder-color: transparent transparent var(--ck-color-tooltip-background) transparent;\n\t\t\tborder-width: 0 var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size);\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip south-west of the element.\n\t *\n\t *        [element]\n\t *            ^\n\t *  +-----------+\n\t *  |  Tooltip  |\n\t *  +-----------+\n\t */\n\n\t&.ck-tooltip_sw {\n\t\tright: 50%;\n\t\tleft: auto;\n\n\t\t& .ck-tooltip__text {\n\t\t\tleft: auto;\n\t\t\tright: calc( -2 * var(--ck-tooltip-arrow-size));\n\t\t}\n\n\t\t& .ck-tooltip__text::after {\n\t\t\tleft: auto;\n\t\t\tright: 0;\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip south-east of the element.\n\t *\n\t *  [element]\n\t *      ^\n\t *    +-----------+\n\t *    |  Tooltip  |\n\t *    +-----------+\n\t */\n\t&.ck-tooltip_se {\n\t\tleft: 50%;\n\t\tright: auto;\n\n\t\t& .ck-tooltip__text {\n\t\t\tright: auto;\n\t\t\tleft: calc( -2 * var(--ck-tooltip-arrow-size));\n\t\t}\n\n\t\t& .ck-tooltip__text::after {\n\t\t\tright: auto;\n\t\t\tleft: 0;\n\t\t\ttransform: translateX( 50% );\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip north of the element.\n\t *\n\t *     +-----------+\n\t *     |  Tooltip  |\n\t *     +-----------+\n\t *           V\n\t *       [element]\n\t */\n\t&.ck-tooltip_n {\n\t\ttop: calc(-1 * var(--ck-tooltip-arrow-size));\n\t\ttransform: translateY( -100% );\n\n\t\t& .ck-tooltip__text::after {\n\t\t\tbottom: calc(-1 * var(--ck-tooltip-arrow-size));\n\t\t\ttransform: translateX( -50% );\n\t\t\tborder-color: var(--ck-color-tooltip-background) transparent transparent transparent;\n\t\t\tborder-width: var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) 0 var(--ck-tooltip-arrow-size);\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip east of the element.\n\t *\n\t *                +----------+\n\t *    [element] < |   east   |\n\t *                +----------+\n\t */\n\t&.ck-tooltip_e {\n\t\tleft: calc(100% + var(--ck-tooltip-arrow-size));\n\t\ttop: 50%;\n\n\t\t& .ck-tooltip__text {\n\t\t\tleft: 0;\n\t\t\ttransform: translateY( -50% );\n\n\t\t\t&::after {\n\t\t\t\tleft: calc(-1 * var(--ck-tooltip-arrow-size));\n\t\t\t\ttop: calc(50% - 1 * var(--ck-tooltip-arrow-size));\n\t\t\t\tborder-color: transparent var(--ck-color-tooltip-background) transparent transparent;\n\t\t\t\tborder-width: var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip west of the element.\n\t *\n\t *    +----------+\n\t *    |   west   | > [element]\n\t *    +----------+\n\t */\n\t&.ck-tooltip_w {\n\t\tright: calc(100% + var(--ck-tooltip-arrow-size));\n\t\tleft: auto;\n\t\ttop: 50%;\n\n\t\t& .ck-tooltip__text {\n\t\t\tleft: 0;\n\t\t\ttransform: translateY( -50% );\n\n\t\t\t&::after {\n\t\t\t\tleft: 100%;\n\t\t\t\ttop: calc(50% - 1 * var(--ck-tooltip-arrow-size));\n\t\t\t\tborder-color: transparent transparent transparent var(--ck-color-tooltip-background);\n\t\t\t\tborder-width: var(--ck-tooltip-arrow-size) 0 var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size);\n\t\t\t}\n\t\t}\n\t}\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          6150: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck-hidden{display:none!important}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{box-sizing:border-box;height:auto;position:static;width:auto}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#c4c4c4;--ck-color-base-action:#61b045;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#198cf0;--ck-color-base-active-focus:#0e7fe1;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:208,79%,51%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#bcdefb;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#e6e6e6;--ck-color-button-default-active-background:#d9d9d9;--ck-color-button-default-active-shadow:#bfbfbf;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#dedede;--ck-color-button-on-hover-background:#c4c4c4;--ck-color-button-on-active-background:#bababa;--ck-color-button-on-active-shadow:#a1a1a1;--ck-color-button-on-disabled-background:#dedede;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#579e3d;--ck-color-button-action-active-background:#53973b;--ck-color-button-action-active-shadow:#498433;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#b0b0b0;--ck-color-switch-button-off-hover-background:#a3a3a3;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#579e3d;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:#c7c7c7;--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:#c7c7c7;--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-base-active);--ck-color-list-button-on-background-focus:var(--ck-color-base-active-focus);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-foreground);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{word-wrap:break-word;background:transparent;border:0;margin:0;padding:0;text-decoration:none;transition:none;vertical-align:middle}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_hidden.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_reset.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_zindex.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_transition.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css",
                ],
                names: [],
                mappings:
                  "AAQA,WAGC,sBACD,CCPA,2EAGC,qBAAsB,CAEtB,WAAY,CACZ,eAAgB,CAFhB,UAGD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAgD,CAChD,8BAAmD,CACnD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAmD,CACnD,oCAAuD,CACvD,6BAAkD,CAIlD,+CAAwD,CACxD,qEAA+E,CAC/E,qCAAwD,CACxD,qDAA8D,CAC9D,gDAAyD,CACzD,yCAAqD,CACrD,sCAAsD,CACtD,4CAA0D,CAC1D,sCAAsD,CAItD,gDAAuD,CACvD,kDAA+D,CAC/D,mDAAgE,CAChE,+CAA6D,CAC7D,yDAA8D,CAE9D,uCAAuD,CACvD,6CAA4D,CAC5D,8CAA4D,CAC5D,0CAAyD,CACzD,gDAA8D,CAE9D,+DAAsE,CACtE,iDAAkE,CAClE,kDAAkE,CAClE,8CAA+D,CAC/D,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA4D,CAC5D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAmE,CACnE,yEAA8E,CAC9E,oDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,+BAAiD,CACjD,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,wCAAwD,CACxD,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,gEAAuE,CACvE,4EAAiF,CACjF,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,uDAAmE,CACnE,kDAAgE,CCpGhE,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJoGD,CI9FA,2EAaC,oBAAqB,CANrB,sBAAuB,CADvB,QAAS,CAFT,QAAS,CACT,SAAU,CAGV,oBAAqB,CAErB,eAAgB,CADhB,qBAKD,CAKA,8DAGC,wBAAyB,CAEzB,0BAA2B,CAG3B,WAAY,CACZ,UAAW,CALX,iGAAkG,CAElG,eAAgB,CAChB,kBAGD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDAEC,yBAAoC,CADpC,YAED,CAEA,qEAGC,QAAQ,CADR,SAED,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which hides an element in DOM.\n */\n.ck-hidden {\n\t/* Override selector specificity. Otherwise, all elements with some display\n\tstyle defined will override this one, which is not a desired result. */\n\tdisplay: none !important;\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\tbox-sizing: border-box;\n\twidth: auto;\n\theight: auto;\n\tposition: static;\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-z-default: 1;\n\t--ck-z-modal: calc( var(--ck-z-default) + 999 );\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class that disables all transitions of the element and its children.\n */\n.ck-transitions-disabled,\n.ck-transitions-disabled * {\n\ttransition: none !important;\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-base-foreground: \t\t\t\t\t\t\t\thsl(0, 0%, 98%);\n\t--ck-color-base-background: \t\t\t\t\t\t\t\thsl(0, 0%, 100%);\n\t--ck-color-base-border: \t\t\t\t\t\t\t\t\thsl(0, 0%, 77%);\n\t--ck-color-base-action: \t\t\t\t\t\t\t\t\thsl(104, 44%, 48%);\n\t--ck-color-base-focus: \t\t\t\t\t\t\t\t\t\thsl(209, 92%, 70%);\n\t--ck-color-base-text: \t\t\t\t\t\t\t\t\t\thsl(0, 0%, 20%);\n\t--ck-color-base-active: \t\t\t\t\t\t\t\t\thsl(208, 88%, 52%);\n\t--ck-color-base-active-focus:\t\t\t\t\t\t\t\thsl(208, 88%, 47%);\n\t--ck-color-base-error:\t\t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t/* -- Generic colors ------------------------------------------------------------------------ */\n\n\t--ck-color-focus-border-coordinates: \t\t\t\t\t\t208, 79%, 51%;\n\t--ck-color-focus-border: \t\t\t\t\t\t\t\t\thsl(var(--ck-color-focus-border-coordinates));\n\t--ck-color-focus-outer-shadow:\t\t\t\t\t\t\t\thsl(207, 89%, 86%);\n\t--ck-color-focus-disabled-shadow:\t\t\t\t\t\t\thsla(209, 90%, 72%,.3);\n\t--ck-color-focus-error-shadow:\t\t\t\t\t\t\t\thsla(9,100%,56%,.3);\n\t--ck-color-text: \t\t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-shadow-drop: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.15);\n\t--ck-color-shadow-drop-active:\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.2);\n\t--ck-color-shadow-inner: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Buttons ------------------------------------------------------------------------------- */\n\n\t--ck-color-button-default-background: \t\t\t\t\t\ttransparent;\n\t--ck-color-button-default-hover-background: \t\t\t\thsl(0, 0%, 90%);\n\t--ck-color-button-default-active-background: \t\t\t\thsl(0, 0%, 85%);\n\t--ck-color-button-default-active-shadow: \t\t\t\t\thsl(0, 0%, 75%);\n\t--ck-color-button-default-disabled-background: \t\t\t\ttransparent;\n\n\t--ck-color-button-on-background: \t\t\t\t\t\t\thsl(0, 0%, 87%);\n\t--ck-color-button-on-hover-background: \t\t\t\t\t\thsl(0, 0%, 77%);\n\t--ck-color-button-on-active-background: \t\t\t\t\thsl(0, 0%, 73%);\n\t--ck-color-button-on-active-shadow: \t\t\t\t\t\thsl(0, 0%, 63%);\n\t--ck-color-button-on-disabled-background: \t\t\t\t\thsl(0, 0%, 87%);\n\n\t--ck-color-button-action-background: \t\t\t\t\t\tvar(--ck-color-base-action);\n\t--ck-color-button-action-hover-background: \t\t\t\t\thsl(104, 44%, 43%);\n\t--ck-color-button-action-active-background: \t\t\t\thsl(104, 44%, 41%);\n\t--ck-color-button-action-active-shadow: \t\t\t\t\thsl(104, 44%, 36%);\n\t--ck-color-button-action-disabled-background: \t\t\t\thsl(104, 44%, 58%);\n\t--ck-color-button-action-text: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t--ck-color-button-save: \t\t\t\t\t\t\t\t\thsl(120, 100%, 27%);\n\t--ck-color-button-cancel: \t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t--ck-color-switch-button-off-background:\t\t\t\t\thsl(0, 0%, 69%);\n\t--ck-color-switch-button-off-hover-background:\t\t\t\thsl(0, 0%, 64%);\n\t--ck-color-switch-button-on-background:\t\t\t\t\t\tvar(--ck-color-button-action-background);\n\t--ck-color-switch-button-on-hover-background:\t\t\t\thsl(104, 44%, 43%);\n\t--ck-color-switch-button-inner-background:\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-switch-button-inner-shadow:\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Dropdown ------------------------------------------------------------------------------ */\n\n\t--ck-color-dropdown-panel-background: \t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-dropdown-panel-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Input --------------------------------------------------------------------------------- */\n\n\t--ck-color-input-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-input-border: \t\t\t\t\t\t\t\t\thsl(0, 0%, 78%);\n\t--ck-color-input-error-border:\t\t\t\t\t\t\t\tvar(--ck-color-base-error);\n\t--ck-color-input-text: \t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-input-disabled-background: \t\t\t\t\t\thsl(0, 0%, 95%);\n\t--ck-color-input-disabled-border: \t\t\t\t\t\t\thsl(0, 0%, 78%);\n\t--ck-color-input-disabled-text: \t\t\t\t\t\t\thsl(0, 0%, 46%);\n\n\t/* -- List ---------------------------------------------------------------------------------- */\n\n\t--ck-color-list-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-list-button-hover-background: \t\t\t\t\tvar(--ck-color-button-default-hover-background);\n\t--ck-color-list-button-on-background: \t\t\t\t\t\tvar(--ck-color-base-active);\n\t--ck-color-list-button-on-background-focus: \t\t\t\tvar(--ck-color-base-active-focus);\n\t--ck-color-list-button-on-text:\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Panel --------------------------------------------------------------------------------- */\n\n\t--ck-color-panel-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-panel-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Toolbar ------------------------------------------------------------------------------- */\n\n\t--ck-color-toolbar-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-foreground);\n\t--ck-color-toolbar-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Tooltip ------------------------------------------------------------------------------- */\n\n\t--ck-color-tooltip-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-tooltip-text: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Engine -------------------------------------------------------------------------------- */\n\n\t--ck-color-engine-placeholder-text: \t\t\t\t\t\thsl(0, 0%, 44%);\n\n\t/* -- Upload -------------------------------------------------------------------------------- */\n\n\t--ck-color-upload-bar-background:\t\t \t\t\t\t\thsl(209, 92%, 70%);\n\n\t/* -- Link -------------------------------------------------------------------------------- */\n\n\t--ck-color-link-default:\t\t\t\t\t\t\t\t\thsl(240, 100%, 47%);\n\t--ck-color-link-selected-background:\t\t\t\t\t\thsla(201, 100%, 56%, 0.1);\n\t--ck-color-link-fake-selection:\t\t\t\t\t\t\t\thsla(201, 100%, 56%, 0.3);\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * An opacity value of disabled UI item.\n\t */\n\t--ck-disabled-opacity: .5;\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * The geometry of the of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow-geometry: 0 0 0 3px;\n\n\t/**\n\t * A visual style of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when disabled).\n\t */\n\t--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when has errors).\n\t */\n\t--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\n\n\t/**\n\t * A visual style of focused element's border or outline.\n\t */\n\t--ck-focus-ring: 1px solid var(--ck-color-focus-border);\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-font-size-base: 13px;\n\t--ck-line-height-base: 1.84615;\n\t--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\n\n\t--ck-font-size-tiny: 0.7em;\n\t--ck-font-size-small: 0.75em;\n\t--ck-font-size-normal: 1em;\n\t--ck-font-size-big: 1.4em;\n\t--ck-font-size-large: 1.8em;\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* This is super-important. This is **manually** adjusted so a button without an icon\n\tis never smaller than a button with icon, additionally making sure that text-less buttons\n\tare perfect squares. The value is also shared by other components which should stay "in-line"\n\twith buttons. */\n\t--ck-ui-component-min-height: 2.3em;\n}\n\n/**\n * Resets an element, ignoring its children.\n */\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* Do not include inheritable rules here. */\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tbackground: transparent;\n\ttext-decoration: none;\n\tvertical-align: middle;\n\ttransition: none;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\n\tword-wrap: break-word;\n}\n\n/**\n * Resets an element AND its children.\n */\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n\t/* These are rule inherited by all children elements. */\n\tborder-collapse: collapse;\n\tfont: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\n\tcolor: var(--ck-color-text);\n\ttext-align: left;\n\twhite-space: nowrap;\n\tcursor: auto;\n\tfloat: none;\n}\n\n.ck-reset_all {\n\t& .ck-rtl *:not(.ck-reset_all-excluded *) {\n\t\ttext-align: right;\n\t}\n\n\t& iframe:not(.ck-reset_all-excluded *) {\n\t\t/* For IE */\n\t\tvertical-align: inherit;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *) {\n\t\twhite-space: pre-wrap;\n\t}\n\n\t& textarea:not(.ck-reset_all-excluded *),\n\t& input[type="text"]:not(.ck-reset_all-excluded *),\n\t& input[type="password"]:not(.ck-reset_all-excluded *) {\n\t\tcursor: text;\n\t}\n\n\t& textarea[disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="text"][disabled]:not(.ck-reset_all-excluded *),\n\t& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {\n\t\tcursor: default;\n\t}\n\n\t& fieldset:not(.ck-reset_all-excluded *) {\n\t\tpadding: 10px;\n\t\tborder: 2px groove hsl(255, 7%, 88%);\n\t}\n\n\t& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {\n\t\t/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\n\t\tpadding: 0;\n\t\tborder: 0\n\t}\n}\n\n/**\n * Default UI rules for RTL languages.\n */\n.ck[dir="rtl"],\n.ck[dir="rtl"] .ck {\n\ttext-align: right;\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Default border-radius value.\n */\n:root{\n\t--ck-border-radius: 2px;\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * A visual style of element's inner shadow (i.e. input).\n\t */\n\t--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\n\n\t/**\n\t * A visual style of element's drop shadow (i.e. panel).\n\t */\n\t--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\n\n\t/**\n\t * A visual style of element's active shadow (i.e. comment or suggestion).\n\t */\n\t--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-spacing-unit: \t\t\t\t\t\t0.6em;\n\t--ck-spacing-large: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 1.5);\n\t--ck-spacing-standard: \t\t\t\t\tvar(--ck-spacing-unit);\n\t--ck-spacing-medium: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.8);\n\t--ck-spacing-small: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.5);\n\t--ck-spacing-tiny: \t\t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.3);\n\t--ck-spacing-extra-tiny: \t\t\t\tcalc(var(--ck-spacing-unit) * 0.16);\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          6507: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background);border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}:is(.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover)>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}:is(.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover)>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck-widget_with-selection-handle:is(.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover)>.ck-widget__selection-handle,.ck-widget_with-selection-handle:is(.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover)>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widget.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
                ],
                names: [],
                mappings:
                  "AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CAEtD,qDAAsD,CACtD,6CAA8C,CAF9C,0CAA2C,CAI3C,aAAc,CADd,kCAAmC,CAGnC,uCAAwC,CACxC,4CAA6C,CAF7C,iCAsCD,CAlCC,8NAKC,iBACD,CAEA,0CAEC,qCAAsC,CADtC,oCAED,CAEA,2CAEC,sCAAuC,CADvC,oCAED,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CAEC,QAAS,CADT,6CAAgD,CAEhD,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eAGC,yBAA0B,CAD1B,mBAAoB,CADpB,gDAAiD,CAGjD,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGAKC,iEAAkE,CCnCnE,2BAA2B,CCF3B,qCAA8B,CDC9B,YDqCA,CAIA,4EAKC,4BAA6B,CAa7B,iEAAkE,CAhBlE,qBAAsB,CAoBtB,mDAAoD,CAhBpD,SAAU,CALV,WAAY,CAsBZ,KAAM,CAFN,2BAA4B,CAT5B,6SAgCD,CAnBC,qFAIC,oDAAqD,CADrD,yCAA0C,CAD1C,wCAWD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFAEC,oDAAqD,CADrD,SAED,CAKC,4KAEC,6CAA8C,CAD9C,SAOD,CAHC,kNACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,0ZAEC,gDACD,CAKH,yKAOC,yDACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-resizer: var(--ck-color-focus-border);\n\t--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\n\t--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\n\n\t--ck-resizer-border-radius: var(--ck-border-radius);\n\t--ck-resizer-tooltip-offset: 10px;\n\t--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);\n}\n\n.ck .ck-widget {\n\t/* This is neccessary for type around UI to be positioned properly. */\n\tposition: relative;\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n\n\t& .ck-widget__selection-handle {\n\t\tposition: absolute;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the icon in not a subject to font-size or line-height to avoid\n\t\t\tunnecessary spacing around it. */\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n\n\t/* Show the selection handle when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected > .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n}\n\n.ck .ck-size-view {\n\tbackground: var(--ck-color-resizer-tooltip-background);\n\tcolor: var(--ck-color-resizer-tooltip-text);\n\tborder: 1px solid var(--ck-color-resizer-tooltip-text);\n\tborder-radius: var(--ck-resizer-border-radius);\n\tfont-size: var(--ck-font-size-tiny);\n\tdisplay: block;\n\tpadding: 0 var(--ck-spacing-small);\n\theight: var(--ck-resizer-tooltip-height);\n\tline-height: var(--ck-resizer-tooltip-height);\n\n\t&.ck-orientation-top-left,\n\t&.ck-orientation-top-right,\n\t&.ck-orientation-bottom-right,\n\t&.ck-orientation-bottom-left,\n\t&.ck-orientation-above-center {\n\t\tposition: absolute;\n\t}\n\n\t&.ck-orientation-top-left {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-top-right {\n\t\ttop: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-right {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tright: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t&.ck-orientation-bottom-left {\n\t\tbottom: var(--ck-resizer-tooltip-offset);\n\t\tleft: var(--ck-resizer-tooltip-offset);\n\t}\n\n\t/* Class applied if the widget is too small to contain the size label */\n\t&.ck-orientation-above-center {\n\t\ttop: calc(var(--ck-resizer-tooltip-height) * -1);\n\t\tleft: 50%;\n\t\ttransform: translate(-50%);\n\t}\n}\n",
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n\n:root {\n\t--ck-widget-outline-thickness: 3px;\n\t--ck-widget-handler-icon-size: 16px;\n\t--ck-widget-handler-animation-duration: 200ms;\n\t--ck-widget-handler-animation-curve: ease;\n\n\t--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\n\t--ck-color-widget-hover-border: hsl(43, 100%, 62%);\n\t--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\n\t--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\n}\n\n.ck .ck-widget {\n\toutline-width: var(--ck-widget-outline-thickness);\n\toutline-style: solid;\n\toutline-color: transparent;\n\ttransition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\n\t}\n\n\t&:hover {\n\t\toutline-color: var(--ck-color-widget-hover-border);\n\t}\n}\n\n.ck .ck-editor__nested-editable {\n\tborder: 1px solid transparent;\n\n\t/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\n\tThese styles show a different border for a blink of an eye, so `:focus` need to have same styles applied. */\n\t&.ck-editor__nested-editable_focused,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\n\t\tbackground-color: var(--ck-color-widget-editable-focus-background);\n\t}\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t& .ck-widget__selection-handle {\n\t\tpadding: 4px;\n\t\tbox-sizing: border-box;\n\n\t\t/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\n\t\tbackground-color: transparent;\n\t\topacity: 0;\n\n\t\t/* Transition:\n\t\t   * background-color for the .ck-widget_selected state change,\n\t\t   * visibility for hiding the handler,\n\t\t   * opacity for the proper look of the icon when the handler disappears. */\n\t\ttransition:\n\t\t\tbackground-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\tvisibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\topacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t/* Make only top corners round. */\n\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\n\t\t/* Place the drag handler outside the widget wrapper. */\n\t\ttransform: translateY(-100%);\n\t\tleft: calc(0px - var(--ck-widget-outline-thickness));\n\t\ttop: 0;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\n\t\t\twidth: var(--ck-widget-handler-icon-size);\n\t\t\theight: var(--ck-widget-handler-icon-size);\n\t\t\tcolor: var(--ck-color-widget-drag-handler-icon-color);\n\n\t\t\t/* The "selected" part of the icon is invisible by default */\n\t\t\t& .ck-icon__selected-indicator {\n\t\t\t\topacity: 0;\n\n\t\t\t\t/* Note: The animation is longer on purpose. Simply feels better. */\n\t\t\t\ttransition: opacity 300ms var(--ck-widget-handler-animation-curve);\n\t\t\t}\n\t\t}\n\n\t\t/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\n\t\t&:hover .ck-icon .ck-icon__selected-indicator {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */\n\t&:hover > .ck-widget__selection-handle {\n\t\topacity: 1;\n\t\tbackground-color: var(--ck-color-widget-hover-border);\n\t}\n\n\t/* Show the selection handler when the widget is selected, but not for nested widgets. */\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\t& > .ck-widget__selection-handle {\n\t\t\topacity: 1;\n\t\t\tbackground-color: var(--ck-color-focus-border);\n\n\t\t\t/* When the widget is selected, notify the user using the proper look of the icon. */\n\t\t\t& .ck-icon .ck-icon__selected-indicator {\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* In a RTL environment, align the selection handler to the right side of the widget */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\n\tleft: auto;\n\tright: calc(0px - var(--ck-widget-outline-thickness));\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\n.ck.ck-editor__editable.ck-read-only .ck-widget {\n\t/* Prevent the :hover outline from showing up because of the used outline-color transition. */\n\ttransition: none;\n\n\t&:not(.ck-widget_selected) {\n\t\t/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/1261\n\t\t *\n\t\t * Leave the unit because this custom property is used in calc() by other features.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/6775\n\t\t */\n\t\t--ck-widget-outline-thickness: 0px;\n\t}\n\n\t&.ck-widget_with-selection-handle {\n\t\t& .ck-widget__selection-handle,\n\t\t& .ck-widget__selection-handle:hover {\n\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t}\n\t}\n}\n\n/* Style the widget when it\'s selected but the editable it belongs to lost focus. */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck.ck-editor__editable.ck-blurred .ck-widget {\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline-color: var(--ck-color-widget-blurred-border);\n\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t& > .ck-widget__selection-handle,\n\t\t\t& > .ck-widget__selection-handle:hover {\n\t\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\n\t/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\n\tIn fact, anything with overflow: hidden.\n\thttps://github.com/ckeditor/ckeditor5-block-quote/issues/28\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/44\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/66 */\n\tmargin-top: calc(1em + var(--ck-widget-handler-icon-size));\n}\n',
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          2263: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}",
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgetresize.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css",
                ],
                names: [],
                mappings:
                  "AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CAMb,MAAO,CAFP,mBAAoB,CAHpB,iBAAkB,CAMlB,KACD,CAGC,2EACC,aACD,CAGD,gCAIC,kBAAmB,CAHnB,iBAcD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCAGC,uCAAwC,CACxC,gDAA6D,CAC7D,6CAA8C,CAH9C,6BAA8B,CAD9B,4BAyBD,CAnBC,oEAEC,6BAA8B,CAD9B,4BAED,CAEA,qEAEC,8BAA+B,CAD/B,4BAED,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD",
                sourcesContent: [
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget_with-resizer {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n}\n\n.ck .ck-widget__resizer {\n\tdisplay: none;\n\tposition: absolute;\n\n\t/* The wrapper itself should not interfere with the pointer device, only the handles should. */\n\tpointer-events: none;\n\n\tleft: 0;\n\ttop: 0;\n}\n\n.ck-focused .ck-widget_with-resizer.ck-widget_selected {\n\t& > .ck-widget__resizer {\n\t\tdisplay: block;\n\t}\n}\n\n.ck .ck-widget__resizer__handle {\n\tposition: absolute;\n\n\t/* Resizers are the only UI elements that should interfere with a pointer device. */\n\tpointer-events: all;\n\n\t&.ck-widget__resizer__handle-top-left,\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tcursor: nwse-resize;\n\t}\n\n\t&.ck-widget__resizer__handle-top-right,\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tcursor: nesw-resize;\n\t}\n}\n",
                  "/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-resizer-size: 10px;\n\n\t/* Set the resizer with a 50% offset. */\n\t--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\n\t--ck-resizer-border-width: 1px;\n}\n\n.ck .ck-widget__resizer {\n\toutline: 1px solid var(--ck-color-resizer);\n}\n\n.ck .ck-widget__resizer__handle {\n\twidth: var(--ck-resizer-size);\n\theight: var(--ck-resizer-size);\n\tbackground: var(--ck-color-focus-border);\n\tborder: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);\n\tborder-radius: var(--ck-resizer-border-radius);\n\n\t&.ck-widget__resizer__handle-top-left {\n\t\ttop: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-top-right {\n\t\ttop: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-right {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tright: var(--ck-resizer-offset);\n\t}\n\n\t&.ck-widget__resizer__handle-bottom-left {\n\t\tbottom: var(--ck-resizer-offset);\n\t\tleft: var(--ck-resizer-offset);\n\t}\n}\n",
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          5137: (t, e, n) => {
            "use strict";
            n.d(e, { Z: () => a });
            var i = n(4015),
              o = n.n(i),
              r = n(3645),
              s = n.n(r)()(o());
            s.push([
              t.id,
              '.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}:is(.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover)>.ck-widget__selection-handle{opacity:0}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}',
              "",
              {
                version: 3,
                sources: [
                  "webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgettypearound.css",
                  "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css",
                ],
                names: [],
                mappings:
                  "AASC,+CACC,aAAc,CAEd,eAAgB,CADhB,iBAAkB,CAElB,2BAwBD,CAtBC,mDAGC,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAEA,qFAGC,kBAAoB,CADpB,gDAAoD,CAGpD,0BACD,CAEA,oFAEC,mDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CAGd,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAMD,2EACC,YAAa,CAEb,MAAO,CADP,iBAAkB,CAElB,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHAEC,aAAc,CADd,qDAED,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CAGC,oDAAqD,CACrD,mBAAoB,CAFpB,+CAAgD,CAVjD,SAAU,CACV,mBAAoB,CAYnB,uMAAyM,CAJzM,8CAkDD,CA1CC,mDAEC,UAAW,CAGX,cAAe,CAFf,8BAA+B,CAC/B,6BAA8B,CAH9B,UAoBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLAIC,uEAAkF,CADlF,mBAAoB,CADpB,2DAA4D,CAD5D,0DAID,CAOD,8GACC,gBACD,CAKA,mDAGC,mFAAoF,CAOpF,oCAAqC,CARrC,UAAW,CAOX,oCAAwC,CARxC,mBAUD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CASE,weACC,SACD,CASF,mPACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD",
                sourcesContent: [
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t\toverflow: hidden;\n\t\tz-index: var(--ck-z-default);\n\n\t\t& svg {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: 50%;\n\t\t\tz-index: calc(var(--ck-z-default) + 2);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_before {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\ttop: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tleft: min(10%, 30px);\n\n\t\t\ttransform: translateY(-50%);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_after {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\tbottom: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tright: min(10%, 30px);\n\n\t\t\ttransform: translateY(50%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t\ttop: 1px;\n\t\t\tleft: 1px;\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tdisplay: none;\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t}\n\n\t/*\n\t * When the widget is hovered the "fake caret" would normally be narrower than the\n\t * extra outline displayed around the widget. Let\'s extend the "fake caret" to match\n\t * the full width of the widget.\n\t */\n\t&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tleft: calc( -1 * var(--ck-widget-outline-thickness) );\n\t\tright: calc( -1 * var(--ck-widget-outline-thickness) );\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\ttop: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tbottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n}\n\n/*\n * Integration with the read-only mode of the editor.\n */\n.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the restricted editing mode (feature) of the editor.\n */\n.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the #isEnabled property of the WidgetTypeAround plugin.\n */\n.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {\n\tdisplay: none;\n}\n',
                  '/*\n * Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-widget-type-around-button-size: 20px;\n\t--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);\n\t--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);\n\t--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);\n\t--ck-color-widget-type-around-button-radar-start-alpha: 0;\n\t--ck-color-widget-type-around-button-radar-end-alpha: .3;\n\t--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);\n}\n\n@define-mixin ck-widget-type-around-button-visible {\n\topacity: 1;\n\tpointer-events: auto;\n}\n\n@define-mixin ck-widget-type-around-button-hidden {\n\topacity: 0;\n\tpointer-events: none;\n}\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\twidth: var(--ck-widget-type-around-button-size);\n\t\theight: var(--ck-widget-type-around-button-size);\n\t\tbackground: var(--ck-color-widget-type-around-button);\n\t\tborder-radius: 100px;\n\t\ttransition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t@mixin ck-widget-type-around-button-hidden;\n\n\t\t& svg {\n\t\t\twidth: 10px;\n\t\t\theight: 8px;\n\t\t\ttransform: translate(-50%,-50%);\n\t\t\ttransition: transform .5s ease;\n\t\t\tmargin-top: 1px;\n\n\t\t\t& * {\n\t\t\t\tstroke-dasharray: 10;\n\t\t\t\tstroke-dashoffset: 0;\n\n\t\t\t\tfill: none;\n\t\t\t\tstroke: var(--ck-color-widget-type-around-button-icon);\n\t\t\t\tstroke-width: 1.5px;\n\t\t\t\tstroke-linecap: round;\n\t\t\t\tstroke-linejoin: round;\n\t\t\t}\n\n\t\t\t& line {\n\t\t\t\tstroke-dasharray: 7;\n\t\t\t}\n\t\t}\n\n\t\t&:hover {\n\t\t\t/*\n\t\t\t * Display the "sonar" around the button when hovered.\n\t\t\t */\n\t\t\tanimation: ck-widget-type-around-button-sonar 1s ease infinite;\n\n\t\t\t/*\n\t\t\t * Animate active button\'s icon.\n\t\t\t */\n\t\t\t& svg {\n\t\t\t\t& polyline {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-dash 2s linear;\n\t\t\t\t}\n\n\t\t\t\t& line {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-tip-dash 2s linear;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Show type around buttons when the widget gets selected or being hovered.\n\t */\n\t&.ck-widget_selected,\n\t&:hover {\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-visible;\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when the widget is NOT selected (but the buttons are visible\n\t * and still can be hovered).\n\t */\n\t&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\tbackground: var(--ck-color-widget-type-around-button-hover);\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\tbackground: var(--ck-color-widget-type-around-button-active);\n\n\t\t&::after {\n\t\t\twidth: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\theight: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\tborder-radius: 100px;\n\t\t\tbackground: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the "before" button when the widget has a selection handle. Because some space\n\t * is consumed by the handle, the button must be moved slightly to the right to let it breathe.\n\t */\n\t&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {\n\t\tmargin-left: 20px;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& .ck-widget__type-around__fake-caret {\n\t\tpointer-events: none;\n\t\theight: 1px;\n\t\tanimation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;\n\n\t\t/*\n\t\t * The semi-transparent-outline+background combo improves the contrast\n\t\t * when the background underneath the fake caret is dark.\n\t\t */\n\t\toutline: solid 1px hsla(0, 0%, 100%, .5);\n\t\tbackground: var(--ck-color-base-text);\n\t}\n\n\t/*\n\t * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t * Despite the widget being physically selected in the model, its outline should disappear.\n\t */\n\t&.ck-widget_selected {\n\t\t&.ck-widget_type-around_show-fake-caret_before,\n\t\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t\toutline-color: transparent;\n\t\t}\n\t}\n\n\t&.ck-widget_type-around_show-fake-caret_before,\n\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t/*\n\t\t * When the "fake caret" is visible we simulate that the widget is not selected\n\t\t * (despite being physically selected), so the outline color should be for the\n\t\t * unselected widget.\n\t\t */\n\t\t&.ck-widget_selected:hover {\n\t\t\toutline-color: var(--ck-color-widget-hover-border);\n\t\t}\n\n\t\t/*\n\t\t * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t\t * In this state, the type around buttons would collide with the fake carets so they should disappear.\n\t\t */\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the selection handle. When the caret is visible, simply\n\t\t * hide the handle because it intersects with the caret (and does not make much sense anyway).\n\t\t */\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t&.ck-widget_selected,\n\t\t\t&.ck-widget_selected:hover {\n\t\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\t\topacity: 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the resize UI. When the caret is visible, simply\n\t\t * hide the resize UI because it creates too much noise. It can be visible when the user\n\t\t * hovers the widget, though.\n\t\t */\n\t\t&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {\n\t\t\topacity: 0\n\t\t}\n\t}\n}\n\n/*\n * Styles for the "before" button when the widget has a selection handle in an RTL environment.\n * The selection handler is aligned to the right side of the widget so there is no need to create\n * additional space for it next to the "before" button.\n */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {\n\tmargin-left: 0;\n\tmargin-right: 20px;\n}\n\n/*\n * Hide type around buttons when the widget is selected as a child of a selected\n * nested editable (e.g. mulit-cell table selection).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/7263.\n */\n.ck-editor__nested-editable.ck-editor__editable_selected {\n\t& .ck-widget {\n\t\t&.ck-widget_selected,\n\t\t&:hover {\n\t\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).\n */\n.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {\n\tbackground: var(--ck-color-widget-type-around-button-blurred-editable);\n\n\t& svg * {\n\t\tstroke: hsl(0,0%,60%);\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-dash {\n\t0% {\n\t\tstroke-dashoffset: 10;\n\t}\n\t20%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-tip-dash {\n\t0%, 20% {\n\t\tstroke-dashoffset: 7;\n\t}\n\t40%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-button-sonar {\n\t0% {\n\t\tbox-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n\t50% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));\n\t}\n\t100% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n}\n\n@keyframes ck-widget-type-around-fake-caret-pulse {\n\t0% {\n\t\topacity: 1;\n\t}\n\t49% {\n\t\topacity: 1;\n\t}\n\t50% {\n\t\topacity: 0;\n\t}\n\t99% {\n\t\topacity: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t}\n}\n',
                ],
                sourceRoot: "",
              },
            ]);
            const a = s;
          },
          3645: (t) => {
            "use strict";
            t.exports = function (t) {
              var e = [];
              return (
                (e.toString = function () {
                  return this.map(function (e) {
                    var n = t(e);
                    return e[2]
                      ? "@media ".concat(e[2], " {").concat(n, "}")
                      : n;
                  }).join("");
                }),
                (e.i = function (t, n, i) {
                  "string" == typeof t && (t = [[null, t, ""]]);
                  var o = {};
                  if (i)
                    for (var r = 0; r < this.length; r++) {
                      var s = this[r][0];
                      null != s && (o[s] = !0);
                    }
                  for (var a = 0; a < t.length; a++) {
                    var c = [].concat(t[a]);
                    (i && o[c[0]]) ||
                      (n &&
                        (c[2]
                          ? (c[2] = "".concat(n, " and ").concat(c[2]))
                          : (c[2] = n)),
                      e.push(c));
                  }
                }),
                e
              );
            };
          },
          4015: (t) => {
            "use strict";
            function e(t, e) {
              return (
                (function (t) {
                  if (Array.isArray(t)) return t;
                })(t) ||
                (function (t, e) {
                  var n =
                    t &&
                    (("undefined" != typeof Symbol && t[Symbol.iterator]) ||
                      t["@@iterator"]);
                  if (null == n) return;
                  var i,
                    o,
                    r = [],
                    s = !0,
                    a = !1;
                  try {
                    for (
                      n = n.call(t);
                      !(s = (i = n.next()).done) &&
                      (r.push(i.value), !e || r.length !== e);
                      s = !0
                    );
                  } catch (t) {
                    (a = !0), (o = t);
                  } finally {
                    try {
                      s || null == n.return || n.return();
                    } finally {
                      if (a) throw o;
                    }
                  }
                  return r;
                })(t, e) ||
                (function (t, e) {
                  if (!t) return;
                  if ("string" == typeof t) return n(t, e);
                  var i = Object.prototype.toString.call(t).slice(8, -1);
                  "Object" === i && t.constructor && (i = t.constructor.name);
                  if ("Map" === i || "Set" === i) return Array.from(t);
                  if (
                    "Arguments" === i ||
                    /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)
                  )
                    return n(t, e);
                })(t, e) ||
                (function () {
                  throw new TypeError(
                    "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
                  );
                })()
              );
            }
            function n(t, e) {
              (null == e || e > t.length) && (e = t.length);
              for (var n = 0, i = new Array(e); n < e; n++) i[n] = t[n];
              return i;
            }
            t.exports = function (t) {
              var n = e(t, 4),
                i = n[1],
                o = n[3];
              if (!o) return i;
              if ("function" == typeof btoa) {
                var r = btoa(unescape(encodeURIComponent(JSON.stringify(o)))),
                  s =
                    "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(
                      r
                    ),
                  a = "/*# ".concat(s, " */"),
                  c = o.sources.map(function (t) {
                    return "/*# sourceURL="
                      .concat(o.sourceRoot || "")
                      .concat(t, " */");
                  });
                return [i].concat(c).concat([a]).join("\n");
              }
              return [i].join("\n");
            };
          },
          3379: (t, e, n) => {
            "use strict";
            var i,
              o = function () {
                return (
                  void 0 === i &&
                    (i = Boolean(
                      window && document && document.all && !window.atob
                    )),
                  i
                );
              },
              r = (function () {
                var t = {};
                return function (e) {
                  if (void 0 === t[e]) {
                    var n = document.querySelector(e);
                    if (
                      window.HTMLIFrameElement &&
                      n instanceof window.HTMLIFrameElement
                    )
                      try {
                        n = n.contentDocument.head;
                      } catch (t) {
                        n = null;
                      }
                    t[e] = n;
                  }
                  return t[e];
                };
              })(),
              s = [];
            function a(t) {
              for (var e = -1, n = 0; n < s.length; n++)
                if (s[n].identifier === t) {
                  e = n;
                  break;
                }
              return e;
            }
            function c(t, e) {
              for (var n = {}, i = [], o = 0; o < t.length; o++) {
                var r = t[o],
                  c = e.base ? r[0] + e.base : r[0],
                  l = n[c] || 0,
                  d = "".concat(c, " ").concat(l);
                n[c] = l + 1;
                var h = a(d),
                  u = { css: r[1], media: r[2], sourceMap: r[3] };
                -1 !== h
                  ? (s[h].references++, s[h].updater(u))
                  : s.push({ identifier: d, updater: f(u, e), references: 1 }),
                  i.push(d);
              }
              return i;
            }
            function l(t) {
              var e = document.createElement("style"),
                i = t.attributes || {};
              if (void 0 === i.nonce) {
                var o = n.nc;
                o && (i.nonce = o);
              }
              if (
                (Object.keys(i).forEach(function (t) {
                  e.setAttribute(t, i[t]);
                }),
                "function" == typeof t.insert)
              )
                t.insert(e);
              else {
                var s = r(t.insert || "head");
                if (!s)
                  throw new Error(
                    "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."
                  );
                s.appendChild(e);
              }
              return e;
            }
            var d,
              h =
                ((d = []),
                function (t, e) {
                  return (d[t] = e), d.filter(Boolean).join("\n");
                });
            function u(t, e, n, i) {
              var o = n
                ? ""
                : i.media
                ? "@media ".concat(i.media, " {").concat(i.css, "}")
                : i.css;
              if (t.styleSheet) t.styleSheet.cssText = h(e, o);
              else {
                var r = document.createTextNode(o),
                  s = t.childNodes;
                s[e] && t.removeChild(s[e]),
                  s.length ? t.insertBefore(r, s[e]) : t.appendChild(r);
              }
            }
            function m(t, e, n) {
              var i = n.css,
                o = n.media,
                r = n.sourceMap;
              if (
                (o ? t.setAttribute("media", o) : t.removeAttribute("media"),
                r &&
                  "undefined" != typeof btoa &&
                  (i +=
                    "\n/*# sourceMappingURL=data:application/json;base64,".concat(
                      btoa(unescape(encodeURIComponent(JSON.stringify(r)))),
                      " */"
                    )),
                t.styleSheet)
              )
                t.styleSheet.cssText = i;
              else {
                for (; t.firstChild; ) t.removeChild(t.firstChild);
                t.appendChild(document.createTextNode(i));
              }
            }
            var g = null,
              p = 0;
            function f(t, e) {
              var n, i, o;
              if (e.singleton) {
                var r = p++;
                (n = g || (g = l(e))),
                  (i = u.bind(null, n, r, !1)),
                  (o = u.bind(null, n, r, !0));
              } else
                (n = l(e)),
                  (i = m.bind(null, n, e)),
                  (o = function () {
                    !(function (t) {
                      if (null === t.parentNode) return !1;
                      t.parentNode.removeChild(t);
                    })(n);
                  });
              return (
                i(t),
                function (e) {
                  if (e) {
                    if (
                      e.css === t.css &&
                      e.media === t.media &&
                      e.sourceMap === t.sourceMap
                    )
                      return;
                    i((t = e));
                  } else o();
                }
              );
            }
            t.exports = function (t, e) {
              (e = e || {}).singleton ||
                "boolean" == typeof e.singleton ||
                (e.singleton = o());
              var n = c((t = t || []), e);
              return function (t) {
                if (
                  ((t = t || []),
                  "[object Array]" === Object.prototype.toString.call(t))
                ) {
                  for (var i = 0; i < n.length; i++) {
                    var o = a(n[i]);
                    s[o].references--;
                  }
                  for (var r = c(t, e), l = 0; l < n.length; l++) {
                    var d = a(n[l]);
                    0 === s[d].references && (s[d].updater(), s.splice(d, 1));
                  }
                  n = r;
                }
              };
            };
          },
          1576: () => {},
        },
        e = {};
      function n(i) {
        var o = e[i];
        if (void 0 !== o) return o.exports;
        var r = (e[i] = { id: i, exports: {} });
        return t[i](r, r.exports, n), r.exports;
      }
      (n.n = (t) => {
        var e = t && t.__esModule ? () => t.default : () => t;
        return n.d(e, { a: e }), e;
      }),
        (n.d = (t, e) => {
          for (var i in e)
            n.o(e, i) &&
              !n.o(t, i) &&
              Object.defineProperty(t, i, { enumerable: !0, get: e[i] });
        }),
        (n.g = (function () {
          if ("object" == typeof globalThis) return globalThis;
          try {
            return this || new Function("return this")();
          } catch (t) {
            if ("object" == typeof window) return window;
          }
        })()),
        (n.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e)),
        (n.nc = void 0);
      var i = {};
      return (
        (() => {
          "use strict";
          n.d(i, { default: () => tE });
          const t = function () {
            return function t() {
              t.called = !0;
            };
          };
          class e {
            constructor(e, n) {
              (this.source = e),
                (this.name = n),
                (this.path = []),
                (this.stop = t()),
                (this.off = t());
            }
          }
          const o = new Array(256)
            .fill()
            .map((t, e) => ("0" + e.toString(16)).slice(-2));
          function r() {
            const t = (4294967296 * Math.random()) >>> 0,
              e = (4294967296 * Math.random()) >>> 0,
              n = (4294967296 * Math.random()) >>> 0,
              i = (4294967296 * Math.random()) >>> 0;
            return (
              "e" +
              o[(t >> 0) & 255] +
              o[(t >> 8) & 255] +
              o[(t >> 16) & 255] +
              o[(t >> 24) & 255] +
              o[(e >> 0) & 255] +
              o[(e >> 8) & 255] +
              o[(e >> 16) & 255] +
              o[(e >> 24) & 255] +
              o[(n >> 0) & 255] +
              o[(n >> 8) & 255] +
              o[(n >> 16) & 255] +
              o[(n >> 24) & 255] +
              o[(i >> 0) & 255] +
              o[(i >> 8) & 255] +
              o[(i >> 16) & 255] +
              o[(i >> 24) & 255]
            );
          }
          const s = {
            get(t) {
              return "number" != typeof t ? this[t] || this.normal : t;
            },
            highest: 1e5,
            high: 1e3,
            normal: 0,
            low: -1e3,
            lowest: -1e5,
          };
          function a(t, e) {
            const n = s.get(e.priority);
            for (let i = 0; i < t.length; i++)
              if (s.get(t[i].priority) < n) return void t.splice(i, 0, e);
            t.push(e);
          }
          class c extends Error {
            constructor(t, e, n) {
              super(
                (function (t, e) {
                  const n = new WeakSet(),
                    i = (t, e) => {
                      if ("object" == typeof e && null !== e) {
                        if (n.has(e)) return `[object ${e.constructor.name}]`;
                        n.add(e);
                      }
                      return e;
                    },
                    o = e ? ` ${JSON.stringify(e, i)}` : "",
                    r = d(t);
                  return t + o + r;
                })(t, n)
              ),
                (this.name = "CKEditorError"),
                (this.context = e),
                (this.data = n);
            }
            is(t) {
              return "CKEditorError" === t;
            }
            static rethrowUnexpectedError(t, e) {
              if (t.is && t.is("CKEditorError")) throw t;
              const n = new c(t.message, e);
              throw ((n.stack = t.stack), n);
            }
          }
          function l(t, e) {
            console.warn(...h(t, e));
          }
          function d(t) {
            return `\nRead more: https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html#error-${t}`;
          }
          function h(t, e) {
            const n = d(t);
            return e ? [t, e, n] : [t, n];
          }
          const u = "34.2.0",
            m = "object" == typeof window ? window : n.g;
          if (m.CKEDITOR_VERSION)
            throw new c("ckeditor-duplicated-modules", null);
          m.CKEDITOR_VERSION = u;
          const g = Symbol("listeningTo"),
            p = Symbol("emitterId"),
            f = {
              on(t, e, n = {}) {
                this.listenTo(this, t, e, n);
              },
              once(t, e, n) {
                let i = !1;
                this.listenTo(
                  this,
                  t,
                  function (t, ...n) {
                    i || ((i = !0), t.off(), e.call(this, t, ...n));
                  },
                  n
                );
              },
              off(t, e) {
                this.stopListening(this, t, e);
              },
              listenTo(t, e, n, i = {}) {
                let o, r;
                this[g] || (this[g] = {});
                const s = this[g];
                w(t) || b(t);
                const a = w(t);
                (o = s[a]) || (o = s[a] = { emitter: t, callbacks: {} }),
                  (r = o.callbacks[e]) || (r = o.callbacks[e] = []),
                  r.push(n),
                  (function (t, e, n, i, o) {
                    e._addEventListener
                      ? e._addEventListener(n, i, o)
                      : t._addEventListener.call(e, n, i, o);
                  })(this, t, e, n, i);
              },
              stopListening(t, e, n) {
                const i = this[g];
                let o = t && w(t);
                const r = i && o && i[o],
                  s = r && e && r.callbacks[e];
                if (!(!i || (t && !r) || (e && !s)))
                  if (n) {
                    y(this, t, e, n);
                    -1 !== s.indexOf(n) &&
                      (1 === s.length
                        ? delete r.callbacks[e]
                        : y(this, t, e, n));
                  } else if (s) {
                    for (; (n = s.pop()); ) y(this, t, e, n);
                    delete r.callbacks[e];
                  } else if (r) {
                    for (e in r.callbacks) this.stopListening(t, e);
                    delete i[o];
                  } else {
                    for (o in i) this.stopListening(i[o].emitter);
                    delete this[g];
                  }
              },
              fire(t, ...n) {
                try {
                  const i = t instanceof e ? t : new e(this, t),
                    o = i.name;
                  let r = C(this, o);
                  if ((i.path.push(this), r)) {
                    const t = [i, ...n];
                    r = Array.from(r);
                    for (
                      let e = 0;
                      e < r.length &&
                      (r[e].callback.apply(this, t),
                      i.off.called &&
                        (delete i.off.called,
                        this._removeEventListener(o, r[e].callback)),
                      !i.stop.called);
                      e++
                    );
                  }
                  if (this._delegations) {
                    const t = this._delegations.get(o),
                      e = this._delegations.get("*");
                    t && v(t, i, n), e && v(e, i, n);
                  }
                  return i.return;
                } catch (t) {
                  c.rethrowUnexpectedError(t, this);
                }
              },
              delegate(...t) {
                return {
                  to: (e, n) => {
                    this._delegations || (this._delegations = new Map()),
                      t.forEach((t) => {
                        const i = this._delegations.get(t);
                        i
                          ? i.set(e, n)
                          : this._delegations.set(t, new Map([[e, n]]));
                      });
                  },
                };
              },
              stopDelegating(t, e) {
                if (this._delegations)
                  if (t)
                    if (e) {
                      const n = this._delegations.get(t);
                      n && n.delete(e);
                    } else this._delegations.delete(t);
                  else this._delegations.clear();
              },
              _addEventListener(t, e, n) {
                !(function (t, e) {
                  const n = A(t);
                  if (n[e]) return;
                  let i = e,
                    o = null;
                  const r = [];
                  for (; "" !== i && !n[i]; )
                    (n[i] = { callbacks: [], childEvents: [] }),
                      r.push(n[i]),
                      o && n[i].childEvents.push(o),
                      (o = i),
                      (i = i.substr(0, i.lastIndexOf(":")));
                  if ("" !== i) {
                    for (const t of r) t.callbacks = n[i].callbacks.slice();
                    n[i].childEvents.push(o);
                  }
                })(this, t);
                const i = _(this, t),
                  o = { callback: e, priority: s.get(n.priority) };
                for (const t of i) a(t, o);
              },
              _removeEventListener(t, e) {
                const n = _(this, t);
                for (const t of n)
                  for (let n = 0; n < t.length; n++)
                    t[n].callback == e && (t.splice(n, 1), n--);
              },
            },
            k = f;
          function b(t, e) {
            t[p] || (t[p] = e || r());
          }
          function w(t) {
            return t[p];
          }
          function A(t) {
            return (
              t._events || Object.defineProperty(t, "_events", { value: {} }),
              t._events
            );
          }
          function _(t, e) {
            const n = A(t)[e];
            if (!n) return [];
            let i = [n.callbacks];
            for (let e = 0; e < n.childEvents.length; e++) {
              const o = _(t, n.childEvents[e]);
              i = i.concat(o);
            }
            return i;
          }
          function C(t, e) {
            let n;
            return t._events && (n = t._events[e]) && n.callbacks.length
              ? n.callbacks
              : e.indexOf(":") > -1
              ? C(t, e.substr(0, e.lastIndexOf(":")))
              : null;
          }
          function v(t, n, i) {
            for (let [o, r] of t) {
              r ? "function" == typeof r && (r = r(n.name)) : (r = n.name);
              const t = new e(n.source, r);
              (t.path = [...n.path]), o.fire(t, ...i);
            }
          }
          function y(t, e, n, i) {
            e._removeEventListener
              ? e._removeEventListener(n, i)
              : t._removeEventListener.call(e, n, i);
          }
          const x = function (t) {
            var e = typeof t;
            return null != t && ("object" == e || "function" == e);
          };
          const E =
            "object" == typeof global &&
            global &&
            global.Object === Object &&
            global;
          var D =
            "object" == typeof self && self && self.Object === Object && self;
          const S = E || D || Function("return this")();
          const I = S.Symbol;
          var T = Object.prototype,
            M = T.hasOwnProperty,
            B = T.toString,
            N = I ? I.toStringTag : void 0;
          const z = function (t) {
            var e = M.call(t, N),
              n = t[N];
            try {
              t[N] = void 0;
              var i = !0;
            } catch (t) {}
            var o = B.call(t);
            return i && (e ? (t[N] = n) : delete t[N]), o;
          };
          var P = Object.prototype.toString;
          const L = function (t) {
            return P.call(t);
          };
          var R = I ? I.toStringTag : void 0;
          const O = function (t) {
            return null == t
              ? void 0 === t
                ? "[object Undefined]"
                : "[object Null]"
              : R && R in Object(t)
              ? z(t)
              : L(t);
          };
          const j = function (t) {
            if (!x(t)) return !1;
            var e = O(t);
            return (
              "[object Function]" == e ||
              "[object GeneratorFunction]" == e ||
              "[object AsyncFunction]" == e ||
              "[object Proxy]" == e
            );
          };
          const F = S["__core-js_shared__"];
          var V = (function () {
            var t = /[^.]+$/.exec((F && F.keys && F.keys.IE_PROTO) || "");
            return t ? "Symbol(src)_1." + t : "";
          })();
          const H = function (t) {
            return !!V && V in t;
          };
          var U = Function.prototype.toString;
          const $ = function (t) {
            if (null != t) {
              try {
                return U.call(t);
              } catch (t) {}
              try {
                return t + "";
              } catch (t) {}
            }
            return "";
          };
          var q = /^\[object .+?Constructor\]$/,
            G = Function.prototype,
            W = Object.prototype,
            Y = G.toString,
            K = W.hasOwnProperty,
            Q = RegExp(
              "^" +
                Y.call(K)
                  .replace(/[\\^$.*+?()[\]{}|]/g, "\\$&")
                  .replace(
                    /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                    "$1.*?"
                  ) +
                "$"
            );
          const Z = function (t) {
            return !(!x(t) || H(t)) && (j(t) ? Q : q).test($(t));
          };
          const J = function (t, e) {
            return null == t ? void 0 : t[e];
          };
          const X = function (t, e) {
            var n = J(t, e);
            return Z(n) ? n : void 0;
          };
          const tt = (function () {
            try {
              var t = X(Object, "defineProperty");
              return t({}, "", {}), t;
            } catch (t) {}
          })();
          const et = function (t, e, n) {
            "__proto__" == e && tt
              ? tt(t, e, {
                  configurable: !0,
                  enumerable: !0,
                  value: n,
                  writable: !0,
                })
              : (t[e] = n);
          };
          const nt = function (t, e) {
            return t === e || (t != t && e != e);
          };
          var it = Object.prototype.hasOwnProperty;
          const ot = function (t, e, n) {
            var i = t[e];
            (it.call(t, e) && nt(i, n) && (void 0 !== n || e in t)) ||
              et(t, e, n);
          };
          const rt = function (t, e, n, i) {
            var o = !n;
            n || (n = {});
            for (var r = -1, s = e.length; ++r < s; ) {
              var a = e[r],
                c = i ? i(n[a], t[a], a, n, t) : void 0;
              void 0 === c && (c = t[a]), o ? et(n, a, c) : ot(n, a, c);
            }
            return n;
          };
          const st = function (t) {
            return t;
          };
          const at = function (t, e, n) {
            switch (n.length) {
              case 0:
                return t.call(e);
              case 1:
                return t.call(e, n[0]);
              case 2:
                return t.call(e, n[0], n[1]);
              case 3:
                return t.call(e, n[0], n[1], n[2]);
            }
            return t.apply(e, n);
          };
          var ct = Math.max;
          const lt = function (t, e, n) {
            return (
              (e = ct(void 0 === e ? t.length - 1 : e, 0)),
              function () {
                for (
                  var i = arguments,
                    o = -1,
                    r = ct(i.length - e, 0),
                    s = Array(r);
                  ++o < r;

                )
                  s[o] = i[e + o];
                o = -1;
                for (var a = Array(e + 1); ++o < e; ) a[o] = i[o];
                return (a[e] = n(s)), at(t, this, a);
              }
            );
          };
          const dt = function (t) {
            return function () {
              return t;
            };
          };
          const ht = tt
            ? function (t, e) {
                return tt(t, "toString", {
                  configurable: !0,
                  enumerable: !1,
                  value: dt(e),
                  writable: !0,
                });
              }
            : st;
          var ut = Date.now;
          const mt = function (t) {
            var e = 0,
              n = 0;
            return function () {
              var i = ut(),
                o = 16 - (i - n);
              if (((n = i), o > 0)) {
                if (++e >= 800) return arguments[0];
              } else e = 0;
              return t.apply(void 0, arguments);
            };
          };
          const gt = mt(ht);
          const pt = function (t, e) {
            return gt(lt(t, e, st), t + "");
          };
          const ft = function (t) {
            return (
              "number" == typeof t &&
              t > -1 &&
              t % 1 == 0 &&
              t <= 9007199254740991
            );
          };
          const kt = function (t) {
            return null != t && ft(t.length) && !j(t);
          };
          var bt = /^(?:0|[1-9]\d*)$/;
          const wt = function (t, e) {
            var n = typeof t;
            return (
              !!(e = null == e ? 9007199254740991 : e) &&
              ("number" == n || ("symbol" != n && bt.test(t))) &&
              t > -1 &&
              t % 1 == 0 &&
              t < e
            );
          };
          const At = function (t, e, n) {
            if (!x(n)) return !1;
            var i = typeof e;
            return (
              !!("number" == i
                ? kt(n) && wt(e, n.length)
                : "string" == i && e in n) && nt(n[e], t)
            );
          };
          const _t = function (t) {
            return pt(function (e, n) {
              var i = -1,
                o = n.length,
                r = o > 1 ? n[o - 1] : void 0,
                s = o > 2 ? n[2] : void 0;
              for (
                r = t.length > 3 && "function" == typeof r ? (o--, r) : void 0,
                  s && At(n[0], n[1], s) && ((r = o < 3 ? void 0 : r), (o = 1)),
                  e = Object(e);
                ++i < o;

              ) {
                var a = n[i];
                a && t(e, a, i, r);
              }
              return e;
            });
          };
          const Ct = function (t, e) {
            for (var n = -1, i = Array(t); ++n < t; ) i[n] = e(n);
            return i;
          };
          const vt = function (t) {
            return null != t && "object" == typeof t;
          };
          const yt = function (t) {
            return vt(t) && "[object Arguments]" == O(t);
          };
          var xt = Object.prototype,
            Et = xt.hasOwnProperty,
            Dt = xt.propertyIsEnumerable;
          const St = yt(
            (function () {
              return arguments;
            })()
          )
            ? yt
            : function (t) {
                return vt(t) && Et.call(t, "callee") && !Dt.call(t, "callee");
              };
          const It = Array.isArray;
          const Tt = function () {
            return !1;
          };
          var Mt =
              "object" == typeof exports &&
              exports &&
              !exports.nodeType &&
              exports,
            Bt =
              Mt &&
              "object" == typeof module &&
              module &&
              !module.nodeType &&
              module,
            Nt = Bt && Bt.exports === Mt ? S.Buffer : void 0;
          const zt = (Nt ? Nt.isBuffer : void 0) || Tt;
          var Pt = {};
          (Pt["[object Float32Array]"] =
            Pt["[object Float64Array]"] =
            Pt["[object Int8Array]"] =
            Pt["[object Int16Array]"] =
            Pt["[object Int32Array]"] =
            Pt["[object Uint8Array]"] =
            Pt["[object Uint8ClampedArray]"] =
            Pt["[object Uint16Array]"] =
            Pt["[object Uint32Array]"] =
              !0),
            (Pt["[object Arguments]"] =
              Pt["[object Array]"] =
              Pt["[object ArrayBuffer]"] =
              Pt["[object Boolean]"] =
              Pt["[object DataView]"] =
              Pt["[object Date]"] =
              Pt["[object Error]"] =
              Pt["[object Function]"] =
              Pt["[object Map]"] =
              Pt["[object Number]"] =
              Pt["[object Object]"] =
              Pt["[object RegExp]"] =
              Pt["[object Set]"] =
              Pt["[object String]"] =
              Pt["[object WeakMap]"] =
                !1);
          const Lt = function (t) {
            return vt(t) && ft(t.length) && !!Pt[O(t)];
          };
          const Rt = function (t) {
            return function (e) {
              return t(e);
            };
          };
          var Ot =
              "object" == typeof exports &&
              exports &&
              !exports.nodeType &&
              exports,
            jt =
              Ot &&
              "object" == typeof module &&
              module &&
              !module.nodeType &&
              module,
            Ft = jt && jt.exports === Ot && E.process;
          const Vt = (function () {
            try {
              var t = jt && jt.require && jt.require("util").types;
              return t || (Ft && Ft.binding && Ft.binding("util"));
            } catch (t) {}
          })();
          var Ht = Vt && Vt.isTypedArray;
          const Ut = Ht ? Rt(Ht) : Lt;
          var $t = Object.prototype.hasOwnProperty;
          const qt = function (t, e) {
            var n = It(t),
              i = !n && St(t),
              o = !n && !i && zt(t),
              r = !n && !i && !o && Ut(t),
              s = n || i || o || r,
              a = s ? Ct(t.length, String) : [],
              c = a.length;
            for (var l in t)
              (!e && !$t.call(t, l)) ||
                (s &&
                  ("length" == l ||
                    (o && ("offset" == l || "parent" == l)) ||
                    (r &&
                      ("buffer" == l ||
                        "byteLength" == l ||
                        "byteOffset" == l)) ||
                    wt(l, c))) ||
                a.push(l);
            return a;
          };
          var Gt = Object.prototype;
          const Wt = function (t) {
            var e = t && t.constructor;
            return t === (("function" == typeof e && e.prototype) || Gt);
          };
          const Yt = function (t) {
            var e = [];
            if (null != t) for (var n in Object(t)) e.push(n);
            return e;
          };
          var Kt = Object.prototype.hasOwnProperty;
          const Qt = function (t) {
            if (!x(t)) return Yt(t);
            var e = Wt(t),
              n = [];
            for (var i in t)
              ("constructor" != i || (!e && Kt.call(t, i))) && n.push(i);
            return n;
          };
          const Zt = function (t) {
            return kt(t) ? qt(t, !0) : Qt(t);
          };
          const Jt = _t(function (t, e) {
              rt(e, Zt(e), t);
            }),
            Xt = Symbol("observableProperties"),
            te = Symbol("boundObservables"),
            ee = Symbol("boundProperties"),
            ne = Symbol("decoratedMethods"),
            ie = Symbol("decoratedOriginal"),
            oe = {
              set(t, e) {
                if (x(t))
                  return void Object.keys(t).forEach((e) => {
                    this.set(e, t[e]);
                  }, this);
                se(this);
                const n = this[Xt];
                if (t in this && !n.has(t))
                  throw new c("observable-set-cannot-override", this);
                Object.defineProperty(this, t, {
                  enumerable: !0,
                  configurable: !0,
                  get: () => n.get(t),
                  set(e) {
                    const i = n.get(t);
                    let o = this.fire("set:" + t, t, e, i);
                    void 0 === o && (o = e),
                      (i === o && n.has(t)) ||
                        (n.set(t, o), this.fire("change:" + t, t, o, i));
                  },
                }),
                  (this[t] = e);
              },
              bind(...t) {
                if (!t.length || !le(t))
                  throw new c("observable-bind-wrong-properties", this);
                if (new Set(t).size !== t.length)
                  throw new c("observable-bind-duplicate-properties", this);
                se(this);
                const e = this[ee];
                t.forEach((t) => {
                  if (e.has(t)) throw new c("observable-bind-rebind", this);
                });
                const n = new Map();
                return (
                  t.forEach((t) => {
                    const i = { property: t, to: [] };
                    e.set(t, i), n.set(t, i);
                  }),
                  {
                    to: ae,
                    toMany: ce,
                    _observable: this,
                    _bindProperties: t,
                    _to: [],
                    _bindings: n,
                  }
                );
              },
              unbind(...t) {
                if (!this[Xt]) return;
                const e = this[ee],
                  n = this[te];
                if (t.length) {
                  if (!le(t))
                    throw new c("observable-unbind-wrong-properties", this);
                  t.forEach((t) => {
                    const i = e.get(t);
                    if (!i) return;
                    let o, r, s, a;
                    i.to.forEach((t) => {
                      (o = t[0]),
                        (r = t[1]),
                        (s = n.get(o)),
                        (a = s[r]),
                        a.delete(i),
                        a.size || delete s[r],
                        Object.keys(s).length ||
                          (n.delete(o), this.stopListening(o, "change"));
                    }),
                      e.delete(t);
                  });
                } else
                  n.forEach((t, e) => {
                    this.stopListening(e, "change");
                  }),
                    n.clear(),
                    e.clear();
              },
              decorate(t) {
                const e = this[t];
                if (!e)
                  throw new c(
                    "observablemixin-cannot-decorate-undefined",
                    this,
                    { object: this, methodName: t }
                  );
                this.on(t, (t, n) => {
                  t.return = e.apply(this, n);
                }),
                  (this[t] = function (...e) {
                    return this.fire(t, e);
                  }),
                  (this[t][ie] = e),
                  this[ne] || (this[ne] = []),
                  this[ne].push(t);
              },
            };
          Jt(oe, k),
            (oe.stopListening = function (t, e, n) {
              if (!t && this[ne]) {
                for (const t of this[ne]) this[t] = this[t][ie];
                delete this[ne];
              }
              k.stopListening.call(this, t, e, n);
            });
          const re = oe;
          function se(t) {
            t[Xt] ||
              (Object.defineProperty(t, Xt, { value: new Map() }),
              Object.defineProperty(t, te, { value: new Map() }),
              Object.defineProperty(t, ee, { value: new Map() }));
          }
          function ae(...t) {
            const e = (function (...t) {
                if (!t.length)
                  throw new c("observable-bind-to-parse-error", null);
                const e = { to: [] };
                let n;
                "function" == typeof t[t.length - 1] && (e.callback = t.pop());
                return (
                  t.forEach((t) => {
                    if ("string" == typeof t) n.properties.push(t);
                    else {
                      if ("object" != typeof t)
                        throw new c("observable-bind-to-parse-error", null);
                      (n = { observable: t, properties: [] }), e.to.push(n);
                    }
                  }),
                  e
                );
              })(...t),
              n = Array.from(this._bindings.keys()),
              i = n.length;
            if (!e.callback && e.to.length > 1)
              throw new c("observable-bind-to-no-callback", this);
            if (i > 1 && e.callback)
              throw new c("observable-bind-to-extra-callback", this);
            var o;
            e.to.forEach((t) => {
              if (t.properties.length && t.properties.length !== i)
                throw new c("observable-bind-to-properties-length", this);
              t.properties.length || (t.properties = this._bindProperties);
            }),
              (this._to = e.to),
              e.callback && (this._bindings.get(n[0]).callback = e.callback),
              (o = this._observable),
              this._to.forEach((t) => {
                const e = o[te];
                let n;
                e.get(t.observable) ||
                  o.listenTo(t.observable, "change", (i, r) => {
                    (n = e.get(t.observable)[r]),
                      n &&
                        n.forEach((t) => {
                          de(o, t.property);
                        });
                  });
              }),
              (function (t) {
                let e;
                t._bindings.forEach((n, i) => {
                  t._to.forEach((o) => {
                    (e =
                      o.properties[
                        n.callback ? 0 : t._bindProperties.indexOf(i)
                      ]),
                      n.to.push([o.observable, e]),
                      (function (t, e, n, i) {
                        const o = t[te],
                          r = o.get(n),
                          s = r || {};
                        s[i] || (s[i] = new Set());
                        s[i].add(e), r || o.set(n, s);
                      })(t._observable, n, o.observable, e);
                  });
                });
              })(this),
              this._bindProperties.forEach((t) => {
                de(this._observable, t);
              });
          }
          function ce(t, e, n) {
            if (this._bindings.size > 1)
              throw new c("observable-bind-to-many-not-one-binding", this);
            this.to(
              ...(function (t, e) {
                const n = t.map((t) => [t, e]);
                return Array.prototype.concat.apply([], n);
              })(t, e),
              n
            );
          }
          function le(t) {
            return t.every((t) => "string" == typeof t);
          }
          function de(t, e) {
            const n = t[ee].get(e);
            let i;
            n.callback
              ? (i = n.callback.apply(
                  t,
                  n.to.map((t) => t[0][t[1]])
                ))
              : ((i = n.to[0]), (i = i[0][i[1]])),
              Object.prototype.hasOwnProperty.call(t, e)
                ? (t[e] = i)
                : t.set(e, i);
          }
          function he(t, ...e) {
            e.forEach((e) => {
              Object.getOwnPropertyNames(e)
                .concat(Object.getOwnPropertySymbols(e))
                .forEach((n) => {
                  if (n in t.prototype) return;
                  const i = Object.getOwnPropertyDescriptor(e, n);
                  (i.enumerable = !1), Object.defineProperty(t.prototype, n, i);
                });
            });
          }
          class ue {
            constructor(t) {
              (this.editor = t),
                this.set("isEnabled", !0),
                (this._disableStack = new Set());
            }
            forceDisabled(t) {
              this._disableStack.add(t),
                1 == this._disableStack.size &&
                  (this.on("set:isEnabled", me, { priority: "highest" }),
                  (this.isEnabled = !1));
            }
            clearForceDisabled(t) {
              this._disableStack.delete(t),
                0 == this._disableStack.size &&
                  (this.off("set:isEnabled", me), (this.isEnabled = !0));
            }
            destroy() {
              this.stopListening();
            }
            static get isContextPlugin() {
              return !1;
            }
          }
          function me(t) {
            (t.return = !1), t.stop();
          }
          he(ue, re);
          class ge {
            constructor(t) {
              (this.editor = t),
                this.set("value", void 0),
                this.set("isEnabled", !1),
                (this.affectsData = !0),
                (this._disableStack = new Set()),
                this.decorate("execute"),
                this.listenTo(this.editor.model.document, "change", () => {
                  this.refresh();
                }),
                this.on(
                  "execute",
                  (t) => {
                    this.isEnabled || t.stop();
                  },
                  { priority: "high" }
                ),
                this.listenTo(t, "change:isReadOnly", (t, e, n) => {
                  n && this.affectsData
                    ? this.forceDisabled("readOnlyMode")
                    : this.clearForceDisabled("readOnlyMode");
                });
            }
            refresh() {
              this.isEnabled = !0;
            }
            forceDisabled(t) {
              this._disableStack.add(t),
                1 == this._disableStack.size &&
                  (this.on("set:isEnabled", pe, { priority: "highest" }),
                  (this.isEnabled = !1));
            }
            clearForceDisabled(t) {
              this._disableStack.delete(t),
                0 == this._disableStack.size &&
                  (this.off("set:isEnabled", pe), this.refresh());
            }
            execute() {}
            destroy() {
              this.stopListening();
            }
          }
          function pe(t) {
            (t.return = !1), t.stop();
          }
          he(ge, re);
          class fe extends ge {
            constructor(t) {
              super(t), (this._childCommandsDefinitions = []);
            }
            refresh() {}
            execute(...t) {
              const e = this._getFirstEnabledCommand();
              return !!e && e.execute(t);
            }
            registerChildCommand(t, e = { priority: "normal" }) {
              a(this._childCommandsDefinitions, {
                command: t,
                priority: e.priority,
              }),
                t.on("change:isEnabled", () => this._checkEnabled()),
                this._checkEnabled();
            }
            _checkEnabled() {
              this.isEnabled = !!this._getFirstEnabledCommand();
            }
            _getFirstEnabledCommand() {
              const t = this._childCommandsDefinitions.find(
                ({ command: t }) => t.isEnabled
              );
              return t && t.command;
            }
          }
          const ke = function (t, e) {
            return function (n) {
              return t(e(n));
            };
          };
          const be = ke(Object.getPrototypeOf, Object);
          var we = Function.prototype,
            Ae = Object.prototype,
            _e = we.toString,
            Ce = Ae.hasOwnProperty,
            ve = _e.call(Object);
          const ye = function (t) {
            if (!vt(t) || "[object Object]" != O(t)) return !1;
            var e = be(t);
            if (null === e) return !0;
            var n = Ce.call(e, "constructor") && e.constructor;
            return "function" == typeof n && n instanceof n && _e.call(n) == ve;
          };
          const xe = function () {
            (this.__data__ = []), (this.size = 0);
          };
          const Ee = function (t, e) {
            for (var n = t.length; n--; ) if (nt(t[n][0], e)) return n;
            return -1;
          };
          var De = Array.prototype.splice;
          const Se = function (t) {
            var e = this.__data__,
              n = Ee(e, t);
            return (
              !(n < 0) &&
              (n == e.length - 1 ? e.pop() : De.call(e, n, 1), --this.size, !0)
            );
          };
          const Ie = function (t) {
            var e = this.__data__,
              n = Ee(e, t);
            return n < 0 ? void 0 : e[n][1];
          };
          const Te = function (t) {
            return Ee(this.__data__, t) > -1;
          };
          const Me = function (t, e) {
            var n = this.__data__,
              i = Ee(n, t);
            return i < 0 ? (++this.size, n.push([t, e])) : (n[i][1] = e), this;
          };
          function Be(t) {
            var e = -1,
              n = null == t ? 0 : t.length;
            for (this.clear(); ++e < n; ) {
              var i = t[e];
              this.set(i[0], i[1]);
            }
          }
          (Be.prototype.clear = xe),
            (Be.prototype.delete = Se),
            (Be.prototype.get = Ie),
            (Be.prototype.has = Te),
            (Be.prototype.set = Me);
          const Ne = Be;
          const ze = function () {
            (this.__data__ = new Ne()), (this.size = 0);
          };
          const Pe = function (t) {
            var e = this.__data__,
              n = e.delete(t);
            return (this.size = e.size), n;
          };
          const Le = function (t) {
            return this.__data__.get(t);
          };
          const Re = function (t) {
            return this.__data__.has(t);
          };
          const Oe = X(S, "Map");
          const je = X(Object, "create");
          const Fe = function () {
            (this.__data__ = je ? je(null) : {}), (this.size = 0);
          };
          const Ve = function (t) {
            var e = this.has(t) && delete this.__data__[t];
            return (this.size -= e ? 1 : 0), e;
          };
          var He = Object.prototype.hasOwnProperty;
          const Ue = function (t) {
            var e = this.__data__;
            if (je) {
              var n = e[t];
              return "__lodash_hash_undefined__" === n ? void 0 : n;
            }
            return He.call(e, t) ? e[t] : void 0;
          };
          var $e = Object.prototype.hasOwnProperty;
          const qe = function (t) {
            var e = this.__data__;
            return je ? void 0 !== e[t] : $e.call(e, t);
          };
          const Ge = function (t, e) {
            var n = this.__data__;
            return (
              (this.size += this.has(t) ? 0 : 1),
              (n[t] = je && void 0 === e ? "__lodash_hash_undefined__" : e),
              this
            );
          };
          function We(t) {
            var e = -1,
              n = null == t ? 0 : t.length;
            for (this.clear(); ++e < n; ) {
              var i = t[e];
              this.set(i[0], i[1]);
            }
          }
          (We.prototype.clear = Fe),
            (We.prototype.delete = Ve),
            (We.prototype.get = Ue),
            (We.prototype.has = qe),
            (We.prototype.set = Ge);
          const Ye = We;
          const Ke = function () {
            (this.size = 0),
              (this.__data__ = {
                hash: new Ye(),
                map: new (Oe || Ne)(),
                string: new Ye(),
              });
          };
          const Qe = function (t) {
            var e = typeof t;
            return "string" == e ||
              "number" == e ||
              "symbol" == e ||
              "boolean" == e
              ? "__proto__" !== t
              : null === t;
          };
          const Ze = function (t, e) {
            var n = t.__data__;
            return Qe(e) ? n["string" == typeof e ? "string" : "hash"] : n.map;
          };
          const Je = function (t) {
            var e = Ze(this, t).delete(t);
            return (this.size -= e ? 1 : 0), e;
          };
          const Xe = function (t) {
            return Ze(this, t).get(t);
          };
          const tn = function (t) {
            return Ze(this, t).has(t);
          };
          const en = function (t, e) {
            var n = Ze(this, t),
              i = n.size;
            return n.set(t, e), (this.size += n.size == i ? 0 : 1), this;
          };
          function nn(t) {
            var e = -1,
              n = null == t ? 0 : t.length;
            for (this.clear(); ++e < n; ) {
              var i = t[e];
              this.set(i[0], i[1]);
            }
          }
          (nn.prototype.clear = Ke),
            (nn.prototype.delete = Je),
            (nn.prototype.get = Xe),
            (nn.prototype.has = tn),
            (nn.prototype.set = en);
          const on = nn;
          const rn = function (t, e) {
            var n = this.__data__;
            if (n instanceof Ne) {
              var i = n.__data__;
              if (!Oe || i.length < 199)
                return i.push([t, e]), (this.size = ++n.size), this;
              n = this.__data__ = new on(i);
            }
            return n.set(t, e), (this.size = n.size), this;
          };
          function sn(t) {
            var e = (this.__data__ = new Ne(t));
            this.size = e.size;
          }
          (sn.prototype.clear = ze),
            (sn.prototype.delete = Pe),
            (sn.prototype.get = Le),
            (sn.prototype.has = Re),
            (sn.prototype.set = rn);
          const an = sn;
          const cn = function (t, e) {
            for (
              var n = -1, i = null == t ? 0 : t.length;
              ++n < i && !1 !== e(t[n], n, t);

            );
            return t;
          };
          const ln = ke(Object.keys, Object);
          var dn = Object.prototype.hasOwnProperty;
          const hn = function (t) {
            if (!Wt(t)) return ln(t);
            var e = [];
            for (var n in Object(t))
              dn.call(t, n) && "constructor" != n && e.push(n);
            return e;
          };
          const un = function (t) {
            return kt(t) ? qt(t) : hn(t);
          };
          const mn = function (t, e) {
            return t && rt(e, un(e), t);
          };
          const gn = function (t, e) {
            return t && rt(e, Zt(e), t);
          };
          var pn =
              "object" == typeof exports &&
              exports &&
              !exports.nodeType &&
              exports,
            fn =
              pn &&
              "object" == typeof module &&
              module &&
              !module.nodeType &&
              module,
            kn = fn && fn.exports === pn ? S.Buffer : void 0,
            bn = kn ? kn.allocUnsafe : void 0;
          const wn = function (t, e) {
            if (e) return t.slice();
            var n = t.length,
              i = bn ? bn(n) : new t.constructor(n);
            return t.copy(i), i;
          };
          const An = function (t, e) {
            var n = -1,
              i = t.length;
            for (e || (e = Array(i)); ++n < i; ) e[n] = t[n];
            return e;
          };
          const _n = function (t, e) {
            for (
              var n = -1, i = null == t ? 0 : t.length, o = 0, r = [];
              ++n < i;

            ) {
              var s = t[n];
              e(s, n, t) && (r[o++] = s);
            }
            return r;
          };
          const Cn = function () {
            return [];
          };
          var vn = Object.prototype.propertyIsEnumerable,
            yn = Object.getOwnPropertySymbols;
          const xn = yn
            ? function (t) {
                return null == t
                  ? []
                  : ((t = Object(t)),
                    _n(yn(t), function (e) {
                      return vn.call(t, e);
                    }));
              }
            : Cn;
          const En = function (t, e) {
            return rt(t, xn(t), e);
          };
          const Dn = function (t, e) {
            for (var n = -1, i = e.length, o = t.length; ++n < i; )
              t[o + n] = e[n];
            return t;
          };
          const Sn = Object.getOwnPropertySymbols
            ? function (t) {
                for (var e = []; t; ) Dn(e, xn(t)), (t = be(t));
                return e;
              }
            : Cn;
          const In = function (t, e) {
            return rt(t, Sn(t), e);
          };
          const Tn = function (t, e, n) {
            var i = e(t);
            return It(t) ? i : Dn(i, n(t));
          };
          const Mn = function (t) {
            return Tn(t, un, xn);
          };
          const Bn = function (t) {
            return Tn(t, Zt, Sn);
          };
          const Nn = X(S, "DataView");
          const zn = X(S, "Promise");
          const Pn = X(S, "Set");
          const Ln = X(S, "WeakMap");
          var Rn = "[object Map]",
            On = "[object Promise]",
            jn = "[object Set]",
            Fn = "[object WeakMap]",
            Vn = "[object DataView]",
            Hn = $(Nn),
            Un = $(Oe),
            $n = $(zn),
            qn = $(Pn),
            Gn = $(Ln),
            Wn = O;
          ((Nn && Wn(new Nn(new ArrayBuffer(1))) != Vn) ||
            (Oe && Wn(new Oe()) != Rn) ||
            (zn && Wn(zn.resolve()) != On) ||
            (Pn && Wn(new Pn()) != jn) ||
            (Ln && Wn(new Ln()) != Fn)) &&
            (Wn = function (t) {
              var e = O(t),
                n = "[object Object]" == e ? t.constructor : void 0,
                i = n ? $(n) : "";
              if (i)
                switch (i) {
                  case Hn:
                    return Vn;
                  case Un:
                    return Rn;
                  case $n:
                    return On;
                  case qn:
                    return jn;
                  case Gn:
                    return Fn;
                }
              return e;
            });
          const Yn = Wn;
          var Kn = Object.prototype.hasOwnProperty;
          const Qn = function (t) {
            var e = t.length,
              n = new t.constructor(e);
            return (
              e &&
                "string" == typeof t[0] &&
                Kn.call(t, "index") &&
                ((n.index = t.index), (n.input = t.input)),
              n
            );
          };
          const Zn = S.Uint8Array;
          const Jn = function (t) {
            var e = new t.constructor(t.byteLength);
            return new Zn(e).set(new Zn(t)), e;
          };
          const Xn = function (t, e) {
            var n = e ? Jn(t.buffer) : t.buffer;
            return new t.constructor(n, t.byteOffset, t.byteLength);
          };
          var ti = /\w*$/;
          const ei = function (t) {
            var e = new t.constructor(t.source, ti.exec(t));
            return (e.lastIndex = t.lastIndex), e;
          };
          var ni = I ? I.prototype : void 0,
            ii = ni ? ni.valueOf : void 0;
          const oi = function (t) {
            return ii ? Object(ii.call(t)) : {};
          };
          const ri = function (t, e) {
            var n = e ? Jn(t.buffer) : t.buffer;
            return new t.constructor(n, t.byteOffset, t.length);
          };
          const si = function (t, e, n) {
            var i = t.constructor;
            switch (e) {
              case "[object ArrayBuffer]":
                return Jn(t);
              case "[object Boolean]":
              case "[object Date]":
                return new i(+t);
              case "[object DataView]":
                return Xn(t, n);
              case "[object Float32Array]":
              case "[object Float64Array]":
              case "[object Int8Array]":
              case "[object Int16Array]":
              case "[object Int32Array]":
              case "[object Uint8Array]":
              case "[object Uint8ClampedArray]":
              case "[object Uint16Array]":
              case "[object Uint32Array]":
                return ri(t, n);
              case "[object Map]":
              case "[object Set]":
                return new i();
              case "[object Number]":
              case "[object String]":
                return new i(t);
              case "[object RegExp]":
                return ei(t);
              case "[object Symbol]":
                return oi(t);
            }
          };
          var ai = Object.create;
          const ci = (function () {
            function t() {}
            return function (e) {
              if (!x(e)) return {};
              if (ai) return ai(e);
              t.prototype = e;
              var n = new t();
              return (t.prototype = void 0), n;
            };
          })();
          const li = function (t) {
            return "function" != typeof t.constructor || Wt(t) ? {} : ci(be(t));
          };
          const di = function (t) {
            return vt(t) && "[object Map]" == Yn(t);
          };
          var hi = Vt && Vt.isMap;
          const ui = hi ? Rt(hi) : di;
          const mi = function (t) {
            return vt(t) && "[object Set]" == Yn(t);
          };
          var gi = Vt && Vt.isSet;
          const pi = gi ? Rt(gi) : mi;
          var fi = "[object Arguments]",
            ki = "[object Function]",
            bi = "[object Object]",
            wi = {};
          (wi[fi] =
            wi["[object Array]"] =
            wi["[object ArrayBuffer]"] =
            wi["[object DataView]"] =
            wi["[object Boolean]"] =
            wi["[object Date]"] =
            wi["[object Float32Array]"] =
            wi["[object Float64Array]"] =
            wi["[object Int8Array]"] =
            wi["[object Int16Array]"] =
            wi["[object Int32Array]"] =
            wi["[object Map]"] =
            wi["[object Number]"] =
            wi["[object Object]"] =
            wi["[object RegExp]"] =
            wi["[object Set]"] =
            wi["[object String]"] =
            wi["[object Symbol]"] =
            wi["[object Uint8Array]"] =
            wi["[object Uint8ClampedArray]"] =
            wi["[object Uint16Array]"] =
            wi["[object Uint32Array]"] =
              !0),
            (wi["[object Error]"] = wi[ki] = wi["[object WeakMap]"] = !1);
          const Ai = function t(e, n, i, o, r, s) {
            var a,
              c = 1 & n,
              l = 2 & n,
              d = 4 & n;
            if ((i && (a = r ? i(e, o, r, s) : i(e)), void 0 !== a)) return a;
            if (!x(e)) return e;
            var h = It(e);
            if (h) {
              if (((a = Qn(e)), !c)) return An(e, a);
            } else {
              var u = Yn(e),
                m = u == ki || "[object GeneratorFunction]" == u;
              if (zt(e)) return wn(e, c);
              if (u == bi || u == fi || (m && !r)) {
                if (((a = l || m ? {} : li(e)), !c))
                  return l ? In(e, gn(a, e)) : En(e, mn(a, e));
              } else {
                if (!wi[u]) return r ? e : {};
                a = si(e, u, c);
              }
            }
            s || (s = new an());
            var g = s.get(e);
            if (g) return g;
            s.set(e, a),
              pi(e)
                ? e.forEach(function (o) {
                    a.add(t(o, n, i, o, e, s));
                  })
                : ui(e) &&
                  e.forEach(function (o, r) {
                    a.set(r, t(o, n, i, r, e, s));
                  });
            var p = h ? void 0 : (d ? (l ? Bn : Mn) : l ? Zt : un)(e);
            return (
              cn(p || e, function (o, r) {
                p && (o = e[(r = o)]), ot(a, r, t(o, n, i, r, e, s));
              }),
              a
            );
          };
          const _i = function (t, e) {
            return Ai(t, 5, (e = "function" == typeof e ? e : void 0));
          };
          const Ci = function (t) {
            return vt(t) && 1 === t.nodeType && !ye(t);
          };
          class vi {
            constructor(t, e) {
              (this._config = {}),
                e && this.define(yi(e)),
                t && this._setObjectToTarget(this._config, t);
            }
            set(t, e) {
              this._setToTarget(this._config, t, e);
            }
            define(t, e) {
              this._setToTarget(this._config, t, e, !0);
            }
            get(t) {
              return this._getFromSource(this._config, t);
            }
            *names() {
              for (const t of Object.keys(this._config)) yield t;
            }
            _setToTarget(t, e, n, i = !1) {
              if (ye(e)) return void this._setObjectToTarget(t, e, i);
              const o = e.split(".");
              e = o.pop();
              for (const e of o) ye(t[e]) || (t[e] = {}), (t = t[e]);
              if (ye(n))
                return (
                  ye(t[e]) || (t[e] = {}),
                  (t = t[e]),
                  void this._setObjectToTarget(t, n, i)
                );
              (i && void 0 !== t[e]) || (t[e] = n);
            }
            _getFromSource(t, e) {
              const n = e.split(".");
              e = n.pop();
              for (const e of n) {
                if (!ye(t[e])) {
                  t = null;
                  break;
                }
                t = t[e];
              }
              return t ? yi(t[e]) : void 0;
            }
            _setObjectToTarget(t, e, n) {
              Object.keys(e).forEach((i) => {
                this._setToTarget(t, i, e[i], n);
              });
            }
          }
          function yi(t) {
            return _i(t, xi);
          }
          function xi(t) {
            return Ci(t) ? t : void 0;
          }
          function Ei(t) {
            return !(!t || !t[Symbol.iterator]);
          }
          class Di {
            constructor(t = {}, e = {}) {
              const n = Ei(t);
              if (
                (n || (e = t),
                (this._items = []),
                (this._itemMap = new Map()),
                (this._idProperty = e.idProperty || "id"),
                (this._bindToExternalToInternalMap = new WeakMap()),
                (this._bindToInternalToExternalMap = new WeakMap()),
                (this._skippedIndexesFromExternal = []),
                n)
              )
                for (const e of t)
                  this._items.push(e),
                    this._itemMap.set(this._getItemIdBeforeAdding(e), e);
            }
            get length() {
              return this._items.length;
            }
            get first() {
              return this._items[0] || null;
            }
            get last() {
              return this._items[this.length - 1] || null;
            }
            add(t, e) {
              return this.addMany([t], e);
            }
            addMany(t, e) {
              if (void 0 === e) e = this._items.length;
              else if (e > this._items.length || e < 0)
                throw new c("collection-add-item-invalid-index", this);
              for (let n = 0; n < t.length; n++) {
                const i = t[n],
                  o = this._getItemIdBeforeAdding(i),
                  r = e + n;
                this._items.splice(r, 0, i),
                  this._itemMap.set(o, i),
                  this.fire("add", i, r);
              }
              return (
                this.fire("change", { added: t, removed: [], index: e }), this
              );
            }
            get(t) {
              let e;
              if ("string" == typeof t) e = this._itemMap.get(t);
              else {
                if ("number" != typeof t)
                  throw new c("collection-get-invalid-arg", this);
                e = this._items[t];
              }
              return e || null;
            }
            has(t) {
              if ("string" == typeof t) return this._itemMap.has(t);
              {
                const e = t[this._idProperty];
                return this._itemMap.has(e);
              }
            }
            getIndex(t) {
              let e;
              return (
                (e = "string" == typeof t ? this._itemMap.get(t) : t),
                this._items.indexOf(e)
              );
            }
            remove(t) {
              const [e, n] = this._remove(t);
              return (
                this.fire("change", { added: [], removed: [e], index: n }), e
              );
            }
            map(t, e) {
              return this._items.map(t, e);
            }
            find(t, e) {
              return this._items.find(t, e);
            }
            filter(t, e) {
              return this._items.filter(t, e);
            }
            clear() {
              this._bindToCollection &&
                (this.stopListening(this._bindToCollection),
                (this._bindToCollection = null));
              const t = Array.from(this._items);
              for (; this.length; ) this._remove(0);
              this.fire("change", { added: [], removed: t, index: 0 });
            }
            bindTo(t) {
              if (this._bindToCollection)
                throw new c("collection-bind-to-rebind", this);
              return (
                (this._bindToCollection = t),
                {
                  as: (t) => {
                    this._setUpBindToBinding((e) => new t(e));
                  },
                  using: (t) => {
                    "function" == typeof t
                      ? this._setUpBindToBinding((e) => t(e))
                      : this._setUpBindToBinding((e) => e[t]);
                  },
                }
              );
            }
            _setUpBindToBinding(t) {
              const e = this._bindToCollection,
                n = (n, i, o) => {
                  const r = e._bindToCollection == this,
                    s = e._bindToInternalToExternalMap.get(i);
                  if (r && s)
                    this._bindToExternalToInternalMap.set(i, s),
                      this._bindToInternalToExternalMap.set(s, i);
                  else {
                    const n = t(i);
                    if (!n)
                      return void this._skippedIndexesFromExternal.push(o);
                    let r = o;
                    for (const t of this._skippedIndexesFromExternal)
                      o > t && r--;
                    for (const t of e._skippedIndexesFromExternal)
                      r >= t && r++;
                    this._bindToExternalToInternalMap.set(i, n),
                      this._bindToInternalToExternalMap.set(n, i),
                      this.add(n, r);
                    for (
                      let t = 0;
                      t < e._skippedIndexesFromExternal.length;
                      t++
                    )
                      r <= e._skippedIndexesFromExternal[t] &&
                        e._skippedIndexesFromExternal[t]++;
                  }
                };
              for (const t of e) n(0, t, e.getIndex(t));
              this.listenTo(e, "add", n),
                this.listenTo(e, "remove", (t, e, n) => {
                  const i = this._bindToExternalToInternalMap.get(e);
                  i && this.remove(i),
                    (this._skippedIndexesFromExternal =
                      this._skippedIndexesFromExternal.reduce(
                        (t, e) => (
                          n < e && t.push(e - 1), n > e && t.push(e), t
                        ),
                        []
                      ));
                });
            }
            _getItemIdBeforeAdding(t) {
              const e = this._idProperty;
              let n;
              if (e in t) {
                if (((n = t[e]), "string" != typeof n))
                  throw new c("collection-add-invalid-id", this);
                if (this.get(n))
                  throw new c("collection-add-item-already-exists", this);
              } else t[e] = n = r();
              return n;
            }
            _remove(t) {
              let e,
                n,
                i,
                o = !1;
              const r = this._idProperty;
              if (
                ("string" == typeof t
                  ? ((n = t),
                    (i = this._itemMap.get(n)),
                    (o = !i),
                    i && (e = this._items.indexOf(i)))
                  : "number" == typeof t
                  ? ((e = t), (i = this._items[e]), (o = !i), i && (n = i[r]))
                  : ((i = t),
                    (n = i[r]),
                    (e = this._items.indexOf(i)),
                    (o = -1 == e || !this._itemMap.get(n))),
                o)
              )
                throw new c("collection-remove-404", this);
              this._items.splice(e, 1), this._itemMap.delete(n);
              const s = this._bindToInternalToExternalMap.get(i);
              return (
                this._bindToInternalToExternalMap.delete(i),
                this._bindToExternalToInternalMap.delete(s),
                this.fire("remove", i, e),
                [i, e]
              );
            }
            [Symbol.iterator]() {
              return this._items[Symbol.iterator]();
            }
          }
          he(Di, k);
          class Si {
            constructor(t, e = [], n = []) {
              (this._context = t),
                (this._plugins = new Map()),
                (this._availablePlugins = new Map());
              for (const t of e)
                t.pluginName && this._availablePlugins.set(t.pluginName, t);
              this._contextPlugins = new Map();
              for (const [t, e] of n)
                this._contextPlugins.set(t, e),
                  this._contextPlugins.set(e, t),
                  t.pluginName && this._availablePlugins.set(t.pluginName, t);
            }
            *[Symbol.iterator]() {
              for (const t of this._plugins)
                "function" == typeof t[0] && (yield t);
            }
            get(t) {
              const e = this._plugins.get(t);
              if (!e) {
                let e = t;
                throw (
                  ("function" == typeof t && (e = t.pluginName || t.name),
                  new c("plugincollection-plugin-not-loaded", this._context, {
                    plugin: e,
                  }))
                );
              }
              return e;
            }
            has(t) {
              return this._plugins.has(t);
            }
            init(t, e = [], n = []) {
              const i = this,
                o = this._context;
              !(function t(e, n = new Set()) {
                e.forEach((e) => {
                  a(e) &&
                    (n.has(e) ||
                      (n.add(e),
                      e.pluginName &&
                        !i._availablePlugins.has(e.pluginName) &&
                        i._availablePlugins.set(e.pluginName, e),
                      e.requires && t(e.requires, n)));
                });
              })(t),
                u(t);
              const r = [
                ...(function t(e, n = new Set()) {
                  return e
                    .map((t) => (a(t) ? t : i._availablePlugins.get(t)))
                    .reduce(
                      (e, i) =>
                        n.has(i)
                          ? e
                          : (n.add(i),
                            i.requires &&
                              (u(i.requires, i),
                              t(i.requires, n).forEach((t) => e.add(t))),
                            e.add(i)),
                      new Set()
                    );
                })(t.filter((t) => !d(t, e))),
              ];
              !(function (t, e) {
                for (const n of e) {
                  if ("function" != typeof n)
                    throw new c(
                      "plugincollection-replace-plugin-invalid-type",
                      null,
                      { pluginItem: n }
                    );
                  const e = n.pluginName;
                  if (!e)
                    throw new c(
                      "plugincollection-replace-plugin-missing-name",
                      null,
                      { pluginItem: n }
                    );
                  if (n.requires && n.requires.length)
                    throw new c(
                      "plugincollection-plugin-for-replacing-cannot-have-dependencies",
                      null,
                      { pluginName: e }
                    );
                  const o = i._availablePlugins.get(e);
                  if (!o)
                    throw new c(
                      "plugincollection-plugin-for-replacing-not-exist",
                      null,
                      { pluginName: e }
                    );
                  const r = t.indexOf(o);
                  if (-1 === r) {
                    if (i._contextPlugins.has(o)) return;
                    throw new c(
                      "plugincollection-plugin-for-replacing-not-loaded",
                      null,
                      { pluginName: e }
                    );
                  }
                  if (o.requires && o.requires.length)
                    throw new c(
                      "plugincollection-replaced-plugin-cannot-have-dependencies",
                      null,
                      { pluginName: e }
                    );
                  t.splice(r, 1, n), i._availablePlugins.set(e, n);
                }
              })(r, n);
              const s = (function (t) {
                return t.map((t) => {
                  const e = i._contextPlugins.get(t) || new t(o);
                  return i._add(t, e), e;
                });
              })(r);
              return m(s, "init")
                .then(() => m(s, "afterInit"))
                .then(() => s);
              function a(t) {
                return "function" == typeof t;
              }
              function l(t) {
                return a(t) && t.isContextPlugin;
              }
              function d(t, e) {
                return e.some((e) => e === t || h(t) === e || h(e) === t);
              }
              function h(t) {
                return a(t) ? t.pluginName || t.name : t;
              }
              function u(t, n = null) {
                t.map((t) =>
                  a(t) ? t : i._availablePlugins.get(t) || t
                ).forEach((t) => {
                  !(function (t, e) {
                    if (a(t)) return;
                    if (e)
                      throw new c("plugincollection-soft-required", o, {
                        missingPlugin: t,
                        requiredBy: h(e),
                      });
                    throw new c("plugincollection-plugin-not-found", o, {
                      plugin: t,
                    });
                  })(t, n),
                    (function (t, e) {
                      if (!l(e)) return;
                      if (l(t)) return;
                      throw new c("plugincollection-context-required", o, {
                        plugin: h(t),
                        requiredBy: h(e),
                      });
                    })(t, n),
                    (function (t, n) {
                      if (!n) return;
                      if (!d(t, e)) return;
                      throw new c("plugincollection-required", o, {
                        plugin: h(t),
                        requiredBy: h(n),
                      });
                    })(t, n);
                });
              }
              function m(t, e) {
                return t.reduce(
                  (t, n) =>
                    n[e]
                      ? i._contextPlugins.has(n)
                        ? t
                        : t.then(n[e].bind(n))
                      : t,
                  Promise.resolve()
                );
              }
            }
            destroy() {
              const t = [];
              for (const [, e] of this)
                "function" != typeof e.destroy ||
                  this._contextPlugins.has(e) ||
                  t.push(e.destroy());
              return Promise.all(t);
            }
            _add(t, e) {
              this._plugins.set(t, e);
              const n = t.pluginName;
              if (n) {
                if (this._plugins.has(n))
                  throw new c("plugincollection-plugin-name-conflict", null, {
                    pluginName: n,
                    plugin1: this._plugins.get(n).constructor,
                    plugin2: t,
                  });
                this._plugins.set(n, e);
              }
            }
          }
          function Ii(t) {
            return Array.isArray(t) ? t : [t];
          }
          function Ti(t, e, n = 1) {
            if ("number" != typeof n)
              throw new c("translation-service-quantity-not-a-number", null, {
                quantity: n,
              });
            const i = Object.keys(window.CKEDITOR_TRANSLATIONS).length;
            1 === i && (t = Object.keys(window.CKEDITOR_TRANSLATIONS)[0]);
            const o = e.id || e.string;
            if (
              0 === i ||
              !(function (t, e) {
                return (
                  !!window.CKEDITOR_TRANSLATIONS[t] &&
                  !!window.CKEDITOR_TRANSLATIONS[t].dictionary[e]
                );
              })(t, o)
            )
              return 1 !== n ? e.plural : e.string;
            const r = window.CKEDITOR_TRANSLATIONS[t].dictionary,
              s =
                window.CKEDITOR_TRANSLATIONS[t].getPluralForm ||
                ((t) => (1 === t ? 0 : 1));
            if ("string" == typeof r[o]) return r[o];
            const a = Number(s(n));
            return r[o][a];
          }
          he(Si, k),
            window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {});
          const Mi = [
            "ar",
            "ara",
            "fa",
            "per",
            "fas",
            "he",
            "heb",
            "ku",
            "kur",
            "ug",
            "uig",
          ];
          function Bi(t) {
            return Mi.includes(t) ? "rtl" : "ltr";
          }
          class Ni {
            constructor(t = {}) {
              (this.uiLanguage = t.uiLanguage || "en"),
                (this.contentLanguage = t.contentLanguage || this.uiLanguage),
                (this.uiLanguageDirection = Bi(this.uiLanguage)),
                (this.contentLanguageDirection = Bi(this.contentLanguage)),
                (this.t = (t, e) => this._t(t, e));
            }
            get language() {
              return (
                console.warn(
                  "locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead."
                ),
                this.uiLanguage
              );
            }
            _t(t, e = []) {
              (e = Ii(e)), "string" == typeof t && (t = { string: t });
              const n = !!t.plural ? e[0] : 1;
              return (function (t, e) {
                return t.replace(/%(\d+)/g, (t, n) =>
                  n < e.length ? e[n] : t
                );
              })(Ti(this.uiLanguage, t, n), e);
            }
          }
          class zi {
            constructor(t) {
              this.config = new vi(t, this.constructor.defaultConfig);
              const e = this.constructor.builtinPlugins;
              this.config.define("plugins", e),
                (this.plugins = new Si(this, e));
              const n = this.config.get("language") || {};
              (this.locale = new Ni({
                uiLanguage: "string" == typeof n ? n : n.ui,
                contentLanguage: this.config.get("language.content"),
              })),
                (this.t = this.locale.t),
                (this.editors = new Di()),
                (this._contextOwner = null);
            }
            initPlugins() {
              const t = this.config.get("plugins") || [],
                e = this.config.get("substitutePlugins") || [];
              for (const n of t.concat(e)) {
                if ("function" != typeof n)
                  throw new c("context-initplugins-constructor-only", null, {
                    Plugin: n,
                  });
                if (!0 !== n.isContextPlugin)
                  throw new c("context-initplugins-invalid-plugin", null, {
                    Plugin: n,
                  });
              }
              return this.plugins.init(t, [], e);
            }
            destroy() {
              return Promise.all(
                Array.from(this.editors, (t) => t.destroy())
              ).then(() => this.plugins.destroy());
            }
            _addEditor(t, e) {
              if (this._contextOwner)
                throw new c("context-addeditor-private-context");
              this.editors.add(t), e && (this._contextOwner = t);
            }
            _removeEditor(t) {
              return (
                this.editors.has(t) && this.editors.remove(t),
                this._contextOwner === t ? this.destroy() : Promise.resolve()
              );
            }
            _getEditorConfig() {
              const t = {};
              for (const e of this.config.names())
                ["plugins", "removePlugins", "extraPlugins"].includes(e) ||
                  (t[e] = this.config.get(e));
              return t;
            }
            static create(t) {
              return new Promise((e) => {
                const n = new this(t);
                e(n.initPlugins().then(() => n));
              });
            }
          }
          class Pi {
            constructor(t) {
              this.context = t;
            }
            destroy() {
              this.stopListening();
            }
            static get isContextPlugin() {
              return !0;
            }
          }
          function Li(t, e) {
            const n = Math.min(t.length, e.length);
            for (let i = 0; i < n; i++) if (t[i] != e[i]) return i;
            return t.length == e.length
              ? "same"
              : t.length < e.length
              ? "prefix"
              : "extension";
          }
          he(Pi, re);
          const Ri = function (t) {
            return Ai(t, 4);
          };
          class Oi {
            constructor(t) {
              (this.document = t), (this.parent = null);
            }
            get index() {
              let t;
              if (!this.parent) return null;
              if (-1 == (t = this.parent.getChildIndex(this)))
                throw new c("view-node-not-found-in-parent", this);
              return t;
            }
            get nextSibling() {
              const t = this.index;
              return (null !== t && this.parent.getChild(t + 1)) || null;
            }
            get previousSibling() {
              const t = this.index;
              return (null !== t && this.parent.getChild(t - 1)) || null;
            }
            get root() {
              let t = this;
              for (; t.parent; ) t = t.parent;
              return t;
            }
            isAttached() {
              return this.root.is("rootElement");
            }
            getPath() {
              const t = [];
              let e = this;
              for (; e.parent; ) t.unshift(e.index), (e = e.parent);
              return t;
            }
            getAncestors(t = { includeSelf: !1, parentFirst: !1 }) {
              const e = [];
              let n = t.includeSelf ? this : this.parent;
              for (; n; )
                e[t.parentFirst ? "push" : "unshift"](n), (n = n.parent);
              return e;
            }
            getCommonAncestor(t, e = {}) {
              const n = this.getAncestors(e),
                i = t.getAncestors(e);
              let o = 0;
              for (; n[o] == i[o] && n[o]; ) o++;
              return 0 === o ? null : n[o - 1];
            }
            isBefore(t) {
              if (this == t) return !1;
              if (this.root !== t.root) return !1;
              const e = this.getPath(),
                n = t.getPath(),
                i = Li(e, n);
              switch (i) {
                case "prefix":
                  return !0;
                case "extension":
                  return !1;
                default:
                  return e[i] < n[i];
              }
            }
            isAfter(t) {
              return this != t && this.root === t.root && !this.isBefore(t);
            }
            _remove() {
              this.parent._removeChildren(this.index);
            }
            _fireChange(t, e) {
              this.fire("change:" + t, e),
                this.parent && this.parent._fireChange(t, e);
            }
            toJSON() {
              const t = Ri(this);
              return delete t.parent, t;
            }
            is(t) {
              return "node" === t || "view:node" === t;
            }
          }
          he(Oi, k);
          class ji extends Oi {
            constructor(t, e) {
              super(t), (this._textData = e);
            }
            is(t) {
              return (
                "$text" === t ||
                "view:$text" === t ||
                "text" === t ||
                "view:text" === t ||
                "node" === t ||
                "view:node" === t
              );
            }
            get data() {
              return this._textData;
            }
            get _data() {
              return this.data;
            }
            set _data(t) {
              this._fireChange("text", this), (this._textData = t);
            }
            isSimilar(t) {
              return t instanceof ji && (this === t || this.data === t.data);
            }
            _clone() {
              return new ji(this.document, this.data);
            }
          }
          class Fi {
            constructor(t, e, n) {
              if (((this.textNode = t), e < 0 || e > t.data.length))
                throw new c("view-textproxy-wrong-offsetintext", this);
              if (n < 0 || e + n > t.data.length)
                throw new c("view-textproxy-wrong-length", this);
              (this.data = t.data.substring(e, e + n)), (this.offsetInText = e);
            }
            get offsetSize() {
              return this.data.length;
            }
            get isPartial() {
              return this.data.length !== this.textNode.data.length;
            }
            get parent() {
              return this.textNode.parent;
            }
            get root() {
              return this.textNode.root;
            }
            get document() {
              return this.textNode.document;
            }
            is(t) {
              return (
                "$textProxy" === t ||
                "view:$textProxy" === t ||
                "textProxy" === t ||
                "view:textProxy" === t
              );
            }
            getAncestors(t = { includeSelf: !1, parentFirst: !1 }) {
              const e = [];
              let n = t.includeSelf ? this.textNode : this.parent;
              for (; null !== n; )
                e[t.parentFirst ? "push" : "unshift"](n), (n = n.parent);
              return e;
            }
          }
          function Vi(t) {
            return Ei(t)
              ? new Map(t)
              : (function (t) {
                  const e = new Map();
                  for (const n in t) e.set(n, t[n]);
                  return e;
                })(t);
          }
          class Hi {
            constructor(...t) {
              (this._patterns = []), this.add(...t);
            }
            add(...t) {
              for (let e of t)
                ("string" == typeof e || e instanceof RegExp) &&
                  (e = { name: e }),
                  this._patterns.push(e);
            }
            match(...t) {
              for (const e of t)
                for (const t of this._patterns) {
                  const n = Ui(e, t);
                  if (n) return { element: e, pattern: t, match: n };
                }
              return null;
            }
            matchAll(...t) {
              const e = [];
              for (const n of t)
                for (const t of this._patterns) {
                  const i = Ui(n, t);
                  i && e.push({ element: n, pattern: t, match: i });
                }
              return e.length > 0 ? e : null;
            }
            getElementName() {
              if (1 !== this._patterns.length) return null;
              const t = this._patterns[0],
                e = t.name;
              return "function" == typeof t || !e || e instanceof RegExp
                ? null
                : e;
            }
          }
          function Ui(t, e) {
            if ("function" == typeof e) return e(t);
            const n = {};
            return (e.name &&
              ((n.name = (function (t, e) {
                if (t instanceof RegExp) return !!e.match(t);
                return t === e;
              })(e.name, t.name)),
              !n.name)) ||
              (e.attributes &&
                ((n.attributes = (function (t, e) {
                  const n = new Set(e.getAttributeKeys());
                  ye(t)
                    ? (void 0 !== t.style &&
                        l("matcher-pattern-deprecated-attributes-style-key", t),
                      void 0 !== t.class &&
                        l("matcher-pattern-deprecated-attributes-class-key", t))
                    : (n.delete("style"), n.delete("class"));
                  return $i(t, n, (t) => e.getAttribute(t));
                })(e.attributes, t)),
                !n.attributes))
              ? null
              : !(
                  e.classes &&
                  ((n.classes = (function (t, e) {
                    return $i(t, e.getClassNames());
                  })(e.classes, t)),
                  !n.classes)
                ) &&
                  !(
                    e.styles &&
                    ((n.styles = (function (t, e) {
                      return $i(t, e.getStyleNames(!0), (t) => e.getStyle(t));
                    })(e.styles, t)),
                    !n.styles)
                  ) &&
                  n;
          }
          function $i(t, e, n) {
            const i = (function (t) {
                if (Array.isArray(t))
                  return t.map((t) =>
                    ye(t)
                      ? ((void 0 !== t.key && void 0 !== t.value) ||
                          l("matcher-pattern-missing-key-or-value", t),
                        [t.key, t.value])
                      : [t, !0]
                  );
                if (ye(t)) return Object.entries(t);
                return [[t, !0]];
              })(t),
              o = Array.from(e),
              r = [];
            return (
              i.forEach(([t, e]) => {
                o.forEach((i) => {
                  (function (t, e) {
                    return (
                      !0 === t || t === e || (t instanceof RegExp && e.match(t))
                    );
                  })(t, i) &&
                    (function (t, e, n) {
                      if (!0 === t) return !0;
                      const i = n(e);
                      return (
                        t === i || (t instanceof RegExp && !!String(i).match(t))
                      );
                    })(e, i, n) &&
                    r.push(i);
                });
              }),
              !i.length || r.length < i.length ? null : r
            );
          }
          const qi = function (t) {
            return "symbol" == typeof t || (vt(t) && "[object Symbol]" == O(t));
          };
          var Gi = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
            Wi = /^\w*$/;
          const Yi = function (t, e) {
            if (It(t)) return !1;
            var n = typeof t;
            return (
              !(
                "number" != n &&
                "symbol" != n &&
                "boolean" != n &&
                null != t &&
                !qi(t)
              ) ||
              Wi.test(t) ||
              !Gi.test(t) ||
              (null != e && t in Object(e))
            );
          };
          function Ki(t, e) {
            if ("function" != typeof t || (null != e && "function" != typeof e))
              throw new TypeError("Expected a function");
            var n = function () {
              var i = arguments,
                o = e ? e.apply(this, i) : i[0],
                r = n.cache;
              if (r.has(o)) return r.get(o);
              var s = t.apply(this, i);
              return (n.cache = r.set(o, s) || r), s;
            };
            return (n.cache = new (Ki.Cache || on)()), n;
          }
          Ki.Cache = on;
          const Qi = Ki;
          var Zi =
              /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
            Ji = /\\(\\)?/g,
            Xi = (function (t) {
              var e = Qi(t, function (t) {
                  return 500 === n.size && n.clear(), t;
                }),
                n = e.cache;
              return e;
            })(function (t) {
              var e = [];
              return (
                46 === t.charCodeAt(0) && e.push(""),
                t.replace(Zi, function (t, n, i, o) {
                  e.push(i ? o.replace(Ji, "$1") : n || t);
                }),
                e
              );
            });
          const to = Xi;
          const eo = function (t, e) {
            for (
              var n = -1, i = null == t ? 0 : t.length, o = Array(i);
              ++n < i;

            )
              o[n] = e(t[n], n, t);
            return o;
          };
          var no = I ? I.prototype : void 0,
            io = no ? no.toString : void 0;
          const oo = function t(e) {
            if ("string" == typeof e) return e;
            if (It(e)) return eo(e, t) + "";
            if (qi(e)) return io ? io.call(e) : "";
            var n = e + "";
            return "0" == n && 1 / e == -Infinity ? "-0" : n;
          };
          const ro = function (t) {
            return null == t ? "" : oo(t);
          };
          const so = function (t, e) {
            return It(t) ? t : Yi(t, e) ? [t] : to(ro(t));
          };
          const ao = function (t) {
            var e = null == t ? 0 : t.length;
            return e ? t[e - 1] : void 0;
          };
          const co = function (t) {
            if ("string" == typeof t || qi(t)) return t;
            var e = t + "";
            return "0" == e && 1 / t == -Infinity ? "-0" : e;
          };
          const lo = function (t, e) {
            for (var n = 0, i = (e = so(e, t)).length; null != t && n < i; )
              t = t[co(e[n++])];
            return n && n == i ? t : void 0;
          };
          const ho = function (t, e, n) {
            var i = -1,
              o = t.length;
            e < 0 && (e = -e > o ? 0 : o + e),
              (n = n > o ? o : n) < 0 && (n += o),
              (o = e > n ? 0 : (n - e) >>> 0),
              (e >>>= 0);
            for (var r = Array(o); ++i < o; ) r[i] = t[i + e];
            return r;
          };
          const uo = function (t, e) {
            return e.length < 2 ? t : lo(t, ho(e, 0, -1));
          };
          const mo = function (t, e) {
            return (
              (e = so(e, t)), null == (t = uo(t, e)) || delete t[co(ao(e))]
            );
          };
          const go = function (t, e) {
            return null == t || mo(t, e);
          };
          const po = function (t, e, n) {
            var i = null == t ? void 0 : lo(t, e);
            return void 0 === i ? n : i;
          };
          const fo = function (t, e, n) {
            ((void 0 !== n && !nt(t[e], n)) || (void 0 === n && !(e in t))) &&
              et(t, e, n);
          };
          const ko = (function (t) {
            return function (e, n, i) {
              for (var o = -1, r = Object(e), s = i(e), a = s.length; a--; ) {
                var c = s[t ? a : ++o];
                if (!1 === n(r[c], c, r)) break;
              }
              return e;
            };
          })();
          const bo = function (t) {
            return vt(t) && kt(t);
          };
          const wo = function (t, e) {
            if (
              ("constructor" !== e || "function" != typeof t[e]) &&
              "__proto__" != e
            )
              return t[e];
          };
          const Ao = function (t) {
            return rt(t, Zt(t));
          };
          const _o = function (t, e, n, i, o, r, s) {
            var a = wo(t, n),
              c = wo(e, n),
              l = s.get(c);
            if (l) fo(t, n, l);
            else {
              var d = r ? r(a, c, n + "", t, e, s) : void 0,
                h = void 0 === d;
              if (h) {
                var u = It(c),
                  m = !u && zt(c),
                  g = !u && !m && Ut(c);
                (d = c),
                  u || m || g
                    ? It(a)
                      ? (d = a)
                      : bo(a)
                      ? (d = An(a))
                      : m
                      ? ((h = !1), (d = wn(c, !0)))
                      : g
                      ? ((h = !1), (d = ri(c, !0)))
                      : (d = [])
                    : ye(c) || St(c)
                    ? ((d = a),
                      St(a) ? (d = Ao(a)) : (x(a) && !j(a)) || (d = li(c)))
                    : (h = !1);
              }
              h && (s.set(c, d), o(d, c, i, r, s), s.delete(c)), fo(t, n, d);
            }
          };
          const Co = function t(e, n, i, o, r) {
            e !== n &&
              ko(
                n,
                function (s, a) {
                  if ((r || (r = new an()), x(s))) _o(e, n, a, i, t, o, r);
                  else {
                    var c = o ? o(wo(e, a), s, a + "", e, n, r) : void 0;
                    void 0 === c && (c = s), fo(e, a, c);
                  }
                },
                Zt
              );
          };
          const vo = _t(function (t, e, n) {
            Co(t, e, n);
          });
          const yo = function (t, e, n, i) {
            if (!x(t)) return t;
            for (
              var o = -1, r = (e = so(e, t)).length, s = r - 1, a = t;
              null != a && ++o < r;

            ) {
              var c = co(e[o]),
                l = n;
              if ("__proto__" === c || "constructor" === c || "prototype" === c)
                return t;
              if (o != s) {
                var d = a[c];
                void 0 === (l = i ? i(d, c, a) : void 0) &&
                  (l = x(d) ? d : wt(e[o + 1]) ? [] : {});
              }
              ot(a, c, l), (a = a[c]);
            }
            return t;
          };
          const xo = function (t, e, n) {
            return null == t ? t : yo(t, e, n);
          };
          class Eo {
            constructor(t) {
              (this._styles = {}), (this._styleProcessor = t);
            }
            get isEmpty() {
              const t = Object.entries(this._styles);
              return !Array.from(t).length;
            }
            get size() {
              return this.isEmpty ? 0 : this.getStyleNames().length;
            }
            setTo(t) {
              this.clear();
              const e = Array.from(
                (function (t) {
                  let e = null,
                    n = 0,
                    i = 0,
                    o = null;
                  const r = new Map();
                  if ("" === t) return r;
                  ";" != t.charAt(t.length - 1) && (t += ";");
                  for (let s = 0; s < t.length; s++) {
                    const a = t.charAt(s);
                    if (null === e)
                      switch (a) {
                        case ":":
                          o || ((o = t.substr(n, s - n)), (i = s + 1));
                          break;
                        case '"':
                        case "'":
                          e = a;
                          break;
                        case ";": {
                          const e = t.substr(i, s - i);
                          o && r.set(o.trim(), e.trim()),
                            (o = null),
                            (n = s + 1);
                          break;
                        }
                      }
                    else a === e && (e = null);
                  }
                  return r;
                })(t).entries()
              );
              for (const [t, n] of e)
                this._styleProcessor.toNormalizedForm(t, n, this._styles);
            }
            has(t) {
              if (this.isEmpty) return !1;
              const e = this._styleProcessor
                .getReducedForm(t, this._styles)
                .find(([e]) => e === t);
              return Array.isArray(e);
            }
            set(t, e) {
              if (x(t))
                for (const [e, n] of Object.entries(t))
                  this._styleProcessor.toNormalizedForm(e, n, this._styles);
              else this._styleProcessor.toNormalizedForm(t, e, this._styles);
            }
            remove(t) {
              const e = So(t);
              go(this._styles, e),
                delete this._styles[t],
                this._cleanEmptyObjectsOnPath(e);
            }
            getNormalized(t) {
              return this._styleProcessor.getNormalized(t, this._styles);
            }
            toString() {
              return this.isEmpty
                ? ""
                : this._getStylesEntries()
                    .map((t) => t.join(":"))
                    .sort()
                    .join(";") + ";";
            }
            getAsString(t) {
              if (this.isEmpty) return;
              if (this._styles[t] && !x(this._styles[t]))
                return this._styles[t];
              const e = this._styleProcessor
                .getReducedForm(t, this._styles)
                .find(([e]) => e === t);
              return Array.isArray(e) ? e[1] : void 0;
            }
            getStyleNames(t = !1) {
              if (this.isEmpty) return [];
              if (t) return this._styleProcessor.getStyleNames(this._styles);
              return this._getStylesEntries().map(([t]) => t);
            }
            clear() {
              this._styles = {};
            }
            _getStylesEntries() {
              const t = [],
                e = Object.keys(this._styles);
              for (const n of e)
                t.push(...this._styleProcessor.getReducedForm(n, this._styles));
              return t;
            }
            _cleanEmptyObjectsOnPath(t) {
              const e = t.split(".");
              if (!(e.length > 1)) return;
              const n = e.splice(0, e.length - 1).join("."),
                i = po(this._styles, n);
              if (!i) return;
              !Array.from(Object.keys(i)).length && this.remove(n);
            }
          }
          class Do {
            constructor() {
              (this._normalizers = new Map()),
                (this._extractors = new Map()),
                (this._reducers = new Map()),
                (this._consumables = new Map());
            }
            toNormalizedForm(t, e, n) {
              if (x(e)) Io(n, So(t), e);
              else if (this._normalizers.has(t)) {
                const i = this._normalizers.get(t),
                  { path: o, value: r } = i(e);
                Io(n, o, r);
              } else Io(n, t, e);
            }
            getNormalized(t, e) {
              if (!t) return vo({}, e);
              if (void 0 !== e[t]) return e[t];
              if (this._extractors.has(t)) {
                const n = this._extractors.get(t);
                if ("string" == typeof n) return po(e, n);
                const i = n(t, e);
                if (i) return i;
              }
              return po(e, So(t));
            }
            getReducedForm(t, e) {
              const n = this.getNormalized(t, e);
              if (void 0 === n) return [];
              if (this._reducers.has(t)) {
                return this._reducers.get(t)(n);
              }
              return [[t, n]];
            }
            getStyleNames(t) {
              const e = Array.from(this._consumables.keys()).filter((e) => {
                  const n = this.getNormalized(e, t);
                  return n && "object" == typeof n ? Object.keys(n).length : n;
                }),
                n = new Set([...e, ...Object.keys(t)]);
              return Array.from(n.values());
            }
            getRelatedStyles(t) {
              return this._consumables.get(t) || [];
            }
            setNormalizer(t, e) {
              this._normalizers.set(t, e);
            }
            setExtractor(t, e) {
              this._extractors.set(t, e);
            }
            setReducer(t, e) {
              this._reducers.set(t, e);
            }
            setStyleRelation(t, e) {
              this._mapStyleNames(t, e);
              for (const n of e) this._mapStyleNames(n, [t]);
            }
            _mapStyleNames(t, e) {
              this._consumables.has(t) || this._consumables.set(t, []),
                this._consumables.get(t).push(...e);
            }
          }
          function So(t) {
            return t.replace("-", ".");
          }
          function Io(t, e, n) {
            let i = n;
            x(n) && (i = vo({}, po(t, e), n)), xo(t, e, i);
          }
          class To extends Oi {
            constructor(t, e, n, i) {
              if (
                (super(t),
                (this.name = e),
                (this._attrs = (function (t) {
                  t = Vi(t);
                  for (const [e, n] of t)
                    null === n
                      ? t.delete(e)
                      : "string" != typeof n && t.set(e, String(n));
                  return t;
                })(n)),
                (this._children = []),
                i && this._insertChild(0, i),
                (this._classes = new Set()),
                this._attrs.has("class"))
              ) {
                const t = this._attrs.get("class");
                Mo(this._classes, t), this._attrs.delete("class");
              }
              (this._styles = new Eo(this.document.stylesProcessor)),
                this._attrs.has("style") &&
                  (this._styles.setTo(this._attrs.get("style")),
                  this._attrs.delete("style")),
                (this._customProperties = new Map()),
                (this._unsafeAttributesToRender = []);
            }
            get childCount() {
              return this._children.length;
            }
            get isEmpty() {
              return 0 === this._children.length;
            }
            is(t, e = null) {
              return e
                ? e === this.name && ("element" === t || "view:element" === t)
                : "element" === t ||
                    "view:element" === t ||
                    "node" === t ||
                    "view:node" === t;
            }
            getChild(t) {
              return this._children[t];
            }
            getChildIndex(t) {
              return this._children.indexOf(t);
            }
            getChildren() {
              return this._children[Symbol.iterator]();
            }
            *getAttributeKeys() {
              this._classes.size > 0 && (yield "class"),
                this._styles.isEmpty || (yield "style"),
                yield* this._attrs.keys();
            }
            *getAttributes() {
              yield* this._attrs.entries(),
                this._classes.size > 0 &&
                  (yield ["class", this.getAttribute("class")]),
                this._styles.isEmpty ||
                  (yield ["style", this.getAttribute("style")]);
            }
            getAttribute(t) {
              if ("class" == t)
                return this._classes.size > 0
                  ? [...this._classes].join(" ")
                  : void 0;
              if ("style" == t) {
                const t = this._styles.toString();
                return "" == t ? void 0 : t;
              }
              return this._attrs.get(t);
            }
            hasAttribute(t) {
              return "class" == t
                ? this._classes.size > 0
                : "style" == t
                ? !this._styles.isEmpty
                : this._attrs.has(t);
            }
            isSimilar(t) {
              if (!(t instanceof To)) return !1;
              if (this === t) return !0;
              if (this.name != t.name) return !1;
              if (
                this._attrs.size !== t._attrs.size ||
                this._classes.size !== t._classes.size ||
                this._styles.size !== t._styles.size
              )
                return !1;
              for (const [e, n] of this._attrs)
                if (!t._attrs.has(e) || t._attrs.get(e) !== n) return !1;
              for (const e of this._classes) if (!t._classes.has(e)) return !1;
              for (const e of this._styles.getStyleNames())
                if (
                  !t._styles.has(e) ||
                  t._styles.getAsString(e) !== this._styles.getAsString(e)
                )
                  return !1;
              return !0;
            }
            hasClass(...t) {
              for (const e of t) if (!this._classes.has(e)) return !1;
              return !0;
            }
            getClassNames() {
              return this._classes.keys();
            }
            getStyle(t) {
              return this._styles.getAsString(t);
            }
            getNormalizedStyle(t) {
              return this._styles.getNormalized(t);
            }
            getStyleNames(t = !1) {
              return this._styles.getStyleNames(t);
            }
            hasStyle(...t) {
              for (const e of t) if (!this._styles.has(e)) return !1;
              return !0;
            }
            findAncestor(...t) {
              const e = new Hi(...t);
              let n = this.parent;
              for (; n; ) {
                if (e.match(n)) return n;
                n = n.parent;
              }
              return null;
            }
            getCustomProperty(t) {
              return this._customProperties.get(t);
            }
            *getCustomProperties() {
              yield* this._customProperties.entries();
            }
            getIdentity() {
              const t = Array.from(this._classes).sort().join(","),
                e = this._styles.toString(),
                n = Array.from(this._attrs)
                  .map((t) => `${t[0]}="${t[1]}"`)
                  .sort()
                  .join(" ");
              return (
                this.name +
                ("" == t ? "" : ` class="${t}"`) +
                (e ? ` style="${e}"` : "") +
                ("" == n ? "" : ` ${n}`)
              );
            }
            shouldRenderUnsafeAttribute(t) {
              return this._unsafeAttributesToRender.includes(t);
            }
            _clone(t = !1) {
              const e = [];
              if (t) for (const n of this.getChildren()) e.push(n._clone(t));
              const n = new this.constructor(
                this.document,
                this.name,
                this._attrs,
                e
              );
              return (
                (n._classes = new Set(this._classes)),
                n._styles.set(this._styles.getNormalized()),
                (n._customProperties = new Map(this._customProperties)),
                (n.getFillerOffset = this.getFillerOffset),
                (n._unsafeAttributesToRender = this._unsafeAttributesToRender),
                n
              );
            }
            _appendChild(t) {
              return this._insertChild(this.childCount, t);
            }
            _insertChild(t, e) {
              this._fireChange("children", this);
              let n = 0;
              const i = (function (t, e) {
                if ("string" == typeof e) return [new ji(t, e)];
                Ei(e) || (e = [e]);
                return Array.from(e).map((e) =>
                  "string" == typeof e
                    ? new ji(t, e)
                    : e instanceof Fi
                    ? new ji(t, e.data)
                    : e
                );
              })(this.document, e);
              for (const e of i)
                null !== e.parent && e._remove(),
                  (e.parent = this),
                  (e.document = this.document),
                  this._children.splice(t, 0, e),
                  t++,
                  n++;
              return n;
            }
            _removeChildren(t, e = 1) {
              this._fireChange("children", this);
              for (let n = t; n < t + e; n++) this._children[n].parent = null;
              return this._children.splice(t, e);
            }
            _setAttribute(t, e) {
              (e = String(e)),
                this._fireChange("attributes", this),
                "class" == t
                  ? Mo(this._classes, e)
                  : "style" == t
                  ? this._styles.setTo(e)
                  : this._attrs.set(t, e);
            }
            _removeAttribute(t) {
              return (
                this._fireChange("attributes", this),
                "class" == t
                  ? this._classes.size > 0 && (this._classes.clear(), !0)
                  : "style" == t
                  ? !this._styles.isEmpty && (this._styles.clear(), !0)
                  : this._attrs.delete(t)
              );
            }
            _addClass(t) {
              this._fireChange("attributes", this);
              for (const e of Ii(t)) this._classes.add(e);
            }
            _removeClass(t) {
              this._fireChange("attributes", this);
              for (const e of Ii(t)) this._classes.delete(e);
            }
            _setStyle(t, e) {
              this._fireChange("attributes", this), this._styles.set(t, e);
            }
            _removeStyle(t) {
              this._fireChange("attributes", this);
              for (const e of Ii(t)) this._styles.remove(e);
            }
            _setCustomProperty(t, e) {
              this._customProperties.set(t, e);
            }
            _removeCustomProperty(t) {
              return this._customProperties.delete(t);
            }
          }
          function Mo(t, e) {
            const n = e.split(/\s+/);
            t.clear(), n.forEach((e) => t.add(e));
          }
          class Bo extends To {
            constructor(t, e, n, i) {
              super(t, e, n, i), (this.getFillerOffset = No);
            }
            is(t, e = null) {
              return e
                ? e === this.name &&
                    ("containerElement" === t ||
                      "view:containerElement" === t ||
                      "element" === t ||
                      "view:element" === t)
                : "containerElement" === t ||
                    "view:containerElement" === t ||
                    "element" === t ||
                    "view:element" === t ||
                    "node" === t ||
                    "view:node" === t;
            }
          }
          function No() {
            const t = [...this.getChildren()],
              e = t[this.childCount - 1];
            if (e && e.is("element", "br")) return this.childCount;
            for (const e of t) if (!e.is("uiElement")) return null;
            return this.childCount;
          }
          class zo extends Bo {
            constructor(t, e, n, i) {
              super(t, e, n, i),
                this.set("isReadOnly", !1),
                this.set("isFocused", !1),
                this.bind("isReadOnly").to(t),
                this.bind("isFocused").to(
                  t,
                  "isFocused",
                  (e) => e && t.selection.editableElement == this
                ),
                this.listenTo(t.selection, "change", () => {
                  this.isFocused =
                    t.isFocused && t.selection.editableElement == this;
                });
            }
            is(t, e = null) {
              return e
                ? e === this.name &&
                    ("editableElement" === t ||
                      "view:editableElement" === t ||
                      "containerElement" === t ||
                      "view:containerElement" === t ||
                      "element" === t ||
                      "view:element" === t)
                : "editableElement" === t ||
                    "view:editableElement" === t ||
                    "containerElement" === t ||
                    "view:containerElement" === t ||
                    "element" === t ||
                    "view:element" === t ||
                    "node" === t ||
                    "view:node" === t;
            }
            destroy() {
              this.stopListening();
            }
          }
          he(zo, re);
          const Po = Symbol("rootName");
          class Lo extends zo {
            constructor(t, e) {
              super(t, e), (this.rootName = "main");
            }
            is(t, e = null) {
              return e
                ? e === this.name &&
                    ("rootElement" === t ||
                      "view:rootElement" === t ||
                      "editableElement" === t ||
                      "view:editableElement" === t ||
                      "containerElement" === t ||
                      "view:containerElement" === t ||
                      "element" === t ||
                      "view:element" === t)
                : "rootElement" === t ||
                    "view:rootElement" === t ||
                    "editableElement" === t ||
                    "view:editableElement" === t ||
                    "containerElement" === t ||
                    "view:containerElement" === t ||
                    "element" === t ||
                    "view:element" === t ||
                    "node" === t ||
                    "view:node" === t;
            }
            get rootName() {
              return this.getCustomProperty(Po);
            }
            set rootName(t) {
              this._setCustomProperty(Po, t);
            }
            set _name(t) {
              this.name = t;
            }
          }
          class Ro {
            constructor(t = {}) {
              if (!t.boundaries && !t.startPosition)
                throw new c("view-tree-walker-no-start-position", null);
              if (
                t.direction &&
                "forward" != t.direction &&
                "backward" != t.direction
              )
                throw new c(
                  "view-tree-walker-unknown-direction",
                  t.startPosition,
                  { direction: t.direction }
                );
              (this.boundaries = t.boundaries || null),
                t.startPosition
                  ? (this.position = Oo._createAt(t.startPosition))
                  : (this.position = Oo._createAt(
                      t.boundaries["backward" == t.direction ? "end" : "start"]
                    )),
                (this.direction = t.direction || "forward"),
                (this.singleCharacters = !!t.singleCharacters),
                (this.shallow = !!t.shallow),
                (this.ignoreElementEnd = !!t.ignoreElementEnd),
                (this._boundaryStartParent = this.boundaries
                  ? this.boundaries.start.parent
                  : null),
                (this._boundaryEndParent = this.boundaries
                  ? this.boundaries.end.parent
                  : null);
            }
            [Symbol.iterator]() {
              return this;
            }
            skip(t) {
              let e, n, i;
              do {
                (i = this.position), ({ done: e, value: n } = this.next());
              } while (!e && t(n));
              e || (this.position = i);
            }
            next() {
              return "forward" == this.direction
                ? this._next()
                : this._previous();
            }
            _next() {
              let t = this.position.clone();
              const e = this.position,
                n = t.parent;
              if (null === n.parent && t.offset === n.childCount)
                return { done: !0 };
              if (
                n === this._boundaryEndParent &&
                t.offset == this.boundaries.end.offset
              )
                return { done: !0 };
              let i;
              if (n instanceof ji) {
                if (t.isAtEnd)
                  return (this.position = Oo._createAfter(n)), this._next();
                i = n.data[t.offset];
              } else i = n.getChild(t.offset);
              if (i instanceof To)
                return (
                  this.shallow ? t.offset++ : (t = new Oo(i, 0)),
                  (this.position = t),
                  this._formatReturnValue("elementStart", i, e, t, 1)
                );
              if (i instanceof ji) {
                if (this.singleCharacters)
                  return (t = new Oo(i, 0)), (this.position = t), this._next();
                {
                  let n,
                    o = i.data.length;
                  return (
                    i == this._boundaryEndParent
                      ? ((o = this.boundaries.end.offset),
                        (n = new Fi(i, 0, o)),
                        (t = Oo._createAfter(n)))
                      : ((n = new Fi(i, 0, i.data.length)), t.offset++),
                    (this.position = t),
                    this._formatReturnValue("text", n, e, t, o)
                  );
                }
              }
              if ("string" == typeof i) {
                let i;
                if (this.singleCharacters) i = 1;
                else {
                  i =
                    (n === this._boundaryEndParent
                      ? this.boundaries.end.offset
                      : n.data.length) - t.offset;
                }
                const o = new Fi(n, t.offset, i);
                return (
                  (t.offset += i),
                  (this.position = t),
                  this._formatReturnValue("text", o, e, t, i)
                );
              }
              return (
                (t = Oo._createAfter(n)),
                (this.position = t),
                this.ignoreElementEnd
                  ? this._next()
                  : this._formatReturnValue("elementEnd", n, e, t)
              );
            }
            _previous() {
              let t = this.position.clone();
              const e = this.position,
                n = t.parent;
              if (null === n.parent && 0 === t.offset) return { done: !0 };
              if (
                n == this._boundaryStartParent &&
                t.offset == this.boundaries.start.offset
              )
                return { done: !0 };
              let i;
              if (n instanceof ji) {
                if (t.isAtStart)
                  return (
                    (this.position = Oo._createBefore(n)), this._previous()
                  );
                i = n.data[t.offset - 1];
              } else i = n.getChild(t.offset - 1);
              if (i instanceof To)
                return this.shallow
                  ? (t.offset--,
                    (this.position = t),
                    this._formatReturnValue("elementStart", i, e, t, 1))
                  : ((t = new Oo(i, i.childCount)),
                    (this.position = t),
                    this.ignoreElementEnd
                      ? this._previous()
                      : this._formatReturnValue("elementEnd", i, e, t));
              if (i instanceof ji) {
                if (this.singleCharacters)
                  return (
                    (t = new Oo(i, i.data.length)),
                    (this.position = t),
                    this._previous()
                  );
                {
                  let n,
                    o = i.data.length;
                  if (i == this._boundaryStartParent) {
                    const e = this.boundaries.start.offset;
                    (n = new Fi(i, e, i.data.length - e)),
                      (o = n.data.length),
                      (t = Oo._createBefore(n));
                  } else (n = new Fi(i, 0, i.data.length)), t.offset--;
                  return (
                    (this.position = t),
                    this._formatReturnValue("text", n, e, t, o)
                  );
                }
              }
              if ("string" == typeof i) {
                let i;
                if (this.singleCharacters) i = 1;
                else {
                  const e =
                    n === this._boundaryStartParent
                      ? this.boundaries.start.offset
                      : 0;
                  i = t.offset - e;
                }
                t.offset -= i;
                const o = new Fi(n, t.offset, i);
                return (
                  (this.position = t),
                  this._formatReturnValue("text", o, e, t, i)
                );
              }
              return (
                (t = Oo._createBefore(n)),
                (this.position = t),
                this._formatReturnValue("elementStart", n, e, t, 1)
              );
            }
            _formatReturnValue(t, e, n, i, o) {
              return (
                e instanceof Fi &&
                  (e.offsetInText + e.data.length == e.textNode.data.length &&
                    ("forward" != this.direction ||
                    (this.boundaries &&
                      this.boundaries.end.isEqual(this.position))
                      ? (n = Oo._createAfter(e.textNode))
                      : ((i = Oo._createAfter(e.textNode)),
                        (this.position = i))),
                  0 === e.offsetInText &&
                    ("backward" != this.direction ||
                    (this.boundaries &&
                      this.boundaries.start.isEqual(this.position))
                      ? (n = Oo._createBefore(e.textNode))
                      : ((i = Oo._createBefore(e.textNode)),
                        (this.position = i)))),
                {
                  done: !1,
                  value: {
                    type: t,
                    item: e,
                    previousPosition: n,
                    nextPosition: i,
                    length: o,
                  },
                }
              );
            }
          }
          class Oo {
            constructor(t, e) {
              (this.parent = t), (this.offset = e);
            }
            get nodeAfter() {
              return this.parent.is("$text")
                ? null
                : this.parent.getChild(this.offset) || null;
            }
            get nodeBefore() {
              return this.parent.is("$text")
                ? null
                : this.parent.getChild(this.offset - 1) || null;
            }
            get isAtStart() {
              return 0 === this.offset;
            }
            get isAtEnd() {
              const t = this.parent.is("$text")
                ? this.parent.data.length
                : this.parent.childCount;
              return this.offset === t;
            }
            get root() {
              return this.parent.root;
            }
            get editableElement() {
              let t = this.parent;
              for (; !(t instanceof zo); ) {
                if (!t.parent) return null;
                t = t.parent;
              }
              return t;
            }
            getShiftedBy(t) {
              const e = Oo._createAt(this),
                n = e.offset + t;
              return (e.offset = n < 0 ? 0 : n), e;
            }
            getLastMatchingPosition(t, e = {}) {
              e.startPosition = this;
              const n = new Ro(e);
              return n.skip(t), n.position;
            }
            getAncestors() {
              return this.parent.is("documentFragment")
                ? [this.parent]
                : this.parent.getAncestors({ includeSelf: !0 });
            }
            getCommonAncestor(t) {
              const e = this.getAncestors(),
                n = t.getAncestors();
              let i = 0;
              for (; e[i] == n[i] && e[i]; ) i++;
              return 0 === i ? null : e[i - 1];
            }
            is(t) {
              return "position" === t || "view:position" === t;
            }
            isEqual(t) {
              return this.parent == t.parent && this.offset == t.offset;
            }
            isBefore(t) {
              return "before" == this.compareWith(t);
            }
            isAfter(t) {
              return "after" == this.compareWith(t);
            }
            compareWith(t) {
              if (this.root !== t.root) return "different";
              if (this.isEqual(t)) return "same";
              const e = this.parent.is("node") ? this.parent.getPath() : [],
                n = t.parent.is("node") ? t.parent.getPath() : [];
              e.push(this.offset), n.push(t.offset);
              const i = Li(e, n);
              switch (i) {
                case "prefix":
                  return "before";
                case "extension":
                  return "after";
                default:
                  return e[i] < n[i] ? "before" : "after";
              }
            }
            getWalker(t = {}) {
              return (t.startPosition = this), new Ro(t);
            }
            clone() {
              return new Oo(this.parent, this.offset);
            }
            static _createAt(t, e) {
              if (t instanceof Oo) return new this(t.parent, t.offset);
              {
                const n = t;
                if ("end" == e)
                  e = n.is("$text") ? n.data.length : n.childCount;
                else {
                  if ("before" == e) return this._createBefore(n);
                  if ("after" == e) return this._createAfter(n);
                  if (0 !== e && !e)
                    throw new c("view-createpositionat-offset-required", n);
                }
                return new Oo(n, e);
              }
            }
            static _createAfter(t) {
              if (t.is("$textProxy"))
                return new Oo(t.textNode, t.offsetInText + t.data.length);
              if (!t.parent)
                throw new c("view-position-after-root", t, { root: t });
              return new Oo(t.parent, t.index + 1);
            }
            static _createBefore(t) {
              if (t.is("$textProxy")) return new Oo(t.textNode, t.offsetInText);
              if (!t.parent)
                throw new c("view-position-before-root", t, { root: t });
              return new Oo(t.parent, t.index);
            }
          }
          class jo {
            constructor(t, e = null) {
              (this.start = t.clone()), (this.end = e ? e.clone() : t.clone());
            }
            *[Symbol.iterator]() {
              yield* new Ro({ boundaries: this, ignoreElementEnd: !0 });
            }
            get isCollapsed() {
              return this.start.isEqual(this.end);
            }
            get isFlat() {
              return this.start.parent === this.end.parent;
            }
            get root() {
              return this.start.root;
            }
            getEnlarged() {
              let t = this.start.getLastMatchingPosition(Fo, {
                  direction: "backward",
                }),
                e = this.end.getLastMatchingPosition(Fo);
              return (
                t.parent.is("$text") &&
                  t.isAtStart &&
                  (t = Oo._createBefore(t.parent)),
                e.parent.is("$text") &&
                  e.isAtEnd &&
                  (e = Oo._createAfter(e.parent)),
                new jo(t, e)
              );
            }
            getTrimmed() {
              let t = this.start.getLastMatchingPosition(Fo);
              if (t.isAfter(this.end) || t.isEqual(this.end))
                return new jo(t, t);
              let e = this.end.getLastMatchingPosition(Fo, {
                direction: "backward",
              });
              const n = t.nodeAfter,
                i = e.nodeBefore;
              return (
                n && n.is("$text") && (t = new Oo(n, 0)),
                i && i.is("$text") && (e = new Oo(i, i.data.length)),
                new jo(t, e)
              );
            }
            isEqual(t) {
              return (
                this == t ||
                (this.start.isEqual(t.start) && this.end.isEqual(t.end))
              );
            }
            containsPosition(t) {
              return t.isAfter(this.start) && t.isBefore(this.end);
            }
            containsRange(t, e = !1) {
              t.isCollapsed && (e = !1);
              const n =
                  this.containsPosition(t.start) ||
                  (e && this.start.isEqual(t.start)),
                i =
                  this.containsPosition(t.end) ||
                  (e && this.end.isEqual(t.end));
              return n && i;
            }
            getDifference(t) {
              const e = [];
              return (
                this.isIntersecting(t)
                  ? (this.containsPosition(t.start) &&
                      e.push(new jo(this.start, t.start)),
                    this.containsPosition(t.end) &&
                      e.push(new jo(t.end, this.end)))
                  : e.push(this.clone()),
                e
              );
            }
            getIntersection(t) {
              if (this.isIntersecting(t)) {
                let e = this.start,
                  n = this.end;
                return (
                  this.containsPosition(t.start) && (e = t.start),
                  this.containsPosition(t.end) && (n = t.end),
                  new jo(e, n)
                );
              }
              return null;
            }
            getWalker(t = {}) {
              return (t.boundaries = this), new Ro(t);
            }
            getCommonAncestor() {
              return this.start.getCommonAncestor(this.end);
            }
            getContainedElement() {
              if (this.isCollapsed) return null;
              let t = this.start.nodeAfter,
                e = this.end.nodeBefore;
              return (
                this.start.parent.is("$text") &&
                  this.start.isAtEnd &&
                  this.start.parent.nextSibling &&
                  (t = this.start.parent.nextSibling),
                this.end.parent.is("$text") &&
                  this.end.isAtStart &&
                  this.end.parent.previousSibling &&
                  (e = this.end.parent.previousSibling),
                t && t.is("element") && t === e ? t : null
              );
            }
            clone() {
              return new jo(this.start, this.end);
            }
            *getItems(t = {}) {
              (t.boundaries = this), (t.ignoreElementEnd = !0);
              const e = new Ro(t);
              for (const t of e) yield t.item;
            }
            *getPositions(t = {}) {
              t.boundaries = this;
              const e = new Ro(t);
              yield e.position;
              for (const t of e) yield t.nextPosition;
            }
            is(t) {
              return "range" === t || "view:range" === t;
            }
            isIntersecting(t) {
              return this.start.isBefore(t.end) && this.end.isAfter(t.start);
            }
            static _createFromParentsAndOffsets(t, e, n, i) {
              return new this(new Oo(t, e), new Oo(n, i));
            }
            static _createFromPositionAndShift(t, e) {
              const n = t,
                i = t.getShiftedBy(e);
              return e > 0 ? new this(n, i) : new this(i, n);
            }
            static _createIn(t) {
              return this._createFromParentsAndOffsets(t, 0, t, t.childCount);
            }
            static _createOn(t) {
              const e = t.is("$textProxy") ? t.offsetSize : 1;
              return this._createFromPositionAndShift(Oo._createBefore(t), e);
            }
          }
          function Fo(t) {
            return !(!t.item.is("attributeElement") && !t.item.is("uiElement"));
          }
          function Vo(t) {
            let e = 0;
            for (const n of t) e++;
            return e;
          }
          class Ho {
            constructor(t = null, e, n) {
              (this._ranges = []),
                (this._lastRangeBackward = !1),
                (this._isFake = !1),
                (this._fakeSelectionLabel = ""),
                this.setTo(t, e, n);
            }
            get isFake() {
              return this._isFake;
            }
            get fakeSelectionLabel() {
              return this._fakeSelectionLabel;
            }
            get anchor() {
              if (!this._ranges.length) return null;
              const t = this._ranges[this._ranges.length - 1];
              return (this._lastRangeBackward ? t.end : t.start).clone();
            }
            get focus() {
              if (!this._ranges.length) return null;
              const t = this._ranges[this._ranges.length - 1];
              return (this._lastRangeBackward ? t.start : t.end).clone();
            }
            get isCollapsed() {
              return 1 === this.rangeCount && this._ranges[0].isCollapsed;
            }
            get rangeCount() {
              return this._ranges.length;
            }
            get isBackward() {
              return !this.isCollapsed && this._lastRangeBackward;
            }
            get editableElement() {
              return this.anchor ? this.anchor.editableElement : null;
            }
            *getRanges() {
              for (const t of this._ranges) yield t.clone();
            }
            getFirstRange() {
              let t = null;
              for (const e of this._ranges)
                (t && !e.start.isBefore(t.start)) || (t = e);
              return t ? t.clone() : null;
            }
            getLastRange() {
              let t = null;
              for (const e of this._ranges)
                (t && !e.end.isAfter(t.end)) || (t = e);
              return t ? t.clone() : null;
            }
            getFirstPosition() {
              const t = this.getFirstRange();
              return t ? t.start.clone() : null;
            }
            getLastPosition() {
              const t = this.getLastRange();
              return t ? t.end.clone() : null;
            }
            isEqual(t) {
              if (this.isFake != t.isFake) return !1;
              if (
                this.isFake &&
                this.fakeSelectionLabel != t.fakeSelectionLabel
              )
                return !1;
              if (this.rangeCount != t.rangeCount) return !1;
              if (0 === this.rangeCount) return !0;
              if (
                !this.anchor.isEqual(t.anchor) ||
                !this.focus.isEqual(t.focus)
              )
                return !1;
              for (const e of this._ranges) {
                let n = !1;
                for (const i of t._ranges)
                  if (e.isEqual(i)) {
                    n = !0;
                    break;
                  }
                if (!n) return !1;
              }
              return !0;
            }
            isSimilar(t) {
              if (this.isBackward != t.isBackward) return !1;
              const e = Vo(this.getRanges());
              if (e != Vo(t.getRanges())) return !1;
              if (0 == e) return !0;
              for (let e of this.getRanges()) {
                e = e.getTrimmed();
                let n = !1;
                for (let i of t.getRanges())
                  if (
                    ((i = i.getTrimmed()),
                    e.start.isEqual(i.start) && e.end.isEqual(i.end))
                  ) {
                    n = !0;
                    break;
                  }
                if (!n) return !1;
              }
              return !0;
            }
            getSelectedElement() {
              return 1 !== this.rangeCount
                ? null
                : this.getFirstRange().getContainedElement();
            }
            setTo(t, e, n) {
              if (null === t) this._setRanges([]), this._setFakeOptions(e);
              else if (t instanceof Ho || t instanceof Uo)
                this._setRanges(t.getRanges(), t.isBackward),
                  this._setFakeOptions({
                    fake: t.isFake,
                    label: t.fakeSelectionLabel,
                  });
              else if (t instanceof jo)
                this._setRanges([t], e && e.backward), this._setFakeOptions(e);
              else if (t instanceof Oo)
                this._setRanges([new jo(t)]), this._setFakeOptions(e);
              else if (t instanceof Oi) {
                const i = !!n && !!n.backward;
                let o;
                if (void 0 === e)
                  throw new c(
                    "view-selection-setto-required-second-parameter",
                    this
                  );
                (o =
                  "in" == e
                    ? jo._createIn(t)
                    : "on" == e
                    ? jo._createOn(t)
                    : new jo(Oo._createAt(t, e))),
                  this._setRanges([o], i),
                  this._setFakeOptions(n);
              } else {
                if (!Ei(t))
                  throw new c("view-selection-setto-not-selectable", this);
                this._setRanges(t, e && e.backward), this._setFakeOptions(e);
              }
              this.fire("change");
            }
            setFocus(t, e) {
              if (null === this.anchor)
                throw new c("view-selection-setfocus-no-ranges", this);
              const n = Oo._createAt(t, e);
              if ("same" == n.compareWith(this.focus)) return;
              const i = this.anchor;
              this._ranges.pop(),
                "before" == n.compareWith(i)
                  ? this._addRange(new jo(n, i), !0)
                  : this._addRange(new jo(i, n)),
                this.fire("change");
            }
            is(t) {
              return "selection" === t || "view:selection" === t;
            }
            _setRanges(t, e = !1) {
              (t = Array.from(t)), (this._ranges = []);
              for (const e of t) this._addRange(e);
              this._lastRangeBackward = !!e;
            }
            _setFakeOptions(t = {}) {
              (this._isFake = !!t.fake),
                (this._fakeSelectionLabel = (t.fake && t.label) || "");
            }
            _addRange(t, e = !1) {
              if (!(t instanceof jo))
                throw new c("view-selection-add-range-not-range", this);
              this._pushRange(t), (this._lastRangeBackward = !!e);
            }
            _pushRange(t) {
              for (const e of this._ranges)
                if (t.isIntersecting(e))
                  throw new c("view-selection-range-intersects", this, {
                    addedRange: t,
                    intersectingRange: e,
                  });
              this._ranges.push(new jo(t.start, t.end));
            }
          }
          he(Ho, k);
          class Uo {
            constructor(t = null, e, n) {
              (this._selection = new Ho()),
                this._selection.delegate("change").to(this),
                this._selection.setTo(t, e, n);
            }
            get isFake() {
              return this._selection.isFake;
            }
            get fakeSelectionLabel() {
              return this._selection.fakeSelectionLabel;
            }
            get anchor() {
              return this._selection.anchor;
            }
            get focus() {
              return this._selection.focus;
            }
            get isCollapsed() {
              return this._selection.isCollapsed;
            }
            get rangeCount() {
              return this._selection.rangeCount;
            }
            get isBackward() {
              return this._selection.isBackward;
            }
            get editableElement() {
              return this._selection.editableElement;
            }
            get _ranges() {
              return this._selection._ranges;
            }
            *getRanges() {
              yield* this._selection.getRanges();
            }
            getFirstRange() {
              return this._selection.getFirstRange();
            }
            getLastRange() {
              return this._selection.getLastRange();
            }
            getFirstPosition() {
              return this._selection.getFirstPosition();
            }
            getLastPosition() {
              return this._selection.getLastPosition();
            }
            getSelectedElement() {
              return this._selection.getSelectedElement();
            }
            isEqual(t) {
              return this._selection.isEqual(t);
            }
            isSimilar(t) {
              return this._selection.isSimilar(t);
            }
            is(t) {
              return (
                "selection" === t ||
                "documentSelection" == t ||
                "view:selection" == t ||
                "view:documentSelection" == t
              );
            }
            _setTo(t, e, n) {
              this._selection.setTo(t, e, n);
            }
            _setFocus(t, e) {
              this._selection.setFocus(t, e);
            }
          }
          he(Uo, k);
          class $o extends e {
            constructor(t, e, n) {
              super(t, e),
                (this.startRange = n),
                (this._eventPhase = "none"),
                (this._currentTarget = null);
            }
            get eventPhase() {
              return this._eventPhase;
            }
            get currentTarget() {
              return this._currentTarget;
            }
          }
          const qo = Symbol("bubbling contexts"),
            Go = {
              fire(t, ...n) {
                try {
                  const i = t instanceof e ? t : new e(this, t),
                    o = Zo(this);
                  if (!o.size) return;
                  if ((Yo(i, "capturing", this), Ko(o, "$capture", i, ...n)))
                    return i.return;
                  const r = i.startRange || this.selection.getFirstRange(),
                    s = r ? r.getContainedElement() : null,
                    a = !!s && Boolean(Qo(o, s));
                  let c =
                    s ||
                    (function (t) {
                      if (!t) return null;
                      const e = t.start.parent,
                        n = t.end.parent,
                        i = e.getPath(),
                        o = n.getPath();
                      return i.length > o.length ? e : n;
                    })(r);
                  if ((Yo(i, "atTarget", c), !a)) {
                    if (Ko(o, "$text", i, ...n)) return i.return;
                    Yo(i, "bubbling", c);
                  }
                  for (; c; ) {
                    if (c.is("rootElement")) {
                      if (Ko(o, "$root", i, ...n)) return i.return;
                    } else if (c.is("element") && Ko(o, c.name, i, ...n))
                      return i.return;
                    if (Ko(o, c, i, ...n)) return i.return;
                    (c = c.parent), Yo(i, "bubbling", c);
                  }
                  return (
                    Yo(i, "bubbling", this),
                    Ko(o, "$document", i, ...n),
                    i.return
                  );
                } catch (t) {
                  c.rethrowUnexpectedError(t, this);
                }
              },
              _addEventListener(t, e, n) {
                const i = Ii(n.context || "$document"),
                  o = Zo(this);
                for (const r of i) {
                  let i = o.get(r);
                  i || ((i = Object.create(k)), o.set(r, i)),
                    this.listenTo(i, t, e, n);
                }
              },
              _removeEventListener(t, e) {
                const n = Zo(this);
                for (const i of n.values()) this.stopListening(i, t, e);
              },
            },
            Wo = Go;
          function Yo(t, e, n) {
            t instanceof $o && ((t._eventPhase = e), (t._currentTarget = n));
          }
          function Ko(t, e, n, ...i) {
            const o = "string" == typeof e ? t.get(e) : Qo(t, e);
            return !!o && (o.fire(n, ...i), n.stop.called);
          }
          function Qo(t, e) {
            for (const [n, i] of t)
              if ("function" == typeof n && n(e)) return i;
            return null;
          }
          function Zo(t) {
            return t[qo] || (t[qo] = new Map()), t[qo];
          }
          class Jo {
            constructor(t) {
              (this.selection = new Uo()),
                (this.roots = new Di({ idProperty: "rootName" })),
                (this.stylesProcessor = t),
                this.set("isReadOnly", !1),
                this.set("isFocused", !1),
                this.set("isSelecting", !1),
                this.set("isComposing", !1),
                (this._postFixers = new Set());
            }
            getRoot(t = "main") {
              return this.roots.get(t);
            }
            registerPostFixer(t) {
              this._postFixers.add(t);
            }
            destroy() {
              this.roots.map((t) => t.destroy()), this.stopListening();
            }
            _callPostFixers(t) {
              let e = !1;
              do {
                for (const n of this._postFixers) if (((e = n(t)), e)) break;
              } while (e);
            }
          }
          he(Jo, Wo), he(Jo, re);
          class Xo extends To {
            constructor(t, e, n, i) {
              super(t, e, n, i),
                (this.getFillerOffset = tr),
                (this._priority = 10),
                (this._id = null),
                (this._clonesGroup = null);
            }
            get priority() {
              return this._priority;
            }
            get id() {
              return this._id;
            }
            getElementsWithSameId() {
              if (null === this.id)
                throw new c(
                  "attribute-element-get-elements-with-same-id-no-id",
                  this
                );
              return new Set(this._clonesGroup);
            }
            is(t, e = null) {
              return e
                ? e === this.name &&
                    ("attributeElement" === t ||
                      "view:attributeElement" === t ||
                      "element" === t ||
                      "view:element" === t)
                : "attributeElement" === t ||
                    "view:attributeElement" === t ||
                    "element" === t ||
                    "view:element" === t ||
                    "node" === t ||
                    "view:node" === t;
            }
            isSimilar(t) {
              return null !== this.id || null !== t.id
                ? this.id === t.id
                : super.isSimilar(t) && this.priority == t.priority;
            }
            _clone(t) {
              const e = super._clone(t);
              return (e._priority = this._priority), (e._id = this._id), e;
            }
          }
          function tr() {
            if (er(this)) return null;
            let t = this.parent;
            for (; t && t.is("attributeElement"); ) {
              if (er(t) > 1) return null;
              t = t.parent;
            }
            return !t || er(t) > 1 ? null : this.childCount;
          }
          function er(t) {
            return Array.from(t.getChildren()).filter((t) => !t.is("uiElement"))
              .length;
          }
          Xo.DEFAULT_PRIORITY = 10;
          class nr extends To {
            constructor(t, e, n, i) {
              super(t, e, n, i), (this.getFillerOffset = ir);
            }
            is(t, e = null) {
              return e
                ? e === this.name &&
                    ("emptyElement" === t ||
                      "view:emptyElement" === t ||
                      "element" === t ||
                      "view:element" === t)
                : "emptyElement" === t ||
                    "view:emptyElement" === t ||
                    "element" === t ||
                    "view:element" === t ||
                    "node" === t ||
                    "view:node" === t;
            }
            _insertChild(t, e) {
              if (e && (e instanceof Oi || Array.from(e).length > 0))
                throw new c("view-emptyelement-cannot-add", [this, e]);
            }
          }
          function ir() {
            return null;
          }
          const or = navigator.userAgent.toLowerCase(),
            rr = {
              isMac: ar(or),
              isWindows: (function (t) {
                return t.indexOf("windows") > -1;
              })(or),
              isGecko: (function (t) {
                return !!t.match(/gecko\/\d+/);
              })(or),
              isSafari: (function (t) {
                return (
                  t.indexOf(" applewebkit/") > -1 && -1 === t.indexOf("chrome")
                );
              })(or),
              isiOS: (function (t) {
                return (
                  !!t.match(/iphone|ipad/i) ||
                  (ar(t) && navigator.maxTouchPoints > 0)
                );
              })(or),
              isAndroid: (function (t) {
                return t.indexOf("android") > -1;
              })(or),
              isBlink: (function (t) {
                return t.indexOf("chrome/") > -1 && t.indexOf("edge/") < 0;
              })(or),
              features: {
                isRegExpUnicodePropertySupported: (function () {
                  let t = !1;
                  try {
                    t = 0 === "ć".search(new RegExp("[\\p{L}]", "u"));
                  } catch (t) {}
                  return t;
                })(),
              },
            },
            sr = rr;
          function ar(t) {
            return t.indexOf("macintosh") > -1;
          }
          const cr = { ctrl: "⌃", cmd: "⌘", alt: "⌥", shift: "⇧" },
            lr = { ctrl: "Ctrl+", alt: "Alt+", shift: "Shift+" },
            dr = (function () {
              const t = {
                arrowleft: 37,
                arrowup: 38,
                arrowright: 39,
                arrowdown: 40,
                backspace: 8,
                delete: 46,
                enter: 13,
                space: 32,
                esc: 27,
                tab: 9,
                ctrl: 1114112,
                shift: 2228224,
                alt: 4456448,
                cmd: 8912896,
              };
              for (let e = 65; e <= 90; e++) {
                const n = String.fromCharCode(e);
                t[n.toLowerCase()] = e;
              }
              for (let e = 48; e <= 57; e++) t[e - 48] = e;
              for (let e = 112; e <= 123; e++) t["f" + (e - 111)] = e;
              for (const e of "`-=[];',./\\") t[e] = e.charCodeAt(0);
              return t;
            })(),
            hr = Object.fromEntries(
              Object.entries(dr).map(([t, e]) => [
                e,
                t.charAt(0).toUpperCase() + t.slice(1),
              ])
            );
          function ur(t) {
            let e;
            if ("string" == typeof t) {
              if (((e = dr[t.toLowerCase()]), !e))
                throw new c("keyboard-unknown-key", null, { key: t });
            } else
              e =
                t.keyCode +
                (t.altKey ? dr.alt : 0) +
                (t.ctrlKey ? dr.ctrl : 0) +
                (t.shiftKey ? dr.shift : 0) +
                (t.metaKey ? dr.cmd : 0);
            return e;
          }
          function mr(t) {
            return (
              "string" == typeof t &&
                (t = (function (t) {
                  return t.split("+").map((t) => t.trim());
                })(t)),
              t
                .map((t) =>
                  "string" == typeof t
                    ? (function (t) {
                        if (t.endsWith("!")) return ur(t.slice(0, -1));
                        const e = ur(t);
                        return sr.isMac && e == dr.ctrl ? dr.cmd : e;
                      })(t)
                    : t
                )
                .reduce((t, e) => e + t, 0)
            );
          }
          function gr(t) {
            let e = mr(t);
            return (
              Object.entries(sr.isMac ? cr : lr).reduce(
                (t, [n, i]) => (
                  0 != (e & dr[n]) && ((e &= ~dr[n]), (t += i)), t
                ),
                ""
              ) + (e ? hr[e] : "")
            );
          }
          function pr(t, e) {
            const n = "ltr" === e;
            switch (t) {
              case dr.arrowleft:
                return n ? "left" : "right";
              case dr.arrowright:
                return n ? "right" : "left";
              case dr.arrowup:
                return "up";
              case dr.arrowdown:
                return "down";
            }
          }
          class fr extends To {
            constructor(t, e, n, i) {
              super(t, e, n, i), (this.getFillerOffset = br);
            }
            is(t, e = null) {
              return e
                ? e === this.name &&
                    ("uiElement" === t ||
                      "view:uiElement" === t ||
                      "element" === t ||
                      "view:element" === t)
                : "uiElement" === t ||
                    "view:uiElement" === t ||
                    "element" === t ||
                    "view:element" === t ||
                    "node" === t ||
                    "view:node" === t;
            }
            _insertChild(t, e) {
              if (e && (e instanceof Oi || Array.from(e).length > 0))
                throw new c("view-uielement-cannot-add", this);
            }
            render(t) {
              return this.toDomElement(t);
            }
            toDomElement(t) {
              const e = t.createElement(this.name);
              for (const t of this.getAttributeKeys())
                e.setAttribute(t, this.getAttribute(t));
              return e;
            }
          }
          function kr(t) {
            t.document.on(
              "arrowKey",
              (e, n) =>
                (function (t, e, n) {
                  if (e.keyCode == dr.arrowright) {
                    const t =
                        e.domTarget.ownerDocument.defaultView.getSelection(),
                      i = 1 == t.rangeCount && t.getRangeAt(0).collapsed;
                    if (i || e.shiftKey) {
                      const e = t.focusNode,
                        o = t.focusOffset,
                        r = n.domPositionToView(e, o);
                      if (null === r) return;
                      let s = !1;
                      const a = r.getLastMatchingPosition(
                        (t) => (
                          t.item.is("uiElement") && (s = !0),
                          !(
                            !t.item.is("uiElement") &&
                            !t.item.is("attributeElement")
                          )
                        )
                      );
                      if (s) {
                        const e = n.viewPositionToDom(a);
                        i
                          ? t.collapse(e.parent, e.offset)
                          : t.extend(e.parent, e.offset);
                      }
                    }
                  }
                })(0, n, t.domConverter),
              { priority: "low" }
            );
          }
          function br() {
            return null;
          }
          class wr extends To {
            constructor(t, e, n, i) {
              super(t, e, n, i), (this.getFillerOffset = Ar);
            }
            is(t, e = null) {
              return e
                ? e === this.name &&
                    ("rawElement" === t ||
                      "view:rawElement" === t ||
                      "element" === t ||
                      "view:element" === t)
                : "rawElement" === t ||
                    "view:rawElement" === t ||
                    t === this.name ||
                    t === "view:" + this.name ||
                    "element" === t ||
                    "view:element" === t ||
                    "node" === t ||
                    "view:node" === t;
            }
            _insertChild(t, e) {
              if (e && (e instanceof Oi || Array.from(e).length > 0))
                throw new c("view-rawelement-cannot-add", [this, e]);
            }
          }
          function Ar() {
            return null;
          }
          class _r {
            constructor(t, e) {
              (this.document = t),
                (this._children = []),
                e && this._insertChild(0, e);
            }
            [Symbol.iterator]() {
              return this._children[Symbol.iterator]();
            }
            get childCount() {
              return this._children.length;
            }
            get isEmpty() {
              return 0 === this.childCount;
            }
            get root() {
              return this;
            }
            get parent() {
              return null;
            }
            is(t) {
              return "documentFragment" === t || "view:documentFragment" === t;
            }
            _appendChild(t) {
              return this._insertChild(this.childCount, t);
            }
            getChild(t) {
              return this._children[t];
            }
            getChildIndex(t) {
              return this._children.indexOf(t);
            }
            getChildren() {
              return this._children[Symbol.iterator]();
            }
            _insertChild(t, e) {
              this._fireChange("children", this);
              let n = 0;
              const i = (function (t, e) {
                if ("string" == typeof e) return [new ji(t, e)];
                Ei(e) || (e = [e]);
                return Array.from(e).map((e) =>
                  "string" == typeof e
                    ? new ji(t, e)
                    : e instanceof Fi
                    ? new ji(t, e.data)
                    : e
                );
              })(this.document, e);
              for (const e of i)
                null !== e.parent && e._remove(),
                  (e.parent = this),
                  this._children.splice(t, 0, e),
                  t++,
                  n++;
              return n;
            }
            _removeChildren(t, e = 1) {
              this._fireChange("children", this);
              for (let n = t; n < t + e; n++) this._children[n].parent = null;
              return this._children.splice(t, e);
            }
            _fireChange(t, e) {
              this.fire("change:" + t, e);
            }
          }
          he(_r, k);
          class Cr {
            constructor(t) {
              (this.document = t),
                (this._cloneGroups = new Map()),
                (this._slotFactory = null);
            }
            setSelection(t, e, n) {
              this.document.selection._setTo(t, e, n);
            }
            setSelectionFocus(t, e) {
              this.document.selection._setFocus(t, e);
            }
            createDocumentFragment(t) {
              return new _r(this.document, t);
            }
            createText(t) {
              return new ji(this.document, t);
            }
            createAttributeElement(t, e, n = {}) {
              const i = new Xo(this.document, t, e);
              return (
                "number" == typeof n.priority && (i._priority = n.priority),
                n.id && (i._id = n.id),
                n.renderUnsafeAttributes &&
                  i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes),
                i
              );
            }
            createContainerElement(t, e, n = {}, i = {}) {
              let o = null;
              ye(n) ? (i = n) : (o = n);
              const r = new Bo(this.document, t, e, o);
              return (
                i.renderUnsafeAttributes &&
                  r._unsafeAttributesToRender.push(...i.renderUnsafeAttributes),
                r
              );
            }
            createEditableElement(t, e, n = {}) {
              const i = new zo(this.document, t, e);
              return (
                (i._document = this.document),
                n.renderUnsafeAttributes &&
                  i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes),
                i
              );
            }
            createEmptyElement(t, e, n = {}) {
              const i = new nr(this.document, t, e);
              return (
                n.renderUnsafeAttributes &&
                  i._unsafeAttributesToRender.push(...n.renderUnsafeAttributes),
                i
              );
            }
            createUIElement(t, e, n) {
              const i = new fr(this.document, t, e);
              return n && (i.render = n), i;
            }
            createRawElement(t, e, n, i = {}) {
              const o = new wr(this.document, t, e);
              return (
                (o.render = n || (() => {})),
                i.renderUnsafeAttributes &&
                  o._unsafeAttributesToRender.push(...i.renderUnsafeAttributes),
                o
              );
            }
            setAttribute(t, e, n) {
              n._setAttribute(t, e);
            }
            removeAttribute(t, e) {
              e._removeAttribute(t);
            }
            addClass(t, e) {
              e._addClass(t);
            }
            removeClass(t, e) {
              e._removeClass(t);
            }
            setStyle(t, e, n) {
              ye(t) && void 0 === n && (n = e), n._setStyle(t, e);
            }
            removeStyle(t, e) {
              e._removeStyle(t);
            }
            setCustomProperty(t, e, n) {
              n._setCustomProperty(t, e);
            }
            removeCustomProperty(t, e) {
              return e._removeCustomProperty(t);
            }
            breakAttributes(t) {
              return t instanceof Oo
                ? this._breakAttributes(t)
                : this._breakAttributesRange(t);
            }
            breakContainer(t) {
              const e = t.parent;
              if (!e.is("containerElement"))
                throw new c(
                  "view-writer-break-non-container-element",
                  this.document
                );
              if (!e.parent)
                throw new c("view-writer-break-root", this.document);
              if (t.isAtStart) return Oo._createBefore(e);
              if (!t.isAtEnd) {
                const n = e._clone(!1);
                this.insert(Oo._createAfter(e), n);
                const i = new jo(t, Oo._createAt(e, "end")),
                  o = new Oo(n, 0);
                this.move(i, o);
              }
              return Oo._createAfter(e);
            }
            mergeAttributes(t) {
              const e = t.offset,
                n = t.parent;
              if (n.is("$text")) return t;
              if (n.is("attributeElement") && 0 === n.childCount) {
                const t = n.parent,
                  e = n.index;
                return (
                  n._remove(),
                  this._removeFromClonedElementsGroup(n),
                  this.mergeAttributes(new Oo(t, e))
                );
              }
              const i = n.getChild(e - 1),
                o = n.getChild(e);
              if (!i || !o) return t;
              if (i.is("$text") && o.is("$text")) return Dr(i, o);
              if (
                i.is("attributeElement") &&
                o.is("attributeElement") &&
                i.isSimilar(o)
              ) {
                const t = i.childCount;
                return (
                  i._appendChild(o.getChildren()),
                  o._remove(),
                  this._removeFromClonedElementsGroup(o),
                  this.mergeAttributes(new Oo(i, t))
                );
              }
              return t;
            }
            mergeContainers(t) {
              const e = t.nodeBefore,
                n = t.nodeAfter;
              if (
                !(
                  e &&
                  n &&
                  e.is("containerElement") &&
                  n.is("containerElement")
                )
              )
                throw new c(
                  "view-writer-merge-containers-invalid-position",
                  this.document
                );
              const i = e.getChild(e.childCount - 1),
                o =
                  i instanceof ji
                    ? Oo._createAt(i, "end")
                    : Oo._createAt(e, "end");
              return (
                this.move(jo._createIn(n), Oo._createAt(e, "end")),
                this.remove(jo._createOn(n)),
                o
              );
            }
            insert(t, e) {
              Sr((e = Ei(e) ? [...e] : [e]), this.document);
              const n = e.reduce((t, e) => {
                const n = t[t.length - 1],
                  i = !e.is("uiElement");
                return (
                  n && n.breakAttributes == i
                    ? n.nodes.push(e)
                    : t.push({ breakAttributes: i, nodes: [e] }),
                  t
                );
              }, []);
              let i = null,
                o = t;
              for (const { nodes: t, breakAttributes: e } of n) {
                const n = this._insertNodes(o, t, e);
                i || (i = n.start), (o = n.end);
              }
              return i ? new jo(i, o) : new jo(t);
            }
            remove(t) {
              const e = t instanceof jo ? t : jo._createOn(t);
              if ((Mr(e, this.document), e.isCollapsed))
                return new _r(this.document);
              const { start: n, end: i } = this._breakAttributesRange(e, !0),
                o = n.parent,
                r = i.offset - n.offset,
                s = o._removeChildren(n.offset, r);
              for (const t of s) this._removeFromClonedElementsGroup(t);
              const a = this.mergeAttributes(n);
              return (
                (e.start = a), (e.end = a.clone()), new _r(this.document, s)
              );
            }
            clear(t, e) {
              Mr(t, this.document);
              const n = t.getWalker({
                direction: "backward",
                ignoreElementEnd: !0,
              });
              for (const i of n) {
                const n = i.item;
                let o;
                if (n.is("element") && e.isSimilar(n)) o = jo._createOn(n);
                else if (
                  !i.nextPosition.isAfter(t.start) &&
                  n.is("$textProxy")
                ) {
                  const t = n
                    .getAncestors()
                    .find((t) => t.is("element") && e.isSimilar(t));
                  t && (o = jo._createIn(t));
                }
                o &&
                  (o.end.isAfter(t.end) && (o.end = t.end),
                  o.start.isBefore(t.start) && (o.start = t.start),
                  this.remove(o));
              }
            }
            move(t, e) {
              let n;
              if (e.isAfter(t.end)) {
                const i = (e = this._breakAttributes(e, !0)).parent,
                  o = i.childCount;
                (t = this._breakAttributesRange(t, !0)),
                  (n = this.remove(t)),
                  (e.offset += i.childCount - o);
              } else n = this.remove(t);
              return this.insert(e, n);
            }
            wrap(t, e) {
              if (!(e instanceof Xo))
                throw new c(
                  "view-writer-wrap-invalid-attribute",
                  this.document
                );
              if ((Mr(t, this.document), t.isCollapsed)) {
                let i = t.start;
                i.parent.is("element") &&
                  ((n = i.parent),
                  !Array.from(n.getChildren()).some(
                    (t) => !t.is("uiElement")
                  )) &&
                  (i = i.getLastMatchingPosition((t) =>
                    t.item.is("uiElement")
                  )),
                  (i = this._wrapPosition(i, e));
                const o = this.document.selection;
                return (
                  o.isCollapsed &&
                    o.getFirstPosition().isEqual(t.start) &&
                    this.setSelection(i),
                  new jo(i)
                );
              }
              return this._wrapRange(t, e);
              var n;
            }
            unwrap(t, e) {
              if (!(e instanceof Xo))
                throw new c(
                  "view-writer-unwrap-invalid-attribute",
                  this.document
                );
              if ((Mr(t, this.document), t.isCollapsed)) return t;
              const { start: n, end: i } = this._breakAttributesRange(t, !0),
                o = n.parent,
                r = this._unwrapChildren(o, n.offset, i.offset, e),
                s = this.mergeAttributes(r.start);
              s.isEqual(r.start) || r.end.offset--;
              const a = this.mergeAttributes(r.end);
              return new jo(s, a);
            }
            rename(t, e) {
              const n = new Bo(this.document, t, e.getAttributes());
              return (
                this.insert(Oo._createAfter(e), n),
                this.move(jo._createIn(e), Oo._createAt(n, 0)),
                this.remove(jo._createOn(e)),
                n
              );
            }
            clearClonedElementsGroup(t) {
              this._cloneGroups.delete(t);
            }
            createPositionAt(t, e) {
              return Oo._createAt(t, e);
            }
            createPositionAfter(t) {
              return Oo._createAfter(t);
            }
            createPositionBefore(t) {
              return Oo._createBefore(t);
            }
            createRange(t, e) {
              return new jo(t, e);
            }
            createRangeOn(t) {
              return jo._createOn(t);
            }
            createRangeIn(t) {
              return jo._createIn(t);
            }
            createSelection(t, e, n) {
              return new Ho(t, e, n);
            }
            createSlot(t) {
              if (!this._slotFactory)
                throw new c(
                  "view-writer-invalid-create-slot-context",
                  this.document
                );
              return this._slotFactory(this, t);
            }
            _registerSlotFactory(t) {
              this._slotFactory = t;
            }
            _clearSlotFactory() {
              this._slotFactory = null;
            }
            _insertNodes(t, e, n) {
              let i, o;
              if (
                ((i = n
                  ? vr(t)
                  : t.parent.is("$text")
                  ? t.parent.parent
                  : t.parent),
                !i)
              )
                throw new c(
                  "view-writer-invalid-position-container",
                  this.document
                );
              o = n
                ? this._breakAttributes(t, !0)
                : t.parent.is("$text")
                ? Er(t)
                : t;
              const r = i._insertChild(o.offset, e);
              for (const t of e) this._addToClonedElementsGroup(t);
              const s = o.getShiftedBy(r),
                a = this.mergeAttributes(o);
              a.isEqual(o) || s.offset--;
              const l = this.mergeAttributes(s);
              return new jo(a, l);
            }
            _wrapChildren(t, e, n, i) {
              let o = e;
              const r = [];
              for (; o < n; ) {
                const e = t.getChild(o),
                  n = e.is("$text"),
                  s = e.is("attributeElement");
                if (s && this._wrapAttributeElement(i, e)) r.push(new Oo(t, o));
                else if (n || !s || yr(i, e)) {
                  const n = i._clone();
                  e._remove(),
                    n._appendChild(e),
                    t._insertChild(o, n),
                    this._addToClonedElementsGroup(n),
                    r.push(new Oo(t, o));
                } else this._wrapChildren(e, 0, e.childCount, i);
                o++;
              }
              let s = 0;
              for (const t of r) {
                if (((t.offset -= s), t.offset == e)) continue;
                this.mergeAttributes(t).isEqual(t) || (s++, n--);
              }
              return jo._createFromParentsAndOffsets(t, e, t, n);
            }
            _unwrapChildren(t, e, n, i) {
              let o = e;
              const r = [];
              for (; o < n; ) {
                const e = t.getChild(o);
                if (e.is("attributeElement"))
                  if (e.isSimilar(i)) {
                    const i = e.getChildren(),
                      s = e.childCount;
                    e._remove(),
                      t._insertChild(o, i),
                      this._removeFromClonedElementsGroup(e),
                      r.push(new Oo(t, o), new Oo(t, o + s)),
                      (o += s),
                      (n += s - 1);
                  } else
                    this._unwrapAttributeElement(i, e)
                      ? (r.push(new Oo(t, o), new Oo(t, o + 1)), o++)
                      : (this._unwrapChildren(e, 0, e.childCount, i), o++);
                else o++;
              }
              let s = 0;
              for (const t of r) {
                if (((t.offset -= s), t.offset == e || t.offset == n)) continue;
                this.mergeAttributes(t).isEqual(t) || (s++, n--);
              }
              return jo._createFromParentsAndOffsets(t, e, t, n);
            }
            _wrapRange(t, e) {
              const { start: n, end: i } = this._breakAttributesRange(t, !0),
                o = n.parent,
                r = this._wrapChildren(o, n.offset, i.offset, e),
                s = this.mergeAttributes(r.start);
              s.isEqual(r.start) || r.end.offset--;
              const a = this.mergeAttributes(r.end);
              return new jo(s, a);
            }
            _wrapPosition(t, e) {
              if (e.isSimilar(t.parent)) return xr(t.clone());
              t.parent.is("$text") && (t = Er(t));
              const n = this.createAttributeElement();
              (n._priority = Number.POSITIVE_INFINITY),
                (n.isSimilar = () => !1),
                t.parent._insertChild(t.offset, n);
              const i = new jo(t, t.getShiftedBy(1));
              this.wrap(i, e);
              const o = new Oo(n.parent, n.index);
              n._remove();
              const r = o.nodeBefore,
                s = o.nodeAfter;
              return r instanceof ji && s instanceof ji ? Dr(r, s) : xr(o);
            }
            _wrapAttributeElement(t, e) {
              if (!Br(t, e)) return !1;
              if (t.name !== e.name || t.priority !== e.priority) return !1;
              for (const n of t.getAttributeKeys())
                if (
                  "class" !== n &&
                  "style" !== n &&
                  e.hasAttribute(n) &&
                  e.getAttribute(n) !== t.getAttribute(n)
                )
                  return !1;
              for (const n of t.getStyleNames())
                if (e.hasStyle(n) && e.getStyle(n) !== t.getStyle(n)) return !1;
              for (const n of t.getAttributeKeys())
                "class" !== n &&
                  "style" !== n &&
                  (e.hasAttribute(n) ||
                    this.setAttribute(n, t.getAttribute(n), e));
              for (const n of t.getStyleNames())
                e.hasStyle(n) || this.setStyle(n, t.getStyle(n), e);
              for (const n of t.getClassNames())
                e.hasClass(n) || this.addClass(n, e);
              return !0;
            }
            _unwrapAttributeElement(t, e) {
              if (!Br(t, e)) return !1;
              if (t.name !== e.name || t.priority !== e.priority) return !1;
              for (const n of t.getAttributeKeys())
                if (
                  "class" !== n &&
                  "style" !== n &&
                  (!e.hasAttribute(n) ||
                    e.getAttribute(n) !== t.getAttribute(n))
                )
                  return !1;
              if (!e.hasClass(...t.getClassNames())) return !1;
              for (const n of t.getStyleNames())
                if (!e.hasStyle(n) || e.getStyle(n) !== t.getStyle(n))
                  return !1;
              for (const n of t.getAttributeKeys())
                "class" !== n && "style" !== n && this.removeAttribute(n, e);
              return (
                this.removeClass(Array.from(t.getClassNames()), e),
                this.removeStyle(Array.from(t.getStyleNames()), e),
                !0
              );
            }
            _breakAttributesRange(t, e = !1) {
              const n = t.start,
                i = t.end;
              if ((Mr(t, this.document), t.isCollapsed)) {
                const n = this._breakAttributes(t.start, e);
                return new jo(n, n);
              }
              const o = this._breakAttributes(i, e),
                r = o.parent.childCount,
                s = this._breakAttributes(n, e);
              return (o.offset += o.parent.childCount - r), new jo(s, o);
            }
            _breakAttributes(t, e = !1) {
              const n = t.offset,
                i = t.parent;
              if (t.parent.is("emptyElement"))
                throw new c(
                  "view-writer-cannot-break-empty-element",
                  this.document
                );
              if (t.parent.is("uiElement"))
                throw new c(
                  "view-writer-cannot-break-ui-element",
                  this.document
                );
              if (t.parent.is("rawElement"))
                throw new c(
                  "view-writer-cannot-break-raw-element",
                  this.document
                );
              if (!e && i.is("$text") && Tr(i.parent)) return t.clone();
              if (Tr(i)) return t.clone();
              if (i.is("$text")) return this._breakAttributes(Er(t), e);
              if (n == i.childCount) {
                const t = new Oo(i.parent, i.index + 1);
                return this._breakAttributes(t, e);
              }
              if (0 === n) {
                const t = new Oo(i.parent, i.index);
                return this._breakAttributes(t, e);
              }
              {
                const t = i.index + 1,
                  o = i._clone();
                i.parent._insertChild(t, o), this._addToClonedElementsGroup(o);
                const r = i.childCount - n,
                  s = i._removeChildren(n, r);
                o._appendChild(s);
                const a = new Oo(i.parent, t);
                return this._breakAttributes(a, e);
              }
            }
            _addToClonedElementsGroup(t) {
              if (!t.root.is("rootElement")) return;
              if (t.is("element"))
                for (const e of t.getChildren())
                  this._addToClonedElementsGroup(e);
              const e = t.id;
              if (!e) return;
              let n = this._cloneGroups.get(e);
              n || ((n = new Set()), this._cloneGroups.set(e, n)),
                n.add(t),
                (t._clonesGroup = n);
            }
            _removeFromClonedElementsGroup(t) {
              if (t.is("element"))
                for (const e of t.getChildren())
                  this._removeFromClonedElementsGroup(e);
              const e = t.id;
              if (!e) return;
              const n = this._cloneGroups.get(e);
              n && n.delete(t);
            }
          }
          function vr(t) {
            let e = t.parent;
            for (; !Tr(e); ) {
              if (!e) return;
              e = e.parent;
            }
            return e;
          }
          function yr(t, e) {
            return (
              t.priority < e.priority ||
              (!(t.priority > e.priority) && t.getIdentity() < e.getIdentity())
            );
          }
          function xr(t) {
            const e = t.nodeBefore;
            if (e && e.is("$text")) return new Oo(e, e.data.length);
            const n = t.nodeAfter;
            return n && n.is("$text") ? new Oo(n, 0) : t;
          }
          function Er(t) {
            if (t.offset == t.parent.data.length)
              return new Oo(t.parent.parent, t.parent.index + 1);
            if (0 === t.offset) return new Oo(t.parent.parent, t.parent.index);
            const e = t.parent.data.slice(t.offset);
            return (
              (t.parent._data = t.parent.data.slice(0, t.offset)),
              t.parent.parent._insertChild(
                t.parent.index + 1,
                new ji(t.root.document, e)
              ),
              new Oo(t.parent.parent, t.parent.index + 1)
            );
          }
          function Dr(t, e) {
            const n = t.data.length;
            return (t._data += e.data), e._remove(), new Oo(t, n);
          }
          function Sr(t, e) {
            for (const n of t) {
              if (!Ir.some((t) => n instanceof t))
                throw new c("view-writer-insert-invalid-node-type", e);
              n.is("$text") || Sr(n.getChildren(), e);
            }
          }
          const Ir = [ji, Xo, Bo, nr, wr, fr];
          function Tr(t) {
            return t && (t.is("containerElement") || t.is("documentFragment"));
          }
          function Mr(t, e) {
            const n = vr(t.start),
              i = vr(t.end);
            if (!n || !i || n !== i)
              throw new c("view-writer-invalid-range-container", e);
          }
          function Br(t, e) {
            return null === t.id && null === e.id;
          }
          function Nr(t) {
            return "[object Text]" == Object.prototype.toString.call(t);
          }
          const zr = (t) => t.createTextNode(" "),
            Pr = (t) => {
              const e = t.createElement("span");
              return (e.dataset.ckeFiller = !0), (e.innerText = " "), e;
            },
            Lr = (t) => {
              const e = t.createElement("br");
              return (e.dataset.ckeFiller = !0), e;
            },
            Rr = "⁠".repeat(7);
          function Or(t) {
            return Nr(t) && t.data.substr(0, 7) === Rr;
          }
          function jr(t) {
            return 7 == t.data.length && Or(t);
          }
          function Fr(t) {
            return Or(t) ? t.data.slice(7) : t.data;
          }
          function Vr(t, e) {
            if (e.keyCode == dr.arrowleft) {
              const t = e.domTarget.ownerDocument.defaultView.getSelection();
              if (1 == t.rangeCount && t.getRangeAt(0).collapsed) {
                const e = t.getRangeAt(0).startContainer,
                  n = t.getRangeAt(0).startOffset;
                Or(e) && n <= 7 && t.collapse(e, 0);
              }
            }
          }
          function Hr(t, e, n, i = !1) {
            (n =
              n ||
              function (t, e) {
                return t === e;
              }),
              Array.isArray(t) || (t = Array.prototype.slice.call(t)),
              Array.isArray(e) || (e = Array.prototype.slice.call(e));
            const o = (function (t, e, n) {
              const i = Ur(t, e, n);
              if (-1 === i)
                return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
              const o = $r(t, i),
                r = $r(e, i),
                s = Ur(o, r, n),
                a = t.length - s,
                c = e.length - s;
              return { firstIndex: i, lastIndexOld: a, lastIndexNew: c };
            })(t, e, n);
            return i
              ? (function (t, e) {
                  const { firstIndex: n, lastIndexOld: i, lastIndexNew: o } = t;
                  if (-1 === n) return Array(e).fill("equal");
                  let r = [];
                  n > 0 && (r = r.concat(Array(n).fill("equal")));
                  o - n > 0 && (r = r.concat(Array(o - n).fill("insert")));
                  i - n > 0 && (r = r.concat(Array(i - n).fill("delete")));
                  o < e && (r = r.concat(Array(e - o).fill("equal")));
                  return r;
                })(o, e.length)
              : (function (t, e) {
                  const n = [],
                    { firstIndex: i, lastIndexOld: o, lastIndexNew: r } = e;
                  r - i > 0 &&
                    n.push({ index: i, type: "insert", values: t.slice(i, r) });
                  o - i > 0 &&
                    n.push({
                      index: i + (r - i),
                      type: "delete",
                      howMany: o - i,
                    });
                  return n;
                })(e, o);
          }
          function Ur(t, e, n) {
            for (let i = 0; i < Math.max(t.length, e.length); i++)
              if (void 0 === t[i] || void 0 === e[i] || !n(t[i], e[i]))
                return i;
            return -1;
          }
          function $r(t, e) {
            return t.slice(e).reverse();
          }
          function qr(t, e, n) {
            n =
              n ||
              function (t, e) {
                return t === e;
              };
            const i = t.length,
              o = e.length;
            if (i > 200 || o > 200 || i + o > 300)
              return qr.fastDiff(t, e, n, !0);
            let r, s;
            if (o < i) {
              const n = t;
              (t = e), (e = n), (r = "delete"), (s = "insert");
            } else (r = "insert"), (s = "delete");
            const a = t.length,
              c = e.length,
              l = c - a,
              d = {},
              h = {};
            function u(i) {
              const o = (void 0 !== h[i - 1] ? h[i - 1] : -1) + 1,
                l = void 0 !== h[i + 1] ? h[i + 1] : -1,
                u = o > l ? -1 : 1;
              d[i + u] && (d[i] = d[i + u].slice(0)),
                d[i] || (d[i] = []),
                d[i].push(o > l ? r : s);
              let m = Math.max(o, l),
                g = m - i;
              for (; g < a && m < c && n(t[g], e[m]); )
                g++, m++, d[i].push("equal");
              return m;
            }
            let m,
              g = 0;
            do {
              for (m = -g; m < l; m++) h[m] = u(m);
              for (m = l + g; m > l; m--) h[m] = u(m);
              (h[l] = u(l)), g++;
            } while (h[l] !== c);
            return d[l].slice(1);
          }
          function Gr(t, e, n) {
            t.insertBefore(n, t.childNodes[e] || null);
          }
          function Wr(t) {
            const e = t.parentNode;
            e && e.removeChild(t);
          }
          function Yr(t) {
            return t && t.nodeType === Node.COMMENT_NODE;
          }
          function Kr(t) {
            if (t) {
              if (t.defaultView) return t instanceof t.defaultView.Document;
              if (t.ownerDocument && t.ownerDocument.defaultView)
                return t instanceof t.ownerDocument.defaultView.Node;
            }
            return !1;
          }
          qr.fastDiff = Hr;
          var Qr = n(3379),
            Zr = n.n(Qr),
            Jr = n(4401),
            Xr = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Jr.Z, Xr);
          Jr.Z.locals;
          class ts {
            constructor(t, e) {
              (this.domDocuments = new Set()),
                (this.domConverter = t),
                (this.markedAttributes = new Set()),
                (this.markedChildren = new Set()),
                (this.markedTexts = new Set()),
                (this.selection = e),
                this.set("isFocused", !1),
                this.set("isSelecting", !1),
                sr.isBlink &&
                  !sr.isAndroid &&
                  this.on("change:isSelecting", () => {
                    this.isSelecting || this.render();
                  }),
                (this._inlineFiller = null),
                (this._fakeSelectionContainer = null);
            }
            markToSync(t, e) {
              if ("text" === t)
                this.domConverter.mapViewToDom(e.parent) &&
                  this.markedTexts.add(e);
              else {
                if (!this.domConverter.mapViewToDom(e)) return;
                if ("attributes" === t) this.markedAttributes.add(e);
                else {
                  if ("children" !== t)
                    throw new c("view-renderer-unknown-type", this);
                  this.markedChildren.add(e);
                }
              }
            }
            render() {
              let t;
              const e = !(sr.isBlink && !sr.isAndroid) || !this.isSelecting;
              for (const t of this.markedChildren)
                this._updateChildrenMappings(t);
              e
                ? (this._inlineFiller &&
                    !this._isSelectionInInlineFiller() &&
                    this._removeInlineFiller(),
                  this._inlineFiller
                    ? (t = this._getInlineFillerPosition())
                    : this._needsInlineFillerAtSelection() &&
                      ((t = this.selection.getFirstPosition()),
                      this.markedChildren.add(t.parent)))
                : this._inlineFiller &&
                  this._inlineFiller.parentNode &&
                  ((t = this.domConverter.domPositionToView(
                    this._inlineFiller
                  )),
                  t.parent.is("$text") && (t = Oo._createBefore(t.parent)));
              for (const t of this.markedAttributes) this._updateAttrs(t);
              for (const e of this.markedChildren)
                this._updateChildren(e, { inlineFillerPosition: t });
              for (const e of this.markedTexts)
                !this.markedChildren.has(e.parent) &&
                  this.domConverter.mapViewToDom(e.parent) &&
                  this._updateText(e, { inlineFillerPosition: t });
              if (e)
                if (t) {
                  const e = this.domConverter.viewPositionToDom(t),
                    n = e.parent.ownerDocument;
                  Or(e.parent)
                    ? (this._inlineFiller = e.parent)
                    : (this._inlineFiller = es(n, e.parent, e.offset));
                } else this._inlineFiller = null;
              this._updateFocus(),
                this._updateSelection(),
                this.markedTexts.clear(),
                this.markedAttributes.clear(),
                this.markedChildren.clear();
            }
            _updateChildrenMappings(t) {
              const e = this.domConverter.mapViewToDom(t);
              if (!e) return;
              const n = Array.from(
                  this.domConverter.mapViewToDom(t).childNodes
                ),
                i = Array.from(
                  this.domConverter.viewChildrenToDom(t, e.ownerDocument, {
                    withChildren: !1,
                  })
                ),
                o = this._diffNodeLists(n, i),
                r = this._findReplaceActions(o, n, i);
              if (-1 !== r.indexOf("replace")) {
                const e = { equal: 0, insert: 0, delete: 0 };
                for (const o of r)
                  if ("replace" === o) {
                    const o = e.equal + e.insert,
                      r = e.equal + e.delete,
                      s = t.getChild(o);
                    !s ||
                      s.is("uiElement") ||
                      s.is("rawElement") ||
                      this._updateElementMappings(s, n[r]),
                      Wr(i[o]),
                      e.equal++;
                  } else e[o]++;
              }
            }
            _updateElementMappings(t, e) {
              this.domConverter.unbindDomElement(e),
                this.domConverter.bindElements(e, t),
                this.markedChildren.add(t),
                this.markedAttributes.add(t);
            }
            _getInlineFillerPosition() {
              const t = this.selection.getFirstPosition();
              return t.parent.is("$text")
                ? Oo._createBefore(this.selection.getFirstPosition().parent)
                : t;
            }
            _isSelectionInInlineFiller() {
              if (1 != this.selection.rangeCount || !this.selection.isCollapsed)
                return !1;
              const t = this.selection.getFirstPosition(),
                e = this.domConverter.viewPositionToDom(t);
              return !!(e && Nr(e.parent) && Or(e.parent));
            }
            _removeInlineFiller() {
              const t = this._inlineFiller;
              if (!Or(t)) throw new c("view-renderer-filler-was-lost", this);
              jr(t) ? t.remove() : (t.data = t.data.substr(7)),
                (this._inlineFiller = null);
            }
            _needsInlineFillerAtSelection() {
              if (1 != this.selection.rangeCount || !this.selection.isCollapsed)
                return !1;
              const t = this.selection.getFirstPosition(),
                e = t.parent,
                n = t.offset;
              if (!this.domConverter.mapViewToDom(e.root)) return !1;
              if (!e.is("element")) return !1;
              if (
                !(function (t) {
                  if ("false" == t.getAttribute("contenteditable")) return !1;
                  const e = t.findAncestor((t) =>
                    t.hasAttribute("contenteditable")
                  );
                  return !e || "true" == e.getAttribute("contenteditable");
                })(e)
              )
                return !1;
              if (n === e.getFillerOffset()) return !1;
              const i = t.nodeBefore,
                o = t.nodeAfter;
              return !(i instanceof ji || o instanceof ji);
            }
            _updateText(t, e) {
              const n = this.domConverter.findCorrespondingDomText(t),
                i = this.domConverter.viewToDom(t, n.ownerDocument),
                o = n.data;
              let r = i.data;
              const s = e.inlineFillerPosition;
              if (
                (s &&
                  s.parent == t.parent &&
                  s.offset == t.index &&
                  (r = Rr + r),
                o != r)
              ) {
                const t = Hr(o, r);
                for (const e of t)
                  "insert" === e.type
                    ? n.insertData(e.index, e.values.join(""))
                    : n.deleteData(e.index, e.howMany);
              }
            }
            _updateAttrs(t) {
              const e = this.domConverter.mapViewToDom(t);
              if (!e) return;
              const n = Array.from(e.attributes).map((t) => t.name),
                i = t.getAttributeKeys();
              for (const n of i)
                this.domConverter.setDomElementAttribute(
                  e,
                  n,
                  t.getAttribute(n),
                  t
                );
              for (const i of n)
                t.hasAttribute(i) ||
                  this.domConverter.removeDomElementAttribute(e, i);
            }
            _updateChildren(t, e) {
              const n = this.domConverter.mapViewToDom(t);
              if (!n) return;
              const i = e.inlineFillerPosition,
                o = this.domConverter.mapViewToDom(t).childNodes,
                r = Array.from(
                  this.domConverter.viewChildrenToDom(t, n.ownerDocument, {
                    bind: !0,
                  })
                );
              i && i.parent === t && es(n.ownerDocument, r, i.offset);
              const s = this._diffNodeLists(o, r);
              let a = 0;
              const c = new Set();
              for (const t of s)
                "delete" === t ? (c.add(o[a]), Wr(o[a])) : "equal" === t && a++;
              a = 0;
              for (const t of s)
                "insert" === t
                  ? (Gr(n, a, r[a]), a++)
                  : "equal" === t &&
                    (this._markDescendantTextToSync(
                      this.domConverter.domToView(r[a])
                    ),
                    a++);
              for (const t of c)
                t.parentNode || this.domConverter.unbindDomElement(t);
            }
            _diffNodeLists(t, e) {
              return qr(
                (t = (function (t, e) {
                  const n = Array.from(t);
                  if (0 == n.length || !e) return n;
                  n[n.length - 1] == e && n.pop();
                  return n;
                })(t, this._fakeSelectionContainer)),
                e,
                is.bind(null, this.domConverter)
              );
            }
            _findReplaceActions(t, e, n) {
              if (-1 === t.indexOf("insert") || -1 === t.indexOf("delete"))
                return t;
              let i = [],
                o = [],
                r = [];
              const s = { equal: 0, insert: 0, delete: 0 };
              for (const a of t)
                "insert" === a
                  ? r.push(n[s.equal + s.insert])
                  : "delete" === a
                  ? o.push(e[s.equal + s.delete])
                  : ((i = i.concat(
                      qr(o, r, ns).map((t) => ("equal" === t ? "replace" : t))
                    )),
                    i.push("equal"),
                    (o = []),
                    (r = [])),
                  s[a]++;
              return i.concat(
                qr(o, r, ns).map((t) => ("equal" === t ? "replace" : t))
              );
            }
            _markDescendantTextToSync(t) {
              if (t)
                if (t.is("$text")) this.markedTexts.add(t);
                else if (t.is("element"))
                  for (const e of t.getChildren())
                    this._markDescendantTextToSync(e);
            }
            _updateSelection() {
              if (
                sr.isBlink &&
                !sr.isAndroid &&
                this.isSelecting &&
                !this.markedChildren.size
              )
                return;
              if (0 === this.selection.rangeCount)
                return (
                  this._removeDomSelection(), void this._removeFakeSelection()
                );
              const t = this.domConverter.mapViewToDom(
                this.selection.editableElement
              );
              this.isFocused &&
                t &&
                (this.selection.isFake
                  ? this._updateFakeSelection(t)
                  : (this._removeFakeSelection(), this._updateDomSelection(t)));
            }
            _updateFakeSelection(t) {
              const e = t.ownerDocument;
              this._fakeSelectionContainer ||
                (this._fakeSelectionContainer = (function (t) {
                  const e = t.createElement("div");
                  return (
                    (e.className = "ck-fake-selection-container"),
                    Object.assign(e.style, {
                      position: "fixed",
                      top: 0,
                      left: "-9999px",
                      width: "42px",
                    }),
                    (e.textContent = " "),
                    e
                  );
                })(e));
              const n = this._fakeSelectionContainer;
              if (
                (this.domConverter.bindFakeSelection(n, this.selection),
                !this._fakeSelectionNeedsUpdate(t))
              )
                return;
              (n.parentElement && n.parentElement == t) || t.appendChild(n),
                (n.textContent = this.selection.fakeSelectionLabel || " ");
              const i = e.getSelection(),
                o = e.createRange();
              i.removeAllRanges(), o.selectNodeContents(n), i.addRange(o);
            }
            _updateDomSelection(t) {
              const e = t.ownerDocument.defaultView.getSelection();
              if (!this._domSelectionNeedsUpdate(e)) return;
              const n = this.domConverter.viewPositionToDom(
                  this.selection.anchor
                ),
                i = this.domConverter.viewPositionToDom(this.selection.focus);
              e.collapse(n.parent, n.offset),
                e.extend(i.parent, i.offset),
                sr.isGecko &&
                  (function (t, e) {
                    const n = t.parent;
                    if (
                      n.nodeType != Node.ELEMENT_NODE ||
                      t.offset != n.childNodes.length - 1
                    )
                      return;
                    const i = n.childNodes[t.offset];
                    i && "BR" == i.tagName && e.addRange(e.getRangeAt(0));
                  })(i, e);
            }
            _domSelectionNeedsUpdate(t) {
              if (!this.domConverter.isDomSelectionCorrect(t)) return !0;
              const e = t && this.domConverter.domSelectionToView(t);
              return (
                (!e || !this.selection.isEqual(e)) &&
                !(!this.selection.isCollapsed && this.selection.isSimilar(e))
              );
            }
            _fakeSelectionNeedsUpdate(t) {
              const e = this._fakeSelectionContainer,
                n = t.ownerDocument.getSelection();
              return (
                !e ||
                e.parentElement !== t ||
                (n.anchorNode !== e && !e.contains(n.anchorNode)) ||
                e.textContent !== this.selection.fakeSelectionLabel
              );
            }
            _removeDomSelection() {
              for (const t of this.domDocuments) {
                if (t.getSelection().rangeCount) {
                  const e = t.activeElement,
                    n = this.domConverter.mapDomToView(e);
                  e && n && t.getSelection().removeAllRanges();
                }
              }
            }
            _removeFakeSelection() {
              const t = this._fakeSelectionContainer;
              t && t.remove();
            }
            _updateFocus() {
              if (this.isFocused) {
                const t = this.selection.editableElement;
                t && this.domConverter.focus(t);
              }
            }
          }
          function es(t, e, n) {
            const i = e instanceof Array ? e : e.childNodes,
              o = i[n];
            if (Nr(o)) return (o.data = Rr + o.data), o;
            {
              const o = t.createTextNode(Rr);
              return Array.isArray(e) ? i.splice(n, 0, o) : Gr(e, n, o), o;
            }
          }
          function ns(t, e) {
            return (
              Kr(t) &&
              Kr(e) &&
              !Nr(t) &&
              !Nr(e) &&
              !Yr(t) &&
              !Yr(e) &&
              t.tagName.toLowerCase() === e.tagName.toLowerCase()
            );
          }
          function is(t, e, n) {
            return (
              e === n ||
              (Nr(e) && Nr(n)
                ? e.data === n.data
                : !(!t.isBlockFiller(e) || !t.isBlockFiller(n)))
            );
          }
          he(ts, re);
          const os = { window, document };
          function rs(t) {
            let e = 0;
            for (; t.previousSibling; ) (t = t.previousSibling), e++;
            return e;
          }
          function ss(t) {
            const e = [];
            for (; t && t.nodeType != Node.DOCUMENT_NODE; )
              e.unshift(t), (t = t.parentNode);
            return e;
          }
          const as = Lr(document),
            cs = zr(document),
            ls = Pr(document),
            ds = "data-ck-unsafe-attribute-",
            hs = "data-ck-unsafe-element";
          class us {
            constructor(t, e = {}) {
              (this.document = t),
                (this.renderingMode = e.renderingMode || "editing"),
                (this.blockFillerMode =
                  e.blockFillerMode ||
                  ("editing" === this.renderingMode ? "br" : "nbsp")),
                (this.preElements = ["pre"]),
                (this.blockElements = [
                  "address",
                  "article",
                  "aside",
                  "blockquote",
                  "caption",
                  "center",
                  "dd",
                  "details",
                  "dir",
                  "div",
                  "dl",
                  "dt",
                  "fieldset",
                  "figcaption",
                  "figure",
                  "footer",
                  "form",
                  "h1",
                  "h2",
                  "h3",
                  "h4",
                  "h5",
                  "h6",
                  "header",
                  "hgroup",
                  "legend",
                  "li",
                  "main",
                  "menu",
                  "nav",
                  "ol",
                  "p",
                  "pre",
                  "section",
                  "summary",
                  "table",
                  "tbody",
                  "td",
                  "tfoot",
                  "th",
                  "thead",
                  "tr",
                  "ul",
                ]),
                (this.inlineObjectElements = [
                  "object",
                  "iframe",
                  "input",
                  "button",
                  "textarea",
                  "select",
                  "option",
                  "video",
                  "embed",
                  "audio",
                  "img",
                  "canvas",
                ]),
                (this.unsafeElements = ["script", "style"]),
                (this._domToViewMapping = new WeakMap()),
                (this._viewToDomMapping = new WeakMap()),
                (this._fakeSelectionMapping = new WeakMap()),
                (this._rawContentElementMatcher = new Hi()),
                (this._encounteredRawContentDomNodes = new WeakSet());
            }
            bindFakeSelection(t, e) {
              this._fakeSelectionMapping.set(t, new Ho(e));
            }
            fakeSelectionToView(t) {
              return this._fakeSelectionMapping.get(t);
            }
            bindElements(t, e) {
              this._domToViewMapping.set(t, e),
                this._viewToDomMapping.set(e, t);
            }
            unbindDomElement(t) {
              const e = this._domToViewMapping.get(t);
              if (e) {
                this._domToViewMapping.delete(t),
                  this._viewToDomMapping.delete(e);
                for (const e of t.childNodes) this.unbindDomElement(e);
              }
            }
            bindDocumentFragments(t, e) {
              this._domToViewMapping.set(t, e),
                this._viewToDomMapping.set(e, t);
            }
            shouldRenderAttribute(t, e, n) {
              return (
                "data" === this.renderingMode ||
                (!(t = t.toLowerCase()).startsWith("on") &&
                  ("srcdoc" !== t ||
                    !e.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) &&
                  (("img" === n && ("src" === t || "srcset" === t)) ||
                    ("source" === n && "srcset" === t) ||
                    !e.match(
                      /^\s*(javascript:|data:(image\/svg|text\/x?html))/i
                    )))
              );
            }
            setContentOf(t, e) {
              if ("data" === this.renderingMode) return void (t.innerHTML = e);
              const n = new DOMParser().parseFromString(e, "text/html"),
                i = n.createDocumentFragment(),
                o = n.body.childNodes;
              for (; o.length > 0; ) i.appendChild(o[0]);
              const r = n.createTreeWalker(i, NodeFilter.SHOW_ELEMENT),
                s = [];
              let a;
              for (; (a = r.nextNode()); ) s.push(a);
              for (const t of s) {
                for (const e of t.getAttributeNames())
                  this.setDomElementAttribute(t, e, t.getAttribute(e));
                const e = t.tagName.toLowerCase();
                this._shouldRenameElement(e) &&
                  (ps(e),
                  t.replaceWith(this._createReplacementDomElement(e, t)));
              }
              for (; t.firstChild; ) t.firstChild.remove();
              t.append(i);
            }
            viewToDom(t, e, n = {}) {
              if (t.is("$text")) {
                const n = this._processDataFromViewText(t);
                return e.createTextNode(n);
              }
              {
                if (this.mapViewToDom(t)) return this.mapViewToDom(t);
                let i;
                if (t.is("documentFragment"))
                  (i = e.createDocumentFragment()),
                    n.bind && this.bindDocumentFragments(i, t);
                else {
                  if (t.is("uiElement"))
                    return (
                      (i =
                        "$comment" === t.name
                          ? e.createComment(t.getCustomProperty("$rawContent"))
                          : t.render(e, this)),
                      n.bind && this.bindElements(i, t),
                      i
                    );
                  this._shouldRenameElement(t.name)
                    ? (ps(t.name),
                      (i = this._createReplacementDomElement(t.name)))
                    : (i = t.hasAttribute("xmlns")
                        ? e.createElementNS(t.getAttribute("xmlns"), t.name)
                        : e.createElement(t.name)),
                    t.is("rawElement") && t.render(i, this),
                    n.bind && this.bindElements(i, t);
                  for (const e of t.getAttributeKeys())
                    this.setDomElementAttribute(i, e, t.getAttribute(e), t);
                }
                if (!1 !== n.withChildren)
                  for (const o of this.viewChildrenToDom(t, e, n))
                    i.appendChild(o);
                return i;
              }
            }
            setDomElementAttribute(t, e, n, i = null) {
              const o =
                this.shouldRenderAttribute(e, n, t.tagName.toLowerCase()) ||
                (i && i.shouldRenderUnsafeAttribute(e));
              o ||
                l("domconverter-unsafe-attribute-detected", {
                  domElement: t,
                  key: e,
                  value: n,
                }),
                t.hasAttribute(e) && !o
                  ? t.removeAttribute(e)
                  : t.hasAttribute(ds + e) && o && t.removeAttribute(ds + e),
                t.setAttribute(o ? e : ds + e, n);
            }
            removeDomElementAttribute(t, e) {
              e != hs && (t.removeAttribute(e), t.removeAttribute(ds + e));
            }
            *viewChildrenToDom(t, e, n = {}) {
              const i = t.getFillerOffset && t.getFillerOffset();
              let o = 0;
              for (const r of t.getChildren()) {
                i === o && (yield this._getBlockFiller(e));
                const t =
                  r.is("element") &&
                  r.getCustomProperty("dataPipeline:transparentRendering");
                t && "data" == this.renderingMode
                  ? yield* this.viewChildrenToDom(r, e, n)
                  : (t &&
                      l(
                        "domconverter-transparent-rendering-unsupported-in-editing-pipeline",
                        { viewElement: r }
                      ),
                    yield this.viewToDom(r, e, n)),
                  o++;
              }
              i === o && (yield this._getBlockFiller(e));
            }
            viewRangeToDom(t) {
              const e = this.viewPositionToDom(t.start),
                n = this.viewPositionToDom(t.end),
                i = document.createRange();
              return (
                i.setStart(e.parent, e.offset), i.setEnd(n.parent, n.offset), i
              );
            }
            viewPositionToDom(t) {
              const e = t.parent;
              if (e.is("$text")) {
                const n = this.findCorrespondingDomText(e);
                if (!n) return null;
                let i = t.offset;
                return Or(n) && (i += 7), { parent: n, offset: i };
              }
              {
                let n, i, o;
                if (0 === t.offset) {
                  if (((n = this.mapViewToDom(e)), !n)) return null;
                  o = n.childNodes[0];
                } else {
                  const e = t.nodeBefore;
                  if (
                    ((i = e.is("$text")
                      ? this.findCorrespondingDomText(e)
                      : this.mapViewToDom(t.nodeBefore)),
                    !i)
                  )
                    return null;
                  (n = i.parentNode), (o = i.nextSibling);
                }
                if (Nr(o) && Or(o)) return { parent: o, offset: 7 };
                return { parent: n, offset: i ? rs(i) + 1 : 0 };
              }
            }
            domToView(t, e = {}) {
              if (this.isBlockFiller(t)) return null;
              const n = this.getHostViewElement(t);
              if (n) return n;
              if (Yr(t) && e.skipComments) return null;
              if (Nr(t)) {
                if (jr(t)) return null;
                {
                  const e = this._processDataFromDomText(t);
                  return "" === e ? null : new ji(this.document, e);
                }
              }
              {
                if (this.mapDomToView(t)) return this.mapDomToView(t);
                let n;
                if (this.isDocumentFragment(t))
                  (n = new _r(this.document)),
                    e.bind && this.bindDocumentFragments(t, n);
                else {
                  (n = this._createViewElement(t, e)),
                    e.bind && this.bindElements(t, n);
                  const i = t.attributes;
                  if (i)
                    for (let t = i.length, e = 0; e < t; e++)
                      n._setAttribute(i[e].name, i[e].value);
                  if (this._isViewElementWithRawContent(n, e) || Yr(t)) {
                    const e = Yr(t) ? t.data : t.innerHTML;
                    return (
                      n._setCustomProperty("$rawContent", e),
                      this._encounteredRawContentDomNodes.add(t),
                      n
                    );
                  }
                }
                if (!1 !== e.withChildren)
                  for (const i of this.domChildrenToView(t, e))
                    n._appendChild(i);
                return n;
              }
            }
            *domChildrenToView(t, e = {}) {
              for (let n = 0; n < t.childNodes.length; n++) {
                const i = t.childNodes[n],
                  o = this.domToView(i, e);
                null !== o && (yield o);
              }
            }
            domSelectionToView(t) {
              if (1 === t.rangeCount) {
                let e = t.getRangeAt(0).startContainer;
                Nr(e) && (e = e.parentNode);
                const n = this.fakeSelectionToView(e);
                if (n) return n;
              }
              const e = this.isDomSelectionBackward(t),
                n = [];
              for (let e = 0; e < t.rangeCount; e++) {
                const i = t.getRangeAt(e),
                  o = this.domRangeToView(i);
                o && n.push(o);
              }
              return new Ho(n, { backward: e });
            }
            domRangeToView(t) {
              const e = this.domPositionToView(t.startContainer, t.startOffset),
                n = this.domPositionToView(t.endContainer, t.endOffset);
              return e && n ? new jo(e, n) : null;
            }
            domPositionToView(t, e = 0) {
              if (this.isBlockFiller(t))
                return this.domPositionToView(t.parentNode, rs(t));
              const n = this.mapDomToView(t);
              if (n && (n.is("uiElement") || n.is("rawElement")))
                return Oo._createBefore(n);
              if (Nr(t)) {
                if (jr(t)) return this.domPositionToView(t.parentNode, rs(t));
                const n = this.findCorrespondingViewText(t);
                let i = e;
                return n
                  ? (Or(t) && ((i -= 7), (i = i < 0 ? 0 : i)), new Oo(n, i))
                  : null;
              }
              if (0 === e) {
                const e = this.mapDomToView(t);
                if (e) return new Oo(e, 0);
              } else {
                const n = t.childNodes[e - 1],
                  i = Nr(n)
                    ? this.findCorrespondingViewText(n)
                    : this.mapDomToView(n);
                if (i && i.parent) return new Oo(i.parent, i.index + 1);
              }
              return null;
            }
            mapDomToView(t) {
              return (
                this.getHostViewElement(t) || this._domToViewMapping.get(t)
              );
            }
            findCorrespondingViewText(t) {
              if (jr(t)) return null;
              const e = this.getHostViewElement(t);
              if (e) return e;
              const n = t.previousSibling;
              if (n) {
                if (!this.isElement(n)) return null;
                const t = this.mapDomToView(n);
                if (t) {
                  return t.nextSibling instanceof ji ? t.nextSibling : null;
                }
              } else {
                const e = this.mapDomToView(t.parentNode);
                if (e) {
                  const t = e.getChild(0);
                  return t instanceof ji ? t : null;
                }
              }
              return null;
            }
            mapViewToDom(t) {
              return this._viewToDomMapping.get(t);
            }
            findCorrespondingDomText(t) {
              const e = t.previousSibling;
              return e && this.mapViewToDom(e)
                ? this.mapViewToDom(e).nextSibling
                : !e && t.parent && this.mapViewToDom(t.parent)
                ? this.mapViewToDom(t.parent).childNodes[0]
                : null;
            }
            focus(t) {
              const e = this.mapViewToDom(t);
              if (e && e.ownerDocument.activeElement !== e) {
                const { scrollX: t, scrollY: n } = os.window,
                  i = [];
                ms(e, (t) => {
                  const { scrollLeft: e, scrollTop: n } = t;
                  i.push([e, n]);
                }),
                  e.focus(),
                  ms(e, (t) => {
                    const [e, n] = i.shift();
                    (t.scrollLeft = e), (t.scrollTop = n);
                  }),
                  os.window.scrollTo(t, n);
              }
            }
            isElement(t) {
              return t && t.nodeType == Node.ELEMENT_NODE;
            }
            isDocumentFragment(t) {
              return t && t.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
            }
            isBlockFiller(t) {
              return "br" == this.blockFillerMode
                ? t.isEqualNode(as)
                : !(
                    "BR" !== t.tagName ||
                    !gs(t, this.blockElements) ||
                    1 !== t.parentNode.childNodes.length
                  ) ||
                    t.isEqualNode(ls) ||
                    (function (t, e) {
                      return (
                        t.isEqualNode(cs) &&
                        gs(t, e) &&
                        1 === t.parentNode.childNodes.length
                      );
                    })(t, this.blockElements);
            }
            isDomSelectionBackward(t) {
              if (t.isCollapsed) return !1;
              const e = document.createRange();
              e.setStart(t.anchorNode, t.anchorOffset),
                e.setEnd(t.focusNode, t.focusOffset);
              const n = e.collapsed;
              return e.detach(), n;
            }
            getHostViewElement(t) {
              const e = ss(t);
              for (e.pop(); e.length; ) {
                const t = e.pop(),
                  n = this._domToViewMapping.get(t);
                if (n && (n.is("uiElement") || n.is("rawElement"))) return n;
              }
              return null;
            }
            isDomSelectionCorrect(t) {
              return (
                this._isDomSelectionPositionCorrect(
                  t.anchorNode,
                  t.anchorOffset
                ) &&
                this._isDomSelectionPositionCorrect(t.focusNode, t.focusOffset)
              );
            }
            registerRawContentMatcher(t) {
              this._rawContentElementMatcher.add(t);
            }
            _getBlockFiller(t) {
              switch (this.blockFillerMode) {
                case "nbsp":
                  return zr(t);
                case "markedNbsp":
                  return Pr(t);
                case "br":
                  return Lr(t);
              }
            }
            _isDomSelectionPositionCorrect(t, e) {
              if (Nr(t) && Or(t) && e < 7) return !1;
              if (this.isElement(t) && Or(t.childNodes[e])) return !1;
              const n = this.mapDomToView(t);
              return !n || (!n.is("uiElement") && !n.is("rawElement"));
            }
            _processDataFromViewText(t) {
              let e = t.data;
              if (
                t.getAncestors().some((t) => this.preElements.includes(t.name))
              )
                return e;
              if (" " == e.charAt(0)) {
                const n = this._getTouchingInlineViewNode(t, !1);
                (!(n && n.is("$textProxy") && this._nodeEndsWithSpace(n)) &&
                  n) ||
                  (e = " " + e.substr(1));
              }
              if (" " == e.charAt(e.length - 1)) {
                const n = this._getTouchingInlineViewNode(t, !0),
                  i = n && n.is("$textProxy") && " " == n.data.charAt(0);
                (" " != e.charAt(e.length - 2) && n && !i) ||
                  (e = e.substr(0, e.length - 1) + " ");
              }
              return e.replace(/ {2}/g, "  ");
            }
            _nodeEndsWithSpace(t) {
              if (
                t.getAncestors().some((t) => this.preElements.includes(t.name))
              )
                return !1;
              const e = this._processDataFromViewText(t);
              return " " == e.charAt(e.length - 1);
            }
            _processDataFromDomText(t) {
              let e = t.data;
              if (
                (function (t, e) {
                  return ss(t).some(
                    (t) => t.tagName && e.includes(t.tagName.toLowerCase())
                  );
                })(t, this.preElements)
              )
                return Fr(t);
              e = e.replace(/[ \n\t\r]{1,}/g, " ");
              const n = this._getTouchingInlineDomNode(t, !1),
                i = this._getTouchingInlineDomNode(t, !0),
                o = this._checkShouldLeftTrimDomText(t, n),
                r = this._checkShouldRightTrimDomText(t, i);
              o && (e = e.replace(/^ /, "")),
                r && (e = e.replace(/ $/, "")),
                (e = Fr(new Text(e))),
                (e = e.replace(/ \u00A0/g, "  "));
              const s = i && this.isElement(i) && "BR" != i.tagName,
                a = i && Nr(i) && " " == i.data.charAt(0);
              return (
                (/( |\u00A0)\u00A0$/.test(e) || !i || s || a) &&
                  (e = e.replace(/\u00A0$/, " ")),
                (o || (n && this.isElement(n) && "BR" != n.tagName)) &&
                  (e = e.replace(/^\u00A0/, " ")),
                e
              );
            }
            _checkShouldLeftTrimDomText(t, e) {
              return (
                !e ||
                (this.isElement(e)
                  ? "BR" === e.tagName
                  : !this._encounteredRawContentDomNodes.has(
                      t.previousSibling
                    ) && /[^\S\u00A0]/.test(e.data.charAt(e.data.length - 1)))
              );
            }
            _checkShouldRightTrimDomText(t, e) {
              return !e && !Or(t);
            }
            _getTouchingInlineViewNode(t, e) {
              const n = new Ro({
                startPosition: e ? Oo._createAfter(t) : Oo._createBefore(t),
                direction: e ? "forward" : "backward",
              });
              for (const t of n) {
                if (
                  t.item.is("element") &&
                  this.inlineObjectElements.includes(t.item.name)
                )
                  return t.item;
                if (t.item.is("containerElement")) return null;
                if (t.item.is("element", "br")) return null;
                if (t.item.is("$textProxy")) return t.item;
              }
              return null;
            }
            _getTouchingInlineDomNode(t, e) {
              if (!t.parentNode) return null;
              const n = e ? "firstChild" : "lastChild",
                i = e ? "nextSibling" : "previousSibling";
              let o = !0;
              do {
                if (
                  (!o && t[n]
                    ? (t = t[n])
                    : t[i]
                    ? ((t = t[i]), (o = !1))
                    : ((t = t.parentNode), (o = !0)),
                  !t || this._isBlockElement(t))
                )
                  return null;
              } while (
                !Nr(t) &&
                "BR" != t.tagName &&
                !this._isInlineObjectElement(t)
              );
              return t;
            }
            _isBlockElement(t) {
              return (
                this.isElement(t) &&
                this.blockElements.includes(t.tagName.toLowerCase())
              );
            }
            _isInlineObjectElement(t) {
              return (
                this.isElement(t) &&
                this.inlineObjectElements.includes(t.tagName.toLowerCase())
              );
            }
            _createViewElement(t, e) {
              if (Yr(t)) return new fr(this.document, "$comment");
              const n = e.keepOriginalCase
                ? t.tagName
                : t.tagName.toLowerCase();
              return new To(this.document, n);
            }
            _isViewElementWithRawContent(t, e) {
              return (
                !1 !== e.withChildren && this._rawContentElementMatcher.match(t)
              );
            }
            _shouldRenameElement(t) {
              const e = t.toLowerCase();
              return (
                "editing" === this.renderingMode &&
                this.unsafeElements.includes(e)
              );
            }
            _createReplacementDomElement(t, e = null) {
              const n = document.createElement("span");
              if ((n.setAttribute(hs, t), e)) {
                for (; e.firstChild; ) n.appendChild(e.firstChild);
                for (const t of e.getAttributeNames())
                  n.setAttribute(t, e.getAttribute(t));
              }
              return n;
            }
          }
          function ms(t, e) {
            for (; t && t != os.document; ) e(t), (t = t.parentNode);
          }
          function gs(t, e) {
            const n = t.parentNode;
            return n && n.tagName && e.includes(n.tagName.toLowerCase());
          }
          function ps(t) {
            "script" === t && l("domconverter-unsafe-script-element-detected"),
              "style" === t && l("domconverter-unsafe-style-element-detected");
          }
          function fs(t) {
            const e = Object.prototype.toString.apply(t);
            return "[object Window]" == e || "[object global]" == e;
          }
          const ks = Jt({}, k, {
              listenTo(t, e, n, i = {}) {
                if (Kr(t) || fs(t)) {
                  const o = {
                      capture: !!i.useCapture,
                      passive: !!i.usePassive,
                    },
                    r = this._getProxyEmitter(t, o) || new ws(t, o);
                  this.listenTo(r, e, n, i);
                } else k.listenTo.call(this, t, e, n, i);
              },
              stopListening(t, e, n) {
                if (Kr(t) || fs(t)) {
                  const i = this._getAllProxyEmitters(t);
                  for (const t of i) this.stopListening(t, e, n);
                } else k.stopListening.call(this, t, e, n);
              },
              _getProxyEmitter(t, e) {
                return (
                  (n = this),
                  (i = As(t, e)),
                  n[g] && n[g][i] ? n[g][i].emitter : null
                );
                var n, i;
              },
              _getAllProxyEmitters(t) {
                return [
                  { capture: !1, passive: !1 },
                  { capture: !1, passive: !0 },
                  { capture: !0, passive: !1 },
                  { capture: !0, passive: !0 },
                ]
                  .map((e) => this._getProxyEmitter(t, e))
                  .filter((t) => !!t);
              },
            }),
            bs = ks;
          class ws {
            constructor(t, e) {
              b(this, As(t, e)), (this._domNode = t), (this._options = e);
            }
          }
          function As(t, e) {
            let n = (function (t) {
              return t["data-ck-expando"] || (t["data-ck-expando"] = r());
            })(t);
            for (const t of Object.keys(e).sort()) e[t] && (n += "-" + t);
            return n;
          }
          Jt(ws.prototype, k, {
            attach(t) {
              if (this._domListeners && this._domListeners[t]) return;
              const e = this._createDomListener(t);
              this._domNode.addEventListener(t, e, this._options),
                this._domListeners || (this._domListeners = {}),
                (this._domListeners[t] = e);
            },
            detach(t) {
              let e;
              !this._domListeners[t] ||
                ((e = this._events[t]) && e.callbacks.length) ||
                this._domListeners[t].removeListener();
            },
            _addEventListener(t, e, n) {
              this.attach(t), k._addEventListener.call(this, t, e, n);
            },
            _removeEventListener(t, e) {
              k._removeEventListener.call(this, t, e), this.detach(t);
            },
            _createDomListener(t) {
              const e = (e) => {
                this.fire(t, e);
              };
              return (
                (e.removeListener = () => {
                  this._domNode.removeEventListener(t, e, this._options),
                    delete this._domListeners[t];
                }),
                e
              );
            },
          });
          class _s {
            constructor(t) {
              (this.view = t),
                (this.document = t.document),
                (this.isEnabled = !1);
            }
            enable() {
              this.isEnabled = !0;
            }
            disable() {
              this.isEnabled = !1;
            }
            destroy() {
              this.disable(), this.stopListening();
            }
            checkShouldIgnoreEventFromTarget(t) {
              return (
                t && 3 === t.nodeType && (t = t.parentNode),
                !(!t || 1 !== t.nodeType) &&
                  t.matches(
                    "[data-cke-ignore-events], [data-cke-ignore-events] *"
                  )
              );
            }
          }
          he(_s, bs);
          const Cs = function (t) {
            return this.__data__.set(t, "__lodash_hash_undefined__"), this;
          };
          const vs = function (t) {
            return this.__data__.has(t);
          };
          function ys(t) {
            var e = -1,
              n = null == t ? 0 : t.length;
            for (this.__data__ = new on(); ++e < n; ) this.add(t[e]);
          }
          (ys.prototype.add = ys.prototype.push = Cs), (ys.prototype.has = vs);
          const xs = ys;
          const Es = function (t, e) {
            for (var n = -1, i = null == t ? 0 : t.length; ++n < i; )
              if (e(t[n], n, t)) return !0;
            return !1;
          };
          const Ds = function (t, e) {
            return t.has(e);
          };
          const Ss = function (t, e, n, i, o, r) {
            var s = 1 & n,
              a = t.length,
              c = e.length;
            if (a != c && !(s && c > a)) return !1;
            var l = r.get(t),
              d = r.get(e);
            if (l && d) return l == e && d == t;
            var h = -1,
              u = !0,
              m = 2 & n ? new xs() : void 0;
            for (r.set(t, e), r.set(e, t); ++h < a; ) {
              var g = t[h],
                p = e[h];
              if (i) var f = s ? i(p, g, h, e, t, r) : i(g, p, h, t, e, r);
              if (void 0 !== f) {
                if (f) continue;
                u = !1;
                break;
              }
              if (m) {
                if (
                  !Es(e, function (t, e) {
                    if (!Ds(m, e) && (g === t || o(g, t, n, i, r)))
                      return m.push(e);
                  })
                ) {
                  u = !1;
                  break;
                }
              } else if (g !== p && !o(g, p, n, i, r)) {
                u = !1;
                break;
              }
            }
            return r.delete(t), r.delete(e), u;
          };
          const Is = function (t) {
            var e = -1,
              n = Array(t.size);
            return (
              t.forEach(function (t, i) {
                n[++e] = [i, t];
              }),
              n
            );
          };
          const Ts = function (t) {
            var e = -1,
              n = Array(t.size);
            return (
              t.forEach(function (t) {
                n[++e] = t;
              }),
              n
            );
          };
          var Ms = I ? I.prototype : void 0,
            Bs = Ms ? Ms.valueOf : void 0;
          const Ns = function (t, e, n, i, o, r, s) {
            switch (n) {
              case "[object DataView]":
                if (
                  t.byteLength != e.byteLength ||
                  t.byteOffset != e.byteOffset
                )
                  return !1;
                (t = t.buffer), (e = e.buffer);
              case "[object ArrayBuffer]":
                return !(
                  t.byteLength != e.byteLength || !r(new Zn(t), new Zn(e))
                );
              case "[object Boolean]":
              case "[object Date]":
              case "[object Number]":
                return nt(+t, +e);
              case "[object Error]":
                return t.name == e.name && t.message == e.message;
              case "[object RegExp]":
              case "[object String]":
                return t == e + "";
              case "[object Map]":
                var a = Is;
              case "[object Set]":
                var c = 1 & i;
                if ((a || (a = Ts), t.size != e.size && !c)) return !1;
                var l = s.get(t);
                if (l) return l == e;
                (i |= 2), s.set(t, e);
                var d = Ss(a(t), a(e), i, o, r, s);
                return s.delete(t), d;
              case "[object Symbol]":
                if (Bs) return Bs.call(t) == Bs.call(e);
            }
            return !1;
          };
          var zs = Object.prototype.hasOwnProperty;
          const Ps = function (t, e, n, i, o, r) {
            var s = 1 & n,
              a = Mn(t),
              c = a.length;
            if (c != Mn(e).length && !s) return !1;
            for (var l = c; l--; ) {
              var d = a[l];
              if (!(s ? d in e : zs.call(e, d))) return !1;
            }
            var h = r.get(t),
              u = r.get(e);
            if (h && u) return h == e && u == t;
            var m = !0;
            r.set(t, e), r.set(e, t);
            for (var g = s; ++l < c; ) {
              var p = t[(d = a[l])],
                f = e[d];
              if (i) var k = s ? i(f, p, d, e, t, r) : i(p, f, d, t, e, r);
              if (!(void 0 === k ? p === f || o(p, f, n, i, r) : k)) {
                m = !1;
                break;
              }
              g || (g = "constructor" == d);
            }
            if (m && !g) {
              var b = t.constructor,
                w = e.constructor;
              b == w ||
                !("constructor" in t) ||
                !("constructor" in e) ||
                ("function" == typeof b &&
                  b instanceof b &&
                  "function" == typeof w &&
                  w instanceof w) ||
                (m = !1);
            }
            return r.delete(t), r.delete(e), m;
          };
          var Ls = "[object Arguments]",
            Rs = "[object Array]",
            Os = "[object Object]",
            js = Object.prototype.hasOwnProperty;
          const Fs = function (t, e, n, i, o, r) {
            var s = It(t),
              a = It(e),
              c = s ? Rs : Yn(t),
              l = a ? Rs : Yn(e),
              d = (c = c == Ls ? Os : c) == Os,
              h = (l = l == Ls ? Os : l) == Os,
              u = c == l;
            if (u && zt(t)) {
              if (!zt(e)) return !1;
              (s = !0), (d = !1);
            }
            if (u && !d)
              return (
                r || (r = new an()),
                s || Ut(t) ? Ss(t, e, n, i, o, r) : Ns(t, e, c, n, i, o, r)
              );
            if (!(1 & n)) {
              var m = d && js.call(t, "__wrapped__"),
                g = h && js.call(e, "__wrapped__");
              if (m || g) {
                var p = m ? t.value() : t,
                  f = g ? e.value() : e;
                return r || (r = new an()), o(p, f, n, i, r);
              }
            }
            return !!u && (r || (r = new an()), Ps(t, e, n, i, o, r));
          };
          const Vs = function t(e, n, i, o, r) {
            return (
              e === n ||
              (null == e || null == n || (!vt(e) && !vt(n))
                ? e != e && n != n
                : Fs(e, n, i, o, t, r))
            );
          };
          const Hs = function (t, e, n) {
            var i = (n = "function" == typeof n ? n : void 0)
              ? n(t, e)
              : void 0;
            return void 0 === i ? Vs(t, e, void 0, n) : !!i;
          };
          class Us extends _s {
            constructor(t) {
              super(t),
                (this._config = {
                  childList: !0,
                  characterData: !0,
                  characterDataOldValue: !0,
                  subtree: !0,
                }),
                (this.domConverter = t.domConverter),
                (this.renderer = t._renderer),
                (this._domElements = []),
                (this._mutationObserver = new window.MutationObserver(
                  this._onMutations.bind(this)
                ));
            }
            flush() {
              this._onMutations(this._mutationObserver.takeRecords());
            }
            observe(t) {
              this._domElements.push(t),
                this.isEnabled &&
                  this._mutationObserver.observe(t, this._config);
            }
            enable() {
              super.enable();
              for (const t of this._domElements)
                this._mutationObserver.observe(t, this._config);
            }
            disable() {
              super.disable(), this._mutationObserver.disconnect();
            }
            destroy() {
              super.destroy(), this._mutationObserver.disconnect();
            }
            _onMutations(t) {
              if (0 === t.length) return;
              const e = this.domConverter,
                n = new Map(),
                i = new Set();
              for (const n of t)
                if ("childList" === n.type) {
                  const t = e.mapDomToView(n.target);
                  if (t && (t.is("uiElement") || t.is("rawElement"))) continue;
                  t && !this._isBogusBrMutation(n) && i.add(t);
                }
              for (const o of t) {
                const t = e.mapDomToView(o.target);
                if (
                  (!t || (!t.is("uiElement") && !t.is("rawElement"))) &&
                  "characterData" === o.type
                ) {
                  const t = e.findCorrespondingViewText(o.target);
                  t && !i.has(t.parent)
                    ? n.set(t, {
                        type: "text",
                        oldText: t.data,
                        newText: Fr(o.target),
                        node: t,
                      })
                    : !t &&
                      Or(o.target) &&
                      i.add(e.mapDomToView(o.target.parentNode));
                }
              }
              const o = [];
              for (const t of n.values())
                this.renderer.markToSync("text", t.node), o.push(t);
              for (const t of i) {
                const n = e.mapViewToDom(t),
                  i = Array.from(t.getChildren()),
                  r = Array.from(e.domChildrenToView(n, { withChildren: !1 }));
                Hs(i, r, a) ||
                  (this.renderer.markToSync("children", t),
                  o.push({
                    type: "children",
                    oldChildren: i,
                    newChildren: r,
                    node: t,
                  }));
              }
              const r = t[0].target.ownerDocument.getSelection();
              let s = null;
              if (r && r.anchorNode) {
                const t = e.domPositionToView(r.anchorNode, r.anchorOffset),
                  n = e.domPositionToView(r.focusNode, r.focusOffset);
                t && n && ((s = new Ho(t)), s.setFocus(n));
              }
              function a(t, e) {
                if (!Array.isArray(t))
                  return (
                    t === e ||
                    (!(!t.is("$text") || !e.is("$text")) && t.data === e.data)
                  );
              }
              o.length &&
                (this.document.fire("mutations", o, s),
                this.view.forceRender());
            }
            _isBogusBrMutation(t) {
              let e = null;
              return (
                null === t.nextSibling &&
                  0 === t.removedNodes.length &&
                  1 == t.addedNodes.length &&
                  (e = this.domConverter.domToView(t.addedNodes[0], {
                    withChildren: !1,
                  })),
                e && e.is("element", "br")
              );
            }
          }
          class $s {
            constructor(t, e, n) {
              (this.view = t),
                (this.document = t.document),
                (this.domEvent = e),
                (this.domTarget = e.target),
                Jt(this, n);
            }
            get target() {
              return this.view.domConverter.mapDomToView(this.domTarget);
            }
            preventDefault() {
              this.domEvent.preventDefault();
            }
            stopPropagation() {
              this.domEvent.stopPropagation();
            }
          }
          class qs extends _s {
            constructor(t) {
              super(t), (this.useCapture = !1);
            }
            observe(t) {
              ("string" == typeof this.domEventType
                ? [this.domEventType]
                : this.domEventType
              ).forEach((e) => {
                this.listenTo(
                  t,
                  e,
                  (t, e) => {
                    this.isEnabled &&
                      !this.checkShouldIgnoreEventFromTarget(e.target) &&
                      this.onDomEvent(e);
                  },
                  { useCapture: this.useCapture }
                );
              });
            }
            fire(t, e, n) {
              this.isEnabled && this.document.fire(t, new $s(this.view, e, n));
            }
          }
          class Gs extends qs {
            constructor(t) {
              super(t), (this.domEventType = ["keydown", "keyup"]);
            }
            onDomEvent(t) {
              this.fire(t.type, t, {
                keyCode: t.keyCode,
                altKey: t.altKey,
                ctrlKey: t.ctrlKey,
                shiftKey: t.shiftKey,
                metaKey: t.metaKey,
                get keystroke() {
                  return ur(this);
                },
              });
            }
          }
          const Ws = function () {
            return S.Date.now();
          };
          var Ys = /\s/;
          const Ks = function (t) {
            for (var e = t.length; e-- && Ys.test(t.charAt(e)); );
            return e;
          };
          var Qs = /^\s+/;
          const Zs = function (t) {
            return t ? t.slice(0, Ks(t) + 1).replace(Qs, "") : t;
          };
          var Js = /^[-+]0x[0-9a-f]+$/i,
            Xs = /^0b[01]+$/i,
            ta = /^0o[0-7]+$/i,
            ea = parseInt;
          const na = function (t) {
            if ("number" == typeof t) return t;
            if (qi(t)) return NaN;
            if (x(t)) {
              var e = "function" == typeof t.valueOf ? t.valueOf() : t;
              t = x(e) ? e + "" : e;
            }
            if ("string" != typeof t) return 0 === t ? t : +t;
            t = Zs(t);
            var n = Xs.test(t);
            return n || ta.test(t)
              ? ea(t.slice(2), n ? 2 : 8)
              : Js.test(t)
              ? NaN
              : +t;
          };
          var ia = Math.max,
            oa = Math.min;
          const ra = function (t, e, n) {
            var i,
              o,
              r,
              s,
              a,
              c,
              l = 0,
              d = !1,
              h = !1,
              u = !0;
            if ("function" != typeof t)
              throw new TypeError("Expected a function");
            function m(e) {
              var n = i,
                r = o;
              return (i = o = void 0), (l = e), (s = t.apply(r, n));
            }
            function g(t) {
              return (l = t), (a = setTimeout(f, e)), d ? m(t) : s;
            }
            function p(t) {
              var n = t - c;
              return void 0 === c || n >= e || n < 0 || (h && t - l >= r);
            }
            function f() {
              var t = Ws();
              if (p(t)) return k(t);
              a = setTimeout(
                f,
                (function (t) {
                  var n = e - (t - c);
                  return h ? oa(n, r - (t - l)) : n;
                })(t)
              );
            }
            function k(t) {
              return (a = void 0), u && i ? m(t) : ((i = o = void 0), s);
            }
            function b() {
              var t = Ws(),
                n = p(t);
              if (((i = arguments), (o = this), (c = t), n)) {
                if (void 0 === a) return g(c);
                if (h) return clearTimeout(a), (a = setTimeout(f, e)), m(c);
              }
              return void 0 === a && (a = setTimeout(f, e)), s;
            }
            return (
              (e = na(e) || 0),
              x(n) &&
                ((d = !!n.leading),
                (r = (h = "maxWait" in n) ? ia(na(n.maxWait) || 0, e) : r),
                (u = "trailing" in n ? !!n.trailing : u)),
              (b.cancel = function () {
                void 0 !== a && clearTimeout(a),
                  (l = 0),
                  (i = c = o = a = void 0);
              }),
              (b.flush = function () {
                return void 0 === a ? s : k(Ws());
              }),
              b
            );
          };
          class sa extends _s {
            constructor(t) {
              super(t),
                (this._fireSelectionChangeDoneDebounced = ra(
                  (t) => this.document.fire("selectionChangeDone", t),
                  200
                ));
            }
            observe() {
              const t = this.document;
              t.on(
                "arrowKey",
                (e, n) => {
                  t.selection.isFake && this.isEnabled && n.preventDefault();
                },
                { context: "$capture" }
              ),
                t.on(
                  "arrowKey",
                  (e, n) => {
                    t.selection.isFake &&
                      this.isEnabled &&
                      this._handleSelectionMove(n.keyCode);
                  },
                  { priority: "lowest" }
                );
            }
            destroy() {
              super.destroy(), this._fireSelectionChangeDoneDebounced.cancel();
            }
            _handleSelectionMove(t) {
              const e = this.document.selection,
                n = new Ho(e.getRanges(), { backward: e.isBackward, fake: !1 });
              (t != dr.arrowleft && t != dr.arrowup) ||
                n.setTo(n.getFirstPosition()),
                (t != dr.arrowright && t != dr.arrowdown) ||
                  n.setTo(n.getLastPosition());
              const i = {
                oldSelection: e,
                newSelection: n,
                domSelection: null,
              };
              this.document.fire("selectionChange", i),
                this._fireSelectionChangeDoneDebounced(i);
            }
          }
          class aa extends _s {
            constructor(t) {
              super(t),
                (this.mutationObserver = t.getObserver(Us)),
                (this.selection = this.document.selection),
                (this.domConverter = t.domConverter),
                (this._documents = new WeakSet()),
                (this._fireSelectionChangeDoneDebounced = ra(
                  (t) => this.document.fire("selectionChangeDone", t),
                  200
                )),
                (this._clearInfiniteLoopInterval = setInterval(
                  () => this._clearInfiniteLoop(),
                  1e3
                )),
                (this._documentIsSelectingInactivityTimeoutDebounced = ra(
                  () => (this.document.isSelecting = !1),
                  5e3
                )),
                (this._loopbackCounter = 0);
            }
            observe(t) {
              const e = t.ownerDocument,
                n = () => {
                  (this.document.isSelecting = !1),
                    this._documentIsSelectingInactivityTimeoutDebounced.cancel();
                };
              this.listenTo(
                t,
                "selectstart",
                () => {
                  (this.document.isSelecting = !0),
                    this._documentIsSelectingInactivityTimeoutDebounced();
                },
                { priority: "highest" }
              ),
                this.listenTo(t, "keydown", n, { priority: "highest" }),
                this.listenTo(t, "keyup", n, { priority: "highest" }),
                this._documents.has(e) ||
                  (this.listenTo(e, "mouseup", n, { priority: "highest" }),
                  this.listenTo(e, "selectionchange", (t, n) => {
                    this._handleSelectionChange(n, e),
                      this._documentIsSelectingInactivityTimeoutDebounced();
                  }),
                  this._documents.add(e));
            }
            destroy() {
              super.destroy(),
                clearInterval(this._clearInfiniteLoopInterval),
                this._fireSelectionChangeDoneDebounced.cancel(),
                this._documentIsSelectingInactivityTimeoutDebounced.cancel();
            }
            _handleSelectionChange(t, e) {
              if (!this.isEnabled) return;
              const n = e.defaultView.getSelection();
              if (this.checkShouldIgnoreEventFromTarget(n.anchorNode)) return;
              this.mutationObserver.flush();
              const i = this.domConverter.domSelectionToView(n);
              if (0 != i.rangeCount) {
                if (
                  ((this.view.hasDomSelection = !0),
                  !(
                    (this.selection.isEqual(i) &&
                      this.domConverter.isDomSelectionCorrect(n)) ||
                    ++this._loopbackCounter > 60
                  ))
                )
                  if (this.selection.isSimilar(i)) this.view.forceRender();
                  else {
                    const t = {
                      oldSelection: this.selection,
                      newSelection: i,
                      domSelection: n,
                    };
                    this.document.fire("selectionChange", t),
                      this._fireSelectionChangeDoneDebounced(t);
                  }
              } else this.view.hasDomSelection = !1;
            }
            _clearInfiniteLoop() {
              this._loopbackCounter = 0;
            }
          }
          class ca extends qs {
            constructor(t) {
              super(t),
                (this.domEventType = ["focus", "blur"]),
                (this.useCapture = !0);
              const e = this.document;
              e.on("focus", () => {
                (e.isFocused = !0),
                  (this._renderTimeoutId = setTimeout(
                    () => t.change(() => {}),
                    50
                  ));
              }),
                e.on("blur", (n, i) => {
                  const o = e.selection.editableElement;
                  (null !== o && o !== i.target) ||
                    ((e.isFocused = !1), t.change(() => {}));
                });
            }
            onDomEvent(t) {
              this.fire(t.type, t);
            }
            destroy() {
              this._renderTimeoutId && clearTimeout(this._renderTimeoutId),
                super.destroy();
            }
          }
          class la extends qs {
            constructor(t) {
              super(t),
                (this.domEventType = [
                  "compositionstart",
                  "compositionupdate",
                  "compositionend",
                ]);
              const e = this.document;
              e.on("compositionstart", () => {
                e.isComposing = !0;
              }),
                e.on("compositionend", () => {
                  e.isComposing = !1;
                });
            }
            onDomEvent(t) {
              this.fire(t.type, t);
            }
          }
          class da extends qs {
            constructor(t) {
              super(t), (this.domEventType = ["beforeinput"]);
            }
            onDomEvent(t) {
              this.fire(t.type, t);
            }
          }
          class ha {
            constructor() {
              this._replacedElements = [];
            }
            replace(t, e) {
              this._replacedElements.push({ element: t, newElement: e }),
                (t.style.display = "none"),
                e && t.parentNode.insertBefore(e, t.nextSibling);
            }
            restore() {
              this._replacedElements.forEach(
                ({ element: t, newElement: e }) => {
                  (t.style.display = ""), e && e.remove();
                }
              ),
                (this._replacedElements = []);
            }
          }
          const ua = function (t) {
            return (
              "string" == typeof t ||
              (!It(t) && vt(t) && "[object String]" == O(t))
            );
          };
          function ma(t, e, n = {}, i = []) {
            const o = n && n.xmlns,
              r = o ? t.createElementNS(o, e) : t.createElement(e);
            for (const t in n) r.setAttribute(t, n[t]);
            (!ua(i) && Ei(i)) || (i = [i]);
            for (let e of i)
              ua(e) && (e = t.createTextNode(e)), r.appendChild(e);
            return r;
          }
          function ga(t) {
            return "[object Range]" == Object.prototype.toString.apply(t);
          }
          function pa(t) {
            const e = t.ownerDocument.defaultView.getComputedStyle(t);
            return {
              top: parseInt(e.borderTopWidth, 10),
              right: parseInt(e.borderRightWidth, 10),
              bottom: parseInt(e.borderBottomWidth, 10),
              left: parseInt(e.borderLeftWidth, 10),
            };
          }
          const fa = ["top", "right", "bottom", "left", "width", "height"];
          class ka {
            constructor(t) {
              const e = ga(t);
              if (
                (Object.defineProperty(this, "_source", {
                  value: t._source || t,
                  writable: !0,
                  enumerable: !1,
                }),
                Ci(t) || e)
              )
                if (e) {
                  const e = ka.getDomRangeRects(t);
                  ba(this, ka.getBoundingRect(e));
                } else ba(this, t.getBoundingClientRect());
              else if (fs(t)) {
                const { innerWidth: e, innerHeight: n } = t;
                ba(this, {
                  top: 0,
                  right: e,
                  bottom: n,
                  left: 0,
                  width: e,
                  height: n,
                });
              } else ba(this, t);
            }
            clone() {
              return new ka(this);
            }
            moveTo(t, e) {
              return (
                (this.top = e),
                (this.right = t + this.width),
                (this.bottom = e + this.height),
                (this.left = t),
                this
              );
            }
            moveBy(t, e) {
              return (
                (this.top += e),
                (this.right += t),
                (this.left += t),
                (this.bottom += e),
                this
              );
            }
            getIntersection(t) {
              const e = {
                top: Math.max(this.top, t.top),
                right: Math.min(this.right, t.right),
                bottom: Math.min(this.bottom, t.bottom),
                left: Math.max(this.left, t.left),
              };
              return (
                (e.width = e.right - e.left),
                (e.height = e.bottom - e.top),
                e.width < 0 || e.height < 0 ? null : new ka(e)
              );
            }
            getIntersectionArea(t) {
              const e = this.getIntersection(t);
              return e ? e.getArea() : 0;
            }
            getArea() {
              return this.width * this.height;
            }
            getVisible() {
              const t = this._source;
              let e = this.clone();
              if (!wa(t)) {
                let n = t.parentNode || t.commonAncestorContainer;
                for (; n && !wa(n); ) {
                  const t = new ka(n),
                    i = e.getIntersection(t);
                  if (!i) return null;
                  i.getArea() < e.getArea() && (e = i), (n = n.parentNode);
                }
              }
              return e;
            }
            isEqual(t) {
              for (const e of fa) if (this[e] !== t[e]) return !1;
              return !0;
            }
            contains(t) {
              const e = this.getIntersection(t);
              return !(!e || !e.isEqual(t));
            }
            excludeScrollbarsAndBorders() {
              const t = this._source;
              let e, n, i;
              if (fs(t))
                (e = t.innerWidth - t.document.documentElement.clientWidth),
                  (n = t.innerHeight - t.document.documentElement.clientHeight),
                  (i = t.getComputedStyle(
                    t.document.documentElement
                  ).direction);
              else {
                const o = pa(this._source);
                (e = t.offsetWidth - t.clientWidth - o.left - o.right),
                  (n = t.offsetHeight - t.clientHeight - o.top - o.bottom),
                  (i =
                    t.ownerDocument.defaultView.getComputedStyle(t).direction),
                  (this.left += o.left),
                  (this.top += o.top),
                  (this.right -= o.right),
                  (this.bottom -= o.bottom),
                  (this.width = this.right - this.left),
                  (this.height = this.bottom - this.top);
              }
              return (
                (this.width -= e),
                "ltr" === i ? (this.right -= e) : (this.left += e),
                (this.height -= n),
                (this.bottom -= n),
                this
              );
            }
            static getDomRangeRects(t) {
              const e = [],
                n = Array.from(t.getClientRects());
              if (n.length) for (const t of n) e.push(new ka(t));
              else {
                let n = t.startContainer;
                Nr(n) && (n = n.parentNode);
                const i = new ka(n.getBoundingClientRect());
                (i.right = i.left), (i.width = 0), e.push(i);
              }
              return e;
            }
            static getBoundingRect(t) {
              const e = {
                left: Number.POSITIVE_INFINITY,
                top: Number.POSITIVE_INFINITY,
                right: Number.NEGATIVE_INFINITY,
                bottom: Number.NEGATIVE_INFINITY,
              };
              let n = 0;
              for (const i of t)
                n++,
                  (e.left = Math.min(e.left, i.left)),
                  (e.top = Math.min(e.top, i.top)),
                  (e.right = Math.max(e.right, i.right)),
                  (e.bottom = Math.max(e.bottom, i.bottom));
              return 0 == n
                ? null
                : ((e.width = e.right - e.left),
                  (e.height = e.bottom - e.top),
                  new ka(e));
            }
          }
          function ba(t, e) {
            for (const n of fa) t[n] = e[n];
          }
          function wa(t) {
            return !!Ci(t) && t === t.ownerDocument.body;
          }
          class Aa {
            constructor(t, e) {
              Aa._observerInstance || Aa._createObserver(),
                (this._element = t),
                (this._callback = e),
                Aa._addElementCallback(t, e),
                Aa._observerInstance.observe(t);
            }
            destroy() {
              Aa._deleteElementCallback(this._element, this._callback);
            }
            static _addElementCallback(t, e) {
              Aa._elementCallbacks || (Aa._elementCallbacks = new Map());
              let n = Aa._elementCallbacks.get(t);
              n || ((n = new Set()), Aa._elementCallbacks.set(t, n)), n.add(e);
            }
            static _deleteElementCallback(t, e) {
              const n = Aa._getElementCallbacks(t);
              n &&
                (n.delete(e),
                n.size ||
                  (Aa._elementCallbacks.delete(t),
                  Aa._observerInstance.unobserve(t))),
                Aa._elementCallbacks &&
                  !Aa._elementCallbacks.size &&
                  ((Aa._observerInstance = null),
                  (Aa._elementCallbacks = null));
            }
            static _getElementCallbacks(t) {
              return Aa._elementCallbacks ? Aa._elementCallbacks.get(t) : null;
            }
            static _createObserver() {
              let t;
              (t =
                "function" == typeof os.window.ResizeObserver
                  ? os.window.ResizeObserver
                  : _a),
                (Aa._observerInstance = new t((t) => {
                  for (const e of t) {
                    const t = Aa._getElementCallbacks(e.target);
                    if (t) for (const n of t) n(e);
                  }
                }));
            }
          }
          (Aa._observerInstance = null), (Aa._elementCallbacks = null);
          class _a {
            constructor(t) {
              (this._callback = t),
                (this._elements = new Set()),
                (this._previousRects = new Map()),
                (this._periodicCheckTimeout = null);
            }
            observe(t) {
              this._elements.add(t),
                this._checkElementRectsAndExecuteCallback(),
                1 === this._elements.size && this._startPeriodicCheck();
            }
            unobserve(t) {
              this._elements.delete(t),
                this._previousRects.delete(t),
                this._elements.size || this._stopPeriodicCheck();
            }
            _startPeriodicCheck() {
              const t = () => {
                this._checkElementRectsAndExecuteCallback(),
                  (this._periodicCheckTimeout = setTimeout(t, 100));
              };
              this.listenTo(os.window, "resize", () => {
                this._checkElementRectsAndExecuteCallback();
              }),
                (this._periodicCheckTimeout = setTimeout(t, 100));
            }
            _stopPeriodicCheck() {
              clearTimeout(this._periodicCheckTimeout),
                this.stopListening(),
                this._previousRects.clear();
            }
            _checkElementRectsAndExecuteCallback() {
              const t = [];
              for (const e of this._elements)
                this._hasRectChanged(e) &&
                  t.push({
                    target: e,
                    contentRect: this._previousRects.get(e),
                  });
              t.length && this._callback(t);
            }
            _hasRectChanged(t) {
              if (!t.ownerDocument.body.contains(t)) return !1;
              const e = new ka(t),
                n = this._previousRects.get(t),
                i = !n || !n.isEqual(e);
              return this._previousRects.set(t, e), i;
            }
          }
          function Ca(t) {
            return !!(t && t.getClientRects && t.getClientRects().length);
          }
          he(_a, bs);
          function va({ target: t, viewportOffset: e = 0 }) {
            const n = Ta(t);
            let i = n,
              o = null;
            for (; i; ) {
              let r;
              (r = Ma(i == n ? t : o)), xa(r, () => Ba(t, i));
              const s = Ba(t, i);
              if ((ya(i, s, e), i.parent != i)) {
                if (((o = i.frameElement), (i = i.parent), !o)) return;
              } else i = null;
            }
          }
          function ya(t, e, n) {
            const i = e.clone().moveBy(0, n),
              o = e.clone().moveBy(0, -n),
              r = new ka(t).excludeScrollbarsAndBorders();
            if (![o, i].every((t) => r.contains(t))) {
              let { scrollX: s, scrollY: a } = t;
              Da(o, r)
                ? (a -= r.top - e.top + n)
                : Ea(i, r) && (a += e.bottom - r.bottom + n),
                Sa(e, r)
                  ? (s -= r.left - e.left + n)
                  : Ia(e, r) && (s += e.right - r.right + n),
                t.scrollTo(s, a);
            }
          }
          function xa(t, e) {
            const n = Ta(t);
            let i, o;
            for (; t != n.document.body; )
              (o = e()),
                (i = new ka(t).excludeScrollbarsAndBorders()),
                i.contains(o) ||
                  (Da(o, i)
                    ? (t.scrollTop -= i.top - o.top)
                    : Ea(o, i) && (t.scrollTop += o.bottom - i.bottom),
                  Sa(o, i)
                    ? (t.scrollLeft -= i.left - o.left)
                    : Ia(o, i) && (t.scrollLeft += o.right - i.right)),
                (t = t.parentNode);
          }
          function Ea(t, e) {
            return t.bottom > e.bottom;
          }
          function Da(t, e) {
            return t.top < e.top;
          }
          function Sa(t, e) {
            return t.left < e.left;
          }
          function Ia(t, e) {
            return t.right > e.right;
          }
          function Ta(t) {
            return ga(t)
              ? t.startContainer.ownerDocument.defaultView
              : t.ownerDocument.defaultView;
          }
          function Ma(t) {
            if (ga(t)) {
              let e = t.commonAncestorContainer;
              return Nr(e) && (e = e.parentNode), e;
            }
            return t.parentNode;
          }
          function Ba(t, e) {
            const n = Ta(t),
              i = new ka(t);
            if (n === e) return i;
            {
              let t = n;
              for (; t != e; ) {
                const e = t.frameElement,
                  n = new ka(e).excludeScrollbarsAndBorders();
                i.moveBy(n.left, n.top), (t = t.parent);
              }
            }
            return i;
          }
          function Na(t) {
            const e = t.next();
            return e.done ? null : e.value;
          }
          Object.assign(
            {},
            {
              scrollViewportToShowTarget: va,
              scrollAncestorsToShowTarget: function (t) {
                xa(Ma(t), () => new ka(t));
              },
            }
          );
          class za {
            constructor() {
              this.set("isFocused", !1),
                this.set("focusedElement", null),
                (this._elements = new Set()),
                (this._nextEventLoopTimeout = null);
            }
            add(t) {
              if (this._elements.has(t))
                throw new c("focustracker-add-element-already-exist", this);
              this.listenTo(t, "focus", () => this._focus(t), {
                useCapture: !0,
              }),
                this.listenTo(t, "blur", () => this._blur(), {
                  useCapture: !0,
                }),
                this._elements.add(t);
            }
            remove(t) {
              t === this.focusedElement && this._blur(t),
                this._elements.has(t) &&
                  (this.stopListening(t), this._elements.delete(t));
            }
            destroy() {
              this.stopListening();
            }
            _focus(t) {
              clearTimeout(this._nextEventLoopTimeout),
                (this.focusedElement = t),
                (this.isFocused = !0);
            }
            _blur() {
              clearTimeout(this._nextEventLoopTimeout),
                (this._nextEventLoopTimeout = setTimeout(() => {
                  (this.focusedElement = null), (this.isFocused = !1);
                }, 0));
            }
          }
          he(za, bs), he(za, re);
          class Pa {
            constructor() {
              this._listener = Object.create(bs);
            }
            listenTo(t) {
              this._listener.listenTo(t, "keydown", (t, e) => {
                this._listener.fire("_keydown:" + ur(e), e);
              });
            }
            set(t, e, n = {}) {
              const i = mr(t),
                o = n.priority;
              this._listener.listenTo(
                this._listener,
                "_keydown:" + i,
                (t, n) => {
                  e(n, () => {
                    n.preventDefault(), n.stopPropagation(), t.stop();
                  }),
                    (t.return = !0);
                },
                { priority: o }
              );
            }
            press(t) {
              return !!this._listener.fire("_keydown:" + ur(t), t);
            }
            destroy() {
              this._listener.stopListening();
            }
          }
          class La extends _s {
            constructor(t) {
              super(t),
                this.document.on("keydown", (t, e) => {
                  if (
                    this.isEnabled &&
                    ((n = e.keyCode) == dr.arrowright ||
                      n == dr.arrowleft ||
                      n == dr.arrowup ||
                      n == dr.arrowdown)
                  ) {
                    const n = new $o(
                      this.document,
                      "arrowKey",
                      this.document.selection.getFirstRange()
                    );
                    this.document.fire(n, e), n.stop.called && t.stop();
                  }
                  var n;
                });
            }
            observe() {}
          }
          class Ra extends _s {
            constructor(t) {
              super(t);
              const e = this.document;
              e.on("keydown", (t, n) => {
                if (!this.isEnabled || n.keyCode != dr.tab || n.ctrlKey) return;
                const i = new $o(e, "tab", e.selection.getFirstRange());
                e.fire(i, n), i.stop.called && t.stop();
              });
            }
            observe() {}
          }
          class Oa {
            constructor(t) {
              (this.document = new Jo(t)),
                (this.domConverter = new us(this.document)),
                (this.domRoots = new Map()),
                this.set("isRenderingInProgress", !1),
                this.set("hasDomSelection", !1),
                (this._renderer = new ts(
                  this.domConverter,
                  this.document.selection
                )),
                this._renderer
                  .bind("isFocused", "isSelecting")
                  .to(this.document),
                (this._initialDomRootAttributes = new WeakMap()),
                (this._observers = new Map()),
                (this._ongoingChange = !1),
                (this._postFixersInProgress = !1),
                (this._renderingDisabled = !1),
                (this._hasChangedSinceTheLastRendering = !1),
                (this._writer = new Cr(this.document)),
                this.addObserver(Us),
                this.addObserver(aa),
                this.addObserver(ca),
                this.addObserver(Gs),
                this.addObserver(sa),
                this.addObserver(la),
                this.addObserver(La),
                this.addObserver(Ra),
                sr.isAndroid && this.addObserver(da),
                this.document.on("arrowKey", Vr, { priority: "low" }),
                kr(this),
                this.on("render", () => {
                  this._render(),
                    this.document.fire("layoutChanged"),
                    (this._hasChangedSinceTheLastRendering = !1);
                }),
                this.listenTo(this.document.selection, "change", () => {
                  this._hasChangedSinceTheLastRendering = !0;
                }),
                this.listenTo(this.document, "change:isFocused", () => {
                  this._hasChangedSinceTheLastRendering = !0;
                });
            }
            attachDomRoot(t, e = "main") {
              const n = this.document.getRoot(e);
              n._name = t.tagName.toLowerCase();
              const i = {};
              for (const { name: e, value: o } of Array.from(t.attributes))
                (i[e] = o),
                  "class" === e
                    ? this._writer.addClass(o.split(" "), n)
                    : this._writer.setAttribute(e, o, n);
              this._initialDomRootAttributes.set(t, i);
              const o = () => {
                this._writer.setAttribute("contenteditable", !n.isReadOnly, n),
                  n.isReadOnly
                    ? this._writer.addClass("ck-read-only", n)
                    : this._writer.removeClass("ck-read-only", n);
              };
              o(),
                this.domRoots.set(e, t),
                this.domConverter.bindElements(t, n),
                this._renderer.markToSync("children", n),
                this._renderer.markToSync("attributes", n),
                this._renderer.domDocuments.add(t.ownerDocument),
                n.on("change:children", (t, e) =>
                  this._renderer.markToSync("children", e)
                ),
                n.on("change:attributes", (t, e) =>
                  this._renderer.markToSync("attributes", e)
                ),
                n.on("change:text", (t, e) =>
                  this._renderer.markToSync("text", e)
                ),
                n.on("change:isReadOnly", () => this.change(o)),
                n.on("change", () => {
                  this._hasChangedSinceTheLastRendering = !0;
                });
              for (const n of this._observers.values()) n.observe(t, e);
            }
            detachDomRoot(t) {
              const e = this.domRoots.get(t);
              Array.from(e.attributes).forEach(({ name: t }) =>
                e.removeAttribute(t)
              );
              const n = this._initialDomRootAttributes.get(e);
              for (const t in n) e.setAttribute(t, n[t]);
              this.domRoots.delete(t), this.domConverter.unbindDomElement(e);
            }
            getDomRoot(t = "main") {
              return this.domRoots.get(t);
            }
            addObserver(t) {
              let e = this._observers.get(t);
              if (e) return e;
              (e = new t(this)), this._observers.set(t, e);
              for (const [t, n] of this.domRoots) e.observe(n, t);
              return e.enable(), e;
            }
            getObserver(t) {
              return this._observers.get(t);
            }
            disableObservers() {
              for (const t of this._observers.values()) t.disable();
            }
            enableObservers() {
              for (const t of this._observers.values()) t.enable();
            }
            scrollToTheSelection() {
              const t = this.document.selection.getFirstRange();
              t &&
                va({
                  target: this.domConverter.viewRangeToDom(t),
                  viewportOffset: 20,
                });
            }
            focus() {
              if (!this.document.isFocused) {
                const t = this.document.selection.editableElement;
                t && (this.domConverter.focus(t), this.forceRender());
              }
            }
            change(t) {
              if (this.isRenderingInProgress || this._postFixersInProgress)
                throw new c("cannot-change-view-tree", this);
              try {
                if (this._ongoingChange) return t(this._writer);
                this._ongoingChange = !0;
                const e = t(this._writer);
                return (
                  (this._ongoingChange = !1),
                  !this._renderingDisabled &&
                    this._hasChangedSinceTheLastRendering &&
                    ((this._postFixersInProgress = !0),
                    this.document._callPostFixers(this._writer),
                    (this._postFixersInProgress = !1),
                    this.fire("render")),
                  e
                );
              } catch (t) {
                c.rethrowUnexpectedError(t, this);
              }
            }
            forceRender() {
              (this._hasChangedSinceTheLastRendering = !0),
                this.change(() => {});
            }
            destroy() {
              for (const t of this._observers.values()) t.destroy();
              this.document.destroy(), this.stopListening();
            }
            createPositionAt(t, e) {
              return Oo._createAt(t, e);
            }
            createPositionAfter(t) {
              return Oo._createAfter(t);
            }
            createPositionBefore(t) {
              return Oo._createBefore(t);
            }
            createRange(t, e) {
              return new jo(t, e);
            }
            createRangeOn(t) {
              return jo._createOn(t);
            }
            createRangeIn(t) {
              return jo._createIn(t);
            }
            createSelection(t, e, n) {
              return new Ho(t, e, n);
            }
            _disableRendering(t) {
              (this._renderingDisabled = t), 0 == t && this.change(() => {});
            }
            _render() {
              (this.isRenderingInProgress = !0),
                this.disableObservers(),
                this._renderer.render(),
                this.enableObservers(),
                (this.isRenderingInProgress = !1);
            }
          }
          he(Oa, re);
          class ja {
            constructor(t) {
              (this.parent = null), (this._attrs = Vi(t));
            }
            get index() {
              let t;
              if (!this.parent) return null;
              if (null === (t = this.parent.getChildIndex(this)))
                throw new c("model-node-not-found-in-parent", this);
              return t;
            }
            get startOffset() {
              let t;
              if (!this.parent) return null;
              if (null === (t = this.parent.getChildStartOffset(this)))
                throw new c("model-node-not-found-in-parent", this);
              return t;
            }
            get offsetSize() {
              return 1;
            }
            get endOffset() {
              return this.parent ? this.startOffset + this.offsetSize : null;
            }
            get nextSibling() {
              const t = this.index;
              return (null !== t && this.parent.getChild(t + 1)) || null;
            }
            get previousSibling() {
              const t = this.index;
              return (null !== t && this.parent.getChild(t - 1)) || null;
            }
            get root() {
              let t = this;
              for (; t.parent; ) t = t.parent;
              return t;
            }
            isAttached() {
              return this.root.is("rootElement");
            }
            getPath() {
              const t = [];
              let e = this;
              for (; e.parent; ) t.unshift(e.startOffset), (e = e.parent);
              return t;
            }
            getAncestors(t = { includeSelf: !1, parentFirst: !1 }) {
              const e = [];
              let n = t.includeSelf ? this : this.parent;
              for (; n; )
                e[t.parentFirst ? "push" : "unshift"](n), (n = n.parent);
              return e;
            }
            getCommonAncestor(t, e = {}) {
              const n = this.getAncestors(e),
                i = t.getAncestors(e);
              let o = 0;
              for (; n[o] == i[o] && n[o]; ) o++;
              return 0 === o ? null : n[o - 1];
            }
            isBefore(t) {
              if (this == t) return !1;
              if (this.root !== t.root) return !1;
              const e = this.getPath(),
                n = t.getPath(),
                i = Li(e, n);
              switch (i) {
                case "prefix":
                  return !0;
                case "extension":
                  return !1;
                default:
                  return e[i] < n[i];
              }
            }
            isAfter(t) {
              return this != t && this.root === t.root && !this.isBefore(t);
            }
            hasAttribute(t) {
              return this._attrs.has(t);
            }
            getAttribute(t) {
              return this._attrs.get(t);
            }
            getAttributes() {
              return this._attrs.entries();
            }
            getAttributeKeys() {
              return this._attrs.keys();
            }
            toJSON() {
              const t = {};
              return (
                this._attrs.size &&
                  (t.attributes = Array.from(this._attrs).reduce(
                    (t, e) => ((t[e[0]] = e[1]), t),
                    {}
                  )),
                t
              );
            }
            is(t) {
              return "node" === t || "model:node" === t;
            }
            _clone() {
              return new ja(this._attrs);
            }
            _remove() {
              this.parent._removeChildren(this.index);
            }
            _setAttribute(t, e) {
              this._attrs.set(t, e);
            }
            _setAttributesTo(t) {
              this._attrs = Vi(t);
            }
            _removeAttribute(t) {
              return this._attrs.delete(t);
            }
            _clearAttributes() {
              this._attrs.clear();
            }
          }
          class Fa extends ja {
            constructor(t, e) {
              super(e), (this._data = t || "");
            }
            get offsetSize() {
              return this.data.length;
            }
            get data() {
              return this._data;
            }
            is(t) {
              return (
                "$text" === t ||
                "model:$text" === t ||
                "text" === t ||
                "model:text" === t ||
                "node" === t ||
                "model:node" === t
              );
            }
            toJSON() {
              const t = super.toJSON();
              return (t.data = this.data), t;
            }
            _clone() {
              return new Fa(this.data, this.getAttributes());
            }
            static fromJSON(t) {
              return new Fa(t.data, t.attributes);
            }
          }
          class Va {
            constructor(t, e, n) {
              if (((this.textNode = t), e < 0 || e > t.offsetSize))
                throw new c("model-textproxy-wrong-offsetintext", this);
              if (n < 0 || e + n > t.offsetSize)
                throw new c("model-textproxy-wrong-length", this);
              (this.data = t.data.substring(e, e + n)), (this.offsetInText = e);
            }
            get startOffset() {
              return null !== this.textNode.startOffset
                ? this.textNode.startOffset + this.offsetInText
                : null;
            }
            get offsetSize() {
              return this.data.length;
            }
            get endOffset() {
              return null !== this.startOffset
                ? this.startOffset + this.offsetSize
                : null;
            }
            get isPartial() {
              return this.offsetSize !== this.textNode.offsetSize;
            }
            get parent() {
              return this.textNode.parent;
            }
            get root() {
              return this.textNode.root;
            }
            is(t) {
              return (
                "$textProxy" === t ||
                "model:$textProxy" === t ||
                "textProxy" === t ||
                "model:textProxy" === t
              );
            }
            getPath() {
              const t = this.textNode.getPath();
              return t.length > 0 && (t[t.length - 1] += this.offsetInText), t;
            }
            getAncestors(t = { includeSelf: !1, parentFirst: !1 }) {
              const e = [];
              let n = t.includeSelf ? this : this.parent;
              for (; n; )
                e[t.parentFirst ? "push" : "unshift"](n), (n = n.parent);
              return e;
            }
            hasAttribute(t) {
              return this.textNode.hasAttribute(t);
            }
            getAttribute(t) {
              return this.textNode.getAttribute(t);
            }
            getAttributes() {
              return this.textNode.getAttributes();
            }
            getAttributeKeys() {
              return this.textNode.getAttributeKeys();
            }
          }
          class Ha {
            constructor(t) {
              (this._nodes = []), t && this._insertNodes(0, t);
            }
            [Symbol.iterator]() {
              return this._nodes[Symbol.iterator]();
            }
            get length() {
              return this._nodes.length;
            }
            get maxOffset() {
              return this._nodes.reduce((t, e) => t + e.offsetSize, 0);
            }
            getNode(t) {
              return this._nodes[t] || null;
            }
            getNodeIndex(t) {
              const e = this._nodes.indexOf(t);
              return -1 == e ? null : e;
            }
            getNodeStartOffset(t) {
              const e = this.getNodeIndex(t);
              return null === e
                ? null
                : this._nodes.slice(0, e).reduce((t, e) => t + e.offsetSize, 0);
            }
            indexToOffset(t) {
              if (t == this._nodes.length) return this.maxOffset;
              const e = this._nodes[t];
              if (!e) throw new c("model-nodelist-index-out-of-bounds", this);
              return this.getNodeStartOffset(e);
            }
            offsetToIndex(t) {
              let e = 0;
              for (const n of this._nodes) {
                if (t >= e && t < e + n.offsetSize) return this.getNodeIndex(n);
                e += n.offsetSize;
              }
              if (e != t)
                throw new c("model-nodelist-offset-out-of-bounds", this, {
                  offset: t,
                  nodeList: this,
                });
              return this.length;
            }
            _insertNodes(t, e) {
              for (const t of e)
                if (!(t instanceof ja))
                  throw new c("model-nodelist-insertnodes-not-node", this);
              this._nodes.splice(t, 0, ...e);
            }
            _removeNodes(t, e = 1) {
              return this._nodes.splice(t, e);
            }
            toJSON() {
              return this._nodes.map((t) => t.toJSON());
            }
          }
          class Ua extends ja {
            constructor(t, e, n) {
              super(e),
                (this.name = t),
                (this._children = new Ha()),
                n && this._insertChild(0, n);
            }
            get childCount() {
              return this._children.length;
            }
            get maxOffset() {
              return this._children.maxOffset;
            }
            get isEmpty() {
              return 0 === this.childCount;
            }
            is(t, e = null) {
              return e
                ? e === this.name && ("element" === t || "model:element" === t)
                : "element" === t ||
                    "model:element" === t ||
                    "node" === t ||
                    "model:node" === t;
            }
            getChild(t) {
              return this._children.getNode(t);
            }
            getChildren() {
              return this._children[Symbol.iterator]();
            }
            getChildIndex(t) {
              return this._children.getNodeIndex(t);
            }
            getChildStartOffset(t) {
              return this._children.getNodeStartOffset(t);
            }
            offsetToIndex(t) {
              return this._children.offsetToIndex(t);
            }
            getNodeByPath(t) {
              let e = this;
              for (const n of t) e = e.getChild(e.offsetToIndex(n));
              return e;
            }
            findAncestor(t, e = { includeSelf: !1 }) {
              let n = e.includeSelf ? this : this.parent;
              for (; n; ) {
                if (n.name === t) return n;
                n = n.parent;
              }
              return null;
            }
            toJSON() {
              const t = super.toJSON();
              if (((t.name = this.name), this._children.length > 0)) {
                t.children = [];
                for (const e of this._children) t.children.push(e.toJSON());
              }
              return t;
            }
            _clone(t = !1) {
              const e = t
                ? Array.from(this._children).map((t) => t._clone(!0))
                : null;
              return new Ua(this.name, this.getAttributes(), e);
            }
            _appendChild(t) {
              this._insertChild(this.childCount, t);
            }
            _insertChild(t, e) {
              const n = (function (t) {
                if ("string" == typeof t) return [new Fa(t)];
                Ei(t) || (t = [t]);
                return Array.from(t).map((t) =>
                  "string" == typeof t
                    ? new Fa(t)
                    : t instanceof Va
                    ? new Fa(t.data, t.getAttributes())
                    : t
                );
              })(e);
              for (const t of n)
                null !== t.parent && t._remove(), (t.parent = this);
              this._children._insertNodes(t, n);
            }
            _removeChildren(t, e = 1) {
              const n = this._children._removeNodes(t, e);
              for (const t of n) t.parent = null;
              return n;
            }
            static fromJSON(t) {
              let e = null;
              if (t.children) {
                e = [];
                for (const n of t.children)
                  n.name ? e.push(Ua.fromJSON(n)) : e.push(Fa.fromJSON(n));
              }
              return new Ua(t.name, t.attributes, e);
            }
          }
          class $a {
            constructor(t = {}) {
              if (!t.boundaries && !t.startPosition)
                throw new c("model-tree-walker-no-start-position", null);
              const e = t.direction || "forward";
              if ("forward" != e && "backward" != e)
                throw new c("model-tree-walker-unknown-direction", t, {
                  direction: e,
                });
              (this.direction = e),
                (this.boundaries = t.boundaries || null),
                t.startPosition
                  ? (this.position = t.startPosition.clone())
                  : (this.position = Ga._createAt(
                      this.boundaries[
                        "backward" == this.direction ? "end" : "start"
                      ]
                    )),
                (this.position.stickiness = "toNone"),
                (this.singleCharacters = !!t.singleCharacters),
                (this.shallow = !!t.shallow),
                (this.ignoreElementEnd = !!t.ignoreElementEnd),
                (this._boundaryStartParent = this.boundaries
                  ? this.boundaries.start.parent
                  : null),
                (this._boundaryEndParent = this.boundaries
                  ? this.boundaries.end.parent
                  : null),
                (this._visitedParent = this.position.parent);
            }
            [Symbol.iterator]() {
              return this;
            }
            skip(t) {
              let e, n, i, o;
              do {
                (i = this.position),
                  (o = this._visitedParent),
                  ({ done: e, value: n } = this.next());
              } while (!e && t(n));
              e || ((this.position = i), (this._visitedParent = o));
            }
            next() {
              return "forward" == this.direction
                ? this._next()
                : this._previous();
            }
            _next() {
              const t = this.position,
                e = this.position.clone(),
                n = this._visitedParent;
              if (null === n.parent && e.offset === n.maxOffset)
                return { done: !0 };
              if (
                n === this._boundaryEndParent &&
                e.offset == this.boundaries.end.offset
              )
                return { done: !0 };
              const i = Wa(e, n),
                o = i || Ya(e, n, i);
              if (o instanceof Ua)
                return (
                  this.shallow
                    ? e.offset++
                    : (e.path.push(0), (this._visitedParent = o)),
                  (this.position = e),
                  qa("elementStart", o, t, e, 1)
                );
              if (o instanceof Fa) {
                let i;
                if (this.singleCharacters) i = 1;
                else {
                  let t = o.endOffset;
                  this._boundaryEndParent == n &&
                    this.boundaries.end.offset < t &&
                    (t = this.boundaries.end.offset),
                    (i = t - e.offset);
                }
                const r = e.offset - o.startOffset,
                  s = new Va(o, r, i);
                return (
                  (e.offset += i), (this.position = e), qa("text", s, t, e, i)
                );
              }
              return (
                e.path.pop(),
                e.offset++,
                (this.position = e),
                (this._visitedParent = n.parent),
                this.ignoreElementEnd ? this._next() : qa("elementEnd", n, t, e)
              );
            }
            _previous() {
              const t = this.position,
                e = this.position.clone(),
                n = this._visitedParent;
              if (null === n.parent && 0 === e.offset) return { done: !0 };
              if (
                n == this._boundaryStartParent &&
                e.offset == this.boundaries.start.offset
              )
                return { done: !0 };
              const i = e.parent,
                o = Wa(e, i),
                r = o || Ka(e, i, o);
              if (r instanceof Ua)
                return (
                  e.offset--,
                  this.shallow
                    ? ((this.position = e), qa("elementStart", r, t, e, 1))
                    : (e.path.push(r.maxOffset),
                      (this.position = e),
                      (this._visitedParent = r),
                      this.ignoreElementEnd
                        ? this._previous()
                        : qa("elementEnd", r, t, e))
                );
              if (r instanceof Fa) {
                let i;
                if (this.singleCharacters) i = 1;
                else {
                  let t = r.startOffset;
                  this._boundaryStartParent == n &&
                    this.boundaries.start.offset > t &&
                    (t = this.boundaries.start.offset),
                    (i = e.offset - t);
                }
                const o = e.offset - r.startOffset,
                  s = new Va(r, o - i, i);
                return (
                  (e.offset -= i), (this.position = e), qa("text", s, t, e, i)
                );
              }
              return (
                e.path.pop(),
                (this.position = e),
                (this._visitedParent = n.parent),
                qa("elementStart", n, t, e, 1)
              );
            }
          }
          function qa(t, e, n, i, o) {
            return {
              done: !1,
              value: {
                type: t,
                item: e,
                previousPosition: n,
                nextPosition: i,
                length: o,
              },
            };
          }
          class Ga {
            constructor(t, e, n = "toNone") {
              if (!t.is("element") && !t.is("documentFragment"))
                throw new c("model-position-root-invalid", t);
              if (!(e instanceof Array) || 0 === e.length)
                throw new c("model-position-path-incorrect-format", t, {
                  path: e,
                });
              t.is("rootElement")
                ? (e = e.slice())
                : ((e = [...t.getPath(), ...e]), (t = t.root)),
                (this.root = t),
                (this.path = e),
                (this.stickiness = n);
            }
            get offset() {
              return this.path[this.path.length - 1];
            }
            set offset(t) {
              this.path[this.path.length - 1] = t;
            }
            get parent() {
              let t = this.root;
              for (let e = 0; e < this.path.length - 1; e++)
                if (((t = t.getChild(t.offsetToIndex(this.path[e]))), !t))
                  throw new c("model-position-path-incorrect", this, {
                    position: this,
                  });
              if (t.is("$text"))
                throw new c("model-position-path-incorrect", this, {
                  position: this,
                });
              return t;
            }
            get index() {
              return this.parent.offsetToIndex(this.offset);
            }
            get textNode() {
              return Wa(this, this.parent);
            }
            get nodeAfter() {
              const t = this.parent;
              return Ya(this, t, Wa(this, t));
            }
            get nodeBefore() {
              const t = this.parent;
              return Ka(this, t, Wa(this, t));
            }
            get isAtStart() {
              return 0 === this.offset;
            }
            get isAtEnd() {
              return this.offset == this.parent.maxOffset;
            }
            compareWith(t) {
              if (this.root != t.root) return "different";
              const e = Li(this.path, t.path);
              switch (e) {
                case "same":
                  return "same";
                case "prefix":
                  return "before";
                case "extension":
                  return "after";
                default:
                  return this.path[e] < t.path[e] ? "before" : "after";
              }
            }
            getLastMatchingPosition(t, e = {}) {
              e.startPosition = this;
              const n = new $a(e);
              return n.skip(t), n.position;
            }
            getParentPath() {
              return this.path.slice(0, -1);
            }
            getAncestors() {
              const t = this.parent;
              return t.is("documentFragment")
                ? [t]
                : t.getAncestors({ includeSelf: !0 });
            }
            findAncestor(t) {
              const e = this.parent;
              return e.is("element")
                ? e.findAncestor(t, { includeSelf: !0 })
                : null;
            }
            getCommonPath(t) {
              if (this.root != t.root) return [];
              const e = Li(this.path, t.path),
                n =
                  "string" == typeof e
                    ? Math.min(this.path.length, t.path.length)
                    : e;
              return this.path.slice(0, n);
            }
            getCommonAncestor(t) {
              const e = this.getAncestors(),
                n = t.getAncestors();
              let i = 0;
              for (; e[i] == n[i] && e[i]; ) i++;
              return 0 === i ? null : e[i - 1];
            }
            getShiftedBy(t) {
              const e = this.clone(),
                n = e.offset + t;
              return (e.offset = n < 0 ? 0 : n), e;
            }
            isAfter(t) {
              return "after" == this.compareWith(t);
            }
            isBefore(t) {
              return "before" == this.compareWith(t);
            }
            isEqual(t) {
              return "same" == this.compareWith(t);
            }
            isTouching(t) {
              let e = null,
                n = null;
              switch (this.compareWith(t)) {
                case "same":
                  return !0;
                case "before":
                  (e = Ga._createAt(this)), (n = Ga._createAt(t));
                  break;
                case "after":
                  (e = Ga._createAt(t)), (n = Ga._createAt(this));
                  break;
                default:
                  return !1;
              }
              let i = e.parent;
              for (; e.path.length + n.path.length; ) {
                if (e.isEqual(n)) return !0;
                if (e.path.length > n.path.length) {
                  if (e.offset !== i.maxOffset) return !1;
                  (e.path = e.path.slice(0, -1)), (i = i.parent), e.offset++;
                } else {
                  if (0 !== n.offset) return !1;
                  n.path = n.path.slice(0, -1);
                }
              }
            }
            is(t) {
              return "position" === t || "model:position" === t;
            }
            hasSameParentAs(t) {
              if (this.root !== t.root) return !1;
              return "same" == Li(this.getParentPath(), t.getParentPath());
            }
            getTransformedByOperation(t) {
              let e;
              switch (t.type) {
                case "insert":
                  e = this._getTransformedByInsertOperation(t);
                  break;
                case "move":
                case "remove":
                case "reinsert":
                  e = this._getTransformedByMoveOperation(t);
                  break;
                case "split":
                  e = this._getTransformedBySplitOperation(t);
                  break;
                case "merge":
                  e = this._getTransformedByMergeOperation(t);
                  break;
                default:
                  e = Ga._createAt(this);
              }
              return e;
            }
            _getTransformedByInsertOperation(t) {
              return this._getTransformedByInsertion(t.position, t.howMany);
            }
            _getTransformedByMoveOperation(t) {
              return this._getTransformedByMove(
                t.sourcePosition,
                t.targetPosition,
                t.howMany
              );
            }
            _getTransformedBySplitOperation(t) {
              const e = t.movedRange;
              return e.containsPosition(this) ||
                (e.start.isEqual(this) && "toNext" == this.stickiness)
                ? this._getCombined(t.splitPosition, t.moveTargetPosition)
                : t.graveyardPosition
                ? this._getTransformedByMove(
                    t.graveyardPosition,
                    t.insertionPosition,
                    1
                  )
                : this._getTransformedByInsertion(t.insertionPosition, 1);
            }
            _getTransformedByMergeOperation(t) {
              const e = t.movedRange;
              let n;
              return (
                e.containsPosition(this) || e.start.isEqual(this)
                  ? ((n = this._getCombined(
                      t.sourcePosition,
                      t.targetPosition
                    )),
                    t.sourcePosition.isBefore(t.targetPosition) &&
                      (n = n._getTransformedByDeletion(t.deletionPosition, 1)))
                  : (n = this.isEqual(t.deletionPosition)
                      ? Ga._createAt(t.deletionPosition)
                      : this._getTransformedByMove(
                          t.deletionPosition,
                          t.graveyardPosition,
                          1
                        )),
                n
              );
            }
            _getTransformedByDeletion(t, e) {
              const n = Ga._createAt(this);
              if (this.root != t.root) return n;
              if ("same" == Li(t.getParentPath(), this.getParentPath())) {
                if (t.offset < this.offset) {
                  if (t.offset + e > this.offset) return null;
                  n.offset -= e;
                }
              } else if (
                "prefix" == Li(t.getParentPath(), this.getParentPath())
              ) {
                const i = t.path.length - 1;
                if (t.offset <= this.path[i]) {
                  if (t.offset + e > this.path[i]) return null;
                  n.path[i] -= e;
                }
              }
              return n;
            }
            _getTransformedByInsertion(t, e) {
              const n = Ga._createAt(this);
              if (this.root != t.root) return n;
              if ("same" == Li(t.getParentPath(), this.getParentPath()))
                (t.offset < this.offset ||
                  (t.offset == this.offset &&
                    "toPrevious" != this.stickiness)) &&
                  (n.offset += e);
              else if (
                "prefix" == Li(t.getParentPath(), this.getParentPath())
              ) {
                const i = t.path.length - 1;
                t.offset <= this.path[i] && (n.path[i] += e);
              }
              return n;
            }
            _getTransformedByMove(t, e, n) {
              if (((e = e._getTransformedByDeletion(t, n)), t.isEqual(e)))
                return Ga._createAt(this);
              const i = this._getTransformedByDeletion(t, n);
              return null === i ||
                (t.isEqual(this) && "toNext" == this.stickiness) ||
                (t.getShiftedBy(n).isEqual(this) &&
                  "toPrevious" == this.stickiness)
                ? this._getCombined(t, e)
                : i._getTransformedByInsertion(e, n);
            }
            _getCombined(t, e) {
              const n = t.path.length - 1,
                i = Ga._createAt(e);
              return (
                (i.stickiness = this.stickiness),
                (i.offset = i.offset + this.path[n] - t.offset),
                (i.path = [...i.path, ...this.path.slice(n + 1)]),
                i
              );
            }
            toJSON() {
              return {
                root: this.root.toJSON(),
                path: Array.from(this.path),
                stickiness: this.stickiness,
              };
            }
            clone() {
              return new this.constructor(
                this.root,
                this.path,
                this.stickiness
              );
            }
            static _createAt(t, e, n = "toNone") {
              if (t instanceof Ga) return new Ga(t.root, t.path, t.stickiness);
              {
                const i = t;
                if ("end" == e) e = i.maxOffset;
                else {
                  if ("before" == e) return this._createBefore(i, n);
                  if ("after" == e) return this._createAfter(i, n);
                  if (0 !== e && !e)
                    throw new c("model-createpositionat-offset-required", [
                      this,
                      t,
                    ]);
                }
                if (!i.is("element") && !i.is("documentFragment"))
                  throw new c("model-position-parent-incorrect", [this, t]);
                const o = i.getPath();
                return o.push(e), new this(i.root, o, n);
              }
            }
            static _createAfter(t, e) {
              if (!t.parent)
                throw new c("model-position-after-root", [this, t], {
                  root: t,
                });
              return this._createAt(t.parent, t.endOffset, e);
            }
            static _createBefore(t, e) {
              if (!t.parent)
                throw new c("model-position-before-root", t, { root: t });
              return this._createAt(t.parent, t.startOffset, e);
            }
            static fromJSON(t, e) {
              if ("$graveyard" === t.root) {
                const n = new Ga(e.graveyard, t.path);
                return (n.stickiness = t.stickiness), n;
              }
              if (!e.getRoot(t.root))
                throw new c("model-position-fromjson-no-root", e, {
                  rootName: t.root,
                });
              return new Ga(e.getRoot(t.root), t.path, t.stickiness);
            }
          }
          function Wa(t, e) {
            const n = e.getChild(e.offsetToIndex(t.offset));
            return n && n.is("$text") && n.startOffset < t.offset ? n : null;
          }
          function Ya(t, e, n) {
            return null !== n ? null : e.getChild(e.offsetToIndex(t.offset));
          }
          function Ka(t, e, n) {
            return null !== n
              ? null
              : e.getChild(e.offsetToIndex(t.offset) - 1);
          }
          class Qa {
            constructor(t, e = null) {
              (this.start = Ga._createAt(t)),
                (this.end = e ? Ga._createAt(e) : Ga._createAt(t)),
                (this.start.stickiness = this.isCollapsed
                  ? "toNone"
                  : "toNext"),
                (this.end.stickiness = this.isCollapsed
                  ? "toNone"
                  : "toPrevious");
            }
            *[Symbol.iterator]() {
              yield* new $a({ boundaries: this, ignoreElementEnd: !0 });
            }
            get isCollapsed() {
              return this.start.isEqual(this.end);
            }
            get isFlat() {
              return (
                "same" ==
                Li(this.start.getParentPath(), this.end.getParentPath())
              );
            }
            get root() {
              return this.start.root;
            }
            containsPosition(t) {
              return t.isAfter(this.start) && t.isBefore(this.end);
            }
            containsRange(t, e = !1) {
              t.isCollapsed && (e = !1);
              const n =
                  this.containsPosition(t.start) ||
                  (e && this.start.isEqual(t.start)),
                i =
                  this.containsPosition(t.end) ||
                  (e && this.end.isEqual(t.end));
              return n && i;
            }
            containsItem(t) {
              const e = Ga._createBefore(t);
              return this.containsPosition(e) || this.start.isEqual(e);
            }
            is(t) {
              return "range" === t || "model:range" === t;
            }
            isEqual(t) {
              return this.start.isEqual(t.start) && this.end.isEqual(t.end);
            }
            isIntersecting(t) {
              return this.start.isBefore(t.end) && this.end.isAfter(t.start);
            }
            getDifference(t) {
              const e = [];
              return (
                this.isIntersecting(t)
                  ? (this.containsPosition(t.start) &&
                      e.push(new Qa(this.start, t.start)),
                    this.containsPosition(t.end) &&
                      e.push(new Qa(t.end, this.end)))
                  : e.push(new Qa(this.start, this.end)),
                e
              );
            }
            getIntersection(t) {
              if (this.isIntersecting(t)) {
                let e = this.start,
                  n = this.end;
                return (
                  this.containsPosition(t.start) && (e = t.start),
                  this.containsPosition(t.end) && (n = t.end),
                  new Qa(e, n)
                );
              }
              return null;
            }
            getJoined(t, e = !1) {
              let n = this.isIntersecting(t);
              if (
                (n ||
                  (n = this.start.isBefore(t.start)
                    ? e
                      ? this.end.isTouching(t.start)
                      : this.end.isEqual(t.start)
                    : e
                    ? t.end.isTouching(this.start)
                    : t.end.isEqual(this.start)),
                !n)
              )
                return null;
              let i = this.start,
                o = this.end;
              return (
                t.start.isBefore(i) && (i = t.start),
                t.end.isAfter(o) && (o = t.end),
                new Qa(i, o)
              );
            }
            getMinimalFlatRanges() {
              const t = [],
                e = this.start.getCommonPath(this.end).length,
                n = Ga._createAt(this.start);
              let i = n.parent;
              for (; n.path.length > e + 1; ) {
                const e = i.maxOffset - n.offset;
                0 !== e && t.push(new Qa(n, n.getShiftedBy(e))),
                  (n.path = n.path.slice(0, -1)),
                  n.offset++,
                  (i = i.parent);
              }
              for (; n.path.length <= this.end.path.length; ) {
                const e = this.end.path[n.path.length - 1],
                  i = e - n.offset;
                0 !== i && t.push(new Qa(n, n.getShiftedBy(i))),
                  (n.offset = e),
                  n.path.push(0);
              }
              return t;
            }
            getWalker(t = {}) {
              return (t.boundaries = this), new $a(t);
            }
            *getItems(t = {}) {
              (t.boundaries = this), (t.ignoreElementEnd = !0);
              const e = new $a(t);
              for (const t of e) yield t.item;
            }
            *getPositions(t = {}) {
              t.boundaries = this;
              const e = new $a(t);
              yield e.position;
              for (const t of e) yield t.nextPosition;
            }
            getTransformedByOperation(t) {
              switch (t.type) {
                case "insert":
                  return this._getTransformedByInsertOperation(t);
                case "move":
                case "remove":
                case "reinsert":
                  return this._getTransformedByMoveOperation(t);
                case "split":
                  return [this._getTransformedBySplitOperation(t)];
                case "merge":
                  return [this._getTransformedByMergeOperation(t)];
              }
              return [new Qa(this.start, this.end)];
            }
            getTransformedByOperations(t) {
              const e = [new Qa(this.start, this.end)];
              for (const n of t)
                for (let t = 0; t < e.length; t++) {
                  const i = e[t].getTransformedByOperation(n);
                  e.splice(t, 1, ...i), (t += i.length - 1);
                }
              for (let t = 0; t < e.length; t++) {
                const n = e[t];
                for (let i = t + 1; i < e.length; i++) {
                  const t = e[i];
                  (n.containsRange(t) || t.containsRange(n) || n.isEqual(t)) &&
                    e.splice(i, 1);
                }
              }
              return e;
            }
            getCommonAncestor() {
              return this.start.getCommonAncestor(this.end);
            }
            getContainedElement() {
              if (this.isCollapsed) return null;
              const t = this.start.nodeAfter,
                e = this.end.nodeBefore;
              return t && t.is("element") && t === e ? t : null;
            }
            toJSON() {
              return { start: this.start.toJSON(), end: this.end.toJSON() };
            }
            clone() {
              return new this.constructor(this.start, this.end);
            }
            _getTransformedByInsertOperation(t, e = !1) {
              return this._getTransformedByInsertion(t.position, t.howMany, e);
            }
            _getTransformedByMoveOperation(t, e = !1) {
              const n = t.sourcePosition,
                i = t.howMany,
                o = t.targetPosition;
              return this._getTransformedByMove(n, o, i, e);
            }
            _getTransformedBySplitOperation(t) {
              const e = this.start._getTransformedBySplitOperation(t);
              let n = this.end._getTransformedBySplitOperation(t);
              return (
                this.end.isEqual(t.insertionPosition) &&
                  (n = this.end.getShiftedBy(1)),
                e.root != n.root && (n = this.end.getShiftedBy(-1)),
                new Qa(e, n)
              );
            }
            _getTransformedByMergeOperation(t) {
              if (
                this.start.isEqual(t.targetPosition) &&
                this.end.isEqual(t.deletionPosition)
              )
                return new Qa(this.start);
              let e = this.start._getTransformedByMergeOperation(t),
                n = this.end._getTransformedByMergeOperation(t);
              return (
                e.root != n.root && (n = this.end.getShiftedBy(-1)),
                e.isAfter(n)
                  ? (t.sourcePosition.isBefore(t.targetPosition)
                      ? ((e = Ga._createAt(n)), (e.offset = 0))
                      : (t.deletionPosition.isEqual(e) ||
                          (n = t.deletionPosition),
                        (e = t.targetPosition)),
                    new Qa(e, n))
                  : new Qa(e, n)
              );
            }
            _getTransformedByInsertion(t, e, n = !1) {
              if (n && this.containsPosition(t))
                return [
                  new Qa(this.start, t),
                  new Qa(
                    t.getShiftedBy(e),
                    this.end._getTransformedByInsertion(t, e)
                  ),
                ];
              {
                const n = new Qa(this.start, this.end);
                return (
                  (n.start = n.start._getTransformedByInsertion(t, e)),
                  (n.end = n.end._getTransformedByInsertion(t, e)),
                  [n]
                );
              }
            }
            _getTransformedByMove(t, e, n, i = !1) {
              if (this.isCollapsed) {
                const i = this.start._getTransformedByMove(t, e, n);
                return [new Qa(i)];
              }
              const o = Qa._createFromPositionAndShift(t, n),
                r = e._getTransformedByDeletion(t, n);
              if (
                this.containsPosition(e) &&
                !i &&
                (o.containsPosition(this.start) || o.containsPosition(this.end))
              ) {
                const i = this.start._getTransformedByMove(t, e, n),
                  o = this.end._getTransformedByMove(t, e, n);
                return [new Qa(i, o)];
              }
              let s;
              const a = this.getDifference(o);
              let c = null;
              const l = this.getIntersection(o);
              if (
                (1 == a.length
                  ? (c = new Qa(
                      a[0].start._getTransformedByDeletion(t, n),
                      a[0].end._getTransformedByDeletion(t, n)
                    ))
                  : 2 == a.length &&
                    (c = new Qa(
                      this.start,
                      this.end._getTransformedByDeletion(t, n)
                    )),
                (s = c
                  ? c._getTransformedByInsertion(r, n, null !== l || i)
                  : []),
                l)
              ) {
                const t = new Qa(
                  l.start._getCombined(o.start, r),
                  l.end._getCombined(o.start, r)
                );
                2 == s.length ? s.splice(1, 0, t) : s.push(t);
              }
              return s;
            }
            _getTransformedByDeletion(t, e) {
              let n = this.start._getTransformedByDeletion(t, e),
                i = this.end._getTransformedByDeletion(t, e);
              return null == n && null == i
                ? null
                : (null == n && (n = t), null == i && (i = t), new Qa(n, i));
            }
            static _createFromPositionAndShift(t, e) {
              const n = t,
                i = t.getShiftedBy(e);
              return e > 0 ? new this(n, i) : new this(i, n);
            }
            static _createIn(t) {
              return new this(Ga._createAt(t, 0), Ga._createAt(t, t.maxOffset));
            }
            static _createOn(t) {
              return this._createFromPositionAndShift(
                Ga._createBefore(t),
                t.offsetSize
              );
            }
            static _createFromRanges(t) {
              if (0 === t.length)
                throw new c("range-create-from-ranges-empty-array", null);
              if (1 == t.length) return t[0].clone();
              const e = t[0];
              t.sort((t, e) => (t.start.isAfter(e.start) ? 1 : -1));
              const n = t.indexOf(e),
                i = new this(e.start, e.end);
              if (n > 0)
                for (let e = n - 1; t[e].end.isEqual(i.start); e++)
                  i.start = Ga._createAt(t[e].start);
              for (
                let e = n + 1;
                e < t.length && t[e].start.isEqual(i.end);
                e++
              )
                i.end = Ga._createAt(t[e].end);
              return i;
            }
            static fromJSON(t, e) {
              return new this(Ga.fromJSON(t.start, e), Ga.fromJSON(t.end, e));
            }
          }
          class Za {
            constructor() {
              (this._modelToViewMapping = new WeakMap()),
                (this._viewToModelMapping = new WeakMap()),
                (this._viewToModelLengthCallbacks = new Map()),
                (this._markerNameToElements = new Map()),
                (this._elementToMarkerNames = new Map()),
                (this._deferredBindingRemovals = new Map()),
                (this._unboundMarkerNames = new Set()),
                this.on(
                  "modelToViewPosition",
                  (t, e) => {
                    if (e.viewPosition) return;
                    const n = this._modelToViewMapping.get(
                      e.modelPosition.parent
                    );
                    if (!n)
                      throw new c(
                        "mapping-model-position-view-parent-not-found",
                        this,
                        { modelPosition: e.modelPosition }
                      );
                    e.viewPosition = this.findPositionIn(
                      n,
                      e.modelPosition.offset
                    );
                  },
                  { priority: "low" }
                ),
                this.on(
                  "viewToModelPosition",
                  (t, e) => {
                    if (e.modelPosition) return;
                    const n = this.findMappedViewAncestor(e.viewPosition),
                      i = this._viewToModelMapping.get(n),
                      o = this._toModelOffset(
                        e.viewPosition.parent,
                        e.viewPosition.offset,
                        n
                      );
                    e.modelPosition = Ga._createAt(i, o);
                  },
                  { priority: "low" }
                );
            }
            bindElements(t, e) {
              this._modelToViewMapping.set(t, e),
                this._viewToModelMapping.set(e, t);
            }
            unbindViewElement(t, e = {}) {
              const n = this.toModelElement(t);
              if (this._elementToMarkerNames.has(t))
                for (const e of this._elementToMarkerNames.get(t))
                  this._unboundMarkerNames.add(e);
              e.defer
                ? this._deferredBindingRemovals.set(t, t.root)
                : (this._viewToModelMapping.delete(t),
                  this._modelToViewMapping.get(n) == t &&
                    this._modelToViewMapping.delete(n));
            }
            unbindModelElement(t) {
              const e = this.toViewElement(t);
              this._modelToViewMapping.delete(t),
                this._viewToModelMapping.get(e) == t &&
                  this._viewToModelMapping.delete(e);
            }
            bindElementToMarker(t, e) {
              const n = this._markerNameToElements.get(e) || new Set();
              n.add(t);
              const i = this._elementToMarkerNames.get(t) || new Set();
              i.add(e),
                this._markerNameToElements.set(e, n),
                this._elementToMarkerNames.set(t, i);
            }
            unbindElementFromMarkerName(t, e) {
              const n = this._markerNameToElements.get(e);
              n &&
                (n.delete(t),
                0 == n.size && this._markerNameToElements.delete(e));
              const i = this._elementToMarkerNames.get(t);
              i &&
                (i.delete(e),
                0 == i.size && this._elementToMarkerNames.delete(t));
            }
            flushUnboundMarkerNames() {
              const t = Array.from(this._unboundMarkerNames);
              return this._unboundMarkerNames.clear(), t;
            }
            flushDeferredBindings() {
              for (const [t, e] of this._deferredBindingRemovals)
                t.root == e && this.unbindViewElement(t);
              this._deferredBindingRemovals = new Map();
            }
            clearBindings() {
              (this._modelToViewMapping = new WeakMap()),
                (this._viewToModelMapping = new WeakMap()),
                (this._markerNameToElements = new Map()),
                (this._elementToMarkerNames = new Map()),
                (this._unboundMarkerNames = new Set()),
                (this._deferredBindingRemovals = new Map());
            }
            toModelElement(t) {
              return this._viewToModelMapping.get(t);
            }
            toViewElement(t) {
              return this._modelToViewMapping.get(t);
            }
            toModelRange(t) {
              return new Qa(
                this.toModelPosition(t.start),
                this.toModelPosition(t.end)
              );
            }
            toViewRange(t) {
              return new jo(
                this.toViewPosition(t.start),
                this.toViewPosition(t.end)
              );
            }
            toModelPosition(t) {
              const e = { viewPosition: t, mapper: this };
              return this.fire("viewToModelPosition", e), e.modelPosition;
            }
            toViewPosition(t, e = { isPhantom: !1 }) {
              const n = {
                modelPosition: t,
                mapper: this,
                isPhantom: e.isPhantom,
              };
              return this.fire("modelToViewPosition", n), n.viewPosition;
            }
            markerNameToElements(t) {
              const e = this._markerNameToElements.get(t);
              if (!e) return null;
              const n = new Set();
              for (const t of e)
                if (t.is("attributeElement"))
                  for (const e of t.getElementsWithSameId()) n.add(e);
                else n.add(t);
              return n;
            }
            registerViewToModelLength(t, e) {
              this._viewToModelLengthCallbacks.set(t, e);
            }
            findMappedViewAncestor(t) {
              let e = t.parent;
              for (; !this._viewToModelMapping.has(e); ) e = e.parent;
              return e;
            }
            _toModelOffset(t, e, n) {
              if (n != t) {
                return (
                  this._toModelOffset(t.parent, t.index, n) +
                  this._toModelOffset(t, e, t)
                );
              }
              if (t.is("$text")) return e;
              let i = 0;
              for (let n = 0; n < e; n++)
                i += this.getModelLength(t.getChild(n));
              return i;
            }
            getModelLength(t) {
              if (this._viewToModelLengthCallbacks.get(t.name)) {
                return this._viewToModelLengthCallbacks.get(t.name)(t);
              }
              if (this._viewToModelMapping.has(t)) return 1;
              if (t.is("$text")) return t.data.length;
              if (t.is("uiElement")) return 0;
              {
                let e = 0;
                for (const n of t.getChildren()) e += this.getModelLength(n);
                return e;
              }
            }
            findPositionIn(t, e) {
              let n,
                i = 0,
                o = 0,
                r = 0;
              if (t.is("$text")) return new Oo(t, e);
              for (; o < e; )
                (n = t.getChild(r)),
                  (i = this.getModelLength(n)),
                  (o += i),
                  r++;
              return o == e
                ? this._moveViewPositionToTextNode(new Oo(t, r))
                : this.findPositionIn(n, e - (o - i));
            }
            _moveViewPositionToTextNode(t) {
              const e = t.nodeBefore,
                n = t.nodeAfter;
              return e instanceof ji
                ? new Oo(e, e.data.length)
                : n instanceof ji
                ? new Oo(n, 0)
                : t;
            }
          }
          he(Za, k);
          class Ja {
            constructor() {
              (this._consumable = new Map()),
                (this._textProxyRegistry = new Map());
            }
            add(t, e) {
              (e = Xa(e)),
                t instanceof Va && (t = this._getSymbolForTextProxy(t)),
                this._consumable.has(t) || this._consumable.set(t, new Map()),
                this._consumable.get(t).set(e, !0);
            }
            consume(t, e) {
              return (
                (e = Xa(e)),
                t instanceof Va && (t = this._getSymbolForTextProxy(t)),
                !!this.test(t, e) && (this._consumable.get(t).set(e, !1), !0)
              );
            }
            test(t, e) {
              (e = Xa(e)),
                t instanceof Va && (t = this._getSymbolForTextProxy(t));
              const n = this._consumable.get(t);
              if (void 0 === n) return null;
              const i = n.get(e);
              return void 0 === i ? null : i;
            }
            revert(t, e) {
              (e = Xa(e)),
                t instanceof Va && (t = this._getSymbolForTextProxy(t));
              const n = this.test(t, e);
              return !1 === n
                ? (this._consumable.get(t).set(e, !0), !0)
                : !0 !== n && null;
            }
            verifyAllConsumed(t) {
              const e = [];
              for (const [n, i] of this._consumable)
                for (const [o, r] of i) {
                  const i = o.split(":")[0];
                  r &&
                    t == i &&
                    e.push({ event: o, item: n.name || n.description });
                }
              if (e.length)
                throw new c("conversion-model-consumable-not-consumed", null, {
                  items: e,
                });
            }
            _getSymbolForTextProxy(t) {
              let e = null;
              const n = this._textProxyRegistry.get(t.startOffset);
              if (n) {
                const i = n.get(t.endOffset);
                i && (e = i.get(t.parent));
              }
              return e || (e = this._addSymbolForTextProxy(t)), e;
            }
            _addSymbolForTextProxy(t) {
              const e = t.startOffset,
                n = t.endOffset,
                i = t.parent,
                o = Symbol("$textProxy:" + t.data);
              let r, s;
              return (
                (r = this._textProxyRegistry.get(e)),
                r || ((r = new Map()), this._textProxyRegistry.set(e, r)),
                (s = r.get(n)),
                s || ((s = new Map()), r.set(n, s)),
                s.set(i, o),
                o
              );
            }
          }
          function Xa(t) {
            const e = t.split(":");
            return "insert" == e[0]
              ? e[0]
              : "addMarker" == e[0] || "removeMarker" == e[0]
              ? t
              : e.length > 1
              ? e[0] + ":" + e[1]
              : e[0];
          }
          class tc {
            constructor(t) {
              (this._conversionApi = { dispatcher: this, ...t }),
                (this._firedEventsMap = new WeakMap());
            }
            convertChanges(t, e, n) {
              const i = this._createConversionApi(n, t.getRefreshedItems());
              for (const e of t.getMarkersToRemove())
                this._convertMarkerRemove(e.name, e.range, i);
              const o = this._reduceChanges(t.getChanges());
              for (const t of o)
                "insert" === t.type
                  ? this._convertInsert(
                      Qa._createFromPositionAndShift(t.position, t.length),
                      i
                    )
                  : "reinsert" === t.type
                  ? this._convertReinsert(
                      Qa._createFromPositionAndShift(t.position, t.length),
                      i
                    )
                  : "remove" === t.type
                  ? this._convertRemove(t.position, t.length, t.name, i)
                  : this._convertAttribute(
                      t.range,
                      t.attributeKey,
                      t.attributeOldValue,
                      t.attributeNewValue,
                      i
                    );
              for (const t of i.mapper.flushUnboundMarkerNames()) {
                const n = e.get(t).getRange();
                this._convertMarkerRemove(t, n, i),
                  this._convertMarkerAdd(t, n, i);
              }
              for (const e of t.getMarkersToAdd())
                this._convertMarkerAdd(e.name, e.range, i);
              i.mapper.flushDeferredBindings(),
                i.consumable.verifyAllConsumed("insert");
            }
            convert(t, e, n, i = {}) {
              const o = this._createConversionApi(n, void 0, i);
              this._convertInsert(t, o);
              for (const [t, n] of e) this._convertMarkerAdd(t, n, o);
              o.consumable.verifyAllConsumed("insert");
            }
            convertSelection(t, e, n) {
              const i = Array.from(
                  e.getMarkersAtPosition(t.getFirstPosition())
                ),
                o = this._createConversionApi(n);
              if (
                (this._addConsumablesForSelection(o.consumable, t, i),
                this.fire("selection", { selection: t }, o),
                t.isCollapsed)
              ) {
                for (const e of i) {
                  const n = e.getRange();
                  if (!ec(t.getFirstPosition(), e, o.mapper)) continue;
                  const i = { item: t, markerName: e.name, markerRange: n };
                  o.consumable.test(t, "addMarker:" + e.name) &&
                    this.fire("addMarker:" + e.name, i, o);
                }
                for (const e of t.getAttributeKeys()) {
                  const n = {
                    item: t,
                    range: t.getFirstRange(),
                    attributeKey: e,
                    attributeOldValue: null,
                    attributeNewValue: t.getAttribute(e),
                  };
                  o.consumable.test(t, "attribute:" + n.attributeKey) &&
                    this.fire("attribute:" + n.attributeKey + ":$text", n, o);
                }
              }
            }
            _convertInsert(t, e, n = {}) {
              n.doNotAddConsumables ||
                this._addConsumablesForInsert(e.consumable, Array.from(t));
              for (const n of Array.from(t.getWalker({ shallow: !0 })).map(nc))
                this._testAndFire("insert", n, e);
            }
            _convertRemove(t, e, n, i) {
              this.fire("remove:" + n, { position: t, length: e }, i);
            }
            _convertAttribute(t, e, n, i, o) {
              this._addConsumablesForRange(o.consumable, t, `attribute:${e}`);
              for (const r of t) {
                const t = {
                  item: r.item,
                  range: Qa._createFromPositionAndShift(
                    r.previousPosition,
                    r.length
                  ),
                  attributeKey: e,
                  attributeOldValue: n,
                  attributeNewValue: i,
                };
                this._testAndFire(`attribute:${e}`, t, o);
              }
            }
            _convertReinsert(t, e) {
              const n = Array.from(t.getWalker({ shallow: !0 }));
              this._addConsumablesForInsert(e.consumable, n);
              for (const t of n.map(nc))
                this._testAndFire("insert", { ...t, reconversion: !0 }, e);
            }
            _convertMarkerAdd(t, e, n) {
              if ("$graveyard" == e.root.rootName) return;
              const i = "addMarker:" + t;
              if (
                (n.consumable.add(e, i),
                this.fire(i, { markerName: t, markerRange: e }, n),
                n.consumable.consume(e, i))
              ) {
                this._addConsumablesForRange(n.consumable, e, i);
                for (const o of e.getItems()) {
                  if (!n.consumable.test(o, i)) continue;
                  const r = {
                    item: o,
                    range: Qa._createOn(o),
                    markerName: t,
                    markerRange: e,
                  };
                  this.fire(i, r, n);
                }
              }
            }
            _convertMarkerRemove(t, e, n) {
              "$graveyard" != e.root.rootName &&
                this.fire(
                  "removeMarker:" + t,
                  { markerName: t, markerRange: e },
                  n
                );
            }
            _reduceChanges(t) {
              const e = { changes: t };
              return this.fire("reduceChanges", e), e.changes;
            }
            _addConsumablesForInsert(t, e) {
              for (const n of e) {
                const e = n.item;
                if (null === t.test(e, "insert")) {
                  t.add(e, "insert");
                  for (const n of e.getAttributeKeys())
                    t.add(e, "attribute:" + n);
                }
              }
              return t;
            }
            _addConsumablesForRange(t, e, n) {
              for (const i of e.getItems()) t.add(i, n);
              return t;
            }
            _addConsumablesForSelection(t, e, n) {
              t.add(e, "selection");
              for (const i of n) t.add(e, "addMarker:" + i.name);
              for (const n of e.getAttributeKeys()) t.add(e, "attribute:" + n);
              return t;
            }
            _testAndFire(t, e, n) {
              const i = (function (t, e) {
                  const n = e.item.name || "$text";
                  return `${t}:${n}`;
                })(t, e),
                o = e.item.is("$textProxy")
                  ? n.consumable._getSymbolForTextProxy(e.item)
                  : e.item,
                r = this._firedEventsMap.get(n),
                s = r.get(o);
              if (s) {
                if (s.has(i)) return;
                s.add(i);
              } else r.set(o, new Set([i]));
              this.fire(i, e, n);
            }
            _testAndFireAddAttributes(t, e) {
              const n = { item: t, range: Qa._createOn(t) };
              for (const t of n.item.getAttributeKeys())
                (n.attributeKey = t),
                  (n.attributeOldValue = null),
                  (n.attributeNewValue = n.item.getAttribute(t)),
                  this._testAndFire(`attribute:${t}`, n, e);
            }
            _createConversionApi(t, e = new Set(), n = {}) {
              const i = {
                ...this._conversionApi,
                consumable: new Ja(),
                writer: t,
                options: n,
                convertItem: (t) => this._convertInsert(Qa._createOn(t), i),
                convertChildren: (t) =>
                  this._convertInsert(Qa._createIn(t), i, {
                    doNotAddConsumables: !0,
                  }),
                convertAttributes: (t) => this._testAndFireAddAttributes(t, i),
                canReuseView: (t) => !e.has(i.mapper.toModelElement(t)),
              };
              return this._firedEventsMap.set(i, new Map()), i;
            }
          }
          function ec(t, e, n) {
            const i = e.getRange(),
              o = Array.from(t.getAncestors());
            o.shift(), o.reverse();
            return !o.some((t) => {
              if (i.containsItem(t)) {
                return !!n.toViewElement(t).getCustomProperty("addHighlight");
              }
            });
          }
          function nc(t) {
            return {
              item: t.item,
              range: Qa._createFromPositionAndShift(
                t.previousPosition,
                t.length
              ),
            };
          }
          he(tc, k);
          class ic {
            constructor(t, e, n) {
              (this._lastRangeBackward = !1),
                (this._ranges = []),
                (this._attrs = new Map()),
                t && this.setTo(t, e, n);
            }
            get anchor() {
              if (this._ranges.length > 0) {
                const t = this._ranges[this._ranges.length - 1];
                return this._lastRangeBackward ? t.end : t.start;
              }
              return null;
            }
            get focus() {
              if (this._ranges.length > 0) {
                const t = this._ranges[this._ranges.length - 1];
                return this._lastRangeBackward ? t.start : t.end;
              }
              return null;
            }
            get isCollapsed() {
              return 1 === this._ranges.length && this._ranges[0].isCollapsed;
            }
            get rangeCount() {
              return this._ranges.length;
            }
            get isBackward() {
              return !this.isCollapsed && this._lastRangeBackward;
            }
            isEqual(t) {
              if (this.rangeCount != t.rangeCount) return !1;
              if (0 === this.rangeCount) return !0;
              if (
                !this.anchor.isEqual(t.anchor) ||
                !this.focus.isEqual(t.focus)
              )
                return !1;
              for (const e of this._ranges) {
                let n = !1;
                for (const i of t._ranges)
                  if (e.isEqual(i)) {
                    n = !0;
                    break;
                  }
                if (!n) return !1;
              }
              return !0;
            }
            *getRanges() {
              for (const t of this._ranges) yield new Qa(t.start, t.end);
            }
            getFirstRange() {
              let t = null;
              for (const e of this._ranges)
                (t && !e.start.isBefore(t.start)) || (t = e);
              return t ? new Qa(t.start, t.end) : null;
            }
            getLastRange() {
              let t = null;
              for (const e of this._ranges)
                (t && !e.end.isAfter(t.end)) || (t = e);
              return t ? new Qa(t.start, t.end) : null;
            }
            getFirstPosition() {
              const t = this.getFirstRange();
              return t ? t.start.clone() : null;
            }
            getLastPosition() {
              const t = this.getLastRange();
              return t ? t.end.clone() : null;
            }
            setTo(t, e, n) {
              if (null === t) this._setRanges([]);
              else if (t instanceof ic)
                this._setRanges(t.getRanges(), t.isBackward);
              else if (t && "function" == typeof t.getRanges)
                this._setRanges(t.getRanges(), t.isBackward);
              else if (t instanceof Qa)
                this._setRanges([t], !!e && !!e.backward);
              else if (t instanceof Ga) this._setRanges([new Qa(t)]);
              else if (t instanceof ja) {
                const i = !!n && !!n.backward;
                let o;
                if ("in" == e) o = Qa._createIn(t);
                else if ("on" == e) o = Qa._createOn(t);
                else {
                  if (void 0 === e)
                    throw new c(
                      "model-selection-setto-required-second-parameter",
                      [this, t]
                    );
                  o = new Qa(Ga._createAt(t, e));
                }
                this._setRanges([o], i);
              } else {
                if (!Ei(t))
                  throw new c("model-selection-setto-not-selectable", [
                    this,
                    t,
                  ]);
                this._setRanges(t, e && !!e.backward);
              }
            }
            _setRanges(t, e = !1) {
              const n = (t = Array.from(t)).some((e) => {
                if (!(e instanceof Qa))
                  throw new c("model-selection-set-ranges-not-range", [
                    this,
                    t,
                  ]);
                return this._ranges.every((t) => !t.isEqual(e));
              });
              if (t.length !== this._ranges.length || n) {
                this._removeAllRanges();
                for (const e of t) this._pushRange(e);
                (this._lastRangeBackward = !!e),
                  this.fire("change:range", { directChange: !0 });
              }
            }
            setFocus(t, e) {
              if (null === this.anchor)
                throw new c("model-selection-setfocus-no-ranges", [this, t]);
              const n = Ga._createAt(t, e);
              if ("same" == n.compareWith(this.focus)) return;
              const i = this.anchor;
              this._ranges.length && this._popRange(),
                "before" == n.compareWith(i)
                  ? (this._pushRange(new Qa(n, i)),
                    (this._lastRangeBackward = !0))
                  : (this._pushRange(new Qa(i, n)),
                    (this._lastRangeBackward = !1)),
                this.fire("change:range", { directChange: !0 });
            }
            getAttribute(t) {
              return this._attrs.get(t);
            }
            getAttributes() {
              return this._attrs.entries();
            }
            getAttributeKeys() {
              return this._attrs.keys();
            }
            hasAttribute(t) {
              return this._attrs.has(t);
            }
            removeAttribute(t) {
              this.hasAttribute(t) &&
                (this._attrs.delete(t),
                this.fire("change:attribute", {
                  attributeKeys: [t],
                  directChange: !0,
                }));
            }
            setAttribute(t, e) {
              this.getAttribute(t) !== e &&
                (this._attrs.set(t, e),
                this.fire("change:attribute", {
                  attributeKeys: [t],
                  directChange: !0,
                }));
            }
            getSelectedElement() {
              return 1 !== this.rangeCount
                ? null
                : this.getFirstRange().getContainedElement();
            }
            is(t) {
              return "selection" === t || "model:selection" === t;
            }
            *getSelectedBlocks() {
              const t = new WeakSet();
              for (const e of this.getRanges()) {
                const n = sc(e.start, t);
                n && ac(n, e) && (yield n);
                for (const n of e.getWalker()) {
                  const i = n.item;
                  "elementEnd" == n.type && rc(i, t, e) && (yield i);
                }
                const i = sc(e.end, t);
                i &&
                  !e.end.isTouching(Ga._createAt(i, 0)) &&
                  ac(i, e) &&
                  (yield i);
              }
            }
            containsEntireContent(t = this.anchor.root) {
              const e = Ga._createAt(t, 0),
                n = Ga._createAt(t, "end");
              return (
                e.isTouching(this.getFirstPosition()) &&
                n.isTouching(this.getLastPosition())
              );
            }
            _pushRange(t) {
              this._checkRange(t), this._ranges.push(new Qa(t.start, t.end));
            }
            _checkRange(t) {
              for (let e = 0; e < this._ranges.length; e++)
                if (t.isIntersecting(this._ranges[e]))
                  throw new c("model-selection-range-intersects", [this, t], {
                    addedRange: t,
                    intersectingRange: this._ranges[e],
                  });
            }
            _removeAllRanges() {
              for (; this._ranges.length > 0; ) this._popRange();
            }
            _popRange() {
              this._ranges.pop();
            }
          }
          function oc(t, e) {
            return (
              !e.has(t) &&
              (e.add(t), t.root.document.model.schema.isBlock(t) && t.parent)
            );
          }
          function rc(t, e, n) {
            return oc(t, e) && ac(t, n);
          }
          function sc(t, e) {
            const n = t.parent.root.document.model.schema,
              i = t.parent.getAncestors({ parentFirst: !0, includeSelf: !0 });
            let o = !1;
            const r = i.find((t) => !o && ((o = n.isLimit(t)), !o && oc(t, e)));
            return i.forEach((t) => e.add(t)), r;
          }
          function ac(t, e) {
            const n = (function (t) {
              const e = t.root.document.model.schema;
              let n = t.parent;
              for (; n; ) {
                if (e.isBlock(n)) return n;
                n = n.parent;
              }
            })(t);
            if (!n) return !0;
            return !e.containsRange(Qa._createOn(n), !0);
          }
          he(ic, k);
          class cc extends Qa {
            constructor(t, e) {
              super(t, e), lc.call(this);
            }
            detach() {
              this.stopListening();
            }
            is(t) {
              return (
                "liveRange" === t ||
                "model:liveRange" === t ||
                "range" == t ||
                "model:range" === t
              );
            }
            toRange() {
              return new Qa(this.start, this.end);
            }
            static fromRange(t) {
              return new cc(t.start, t.end);
            }
          }
          function lc() {
            this.listenTo(
              this.root.document.model,
              "applyOperation",
              (t, e) => {
                const n = e[0];
                n.isDocumentOperation && dc.call(this, n);
              },
              { priority: "low" }
            );
          }
          function dc(t) {
            const e = this.getTransformedByOperation(t),
              n = Qa._createFromRanges(e),
              i = !n.isEqual(this),
              o = (function (t, e) {
                switch (e.type) {
                  case "insert":
                    return t.containsPosition(e.position);
                  case "move":
                  case "remove":
                  case "reinsert":
                  case "merge":
                    return (
                      t.containsPosition(e.sourcePosition) ||
                      t.start.isEqual(e.sourcePosition) ||
                      t.containsPosition(e.targetPosition)
                    );
                  case "split":
                    return (
                      t.containsPosition(e.splitPosition) ||
                      t.containsPosition(e.insertionPosition)
                    );
                }
                return !1;
              })(this, t);
            let r = null;
            if (i) {
              "$graveyard" == n.root.rootName &&
                (r =
                  "remove" == t.type ? t.sourcePosition : t.deletionPosition);
              const e = this.toRange();
              (this.start = n.start),
                (this.end = n.end),
                this.fire("change:range", e, { deletionPosition: r });
            } else
              o &&
                this.fire("change:content", this.toRange(), {
                  deletionPosition: r,
                });
          }
          he(cc, k);
          const hc = "selection:";
          class uc {
            constructor(t) {
              (this._selection = new mc(t)),
                this._selection.delegate("change:range").to(this),
                this._selection.delegate("change:attribute").to(this),
                this._selection.delegate("change:marker").to(this);
            }
            get isCollapsed() {
              return this._selection.isCollapsed;
            }
            get anchor() {
              return this._selection.anchor;
            }
            get focus() {
              return this._selection.focus;
            }
            get rangeCount() {
              return this._selection.rangeCount;
            }
            get hasOwnRange() {
              return this._selection.hasOwnRange;
            }
            get isBackward() {
              return this._selection.isBackward;
            }
            get isGravityOverridden() {
              return this._selection.isGravityOverridden;
            }
            get markers() {
              return this._selection.markers;
            }
            get _ranges() {
              return this._selection._ranges;
            }
            getRanges() {
              return this._selection.getRanges();
            }
            getFirstPosition() {
              return this._selection.getFirstPosition();
            }
            getLastPosition() {
              return this._selection.getLastPosition();
            }
            getFirstRange() {
              return this._selection.getFirstRange();
            }
            getLastRange() {
              return this._selection.getLastRange();
            }
            getSelectedBlocks() {
              return this._selection.getSelectedBlocks();
            }
            getSelectedElement() {
              return this._selection.getSelectedElement();
            }
            containsEntireContent(t) {
              return this._selection.containsEntireContent(t);
            }
            destroy() {
              this._selection.destroy();
            }
            getAttributeKeys() {
              return this._selection.getAttributeKeys();
            }
            getAttributes() {
              return this._selection.getAttributes();
            }
            getAttribute(t) {
              return this._selection.getAttribute(t);
            }
            hasAttribute(t) {
              return this._selection.hasAttribute(t);
            }
            refresh() {
              this._selection._updateMarkers(),
                this._selection._updateAttributes(!1);
            }
            observeMarkers(t) {
              this._selection.observeMarkers(t);
            }
            is(t) {
              return (
                "selection" === t ||
                "model:selection" == t ||
                "documentSelection" == t ||
                "model:documentSelection" == t
              );
            }
            _setFocus(t, e) {
              this._selection.setFocus(t, e);
            }
            _setTo(t, e, n) {
              this._selection.setTo(t, e, n);
            }
            _setAttribute(t, e) {
              this._selection.setAttribute(t, e);
            }
            _removeAttribute(t) {
              this._selection.removeAttribute(t);
            }
            _getStoredAttributes() {
              return this._selection._getStoredAttributes();
            }
            _overrideGravity() {
              return this._selection.overrideGravity();
            }
            _restoreGravity(t) {
              this._selection.restoreGravity(t);
            }
            static _getStoreAttributeKey(t) {
              return hc + t;
            }
            static _isStoreAttributeKey(t) {
              return t.startsWith(hc);
            }
          }
          he(uc, k);
          class mc extends ic {
            constructor(t) {
              super(),
                (this.markers = new Di({ idProperty: "name" })),
                (this._model = t.model),
                (this._document = t),
                (this._attributePriority = new Map()),
                (this._selectionRestorePosition = null),
                (this._hasChangedRange = !1),
                (this._overriddenGravityRegister = new Set()),
                (this._observedMarkers = new Set()),
                this.listenTo(
                  this._model,
                  "applyOperation",
                  (t, e) => {
                    const n = e[0];
                    n.isDocumentOperation &&
                      "marker" != n.type &&
                      "rename" != n.type &&
                      "noop" != n.type &&
                      (0 == this._ranges.length &&
                        this._selectionRestorePosition &&
                        this._fixGraveyardSelection(
                          this._selectionRestorePosition
                        ),
                      (this._selectionRestorePosition = null),
                      this._hasChangedRange &&
                        ((this._hasChangedRange = !1),
                        this.fire("change:range", { directChange: !1 })));
                  },
                  { priority: "lowest" }
                ),
                this.on("change:range", () => {
                  for (const t of this.getRanges())
                    if (!this._document._validateSelectionRange(t))
                      throw new c("document-selection-wrong-position", this, {
                        range: t,
                      });
                }),
                this.listenTo(this._model.markers, "update", (t, e, n, i) => {
                  this._updateMarker(e, i);
                }),
                this.listenTo(this._document, "change", (t, e) => {
                  !(function (t, e) {
                    const n = t.document.differ;
                    for (const i of n.getChanges()) {
                      if ("insert" != i.type) continue;
                      const n = i.position.parent;
                      i.length === n.maxOffset &&
                        t.enqueueChange(e, (t) => {
                          const e = Array.from(n.getAttributeKeys()).filter(
                            (t) => t.startsWith(hc)
                          );
                          for (const i of e) t.removeAttribute(i, n);
                        });
                    }
                  })(this._model, e);
                });
            }
            get isCollapsed() {
              return 0 === this._ranges.length
                ? this._document._getDefaultRange().isCollapsed
                : super.isCollapsed;
            }
            get anchor() {
              return super.anchor || this._document._getDefaultRange().start;
            }
            get focus() {
              return super.focus || this._document._getDefaultRange().end;
            }
            get rangeCount() {
              return this._ranges.length ? this._ranges.length : 1;
            }
            get hasOwnRange() {
              return this._ranges.length > 0;
            }
            get isGravityOverridden() {
              return !!this._overriddenGravityRegister.size;
            }
            destroy() {
              for (let t = 0; t < this._ranges.length; t++)
                this._ranges[t].detach();
              this.stopListening();
            }
            *getRanges() {
              this._ranges.length
                ? yield* super.getRanges()
                : yield this._document._getDefaultRange();
            }
            getFirstRange() {
              return super.getFirstRange() || this._document._getDefaultRange();
            }
            getLastRange() {
              return super.getLastRange() || this._document._getDefaultRange();
            }
            setTo(t, e, n) {
              super.setTo(t, e, n),
                this._updateAttributes(!0),
                this._updateMarkers();
            }
            setFocus(t, e) {
              super.setFocus(t, e),
                this._updateAttributes(!0),
                this._updateMarkers();
            }
            setAttribute(t, e) {
              if (this._setAttribute(t, e)) {
                const e = [t];
                this.fire("change:attribute", {
                  attributeKeys: e,
                  directChange: !0,
                });
              }
            }
            removeAttribute(t) {
              if (this._removeAttribute(t)) {
                const e = [t];
                this.fire("change:attribute", {
                  attributeKeys: e,
                  directChange: !0,
                });
              }
            }
            overrideGravity() {
              const t = r();
              return (
                this._overriddenGravityRegister.add(t),
                1 === this._overriddenGravityRegister.size &&
                  this._updateAttributes(!0),
                t
              );
            }
            restoreGravity(t) {
              if (!this._overriddenGravityRegister.has(t))
                throw new c("document-selection-gravity-wrong-restore", this, {
                  uid: t,
                });
              this._overriddenGravityRegister.delete(t),
                this.isGravityOverridden || this._updateAttributes(!0);
            }
            observeMarkers(t) {
              this._observedMarkers.add(t), this._updateMarkers();
            }
            _popRange() {
              this._ranges.pop().detach();
            }
            _pushRange(t) {
              const e = this._prepareRange(t);
              e && this._ranges.push(e);
            }
            _prepareRange(t) {
              if ((this._checkRange(t), t.root == this._document.graveyard))
                return;
              const e = cc.fromRange(t);
              return (
                e.on("change:range", (t, n, i) => {
                  if (
                    ((this._hasChangedRange = !0),
                    e.root == this._document.graveyard)
                  ) {
                    this._selectionRestorePosition = i.deletionPosition;
                    const t = this._ranges.indexOf(e);
                    this._ranges.splice(t, 1), e.detach();
                  }
                }),
                e
              );
            }
            _updateMarkers() {
              if (!this._observedMarkers.size) return;
              const t = [];
              let e = !1;
              for (const e of this._model.markers) {
                const n = e.name.split(":", 1)[0];
                if (!this._observedMarkers.has(n)) continue;
                const i = e.getRange();
                for (const n of this.getRanges())
                  i.containsRange(n, !n.isCollapsed) && t.push(e);
              }
              const n = Array.from(this.markers);
              for (const n of t)
                this.markers.has(n) || (this.markers.add(n), (e = !0));
              for (const n of Array.from(this.markers))
                t.includes(n) || (this.markers.remove(n), (e = !0));
              e &&
                this.fire("change:marker", { oldMarkers: n, directChange: !1 });
            }
            _updateMarker(t, e) {
              const n = t.name.split(":", 1)[0];
              if (!this._observedMarkers.has(n)) return;
              let i = !1;
              const o = Array.from(this.markers),
                r = this.markers.has(t);
              if (e) {
                let n = !1;
                for (const t of this.getRanges())
                  if (e.containsRange(t, !t.isCollapsed)) {
                    n = !0;
                    break;
                  }
                n && !r
                  ? (this.markers.add(t), (i = !0))
                  : !n && r && (this.markers.remove(t), (i = !0));
              } else r && (this.markers.remove(t), (i = !0));
              i &&
                this.fire("change:marker", { oldMarkers: o, directChange: !1 });
            }
            _updateAttributes(t) {
              const e = Vi(this._getSurroundingAttributes()),
                n = Vi(this.getAttributes());
              if (t)
                (this._attributePriority = new Map()),
                  (this._attrs = new Map());
              else
                for (const [t, e] of this._attributePriority)
                  "low" == e &&
                    (this._attrs.delete(t), this._attributePriority.delete(t));
              this._setAttributesTo(e);
              const i = [];
              for (const [t, e] of this.getAttributes())
                (n.has(t) && n.get(t) === e) || i.push(t);
              for (const [t] of n) this.hasAttribute(t) || i.push(t);
              i.length > 0 &&
                this.fire("change:attribute", {
                  attributeKeys: i,
                  directChange: !1,
                });
            }
            _setAttribute(t, e, n = !0) {
              const i = n ? "normal" : "low";
              if ("low" == i && "normal" == this._attributePriority.get(t))
                return !1;
              return (
                super.getAttribute(t) !== e &&
                (this._attrs.set(t, e), this._attributePriority.set(t, i), !0)
              );
            }
            _removeAttribute(t, e = !0) {
              const n = e ? "normal" : "low";
              return (
                ("low" != n || "normal" != this._attributePriority.get(t)) &&
                (this._attributePriority.set(t, n),
                !!super.hasAttribute(t) && (this._attrs.delete(t), !0))
              );
            }
            _setAttributesTo(t) {
              const e = new Set();
              for (const [e, n] of this.getAttributes())
                t.get(e) !== n && this._removeAttribute(e, !1);
              for (const [n, i] of t) {
                this._setAttribute(n, i, !1) && e.add(n);
              }
              return e;
            }
            *_getStoredAttributes() {
              const t = this.getFirstPosition().parent;
              if (this.isCollapsed && t.isEmpty)
                for (const e of t.getAttributeKeys())
                  if (e.startsWith(hc)) {
                    const n = e.substr(hc.length);
                    yield [n, t.getAttribute(e)];
                  }
            }
            _getSurroundingAttributes() {
              const t = this.getFirstPosition(),
                e = this._model.schema;
              let n = null;
              if (this.isCollapsed) {
                const i = t.textNode ? t.textNode : t.nodeBefore,
                  o = t.textNode ? t.textNode : t.nodeAfter;
                if (
                  (this.isGravityOverridden || (n = gc(i)),
                  n || (n = gc(o)),
                  !this.isGravityOverridden && !n)
                ) {
                  let t = i;
                  for (; t && !e.isInline(t) && !n; )
                    (t = t.previousSibling), (n = gc(t));
                }
                if (!n) {
                  let t = o;
                  for (; t && !e.isInline(t) && !n; )
                    (t = t.nextSibling), (n = gc(t));
                }
                n || (n = this._getStoredAttributes());
              } else {
                const t = this.getFirstRange();
                for (const i of t) {
                  if (i.item.is("element") && e.isObject(i.item)) break;
                  if ("text" == i.type) {
                    n = i.item.getAttributes();
                    break;
                  }
                }
              }
              return n;
            }
            _fixGraveyardSelection(t) {
              const e = this._model.schema.getNearestSelectionRange(t);
              e && this._pushRange(e);
            }
          }
          function gc(t) {
            return t instanceof Va || t instanceof Fa
              ? t.getAttributes()
              : null;
          }
          class pc {
            constructor(t) {
              this._dispatchers = t;
            }
            add(t) {
              for (const e of this._dispatchers) t(e);
              return this;
            }
          }
          const fc = function (t) {
            return Ai(t, 5);
          };
          class kc extends pc {
            elementToElement(t) {
              return this.add(
                (function (t) {
                  ((t = fc(t)).model = Ac(t.model)),
                    (t.view = _c(t.view, "container")),
                    t.model.attributes.length && (t.model.children = !0);
                  return (e) => {
                    e.on(
                      "insert:" + t.model.name,
                      (function (t, e = Ic) {
                        return (n, i, o) => {
                          if (!e(i.item, o.consumable, { preflight: !0 }))
                            return;
                          const r = t(i.item, o, i);
                          if (!r) return;
                          e(i.item, o.consumable);
                          const s = o.mapper.toViewPosition(i.range.start);
                          o.mapper.bindElements(i.item, r),
                            o.writer.insert(s, r),
                            o.convertAttributes(i.item),
                            Dc(r, i.item.getChildren(), o, {
                              reconversion: i.reconversion,
                            });
                        };
                      })(t.view, Ec(t.model)),
                      { priority: t.converterPriority || "normal" }
                    ),
                      (t.model.children || t.model.attributes.length) &&
                        e.on("reduceChanges", xc(t.model), { priority: "low" });
                  };
                })(t)
              );
            }
            elementToStructure(t) {
              return this.add(
                (function (t) {
                  return (
                    ((t = fc(t)).model = Ac(t.model)),
                    (t.view = _c(t.view, "container")),
                    (t.model.children = !0),
                    (e) => {
                      if (
                        e._conversionApi.schema.checkChild(
                          t.model.name,
                          "$text"
                        )
                      )
                        throw new c(
                          "conversion-element-to-structure-disallowed-text",
                          e,
                          { elementName: t.model.name }
                        );
                      var n, i;
                      e.on(
                        "insert:" + t.model.name,
                        ((n = t.view),
                        (i = Ec(t.model)),
                        (t, e, o) => {
                          if (!i(e.item, o.consumable, { preflight: !0 }))
                            return;
                          const r = new Map();
                          o.writer._registerSlotFactory(
                            (function (t, e, n) {
                              return (i, o = "children") => {
                                const r = i.createContainerElement("$slot");
                                let s = null;
                                if ("children" === o)
                                  s = Array.from(t.getChildren());
                                else {
                                  if ("function" != typeof o)
                                    throw new c(
                                      "conversion-slot-mode-unknown",
                                      n.dispatcher,
                                      { modeOrFilter: o }
                                    );
                                  s = Array.from(t.getChildren()).filter((t) =>
                                    o(t)
                                  );
                                }
                                return e.set(r, s), r;
                              };
                            })(e.item, r, o)
                          );
                          const s = n(e.item, o, e);
                          if ((o.writer._clearSlotFactory(), !s)) return;
                          !(function (t, e, n) {
                            const i = Array.from(e.values()).flat(),
                              o = new Set(i);
                            if (o.size != i.length)
                              throw new c(
                                "conversion-slot-filter-overlap",
                                n.dispatcher,
                                { element: t }
                              );
                            if (o.size != t.childCount)
                              throw new c(
                                "conversion-slot-filter-incomplete",
                                n.dispatcher,
                                { element: t }
                              );
                          })(e.item, r, o),
                            i(e.item, o.consumable);
                          const a = o.mapper.toViewPosition(e.range.start);
                          o.mapper.bindElements(e.item, s),
                            o.writer.insert(a, s),
                            o.convertAttributes(e.item),
                            (function (t, e, n, i) {
                              n.mapper.on("modelToViewPosition", s, {
                                priority: "highest",
                              });
                              let o = null,
                                r = null;
                              for ([o, r] of e)
                                Dc(t, r, n, i),
                                  n.writer.move(
                                    n.writer.createRangeIn(o),
                                    n.writer.createPositionBefore(o)
                                  ),
                                  n.writer.remove(o);
                              function s(t, e) {
                                const n = e.modelPosition.nodeAfter,
                                  i = r.indexOf(n);
                                i < 0 ||
                                  (e.viewPosition = e.mapper.findPositionIn(
                                    o,
                                    i
                                  ));
                              }
                              n.mapper.off("modelToViewPosition", s);
                            })(s, r, o, { reconversion: e.reconversion });
                        }),
                        { priority: t.converterPriority || "normal" }
                      ),
                        e.on("reduceChanges", xc(t.model), { priority: "low" });
                    }
                  );
                })(t)
              );
            }
            attributeToElement(t) {
              return this.add(
                (function (t) {
                  t = fc(t);
                  let e = "attribute:" + (t.model.key ? t.model.key : t.model);
                  t.model.name && (e += ":" + t.model.name);
                  if (t.model.values)
                    for (const e of t.model.values)
                      t.view[e] = _c(t.view[e], "attribute");
                  else t.view = _c(t.view, "attribute");
                  const n = Cc(t);
                  return (i) => {
                    i.on(
                      e,
                      (function (t) {
                        return (e, n, i) => {
                          if (!i.consumable.test(n.item, e.name)) return;
                          const o = t(n.attributeOldValue, i, n),
                            r = t(n.attributeNewValue, i, n);
                          if (!o && !r) return;
                          i.consumable.consume(n.item, e.name);
                          const s = i.writer,
                            a = s.document.selection;
                          if (n.item instanceof ic || n.item instanceof uc)
                            s.wrap(a.getFirstRange(), r);
                          else {
                            let t = i.mapper.toViewRange(n.range);
                            null !== n.attributeOldValue &&
                              o &&
                              (t = s.unwrap(t, o)),
                              null !== n.attributeNewValue && r && s.wrap(t, r);
                          }
                        };
                      })(n),
                      { priority: t.converterPriority || "normal" }
                    );
                  };
                })(t)
              );
            }
            attributeToAttribute(t) {
              return this.add(
                (function (t) {
                  t = fc(t);
                  let e = "attribute:" + (t.model.key ? t.model.key : t.model);
                  t.model.name && (e += ":" + t.model.name);
                  if (t.model.values)
                    for (const e of t.model.values) t.view[e] = vc(t.view[e]);
                  else t.view = vc(t.view);
                  const n = Cc(t);
                  return (i) => {
                    var o;
                    i.on(
                      e,
                      ((o = n),
                      (t, e, n) => {
                        if (!n.consumable.test(e.item, t.name)) return;
                        const i = o(e.attributeOldValue, n, e),
                          r = o(e.attributeNewValue, n, e);
                        if (!i && !r) return;
                        n.consumable.consume(e.item, t.name);
                        const s = n.mapper.toViewElement(e.item),
                          a = n.writer;
                        if (!s)
                          throw new c(
                            "conversion-attribute-to-attribute-on-text",
                            n.dispatcher,
                            e
                          );
                        if (null !== e.attributeOldValue && i)
                          if ("class" == i.key) {
                            const t = Ii(i.value);
                            for (const e of t) a.removeClass(e, s);
                          } else if ("style" == i.key) {
                            const t = Object.keys(i.value);
                            for (const e of t) a.removeStyle(e, s);
                          } else a.removeAttribute(i.key, s);
                        if (null !== e.attributeNewValue && r)
                          if ("class" == r.key) {
                            const t = Ii(r.value);
                            for (const e of t) a.addClass(e, s);
                          } else if ("style" == r.key) {
                            const t = Object.keys(r.value);
                            for (const e of t) a.setStyle(e, r.value[e], s);
                          } else a.setAttribute(r.key, r.value, s);
                      }),
                      { priority: t.converterPriority || "normal" }
                    );
                  };
                })(t)
              );
            }
            markerToElement(t) {
              return this.add(
                (function (t) {
                  return (
                    ((t = fc(t)).view = _c(t.view, "ui")),
                    (e) => {
                      var n;
                      e.on(
                        "addMarker:" + t.model,
                        ((n = t.view),
                        (t, e, i) => {
                          e.isOpening = !0;
                          const o = n(e, i);
                          e.isOpening = !1;
                          const r = n(e, i);
                          if (!o || !r) return;
                          const s = e.markerRange;
                          if (s.isCollapsed && !i.consumable.consume(s, t.name))
                            return;
                          for (const e of s)
                            if (!i.consumable.consume(e.item, t.name)) return;
                          const a = i.mapper,
                            c = i.writer;
                          c.insert(a.toViewPosition(s.start), o),
                            i.mapper.bindElementToMarker(o, e.markerName),
                            s.isCollapsed ||
                              (c.insert(a.toViewPosition(s.end), r),
                              i.mapper.bindElementToMarker(r, e.markerName)),
                            t.stop();
                        }),
                        { priority: t.converterPriority || "normal" }
                      ),
                        e.on(
                          "removeMarker:" + t.model,
                          (t.view,
                          (t, e, n) => {
                            const i = n.mapper.markerNameToElements(
                              e.markerName
                            );
                            if (i) {
                              for (const t of i)
                                n.mapper.unbindElementFromMarkerName(
                                  t,
                                  e.markerName
                                ),
                                  n.writer.clear(n.writer.createRangeOn(t), t);
                              n.writer.clearClonedElementsGroup(e.markerName),
                                t.stop();
                            }
                          }),
                          { priority: t.converterPriority || "normal" }
                        );
                    }
                  );
                })(t)
              );
            }
            markerToHighlight(t) {
              return this.add(
                (function (t) {
                  return (e) => {
                    var n;
                    e.on(
                      "addMarker:" + t.model,
                      ((n = t.view),
                      (t, e, i) => {
                        if (!e.item) return;
                        if (
                          !(
                            e.item instanceof ic ||
                            e.item instanceof uc ||
                            e.item.is("$textProxy")
                          )
                        )
                          return;
                        const o = yc(n, e, i);
                        if (!o) return;
                        if (!i.consumable.consume(e.item, t.name)) return;
                        const r = i.writer,
                          s = bc(r, o),
                          a = r.document.selection;
                        if (e.item instanceof ic || e.item instanceof uc)
                          r.wrap(a.getFirstRange(), s, a);
                        else {
                          const t = i.mapper.toViewRange(e.range),
                            n = r.wrap(t, s);
                          for (const t of n.getItems())
                            if (t.is("attributeElement") && t.isSimilar(s)) {
                              i.mapper.bindElementToMarker(t, e.markerName);
                              break;
                            }
                        }
                      }),
                      { priority: t.converterPriority || "normal" }
                    ),
                      e.on(
                        "addMarker:" + t.model,
                        (function (t) {
                          return (e, n, i) => {
                            if (!n.item) return;
                            if (!(n.item instanceof Ua)) return;
                            const o = yc(t, n, i);
                            if (!o) return;
                            if (!i.consumable.test(n.item, e.name)) return;
                            const r = i.mapper.toViewElement(n.item);
                            if (r && r.getCustomProperty("addHighlight")) {
                              i.consumable.consume(n.item, e.name);
                              for (const t of Qa._createIn(n.item))
                                i.consumable.consume(t.item, e.name);
                              r.getCustomProperty("addHighlight")(
                                r,
                                o,
                                i.writer
                              ),
                                i.mapper.bindElementToMarker(r, n.markerName);
                            }
                          };
                        })(t.view),
                        { priority: t.converterPriority || "normal" }
                      ),
                      e.on(
                        "removeMarker:" + t.model,
                        (function (t) {
                          return (e, n, i) => {
                            if (n.markerRange.isCollapsed) return;
                            const o = yc(t, n, i);
                            if (!o) return;
                            const r = bc(i.writer, o),
                              s = i.mapper.markerNameToElements(n.markerName);
                            if (s) {
                              for (const t of s)
                                i.mapper.unbindElementFromMarkerName(
                                  t,
                                  n.markerName
                                ),
                                  t.is("attributeElement")
                                    ? i.writer.unwrap(
                                        i.writer.createRangeOn(t),
                                        r
                                      )
                                    : t.getCustomProperty("removeHighlight")(
                                        t,
                                        o.id,
                                        i.writer
                                      );
                              i.writer.clearClonedElementsGroup(n.markerName),
                                e.stop();
                            }
                          };
                        })(t.view),
                        { priority: t.converterPriority || "normal" }
                      );
                  };
                })(t)
              );
            }
            markerToData(t) {
              return this.add(
                (function (t) {
                  const e = (t = fc(t)).model;
                  t.view ||
                    (t.view = (n) => ({
                      group: e,
                      name: n.substr(t.model.length + 1),
                    }));
                  return (n) => {
                    var i;
                    n.on(
                      "addMarker:" + e,
                      ((i = t.view),
                      (t, e, n) => {
                        const o = i(e.markerName, n);
                        if (!o) return;
                        const r = e.markerRange;
                        n.consumable.consume(r, t.name) &&
                          (wc(r, !1, n, e, o), wc(r, !0, n, e, o), t.stop());
                      }),
                      { priority: t.converterPriority || "normal" }
                    ),
                      n.on(
                        "removeMarker:" + e,
                        (function (t) {
                          return (e, n, i) => {
                            const o = t(n.markerName, i);
                            if (!o) return;
                            const r = i.mapper.markerNameToElements(
                              n.markerName
                            );
                            if (r) {
                              for (const t of r)
                                i.mapper.unbindElementFromMarkerName(
                                  t,
                                  n.markerName
                                ),
                                  t.is("containerElement")
                                    ? (s(`data-${o.group}-start-before`, t),
                                      s(`data-${o.group}-start-after`, t),
                                      s(`data-${o.group}-end-before`, t),
                                      s(`data-${o.group}-end-after`, t))
                                    : i.writer.clear(
                                        i.writer.createRangeOn(t),
                                        t
                                      );
                              i.writer.clearClonedElementsGroup(n.markerName),
                                e.stop();
                            }
                            function s(t, e) {
                              if (e.hasAttribute(t)) {
                                const n = new Set(e.getAttribute(t).split(","));
                                n.delete(o.name),
                                  0 == n.size
                                    ? i.writer.removeAttribute(t, e)
                                    : i.writer.setAttribute(
                                        t,
                                        Array.from(n).join(","),
                                        e
                                      );
                              }
                            }
                          };
                        })(t.view),
                        { priority: t.converterPriority || "normal" }
                      );
                  };
                })(t)
              );
            }
          }
          function bc(t, e) {
            const n = t.createAttributeElement("span", e.attributes);
            return (
              e.classes && n._addClass(e.classes),
              "number" == typeof e.priority && (n._priority = e.priority),
              (n._id = e.id),
              n
            );
          }
          function wc(t, e, n, i, o) {
            const r = e ? t.start : t.end,
              s = r.nodeAfter && r.nodeAfter.is("element") ? r.nodeAfter : null,
              a =
                r.nodeBefore && r.nodeBefore.is("element")
                  ? r.nodeBefore
                  : null;
            if (s || a) {
              let t, r;
              (e && s) || (!e && !a)
                ? ((t = s), (r = !0))
                : ((t = a), (r = !1));
              const c = n.mapper.toViewElement(t);
              if (c)
                return void (function (t, e, n, i, o, r) {
                  const s = `data-${r.group}-${e ? "start" : "end"}-${
                      n ? "before" : "after"
                    }`,
                    a = t.hasAttribute(s) ? t.getAttribute(s).split(",") : [];
                  a.unshift(r.name),
                    i.writer.setAttribute(s, a.join(","), t),
                    i.mapper.bindElementToMarker(t, o.markerName);
                })(c, e, r, n, i, o);
            }
            !(function (t, e, n, i, o) {
              const r = `${o.group}-${e ? "start" : "end"}`,
                s = o.name ? { name: o.name } : null,
                a = n.writer.createUIElement(r, s);
              n.writer.insert(t, a),
                n.mapper.bindElementToMarker(a, i.markerName);
            })(n.mapper.toViewPosition(r), e, n, i, o);
          }
          function Ac(t) {
            return (
              "string" == typeof t && (t = { name: t }),
              t.attributes
                ? Array.isArray(t.attributes) || (t.attributes = [t.attributes])
                : (t.attributes = []),
              (t.children = !!t.children),
              t
            );
          }
          function _c(t, e) {
            return "function" == typeof t
              ? t
              : (n, i) =>
                  (function (t, e, n) {
                    "string" == typeof t && (t = { name: t });
                    let i;
                    const o = e.writer,
                      r = Object.assign({}, t.attributes);
                    if ("container" == n)
                      i = o.createContainerElement(t.name, r);
                    else if ("attribute" == n) {
                      const e = { priority: t.priority || Xo.DEFAULT_PRIORITY };
                      i = o.createAttributeElement(t.name, r, e);
                    } else i = o.createUIElement(t.name, r);
                    if (t.styles) {
                      const e = Object.keys(t.styles);
                      for (const n of e) o.setStyle(n, t.styles[n], i);
                    }
                    if (t.classes) {
                      const e = t.classes;
                      if ("string" == typeof e) o.addClass(e, i);
                      else for (const t of e) o.addClass(t, i);
                    }
                    return i;
                  })(t, i, e);
          }
          function Cc(t) {
            return t.model.values
              ? (e, n) => {
                  const i = t.view[e];
                  return i ? i(e, n) : null;
                }
              : t.view;
          }
          function vc(t) {
            return "string" == typeof t
              ? (e) => ({ key: t, value: e })
              : "object" == typeof t
              ? t.value
                ? () => t
                : (e) => ({ key: t.key, value: e })
              : t;
          }
          function yc(t, e, n) {
            const i = "function" == typeof t ? t(e, n) : t;
            return i
              ? (i.priority || (i.priority = 10),
                i.id || (i.id = e.markerName),
                i)
              : null;
          }
          function xc(t) {
            const e = (function (t) {
              return (e, n) => {
                if (!e.is("element", t.name)) return !1;
                if ("attribute" == n.type) {
                  if (t.attributes.includes(n.attributeKey)) return !0;
                } else if (t.children) return !0;
                return !1;
              };
            })(t);
            return (t, n) => {
              const i = [];
              n.reconvertedElements || (n.reconvertedElements = new Set());
              for (const t of n.changes) {
                const o = t.position
                  ? t.position.parent
                  : t.range.start.nodeAfter;
                if (o && e(o, t)) {
                  if (!n.reconvertedElements.has(o)) {
                    n.reconvertedElements.add(o);
                    const t = Ga._createBefore(o);
                    i.push(
                      { type: "remove", name: o.name, position: t, length: 1 },
                      { type: "reinsert", name: o.name, position: t, length: 1 }
                    );
                  }
                } else i.push(t);
              }
              n.changes = i;
            };
          }
          function Ec(t) {
            return (e, n, i = {}) => {
              const o = ["insert"];
              for (const n of t.attributes)
                e.hasAttribute(n) && o.push(`attribute:${n}`);
              return (
                !!o.every((t) => n.test(e, t)) &&
                (i.preflight || o.forEach((t) => n.consume(e, t)), !0)
              );
            };
          }
          function Dc(t, e, n, i) {
            for (const o of e) Sc(t.root, o, n, i) || n.convertItem(o);
          }
          function Sc(t, e, n, i) {
            const { writer: o, mapper: r } = n;
            if (!i.reconversion) return !1;
            const s = r.toViewElement(e);
            return (
              !(!s || s.root == t) &&
              !!n.canReuseView(s) &&
              (o.move(
                o.createRangeOn(s),
                r.toViewPosition(Ga._createBefore(e))
              ),
              !0)
            );
          }
          function Ic(t, e, { preflight: n } = {}) {
            return n ? e.test(t, "insert") : e.consume(t, "insert");
          }
          function Tc(t) {
            const { schema: e, document: n } = t.model;
            for (const i of n.getRootNames()) {
              const o = n.getRoot(i);
              if (
                o.isEmpty &&
                !e.checkChild(o, "$text") &&
                e.checkChild(o, "paragraph")
              )
                return t.insertElement("paragraph", o), !0;
            }
            return !1;
          }
          function Mc(t, e, n) {
            const i = n.createContext(t);
            return (
              !!n.checkChild(i, "paragraph") &&
              !!n.checkChild(i.push("paragraph"), e)
            );
          }
          function Bc(t, e) {
            const n = e.createElement("paragraph");
            return e.insert(n, t), e.createPositionAt(n, 0);
          }
          class Nc extends pc {
            elementToElement(t) {
              return this.add(zc(t));
            }
            elementToAttribute(t) {
              return this.add(
                (function (t) {
                  Rc((t = fc(t)));
                  const e = Oc(t, !1),
                    n = Pc(t.view),
                    i = n ? "element:" + n : "element";
                  return (n) => {
                    n.on(i, e, { priority: t.converterPriority || "low" });
                  };
                })(t)
              );
            }
            attributeToAttribute(t) {
              return this.add(
                (function (t) {
                  t = fc(t);
                  let e = null;
                  ("string" == typeof t.view || t.view.key) &&
                    (e = (function (t) {
                      "string" == typeof t.view && (t.view = { key: t.view });
                      const e = t.view.key;
                      let n;
                      if ("class" == e || "style" == e) {
                        n = {
                          ["class" == e ? "classes" : "styles"]: t.view.value,
                        };
                      } else {
                        n = {
                          attributes: {
                            [e]:
                              void 0 === t.view.value
                                ? /[\s\S]*/
                                : t.view.value,
                          },
                        };
                      }
                      t.view.name && (n.name = t.view.name);
                      return (t.view = n), e;
                    })(t));
                  Rc(t, e);
                  const n = Oc(t, !0);
                  return (e) => {
                    e.on("element", n, {
                      priority: t.converterPriority || "low",
                    });
                  };
                })(t)
              );
            }
            elementToMarker(t) {
              return this.add(
                (function (t) {
                  return (
                    (function (t) {
                      const e = t.model;
                      t.model = (t, n) => {
                        const i = "string" == typeof e ? e : e(t, n);
                        return n.writer.createElement("$marker", {
                          "data-name": i,
                        });
                      };
                    })((t = fc(t))),
                    zc(t)
                  );
                })(t)
              );
            }
            dataToMarker(t) {
              return this.add(
                (function (t) {
                  (t = fc(t)).model ||
                    (t.model = (e) => (e ? t.view + ":" + e : t.view));
                  const e = Lc(jc(t, "start")),
                    n = Lc(jc(t, "end"));
                  return (i) => {
                    i.on("element:" + t.view + "-start", e, {
                      priority: t.converterPriority || "normal",
                    }),
                      i.on("element:" + t.view + "-end", n, {
                        priority: t.converterPriority || "normal",
                      });
                    const o = s.get("low"),
                      r = s.get("highest"),
                      a = s.get(t.converterPriority) / r;
                    i.on(
                      "element",
                      (function (t) {
                        return (e, n, i) => {
                          const o = `data-${t.view}`;
                          function r(e, o) {
                            for (const r of o) {
                              const o = t.model(r, i),
                                s = i.writer.createElement("$marker", {
                                  "data-name": o,
                                });
                              i.writer.insert(s, e),
                                n.modelCursor.isEqual(e)
                                  ? (n.modelCursor =
                                      n.modelCursor.getShiftedBy(1))
                                  : (n.modelCursor =
                                      n.modelCursor._getTransformedByInsertion(
                                        e,
                                        1
                                      )),
                                (n.modelRange =
                                  n.modelRange._getTransformedByInsertion(
                                    e,
                                    1
                                  )[0]);
                            }
                          }
                          (i.consumable.test(n.viewItem, {
                            attributes: o + "-end-after",
                          }) ||
                            i.consumable.test(n.viewItem, {
                              attributes: o + "-start-after",
                            }) ||
                            i.consumable.test(n.viewItem, {
                              attributes: o + "-end-before",
                            }) ||
                            i.consumable.test(n.viewItem, {
                              attributes: o + "-start-before",
                            })) &&
                            (n.modelRange ||
                              Object.assign(
                                n,
                                i.convertChildren(n.viewItem, n.modelCursor)
                              ),
                            i.consumable.consume(n.viewItem, {
                              attributes: o + "-end-after",
                            }) &&
                              r(
                                n.modelRange.end,
                                n.viewItem
                                  .getAttribute(o + "-end-after")
                                  .split(",")
                              ),
                            i.consumable.consume(n.viewItem, {
                              attributes: o + "-start-after",
                            }) &&
                              r(
                                n.modelRange.end,
                                n.viewItem
                                  .getAttribute(o + "-start-after")
                                  .split(",")
                              ),
                            i.consumable.consume(n.viewItem, {
                              attributes: o + "-end-before",
                            }) &&
                              r(
                                n.modelRange.start,
                                n.viewItem
                                  .getAttribute(o + "-end-before")
                                  .split(",")
                              ),
                            i.consumable.consume(n.viewItem, {
                              attributes: o + "-start-before",
                            }) &&
                              r(
                                n.modelRange.start,
                                n.viewItem
                                  .getAttribute(o + "-start-before")
                                  .split(",")
                              ));
                        };
                      })(t),
                      { priority: o + a }
                    );
                  };
                })(t)
              );
            }
          }
          function zc(t) {
            const e = Lc((t = fc(t))),
              n = Pc(t.view),
              i = n ? "element:" + n : "element";
            return (n) => {
              n.on(i, e, { priority: t.converterPriority || "normal" });
            };
          }
          function Pc(t) {
            return "string" == typeof t
              ? t
              : "object" == typeof t && "string" == typeof t.name
              ? t.name
              : null;
          }
          function Lc(t) {
            const e = new Hi(t.view);
            return (n, i, o) => {
              const r = e.match(i.viewItem);
              if (!r) return;
              const s = r.match;
              if (((s.name = !0), !o.consumable.test(i.viewItem, s))) return;
              const a = (function (t, e, n) {
                return t instanceof Function
                  ? t(e, n)
                  : n.writer.createElement(t);
              })(t.model, i.viewItem, o);
              a &&
                o.safeInsert(a, i.modelCursor) &&
                (o.consumable.consume(i.viewItem, s),
                o.convertChildren(i.viewItem, a),
                o.updateConversionResult(a, i));
            };
          }
          function Rc(t, e = null) {
            const n = null === e || ((t) => t.getAttribute(e)),
              i = "object" != typeof t.model ? t.model : t.model.key,
              o =
                "object" != typeof t.model || void 0 === t.model.value
                  ? n
                  : t.model.value;
            t.model = { key: i, value: o };
          }
          function Oc(t, e) {
            const n = new Hi(t.view);
            return (i, o, r) => {
              if (!o.modelRange && e) return;
              const s = n.match(o.viewItem);
              if (!s) return;
              if (
                (!(function (t, e) {
                  const n = "function" == typeof t ? t(e) : t;
                  if ("object" == typeof n && !Pc(n)) return !1;
                  return !n.classes && !n.attributes && !n.styles;
                })(t.view, o.viewItem)
                  ? delete s.match.name
                  : (s.match.name = !0),
                !r.consumable.test(o.viewItem, s.match))
              )
                return;
              const a = t.model.key,
                c =
                  "function" == typeof t.model.value
                    ? t.model.value(o.viewItem, r)
                    : t.model.value;
              if (null === c) return;
              o.modelRange ||
                Object.assign(o, r.convertChildren(o.viewItem, o.modelCursor));
              const l = (function (t, e, n, i) {
                let o = !1;
                for (const r of Array.from(t.getItems({ shallow: n })))
                  i.schema.checkAttribute(r, e.key) &&
                    ((o = !0),
                    r.hasAttribute(e.key) ||
                      i.writer.setAttribute(e.key, e.value, r));
                return o;
              })(o.modelRange, { key: a, value: c }, e, r);
              l &&
                (r.consumable.test(o.viewItem, { name: !0 }) &&
                  (s.match.name = !0),
                r.consumable.consume(o.viewItem, s.match));
            };
          }
          function jc(t, e) {
            const n = {};
            return (
              (n.view = t.view + "-" + e),
              (n.model = (e, n) => {
                const i = e.getAttribute("name"),
                  o = t.model(i, n);
                return n.writer.createElement("$marker", { "data-name": o });
              }),
              n
            );
          }
          class Fc {
            constructor(t, e) {
              (this.model = t),
                (this.view = new Oa(e)),
                (this.mapper = new Za()),
                (this.downcastDispatcher = new tc({
                  mapper: this.mapper,
                  schema: t.schema,
                }));
              const n = this.model.document,
                i = n.selection,
                o = this.model.markers;
              this.listenTo(
                this.model,
                "_beforeChanges",
                () => {
                  this.view._disableRendering(!0);
                },
                { priority: "highest" }
              ),
                this.listenTo(
                  this.model,
                  "_afterChanges",
                  () => {
                    this.view._disableRendering(!1);
                  },
                  { priority: "lowest" }
                ),
                this.listenTo(
                  n,
                  "change",
                  () => {
                    this.view.change((t) => {
                      this.downcastDispatcher.convertChanges(n.differ, o, t),
                        this.downcastDispatcher.convertSelection(i, o, t);
                    });
                  },
                  { priority: "low" }
                ),
                this.listenTo(
                  this.view.document,
                  "selectionChange",
                  (function (t, e) {
                    return (n, i) => {
                      const o = i.newSelection,
                        r = [];
                      for (const t of o.getRanges()) r.push(e.toModelRange(t));
                      const s = t.createSelection(r, {
                        backward: o.isBackward,
                      });
                      s.isEqual(t.document.selection) ||
                        t.change((t) => {
                          t.setSelection(s);
                        });
                    };
                  })(this.model, this.mapper)
                ),
                this.downcastDispatcher.on(
                  "insert:$text",
                  (t, e, n) => {
                    if (!n.consumable.consume(e.item, t.name)) return;
                    const i = n.writer,
                      o = n.mapper.toViewPosition(e.range.start),
                      r = i.createText(e.item.data);
                    i.insert(o, r);
                  },
                  { priority: "lowest" }
                ),
                this.downcastDispatcher.on(
                  "insert",
                  (t, e, n) => {
                    n.convertAttributes(e.item),
                      e.reconversion ||
                        !e.item.is("element") ||
                        e.item.isEmpty ||
                        n.convertChildren(e.item);
                  },
                  { priority: "lowest" }
                ),
                this.downcastDispatcher.on(
                  "remove",
                  (t, e, n) => {
                    const i = n.mapper.toViewPosition(e.position),
                      o = e.position.getShiftedBy(e.length),
                      r = n.mapper.toViewPosition(o, { isPhantom: !0 }),
                      s = n.writer.createRange(i, r),
                      a = n.writer.remove(s.getTrimmed());
                    for (const t of n.writer.createRangeIn(a).getItems())
                      n.mapper.unbindViewElement(t, { defer: !0 });
                  },
                  { priority: "low" }
                ),
                this.downcastDispatcher.on(
                  "selection",
                  (t, e, n) => {
                    const i = n.writer,
                      o = i.document.selection;
                    for (const t of o.getRanges())
                      t.isCollapsed &&
                        t.end.parent.isAttached() &&
                        n.writer.mergeAttributes(t.start);
                    i.setSelection(null);
                  },
                  { priority: "high" }
                ),
                this.downcastDispatcher.on(
                  "selection",
                  (t, e, n) => {
                    const i = e.selection;
                    if (i.isCollapsed) return;
                    if (!n.consumable.consume(i, "selection")) return;
                    const o = [];
                    for (const t of i.getRanges()) {
                      const e = n.mapper.toViewRange(t);
                      o.push(e);
                    }
                    n.writer.setSelection(o, { backward: i.isBackward });
                  },
                  { priority: "low" }
                ),
                this.downcastDispatcher.on(
                  "selection",
                  (t, e, n) => {
                    const i = e.selection;
                    if (!i.isCollapsed) return;
                    if (!n.consumable.consume(i, "selection")) return;
                    const o = n.writer,
                      r = i.getFirstPosition(),
                      s = n.mapper.toViewPosition(r),
                      a = o.breakAttributes(s);
                    o.setSelection(a);
                  },
                  { priority: "low" }
                ),
                this.view.document.roots
                  .bindTo(this.model.document.roots)
                  .using((t) => {
                    if ("$graveyard" == t.rootName) return null;
                    const e = new Lo(this.view.document, t.name);
                    return (
                      (e.rootName = t.rootName),
                      this.mapper.bindElements(t, e),
                      e
                    );
                  });
            }
            destroy() {
              this.view.destroy(), this.stopListening();
            }
            reconvertMarker(t) {
              const e = "string" == typeof t ? t : t.name,
                n = this.model.markers.get(e);
              if (!n)
                throw new c(
                  "editingcontroller-reconvertmarker-marker-not-exist",
                  this,
                  { markerName: e }
                );
              this.model.change(() => {
                this.model.markers._refresh(n);
              });
            }
            reconvertItem(t) {
              this.model.change(() => {
                this.model.document.differ._refreshItem(t);
              });
            }
          }
          he(Fc, re);
          class Vc {
            constructor() {
              this._commands = new Map();
            }
            add(t, e) {
              this._commands.set(t, e);
            }
            get(t) {
              return this._commands.get(t);
            }
            execute(t, ...e) {
              const n = this.get(t);
              if (!n)
                throw new c("commandcollection-command-not-found", this, {
                  commandName: t,
                });
              return n.execute(...e);
            }
            *names() {
              yield* this._commands.keys();
            }
            *commands() {
              yield* this._commands.values();
            }
            [Symbol.iterator]() {
              return this._commands[Symbol.iterator]();
            }
            destroy() {
              for (const t of this.commands()) t.destroy();
            }
          }
          class Hc {
            constructor() {
              this._consumables = new Map();
            }
            add(t, e) {
              let n;
              t.is("$text") || t.is("documentFragment")
                ? this._consumables.set(t, !0)
                : (this._consumables.has(t)
                    ? (n = this._consumables.get(t))
                    : ((n = new Uc(t)), this._consumables.set(t, n)),
                  n.add(e));
            }
            test(t, e) {
              const n = this._consumables.get(t);
              return void 0 === n
                ? null
                : t.is("$text") || t.is("documentFragment")
                ? n
                : n.test(e);
            }
            consume(t, e) {
              return (
                !!this.test(t, e) &&
                (t.is("$text") || t.is("documentFragment")
                  ? this._consumables.set(t, !1)
                  : this._consumables.get(t).consume(e),
                !0)
              );
            }
            revert(t, e) {
              const n = this._consumables.get(t);
              void 0 !== n &&
                (t.is("$text") || t.is("documentFragment")
                  ? this._consumables.set(t, !0)
                  : n.revert(e));
            }
            static consumablesFromElement(t) {
              const e = {
                  element: t,
                  name: !0,
                  attributes: [],
                  classes: [],
                  styles: [],
                },
                n = t.getAttributeKeys();
              for (const t of n)
                "style" != t && "class" != t && e.attributes.push(t);
              const i = t.getClassNames();
              for (const t of i) e.classes.push(t);
              const o = t.getStyleNames();
              for (const t of o) e.styles.push(t);
              return e;
            }
            static createFrom(t, e) {
              if ((e || (e = new Hc(t)), t.is("$text"))) return e.add(t), e;
              t.is("element") && e.add(t, Hc.consumablesFromElement(t)),
                t.is("documentFragment") && e.add(t);
              for (const n of t.getChildren()) e = Hc.createFrom(n, e);
              return e;
            }
          }
          class Uc {
            constructor(t) {
              (this.element = t),
                (this._canConsumeName = null),
                (this._consumables = {
                  attributes: new Map(),
                  styles: new Map(),
                  classes: new Map(),
                });
            }
            add(t) {
              t.name && (this._canConsumeName = !0);
              for (const e in this._consumables) e in t && this._add(e, t[e]);
            }
            test(t) {
              if (t.name && !this._canConsumeName) return this._canConsumeName;
              for (const e in this._consumables)
                if (e in t) {
                  const n = this._test(e, t[e]);
                  if (!0 !== n) return n;
                }
              return !0;
            }
            consume(t) {
              t.name && (this._canConsumeName = !1);
              for (const e in this._consumables)
                e in t && this._consume(e, t[e]);
            }
            revert(t) {
              t.name && (this._canConsumeName = !0);
              for (const e in this._consumables)
                e in t && this._revert(e, t[e]);
            }
            _add(t, e) {
              const n = It(e) ? e : [e],
                i = this._consumables[t];
              for (const e of n) {
                if ("attributes" === t && ("class" === e || "style" === e))
                  throw new c("viewconsumable-invalid-attribute", this);
                if ((i.set(e, !0), "styles" === t))
                  for (const t of this.element.document.stylesProcessor.getRelatedStyles(
                    e
                  ))
                    i.set(t, !0);
              }
            }
            _test(t, e) {
              const n = It(e) ? e : [e],
                i = this._consumables[t];
              for (const e of n)
                if ("attributes" !== t || ("class" !== e && "style" !== e)) {
                  const t = i.get(e);
                  if (void 0 === t) return null;
                  if (!t) return !1;
                } else {
                  const t = "class" == e ? "classes" : "styles",
                    n = this._test(t, [...this._consumables[t].keys()]);
                  if (!0 !== n) return n;
                }
              return !0;
            }
            _consume(t, e) {
              const n = It(e) ? e : [e],
                i = this._consumables[t];
              for (const e of n)
                if ("attributes" !== t || ("class" !== e && "style" !== e)) {
                  if ((i.set(e, !1), "styles" == t))
                    for (const t of this.element.document.stylesProcessor.getRelatedStyles(
                      e
                    ))
                      i.set(t, !1);
                } else {
                  const t = "class" == e ? "classes" : "styles";
                  this._consume(t, [...this._consumables[t].keys()]);
                }
            }
            _revert(t, e) {
              const n = It(e) ? e : [e],
                i = this._consumables[t];
              for (const e of n)
                if ("attributes" !== t || ("class" !== e && "style" !== e)) {
                  !1 === i.get(e) && i.set(e, !0);
                } else {
                  const t = "class" == e ? "classes" : "styles";
                  this._revert(t, [...this._consumables[t].keys()]);
                }
            }
          }
          class $c {
            constructor() {
              (this._sourceDefinitions = {}),
                (this._attributeProperties = {}),
                this.decorate("checkChild"),
                this.decorate("checkAttribute"),
                this.on(
                  "checkAttribute",
                  (t, e) => {
                    e[0] = new qc(e[0]);
                  },
                  { priority: "highest" }
                ),
                this.on(
                  "checkChild",
                  (t, e) => {
                    (e[0] = new qc(e[0])), (e[1] = this.getDefinition(e[1]));
                  },
                  { priority: "highest" }
                );
            }
            register(t, e) {
              if (this._sourceDefinitions[t])
                throw new c("schema-cannot-register-item-twice", this, {
                  itemName: t,
                });
              (this._sourceDefinitions[t] = [Object.assign({}, e)]),
                this._clearCache();
            }
            extend(t, e) {
              if (!this._sourceDefinitions[t])
                throw new c("schema-cannot-extend-missing-item", this, {
                  itemName: t,
                });
              this._sourceDefinitions[t].push(Object.assign({}, e)),
                this._clearCache();
            }
            getDefinitions() {
              return (
                this._compiledDefinitions || this._compile(),
                this._compiledDefinitions
              );
            }
            getDefinition(t) {
              let e;
              return (
                (e =
                  "string" == typeof t
                    ? t
                    : t.is && (t.is("$text") || t.is("$textProxy"))
                    ? "$text"
                    : t.name),
                this.getDefinitions()[e]
              );
            }
            isRegistered(t) {
              return !!this.getDefinition(t);
            }
            isBlock(t) {
              const e = this.getDefinition(t);
              return !(!e || !e.isBlock);
            }
            isLimit(t) {
              const e = this.getDefinition(t);
              return !!e && !(!e.isLimit && !e.isObject);
            }
            isObject(t) {
              const e = this.getDefinition(t);
              return (
                !!e &&
                !!(e.isObject || (e.isLimit && e.isSelectable && e.isContent))
              );
            }
            isInline(t) {
              const e = this.getDefinition(t);
              return !(!e || !e.isInline);
            }
            isSelectable(t) {
              const e = this.getDefinition(t);
              return !!e && !(!e.isSelectable && !e.isObject);
            }
            isContent(t) {
              const e = this.getDefinition(t);
              return !!e && !(!e.isContent && !e.isObject);
            }
            checkChild(t, e) {
              return !!e && this._checkContextMatch(e, t);
            }
            checkAttribute(t, e) {
              const n = this.getDefinition(t.last);
              return !!n && n.allowAttributes.includes(e);
            }
            checkMerge(t, e = null) {
              if (t instanceof Ga) {
                const e = t.nodeBefore,
                  n = t.nodeAfter;
                if (!(e instanceof Ua))
                  throw new c("schema-check-merge-no-element-before", this);
                if (!(n instanceof Ua))
                  throw new c("schema-check-merge-no-element-after", this);
                return this.checkMerge(e, n);
              }
              for (const n of e.getChildren())
                if (!this.checkChild(t, n)) return !1;
              return !0;
            }
            addChildCheck(t) {
              this.on(
                "checkChild",
                (e, [n, i]) => {
                  if (!i) return;
                  const o = t(n, i);
                  "boolean" == typeof o && (e.stop(), (e.return = o));
                },
                { priority: "high" }
              );
            }
            addAttributeCheck(t) {
              this.on(
                "checkAttribute",
                (e, [n, i]) => {
                  const o = t(n, i);
                  "boolean" == typeof o && (e.stop(), (e.return = o));
                },
                { priority: "high" }
              );
            }
            setAttributeProperties(t, e) {
              this._attributeProperties[t] = Object.assign(
                this.getAttributeProperties(t),
                e
              );
            }
            getAttributeProperties(t) {
              return this._attributeProperties[t] || {};
            }
            getLimitElement(t) {
              let e;
              if (t instanceof Ga) e = t.parent;
              else {
                e = (t instanceof Qa ? [t] : Array.from(t.getRanges())).reduce(
                  (t, e) => {
                    const n = e.getCommonAncestor();
                    return t ? t.getCommonAncestor(n, { includeSelf: !0 }) : n;
                  },
                  null
                );
              }
              for (; !this.isLimit(e) && e.parent; ) e = e.parent;
              return e;
            }
            checkAttributeInSelection(t, e) {
              if (t.isCollapsed) {
                const n = [
                  ...t.getFirstPosition().getAncestors(),
                  new Fa("", t.getAttributes()),
                ];
                return this.checkAttribute(n, e);
              }
              {
                const n = t.getRanges();
                for (const t of n)
                  for (const n of t)
                    if (this.checkAttribute(n.item, e)) return !0;
              }
              return !1;
            }
            *getValidRanges(t, e) {
              t = (function* (t) {
                for (const e of t) yield* e.getMinimalFlatRanges();
              })(t);
              for (const n of t) yield* this._getValidRangesForRange(n, e);
            }
            getNearestSelectionRange(t, e = "both") {
              if (this.checkChild(t, "$text")) return new Qa(t);
              let n, i;
              const o =
                t
                  .getAncestors()
                  .reverse()
                  .find((t) => this.isLimit(t)) || t.root;
              ("both" != e && "backward" != e) ||
                (n = new $a({
                  boundaries: Qa._createIn(o),
                  startPosition: t,
                  direction: "backward",
                })),
                ("both" != e && "forward" != e) ||
                  (i = new $a({
                    boundaries: Qa._createIn(o),
                    startPosition: t,
                  }));
              for (const t of (function* (t, e) {
                let n = !1;
                for (; !n; ) {
                  if (((n = !0), t)) {
                    const e = t.next();
                    e.done || ((n = !1), yield { walker: t, value: e.value });
                  }
                  if (e) {
                    const t = e.next();
                    t.done || ((n = !1), yield { walker: e, value: t.value });
                  }
                }
              })(n, i)) {
                const e = t.walker == n ? "elementEnd" : "elementStart",
                  i = t.value;
                if (i.type == e && this.isObject(i.item))
                  return Qa._createOn(i.item);
                if (this.checkChild(i.nextPosition, "$text"))
                  return new Qa(i.nextPosition);
              }
              return null;
            }
            findAllowedParent(t, e) {
              let n = t.parent;
              for (; n; ) {
                if (this.checkChild(n, e)) return n;
                if (this.isLimit(n)) return null;
                n = n.parent;
              }
              return null;
            }
            setAllowedAttributes(t, e, n) {
              const i = n.model;
              for (const [o, r] of Object.entries(e))
                i.schema.checkAttribute(t, o) && n.setAttribute(o, r, t);
            }
            removeDisallowedAttributes(t, e) {
              for (const n of t)
                if (n.is("$text")) ol(this, n, e);
                else {
                  const t = Qa._createIn(n).getPositions();
                  for (const n of t) {
                    ol(this, n.nodeBefore || n.parent, e);
                  }
                }
            }
            getAttributesWithProperty(t, e, n) {
              const i = {};
              for (const [o, r] of t.getAttributes()) {
                const t = this.getAttributeProperties(o);
                void 0 !== t[e] && ((void 0 !== n && n !== t[e]) || (i[o] = r));
              }
              return i;
            }
            createContext(t) {
              return new qc(t);
            }
            _clearCache() {
              this._compiledDefinitions = null;
            }
            _compile() {
              const t = {},
                e = this._sourceDefinitions,
                n = Object.keys(e);
              for (const i of n) t[i] = Gc(e[i], i);
              for (const e of n) Wc(t, e);
              for (const e of n) Yc(t, e);
              for (const e of n) Kc(t, e);
              for (const e of n) Qc(t, e), Zc(t, e);
              for (const e of n) Jc(t, e), Xc(t, e), tl(t, e);
              this._compiledDefinitions = t;
            }
            _checkContextMatch(t, e, n = e.length - 1) {
              const i = e.getItem(n);
              if (t.allowIn.includes(i.name)) {
                if (0 == n) return !0;
                {
                  const t = this.getDefinition(i);
                  return this._checkContextMatch(t, e, n - 1);
                }
              }
              return !1;
            }
            *_getValidRangesForRange(t, e) {
              let n = t.start,
                i = t.start;
              for (const o of t.getItems({ shallow: !0 }))
                o.is("element") &&
                  (yield* this._getValidRangesForRange(Qa._createIn(o), e)),
                  this.checkAttribute(o, e) ||
                    (n.isEqual(i) || (yield new Qa(n, i)),
                    (n = Ga._createAfter(o))),
                  (i = Ga._createAfter(o));
              n.isEqual(i) || (yield new Qa(n, i));
            }
          }
          he($c, re);
          class qc {
            constructor(t) {
              if (t instanceof qc) return t;
              "string" == typeof t
                ? (t = [t])
                : Array.isArray(t) || (t = t.getAncestors({ includeSelf: !0 })),
                (this._items = t.map(il));
            }
            get length() {
              return this._items.length;
            }
            get last() {
              return this._items[this._items.length - 1];
            }
            [Symbol.iterator]() {
              return this._items[Symbol.iterator]();
            }
            push(t) {
              const e = new qc([t]);
              return (e._items = [...this._items, ...e._items]), e;
            }
            getItem(t) {
              return this._items[t];
            }
            *getNames() {
              yield* this._items.map((t) => t.name);
            }
            endsWith(t) {
              return Array.from(this.getNames()).join(" ").endsWith(t);
            }
            startsWith(t) {
              return Array.from(this.getNames()).join(" ").startsWith(t);
            }
          }
          function Gc(t, e) {
            const n = {
              name: e,
              allowIn: [],
              allowContentOf: [],
              allowWhere: [],
              allowAttributes: [],
              allowAttributesOf: [],
              allowChildren: [],
              inheritTypesFrom: [],
            };
            return (
              (function (t, e) {
                for (const n of t) {
                  const t = Object.keys(n).filter((t) => t.startsWith("is"));
                  for (const i of t) e[i] = n[i];
                }
              })(t, n),
              el(t, n, "allowIn"),
              el(t, n, "allowContentOf"),
              el(t, n, "allowWhere"),
              el(t, n, "allowAttributes"),
              el(t, n, "allowAttributesOf"),
              el(t, n, "allowChildren"),
              el(t, n, "inheritTypesFrom"),
              (function (t, e) {
                for (const n of t) {
                  const t = n.inheritAllFrom;
                  t &&
                    (e.allowContentOf.push(t),
                    e.allowWhere.push(t),
                    e.allowAttributesOf.push(t),
                    e.inheritTypesFrom.push(t));
                }
              })(t, n),
              n
            );
          }
          function Wc(t, e) {
            const n = t[e];
            for (const i of n.allowChildren) {
              const n = t[i];
              n && n.allowIn.push(e);
            }
            n.allowChildren.length = 0;
          }
          function Yc(t, e) {
            for (const n of t[e].allowContentOf)
              if (t[n]) {
                nl(t, n).forEach((t) => {
                  t.allowIn.push(e);
                });
              }
            delete t[e].allowContentOf;
          }
          function Kc(t, e) {
            for (const n of t[e].allowWhere) {
              const i = t[n];
              if (i) {
                const n = i.allowIn;
                t[e].allowIn.push(...n);
              }
            }
            delete t[e].allowWhere;
          }
          function Qc(t, e) {
            for (const n of t[e].allowAttributesOf) {
              const i = t[n];
              if (i) {
                const n = i.allowAttributes;
                t[e].allowAttributes.push(...n);
              }
            }
            delete t[e].allowAttributesOf;
          }
          function Zc(t, e) {
            const n = t[e];
            for (const e of n.inheritTypesFrom) {
              const i = t[e];
              if (i) {
                const t = Object.keys(i).filter((t) => t.startsWith("is"));
                for (const e of t) e in n || (n[e] = i[e]);
              }
            }
            delete n.inheritTypesFrom;
          }
          function Jc(t, e) {
            const n = t[e],
              i = n.allowIn.filter((e) => t[e]);
            n.allowIn = Array.from(new Set(i));
          }
          function Xc(t, e) {
            const n = t[e];
            for (const i of n.allowIn) {
              t[i].allowChildren.push(e);
            }
          }
          function tl(t, e) {
            const n = t[e];
            n.allowAttributes = Array.from(new Set(n.allowAttributes));
          }
          function el(t, e, n) {
            for (const i of t)
              "string" == typeof i[n]
                ? e[n].push(i[n])
                : Array.isArray(i[n]) && e[n].push(...i[n]);
          }
          function nl(t, e) {
            const n = t[e];
            return ((i = t), Object.keys(i).map((t) => i[t])).filter((t) =>
              t.allowIn.includes(n.name)
            );
            var i;
          }
          function il(t) {
            return "string" == typeof t || t.is("documentFragment")
              ? {
                  name: "string" == typeof t ? t : "$documentFragment",
                  *getAttributeKeys() {},
                  getAttribute() {},
                }
              : {
                  name: t.is("element") ? t.name : "$text",
                  *getAttributeKeys() {
                    yield* t.getAttributeKeys();
                  },
                  getAttribute: (e) => t.getAttribute(e),
                };
          }
          function ol(t, e, n) {
            for (const i of e.getAttributeKeys())
              t.checkAttribute(e, i) || n.removeAttribute(i, e);
          }
          class rl {
            constructor(t = {}) {
              (this._splitParts = new Map()),
                (this._cursorParents = new Map()),
                (this._modelCursor = null),
                (this._emptyElementsToKeep = new Set()),
                (this.conversionApi = Object.assign({}, t)),
                (this.conversionApi.convertItem = this._convertItem.bind(this)),
                (this.conversionApi.convertChildren =
                  this._convertChildren.bind(this)),
                (this.conversionApi.safeInsert = this._safeInsert.bind(this)),
                (this.conversionApi.updateConversionResult =
                  this._updateConversionResult.bind(this)),
                (this.conversionApi.splitToAllowedParent =
                  this._splitToAllowedParent.bind(this)),
                (this.conversionApi.getSplitParts =
                  this._getSplitParts.bind(this)),
                (this.conversionApi.keepEmptyElement =
                  this._keepEmptyElement.bind(this));
            }
            convert(t, e, n = ["$root"]) {
              this.fire("viewCleanup", t),
                (this._modelCursor = (function (t, e) {
                  let n;
                  for (const i of new qc(t)) {
                    const t = {};
                    for (const e of i.getAttributeKeys())
                      t[e] = i.getAttribute(e);
                    const o = e.createElement(i.name, t);
                    n && e.append(o, n), (n = Ga._createAt(o, 0));
                  }
                  return n;
                })(n, e)),
                (this.conversionApi.writer = e),
                (this.conversionApi.consumable = Hc.createFrom(t)),
                (this.conversionApi.store = {});
              const { modelRange: i } = this._convertItem(t, this._modelCursor),
                o = e.createDocumentFragment();
              if (i) {
                this._removeEmptyElements();
                for (const t of Array.from(
                  this._modelCursor.parent.getChildren()
                ))
                  e.append(t, o);
                o.markers = (function (t, e) {
                  const n = new Set(),
                    i = new Map(),
                    o = Qa._createIn(t).getItems();
                  for (const t of o) "$marker" == t.name && n.add(t);
                  for (const t of n) {
                    const n = t.getAttribute("data-name"),
                      o = e.createPositionBefore(t);
                    i.has(n)
                      ? (i.get(n).end = o.clone())
                      : i.set(n, new Qa(o.clone())),
                      e.remove(t);
                  }
                  return i;
                })(o, e);
              }
              return (
                (this._modelCursor = null),
                this._splitParts.clear(),
                this._cursorParents.clear(),
                this._emptyElementsToKeep.clear(),
                (this.conversionApi.writer = null),
                (this.conversionApi.store = null),
                o
              );
            }
            _convertItem(t, e) {
              const n = Object.assign({
                viewItem: t,
                modelCursor: e,
                modelRange: null,
              });
              if (
                (t.is("element")
                  ? this.fire("element:" + t.name, n, this.conversionApi)
                  : t.is("$text")
                  ? this.fire("text", n, this.conversionApi)
                  : this.fire("documentFragment", n, this.conversionApi),
                n.modelRange && !(n.modelRange instanceof Qa))
              )
                throw new c(
                  "view-conversion-dispatcher-incorrect-result",
                  this
                );
              return { modelRange: n.modelRange, modelCursor: n.modelCursor };
            }
            _convertChildren(t, e) {
              let n = e.is("position") ? e : Ga._createAt(e, 0);
              const i = new Qa(n);
              for (const e of Array.from(t.getChildren())) {
                const t = this._convertItem(e, n);
                t.modelRange instanceof Qa &&
                  ((i.end = t.modelRange.end), (n = t.modelCursor));
              }
              return { modelRange: i, modelCursor: n };
            }
            _safeInsert(t, e) {
              const n = this._splitToAllowedParent(t, e);
              return (
                !!n && (this.conversionApi.writer.insert(t, n.position), !0)
              );
            }
            _updateConversionResult(t, e) {
              const n = this._getSplitParts(t),
                i = this.conversionApi.writer;
              e.modelRange ||
                (e.modelRange = i.createRange(
                  i.createPositionBefore(t),
                  i.createPositionAfter(n[n.length - 1])
                ));
              const o = this._cursorParents.get(t);
              e.modelCursor = o ? i.createPositionAt(o, 0) : e.modelRange.end;
            }
            _splitToAllowedParent(t, e) {
              const { schema: n, writer: i } = this.conversionApi;
              let o = n.findAllowedParent(e, t);
              if (o) {
                if (o === e.parent) return { position: e };
                this._modelCursor.parent.getAncestors().includes(o) &&
                  (o = null);
              }
              if (!o) return Mc(e, t, n) ? { position: Bc(e, i) } : null;
              const r = this.conversionApi.writer.split(e, o),
                s = [];
              for (const t of r.range.getWalker())
                if ("elementEnd" == t.type) s.push(t.item);
                else {
                  const e = s.pop(),
                    n = t.item;
                  this._registerSplitPair(e, n);
                }
              const a = r.range.end.parent;
              return (
                this._cursorParents.set(t, a),
                { position: r.position, cursorParent: a }
              );
            }
            _registerSplitPair(t, e) {
              this._splitParts.has(t) || this._splitParts.set(t, [t]);
              const n = this._splitParts.get(t);
              this._splitParts.set(e, n), n.push(e);
            }
            _getSplitParts(t) {
              let e;
              return (
                (e = this._splitParts.has(t) ? this._splitParts.get(t) : [t]), e
              );
            }
            _keepEmptyElement(t) {
              this._emptyElementsToKeep.add(t);
            }
            _removeEmptyElements() {
              let t = !1;
              for (const e of this._splitParts.keys())
                e.isEmpty &&
                  !this._emptyElementsToKeep.has(e) &&
                  (this.conversionApi.writer.remove(e),
                  this._splitParts.delete(e),
                  (t = !0));
              t && this._removeEmptyElements();
            }
          }
          he(rl, k);
          class sl {
            getHtml(t) {
              const e = document.implementation
                .createHTMLDocument("")
                .createElement("div");
              return e.appendChild(t), e.innerHTML;
            }
          }
          class al {
            constructor(t) {
              (this.domParser = new DOMParser()),
                (this.domConverter = new us(t, { renderingMode: "data" })),
                (this.htmlWriter = new sl());
            }
            toData(t) {
              const e = this.domConverter.viewToDom(t, document);
              return this.htmlWriter.getHtml(e);
            }
            toView(t) {
              const e = this._toDom(t);
              return this.domConverter.domToView(e);
            }
            registerRawContentMatcher(t) {
              this.domConverter.registerRawContentMatcher(t);
            }
            useFillerType(t) {
              this.domConverter.blockFillerMode =
                "marked" == t ? "markedNbsp" : "nbsp";
            }
            _toDom(t) {
              t.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i) ||
                (t = `<body>${t}</body>`);
              const e = this.domParser.parseFromString(t, "text/html"),
                n = e.createDocumentFragment(),
                i = e.body.childNodes;
              for (; i.length > 0; ) n.appendChild(i[0]);
              return n;
            }
          }
          class cl {
            constructor(t, e) {
              (this.model = t),
                (this.mapper = new Za()),
                (this.downcastDispatcher = new tc({
                  mapper: this.mapper,
                  schema: t.schema,
                })),
                this.downcastDispatcher.on(
                  "insert:$text",
                  (t, e, n) => {
                    if (!n.consumable.consume(e.item, t.name)) return;
                    const i = n.writer,
                      o = n.mapper.toViewPosition(e.range.start),
                      r = i.createText(e.item.data);
                    i.insert(o, r);
                  },
                  { priority: "lowest" }
                ),
                this.downcastDispatcher.on(
                  "insert",
                  (t, e, n) => {
                    n.convertAttributes(e.item),
                      e.reconversion ||
                        !e.item.is("element") ||
                        e.item.isEmpty ||
                        n.convertChildren(e.item);
                  },
                  { priority: "lowest" }
                ),
                (this.upcastDispatcher = new rl({ schema: t.schema })),
                (this.viewDocument = new Jo(e)),
                (this.stylesProcessor = e),
                (this.htmlProcessor = new al(this.viewDocument)),
                (this.processor = this.htmlProcessor),
                (this._viewWriter = new Cr(this.viewDocument)),
                this.upcastDispatcher.on(
                  "text",
                  (t, e, { schema: n, consumable: i, writer: o }) => {
                    let r = e.modelCursor;
                    if (!i.test(e.viewItem)) return;
                    if (!n.checkChild(r, "$text")) {
                      if (!Mc(r, "$text", n)) return;
                      if (0 == e.viewItem.data.trim().length) return;
                      r = Bc(r, o);
                    }
                    i.consume(e.viewItem);
                    const s = o.createText(e.viewItem.data);
                    o.insert(s, r),
                      (e.modelRange = o.createRange(
                        r,
                        r.getShiftedBy(s.offsetSize)
                      )),
                      (e.modelCursor = e.modelRange.end);
                  },
                  { priority: "lowest" }
                ),
                this.upcastDispatcher.on(
                  "element",
                  (t, e, n) => {
                    if (
                      !e.modelRange &&
                      n.consumable.consume(e.viewItem, { name: !0 })
                    ) {
                      const { modelRange: t, modelCursor: i } =
                        n.convertChildren(e.viewItem, e.modelCursor);
                      (e.modelRange = t), (e.modelCursor = i);
                    }
                  },
                  { priority: "lowest" }
                ),
                this.upcastDispatcher.on(
                  "documentFragment",
                  (t, e, n) => {
                    if (
                      !e.modelRange &&
                      n.consumable.consume(e.viewItem, { name: !0 })
                    ) {
                      const { modelRange: t, modelCursor: i } =
                        n.convertChildren(e.viewItem, e.modelCursor);
                      (e.modelRange = t), (e.modelCursor = i);
                    }
                  },
                  { priority: "lowest" }
                ),
                this.decorate("init"),
                this.decorate("set"),
                this.decorate("get"),
                this.on(
                  "init",
                  () => {
                    this.fire("ready");
                  },
                  { priority: "lowest" }
                ),
                this.on(
                  "ready",
                  () => {
                    this.model.enqueueChange({ isUndoable: !1 }, Tc);
                  },
                  { priority: "lowest" }
                );
            }
            get(t = {}) {
              const { rootName: e = "main", trim: n = "empty" } = t;
              if (!this._checkIfRootsExists([e]))
                throw new c("datacontroller-get-non-existent-root", this);
              const i = this.model.document.getRoot(e);
              return "empty" !== n ||
                this.model.hasContent(i, { ignoreWhitespaces: !0 })
                ? this.stringify(i, t)
                : "";
            }
            stringify(t, e = {}) {
              const n = this.toView(t, e);
              return this.processor.toData(n);
            }
            toView(t, e = {}) {
              const n = this.viewDocument,
                i = this._viewWriter;
              this.mapper.clearBindings();
              const o = Qa._createIn(t),
                r = new _r(n);
              this.mapper.bindElements(t, r);
              const s = t.is("documentFragment")
                ? t.markers
                : (function (t) {
                    const e = [],
                      n = t.root.document;
                    if (!n) return new Map();
                    const i = Qa._createIn(t);
                    for (const t of n.model.markers) {
                      const n = t.getRange(),
                        o = n.isCollapsed,
                        r = n.start.isEqual(i.start) || n.end.isEqual(i.end);
                      if (o && r) e.push([t.name, n]);
                      else {
                        const o = i.getIntersection(n);
                        o && e.push([t.name, o]);
                      }
                    }
                    return (
                      e.sort(([t, e], [n, i]) => {
                        if ("after" !== e.end.compareWith(i.start)) return 1;
                        if ("before" !== e.start.compareWith(i.end)) return -1;
                        switch (e.start.compareWith(i.start)) {
                          case "before":
                            return 1;
                          case "after":
                            return -1;
                          default:
                            switch (e.end.compareWith(i.end)) {
                              case "before":
                                return 1;
                              case "after":
                                return -1;
                              default:
                                return n.localeCompare(t);
                            }
                        }
                      }),
                      new Map(e)
                    );
                  })(t);
              return this.downcastDispatcher.convert(o, s, i, e), r;
            }
            init(t) {
              if (this.model.document.version)
                throw new c("datacontroller-init-document-not-empty", this);
              let e = {};
              if (
                ("string" == typeof t ? (e.main = t) : (e = t),
                !this._checkIfRootsExists(Object.keys(e)))
              )
                throw new c("datacontroller-init-non-existent-root", this);
              return (
                this.model.enqueueChange({ isUndoable: !1 }, (t) => {
                  for (const n of Object.keys(e)) {
                    const i = this.model.document.getRoot(n);
                    t.insert(this.parse(e[n], i), i, 0);
                  }
                }),
                Promise.resolve()
              );
            }
            set(t, e = {}) {
              let n = {};
              if (
                ("string" == typeof t ? (n.main = t) : (n = t),
                !this._checkIfRootsExists(Object.keys(n)))
              )
                throw new c("datacontroller-set-non-existent-root", this);
              this.model.enqueueChange(e.batchType || {}, (t) => {
                t.setSelection(null),
                  t.removeSelectionAttribute(
                    this.model.document.selection.getAttributeKeys()
                  );
                for (const e of Object.keys(n)) {
                  const i = this.model.document.getRoot(e);
                  t.remove(t.createRangeIn(i)),
                    t.insert(this.parse(n[e], i), i, 0);
                }
              });
            }
            parse(t, e = "$root") {
              const n = this.processor.toView(t);
              return this.toModel(n, e);
            }
            toModel(t, e = "$root") {
              return this.model.change((n) =>
                this.upcastDispatcher.convert(t, n, e)
              );
            }
            addStyleProcessorRules(t) {
              t(this.stylesProcessor);
            }
            registerRawContentMatcher(t) {
              this.processor &&
                this.processor !== this.htmlProcessor &&
                this.processor.registerRawContentMatcher(t),
                this.htmlProcessor.registerRawContentMatcher(t);
            }
            destroy() {
              this.stopListening();
            }
            _checkIfRootsExists(t) {
              for (const e of t)
                if (!this.model.document.getRootNames().includes(e)) return !1;
              return !0;
            }
          }
          he(cl, re);
          class ll {
            constructor(t, e) {
              (this._helpers = new Map()),
                (this._downcast = Ii(t)),
                this._createConversionHelpers({
                  name: "downcast",
                  dispatchers: this._downcast,
                  isDowncast: !0,
                }),
                (this._upcast = Ii(e)),
                this._createConversionHelpers({
                  name: "upcast",
                  dispatchers: this._upcast,
                  isDowncast: !1,
                });
            }
            addAlias(t, e) {
              const n = this._downcast.includes(e);
              if (!this._upcast.includes(e) && !n)
                throw new c(
                  "conversion-add-alias-dispatcher-not-registered",
                  this
                );
              this._createConversionHelpers({
                name: t,
                dispatchers: [e],
                isDowncast: n,
              });
            }
            for(t) {
              if (!this._helpers.has(t))
                throw new c("conversion-for-unknown-group", this);
              return this._helpers.get(t);
            }
            elementToElement(t) {
              this.for("downcast").elementToElement(t);
              for (const { model: e, view: n } of dl(t))
                this.for("upcast").elementToElement({
                  model: e,
                  view: n,
                  converterPriority: t.converterPriority,
                });
            }
            attributeToElement(t) {
              this.for("downcast").attributeToElement(t);
              for (const { model: e, view: n } of dl(t))
                this.for("upcast").elementToAttribute({
                  view: n,
                  model: e,
                  converterPriority: t.converterPriority,
                });
            }
            attributeToAttribute(t) {
              this.for("downcast").attributeToAttribute(t);
              for (const { model: e, view: n } of dl(t))
                this.for("upcast").attributeToAttribute({ view: n, model: e });
            }
            _createConversionHelpers({
              name: t,
              dispatchers: e,
              isDowncast: n,
            }) {
              if (this._helpers.has(t))
                throw new c("conversion-group-exists", this);
              const i = n ? new kc(e) : new Nc(e);
              this._helpers.set(t, i);
            }
          }
          function* dl(t) {
            if (t.model.values)
              for (const e of t.model.values) {
                const n = { key: t.model.key, value: e },
                  i = t.view[e],
                  o = t.upcastAlso ? t.upcastAlso[e] : void 0;
                yield* hl(n, i, o);
              }
            else yield* hl(t.model, t.view, t.upcastAlso);
          }
          function* hl(t, e, n) {
            if ((yield { model: t, view: e }, n))
              for (const e of Ii(n)) yield { model: t, view: e };
          }
          class ul {
            constructor(t = {}) {
              "string" == typeof t &&
                ((t = "transparent" === t ? { isUndoable: !1 } : {}),
                l("batch-constructor-deprecated-string-type"));
              const {
                isUndoable: e = !0,
                isLocal: n = !0,
                isUndo: i = !1,
                isTyping: o = !1,
              } = t;
              (this.operations = []),
                (this.isUndoable = e),
                (this.isLocal = n),
                (this.isUndo = i),
                (this.isTyping = o);
            }
            get type() {
              return l("batch-type-deprecated"), "default";
            }
            get baseVersion() {
              for (const t of this.operations)
                if (null !== t.baseVersion) return t.baseVersion;
              return null;
            }
            addOperation(t) {
              return (t.batch = this), this.operations.push(t), t;
            }
          }
          class ml {
            constructor(t) {
              (this.baseVersion = t),
                (this.isDocumentOperation = null !== this.baseVersion),
                (this.batch = null);
            }
            _validate() {}
            toJSON() {
              const t = Object.assign({}, this);
              return (
                (t.__className = this.constructor.className),
                delete t.batch,
                delete t.isDocumentOperation,
                t
              );
            }
            static get className() {
              return "Operation";
            }
            static fromJSON(t) {
              return new this(t.baseVersion);
            }
          }
          class gl {
            constructor(t) {
              (this.markers = new Map()),
                (this._children = new Ha()),
                t && this._insertChild(0, t);
            }
            [Symbol.iterator]() {
              return this.getChildren();
            }
            get childCount() {
              return this._children.length;
            }
            get maxOffset() {
              return this._children.maxOffset;
            }
            get isEmpty() {
              return 0 === this.childCount;
            }
            get root() {
              return this;
            }
            get parent() {
              return null;
            }
            is(t) {
              return "documentFragment" === t || "model:documentFragment" === t;
            }
            getChild(t) {
              return this._children.getNode(t);
            }
            getChildren() {
              return this._children[Symbol.iterator]();
            }
            getChildIndex(t) {
              return this._children.getNodeIndex(t);
            }
            getChildStartOffset(t) {
              return this._children.getNodeStartOffset(t);
            }
            getPath() {
              return [];
            }
            getNodeByPath(t) {
              let e = this;
              for (const n of t) e = e.getChild(e.offsetToIndex(n));
              return e;
            }
            offsetToIndex(t) {
              return this._children.offsetToIndex(t);
            }
            toJSON() {
              const t = [];
              for (const e of this._children) t.push(e.toJSON());
              return t;
            }
            static fromJSON(t) {
              const e = [];
              for (const n of t)
                n.name ? e.push(Ua.fromJSON(n)) : e.push(Fa.fromJSON(n));
              return new gl(e);
            }
            _appendChild(t) {
              this._insertChild(this.childCount, t);
            }
            _insertChild(t, e) {
              const n = (function (t) {
                if ("string" == typeof t) return [new Fa(t)];
                Ei(t) || (t = [t]);
                return Array.from(t).map((t) =>
                  "string" == typeof t
                    ? new Fa(t)
                    : t instanceof Va
                    ? new Fa(t.data, t.getAttributes())
                    : t
                );
              })(e);
              for (const t of n)
                null !== t.parent && t._remove(), (t.parent = this);
              this._children._insertNodes(t, n);
            }
            _removeChildren(t, e = 1) {
              const n = this._children._removeNodes(t, e);
              for (const t of n) t.parent = null;
              return n;
            }
          }
          function pl(t, e) {
            const n = (e = bl(e)).reduce((t, e) => t + e.offsetSize, 0),
              i = t.parent;
            Al(t);
            const o = t.index;
            return (
              i._insertChild(o, e),
              wl(i, o + e.length),
              wl(i, o),
              new Qa(t, t.getShiftedBy(n))
            );
          }
          function fl(t) {
            if (!t.isFlat)
              throw new c("operation-utils-remove-range-not-flat", this);
            const e = t.start.parent;
            Al(t.start), Al(t.end);
            const n = e._removeChildren(
              t.start.index,
              t.end.index - t.start.index
            );
            return wl(e, t.start.index), n;
          }
          function kl(t, e) {
            if (!t.isFlat)
              throw new c("operation-utils-move-range-not-flat", this);
            const n = fl(t);
            return pl(
              (e = e._getTransformedByDeletion(
                t.start,
                t.end.offset - t.start.offset
              )),
              n
            );
          }
          function bl(t) {
            const e = [];
            t instanceof Array || (t = [t]);
            for (let n = 0; n < t.length; n++)
              if ("string" == typeof t[n]) e.push(new Fa(t[n]));
              else if (t[n] instanceof Va)
                e.push(new Fa(t[n].data, t[n].getAttributes()));
              else if (t[n] instanceof gl || t[n] instanceof Ha)
                for (const i of t[n]) e.push(i);
              else t[n] instanceof ja && e.push(t[n]);
            for (let t = 1; t < e.length; t++) {
              const n = e[t],
                i = e[t - 1];
              n instanceof Fa &&
                i instanceof Fa &&
                _l(n, i) &&
                (e.splice(t - 1, 2, new Fa(i.data + n.data, i.getAttributes())),
                t--);
            }
            return e;
          }
          function wl(t, e) {
            const n = t.getChild(e - 1),
              i = t.getChild(e);
            if (n && i && n.is("$text") && i.is("$text") && _l(n, i)) {
              const o = new Fa(n.data + i.data, n.getAttributes());
              t._removeChildren(e - 1, 2), t._insertChild(e - 1, o);
            }
          }
          function Al(t) {
            const e = t.textNode,
              n = t.parent;
            if (e) {
              const i = t.offset - e.startOffset,
                o = e.index;
              n._removeChildren(o, 1);
              const r = new Fa(e.data.substr(0, i), e.getAttributes()),
                s = new Fa(e.data.substr(i), e.getAttributes());
              n._insertChild(o, [r, s]);
            }
          }
          function _l(t, e) {
            const n = t.getAttributes(),
              i = e.getAttributes();
            for (const t of n) {
              if (t[1] !== e.getAttribute(t[0])) return !1;
              i.next();
            }
            return i.next().done;
          }
          const Cl = function (t, e) {
            return Vs(t, e);
          };
          class vl extends ml {
            constructor(t, e, n, i, o) {
              super(o),
                (this.range = t.clone()),
                (this.key = e),
                (this.oldValue = void 0 === n ? null : n),
                (this.newValue = void 0 === i ? null : i);
            }
            get type() {
              return null === this.oldValue
                ? "addAttribute"
                : null === this.newValue
                ? "removeAttribute"
                : "changeAttribute";
            }
            clone() {
              return new vl(
                this.range,
                this.key,
                this.oldValue,
                this.newValue,
                this.baseVersion
              );
            }
            getReversed() {
              return new vl(
                this.range,
                this.key,
                this.newValue,
                this.oldValue,
                this.baseVersion + 1
              );
            }
            toJSON() {
              const t = super.toJSON();
              return (t.range = this.range.toJSON()), t;
            }
            _validate() {
              if (!this.range.isFlat)
                throw new c("attribute-operation-range-not-flat", this);
              for (const t of this.range.getItems({ shallow: !0 })) {
                if (
                  null !== this.oldValue &&
                  !Cl(t.getAttribute(this.key), this.oldValue)
                )
                  throw new c("attribute-operation-wrong-old-value", this, {
                    item: t,
                    key: this.key,
                    value: this.oldValue,
                  });
                if (
                  null === this.oldValue &&
                  null !== this.newValue &&
                  t.hasAttribute(this.key)
                )
                  throw new c("attribute-operation-attribute-exists", this, {
                    node: t,
                    key: this.key,
                  });
              }
            }
            _execute() {
              Cl(this.oldValue, this.newValue) ||
                (function (t, e, n) {
                  Al(t.start), Al(t.end);
                  for (const i of t.getItems({ shallow: !0 })) {
                    const t = i.is("$textProxy") ? i.textNode : i;
                    null !== n ? t._setAttribute(e, n) : t._removeAttribute(e),
                      wl(t.parent, t.index);
                  }
                  wl(t.end.parent, t.end.index);
                })(this.range, this.key, this.newValue);
            }
            static get className() {
              return "AttributeOperation";
            }
            static fromJSON(t, e) {
              return new vl(
                Qa.fromJSON(t.range, e),
                t.key,
                t.oldValue,
                t.newValue,
                t.baseVersion
              );
            }
          }
          class yl extends ml {
            constructor(t, e) {
              super(null),
                (this.sourcePosition = t.clone()),
                (this.howMany = e);
            }
            get type() {
              return "detach";
            }
            toJSON() {
              const t = super.toJSON();
              return (t.sourcePosition = this.sourcePosition.toJSON()), t;
            }
            _validate() {
              if (this.sourcePosition.root.document)
                throw new c("detach-operation-on-document-node", this);
            }
            _execute() {
              fl(
                Qa._createFromPositionAndShift(
                  this.sourcePosition,
                  this.howMany
                )
              );
            }
            static get className() {
              return "DetachOperation";
            }
          }
          class xl extends ml {
            constructor(t, e, n, i) {
              super(i),
                (this.sourcePosition = t.clone()),
                (this.sourcePosition.stickiness = "toNext"),
                (this.howMany = e),
                (this.targetPosition = n.clone()),
                (this.targetPosition.stickiness = "toNone");
            }
            get type() {
              return "$graveyard" == this.targetPosition.root.rootName
                ? "remove"
                : "$graveyard" == this.sourcePosition.root.rootName
                ? "reinsert"
                : "move";
            }
            clone() {
              return new this.constructor(
                this.sourcePosition,
                this.howMany,
                this.targetPosition,
                this.baseVersion
              );
            }
            getMovedRangeStart() {
              return this.targetPosition._getTransformedByDeletion(
                this.sourcePosition,
                this.howMany
              );
            }
            getReversed() {
              const t = this.sourcePosition._getTransformedByInsertion(
                this.targetPosition,
                this.howMany
              );
              return new this.constructor(
                this.getMovedRangeStart(),
                this.howMany,
                t,
                this.baseVersion + 1
              );
            }
            _validate() {
              const t = this.sourcePosition.parent,
                e = this.targetPosition.parent,
                n = this.sourcePosition.offset,
                i = this.targetPosition.offset;
              if (n + this.howMany > t.maxOffset)
                throw new c("move-operation-nodes-do-not-exist", this);
              if (t === e && n < i && i < n + this.howMany)
                throw new c("move-operation-range-into-itself", this);
              if (
                this.sourcePosition.root == this.targetPosition.root &&
                "prefix" ==
                  Li(
                    this.sourcePosition.getParentPath(),
                    this.targetPosition.getParentPath()
                  )
              ) {
                const t = this.sourcePosition.path.length - 1;
                if (
                  this.targetPosition.path[t] >= n &&
                  this.targetPosition.path[t] < n + this.howMany
                )
                  throw new c("move-operation-node-into-itself", this);
              }
            }
            _execute() {
              kl(
                Qa._createFromPositionAndShift(
                  this.sourcePosition,
                  this.howMany
                ),
                this.targetPosition
              );
            }
            toJSON() {
              const t = super.toJSON();
              return (
                (t.sourcePosition = this.sourcePosition.toJSON()),
                (t.targetPosition = this.targetPosition.toJSON()),
                t
              );
            }
            static get className() {
              return "MoveOperation";
            }
            static fromJSON(t, e) {
              const n = Ga.fromJSON(t.sourcePosition, e),
                i = Ga.fromJSON(t.targetPosition, e);
              return new this(n, t.howMany, i, t.baseVersion);
            }
          }
          class El extends ml {
            constructor(t, e, n) {
              super(n),
                (this.position = t.clone()),
                (this.position.stickiness = "toNone"),
                (this.nodes = new Ha(bl(e))),
                (this.shouldReceiveAttributes = !1);
            }
            get type() {
              return "insert";
            }
            get howMany() {
              return this.nodes.maxOffset;
            }
            clone() {
              const t = new Ha([...this.nodes].map((t) => t._clone(!0))),
                e = new El(this.position, t, this.baseVersion);
              return (
                (e.shouldReceiveAttributes = this.shouldReceiveAttributes), e
              );
            }
            getReversed() {
              const t = this.position.root.document.graveyard,
                e = new Ga(t, [0]);
              return new xl(
                this.position,
                this.nodes.maxOffset,
                e,
                this.baseVersion + 1
              );
            }
            _validate() {
              const t = this.position.parent;
              if (!t || t.maxOffset < this.position.offset)
                throw new c("insert-operation-position-invalid", this);
            }
            _execute() {
              const t = this.nodes;
              (this.nodes = new Ha([...t].map((t) => t._clone(!0)))),
                pl(this.position, t);
            }
            toJSON() {
              const t = super.toJSON();
              return (
                (t.position = this.position.toJSON()),
                (t.nodes = this.nodes.toJSON()),
                t
              );
            }
            static get className() {
              return "InsertOperation";
            }
            static fromJSON(t, e) {
              const n = [];
              for (const e of t.nodes)
                e.name ? n.push(Ua.fromJSON(e)) : n.push(Fa.fromJSON(e));
              const i = new El(Ga.fromJSON(t.position, e), n, t.baseVersion);
              return (i.shouldReceiveAttributes = t.shouldReceiveAttributes), i;
            }
          }
          class Dl extends ml {
            constructor(t, e, n, i, o, r) {
              super(r),
                (this.name = t),
                (this.oldRange = e ? e.clone() : null),
                (this.newRange = n ? n.clone() : null),
                (this.affectsData = o),
                (this._markers = i);
            }
            get type() {
              return "marker";
            }
            clone() {
              return new Dl(
                this.name,
                this.oldRange,
                this.newRange,
                this._markers,
                this.affectsData,
                this.baseVersion
              );
            }
            getReversed() {
              return new Dl(
                this.name,
                this.newRange,
                this.oldRange,
                this._markers,
                this.affectsData,
                this.baseVersion + 1
              );
            }
            _execute() {
              const t = this.newRange ? "_set" : "_remove";
              this._markers[t](this.name, this.newRange, !0, this.affectsData);
            }
            toJSON() {
              const t = super.toJSON();
              return (
                this.oldRange && (t.oldRange = this.oldRange.toJSON()),
                this.newRange && (t.newRange = this.newRange.toJSON()),
                delete t._markers,
                t
              );
            }
            static get className() {
              return "MarkerOperation";
            }
            static fromJSON(t, e) {
              return new Dl(
                t.name,
                t.oldRange ? Qa.fromJSON(t.oldRange, e) : null,
                t.newRange ? Qa.fromJSON(t.newRange, e) : null,
                e.model.markers,
                t.affectsData,
                t.baseVersion
              );
            }
          }
          class Sl extends ml {
            constructor(t, e, n, i) {
              super(i),
                (this.position = t),
                (this.position.stickiness = "toNext"),
                (this.oldName = e),
                (this.newName = n);
            }
            get type() {
              return "rename";
            }
            clone() {
              return new Sl(
                this.position.clone(),
                this.oldName,
                this.newName,
                this.baseVersion
              );
            }
            getReversed() {
              return new Sl(
                this.position.clone(),
                this.newName,
                this.oldName,
                this.baseVersion + 1
              );
            }
            _validate() {
              const t = this.position.nodeAfter;
              if (!(t instanceof Ua))
                throw new c("rename-operation-wrong-position", this);
              if (t.name !== this.oldName)
                throw new c("rename-operation-wrong-name", this);
            }
            _execute() {
              this.position.nodeAfter.name = this.newName;
            }
            toJSON() {
              const t = super.toJSON();
              return (t.position = this.position.toJSON()), t;
            }
            static get className() {
              return "RenameOperation";
            }
            static fromJSON(t, e) {
              return new Sl(
                Ga.fromJSON(t.position, e),
                t.oldName,
                t.newName,
                t.baseVersion
              );
            }
          }
          class Il extends ml {
            constructor(t, e, n, i, o) {
              super(o),
                (this.root = t),
                (this.key = e),
                (this.oldValue = n),
                (this.newValue = i);
            }
            get type() {
              return null === this.oldValue
                ? "addRootAttribute"
                : null === this.newValue
                ? "removeRootAttribute"
                : "changeRootAttribute";
            }
            clone() {
              return new Il(
                this.root,
                this.key,
                this.oldValue,
                this.newValue,
                this.baseVersion
              );
            }
            getReversed() {
              return new Il(
                this.root,
                this.key,
                this.newValue,
                this.oldValue,
                this.baseVersion + 1
              );
            }
            _validate() {
              if (
                this.root != this.root.root ||
                this.root.is("documentFragment")
              )
                throw new c("rootattribute-operation-not-a-root", this, {
                  root: this.root,
                  key: this.key,
                });
              if (
                null !== this.oldValue &&
                this.root.getAttribute(this.key) !== this.oldValue
              )
                throw new c("rootattribute-operation-wrong-old-value", this, {
                  root: this.root,
                  key: this.key,
                });
              if (
                null === this.oldValue &&
                null !== this.newValue &&
                this.root.hasAttribute(this.key)
              )
                throw new c("rootattribute-operation-attribute-exists", this, {
                  root: this.root,
                  key: this.key,
                });
            }
            _execute() {
              null !== this.newValue
                ? this.root._setAttribute(this.key, this.newValue)
                : this.root._removeAttribute(this.key);
            }
            toJSON() {
              const t = super.toJSON();
              return (t.root = this.root.toJSON()), t;
            }
            static get className() {
              return "RootAttributeOperation";
            }
            static fromJSON(t, e) {
              if (!e.getRoot(t.root))
                throw new c("rootattribute-operation-fromjson-no-root", this, {
                  rootName: t.root,
                });
              return new Il(
                e.getRoot(t.root),
                t.key,
                t.oldValue,
                t.newValue,
                t.baseVersion
              );
            }
          }
          class Tl extends ml {
            constructor(t, e, n, i, o) {
              super(o),
                (this.sourcePosition = t.clone()),
                (this.sourcePosition.stickiness = "toPrevious"),
                (this.howMany = e),
                (this.targetPosition = n.clone()),
                (this.targetPosition.stickiness = "toNext"),
                (this.graveyardPosition = i.clone());
            }
            get type() {
              return "merge";
            }
            get deletionPosition() {
              return new Ga(
                this.sourcePosition.root,
                this.sourcePosition.path.slice(0, -1)
              );
            }
            get movedRange() {
              const t = this.sourcePosition.getShiftedBy(
                Number.POSITIVE_INFINITY
              );
              return new Qa(this.sourcePosition, t);
            }
            clone() {
              return new this.constructor(
                this.sourcePosition,
                this.howMany,
                this.targetPosition,
                this.graveyardPosition,
                this.baseVersion
              );
            }
            getReversed() {
              const t =
                  this.targetPosition._getTransformedByMergeOperation(this),
                e = this.sourcePosition.path.slice(0, -1),
                n = new Ga(
                  this.sourcePosition.root,
                  e
                )._getTransformedByMergeOperation(this);
              return new Ml(
                t,
                this.howMany,
                n,
                this.graveyardPosition,
                this.baseVersion + 1
              );
            }
            _validate() {
              const t = this.sourcePosition.parent,
                e = this.targetPosition.parent;
              if (!t.parent)
                throw new c("merge-operation-source-position-invalid", this);
              if (!e.parent)
                throw new c("merge-operation-target-position-invalid", this);
              if (this.howMany != t.maxOffset)
                throw new c("merge-operation-how-many-invalid", this);
            }
            _execute() {
              const t = this.sourcePosition.parent;
              kl(Qa._createIn(t), this.targetPosition),
                kl(Qa._createOn(t), this.graveyardPosition);
            }
            toJSON() {
              const t = super.toJSON();
              return (
                (t.sourcePosition = t.sourcePosition.toJSON()),
                (t.targetPosition = t.targetPosition.toJSON()),
                (t.graveyardPosition = t.graveyardPosition.toJSON()),
                t
              );
            }
            static get className() {
              return "MergeOperation";
            }
            static fromJSON(t, e) {
              const n = Ga.fromJSON(t.sourcePosition, e),
                i = Ga.fromJSON(t.targetPosition, e),
                o = Ga.fromJSON(t.graveyardPosition, e);
              return new this(n, t.howMany, i, o, t.baseVersion);
            }
          }
          class Ml extends ml {
            constructor(t, e, n, i, o) {
              super(o),
                (this.splitPosition = t.clone()),
                (this.splitPosition.stickiness = "toNext"),
                (this.howMany = e),
                (this.insertionPosition = n),
                (this.graveyardPosition = i ? i.clone() : null),
                this.graveyardPosition &&
                  (this.graveyardPosition.stickiness = "toNext");
            }
            get type() {
              return "split";
            }
            get moveTargetPosition() {
              const t = this.insertionPosition.path.slice();
              return t.push(0), new Ga(this.insertionPosition.root, t);
            }
            get movedRange() {
              const t = this.splitPosition.getShiftedBy(
                Number.POSITIVE_INFINITY
              );
              return new Qa(this.splitPosition, t);
            }
            clone() {
              return new this.constructor(
                this.splitPosition,
                this.howMany,
                this.insertionPosition,
                this.graveyardPosition,
                this.baseVersion
              );
            }
            getReversed() {
              const t = this.splitPosition.root.document.graveyard,
                e = new Ga(t, [0]);
              return new Tl(
                this.moveTargetPosition,
                this.howMany,
                this.splitPosition,
                e,
                this.baseVersion + 1
              );
            }
            _validate() {
              const t = this.splitPosition.parent,
                e = this.splitPosition.offset;
              if (!t || t.maxOffset < e)
                throw new c("split-operation-position-invalid", this);
              if (!t.parent) throw new c("split-operation-split-in-root", this);
              if (this.howMany != t.maxOffset - this.splitPosition.offset)
                throw new c("split-operation-how-many-invalid", this);
              if (this.graveyardPosition && !this.graveyardPosition.nodeAfter)
                throw new c("split-operation-graveyard-position-invalid", this);
            }
            _execute() {
              const t = this.splitPosition.parent;
              if (this.graveyardPosition)
                kl(
                  Qa._createFromPositionAndShift(this.graveyardPosition, 1),
                  this.insertionPosition
                );
              else {
                const e = t._clone();
                pl(this.insertionPosition, e);
              }
              kl(
                new Qa(
                  Ga._createAt(t, this.splitPosition.offset),
                  Ga._createAt(t, t.maxOffset)
                ),
                this.moveTargetPosition
              );
            }
            toJSON() {
              const t = super.toJSON();
              return (
                (t.splitPosition = this.splitPosition.toJSON()),
                (t.insertionPosition = this.insertionPosition.toJSON()),
                this.graveyardPosition &&
                  (t.graveyardPosition = this.graveyardPosition.toJSON()),
                t
              );
            }
            static get className() {
              return "SplitOperation";
            }
            static getInsertionPosition(t) {
              const e = t.path.slice(0, -1);
              return e[e.length - 1]++, new Ga(t.root, e, "toPrevious");
            }
            static fromJSON(t, e) {
              const n = Ga.fromJSON(t.splitPosition, e),
                i = Ga.fromJSON(t.insertionPosition, e),
                o = t.graveyardPosition
                  ? Ga.fromJSON(t.graveyardPosition, e)
                  : null;
              return new this(n, t.howMany, i, o, t.baseVersion);
            }
          }
          class Bl extends Ua {
            constructor(t, e, n = "main") {
              super(e), (this._document = t), (this.rootName = n);
            }
            get document() {
              return this._document;
            }
            is(t, e) {
              return e
                ? e === this.name &&
                    ("rootElement" === t ||
                      "model:rootElement" === t ||
                      "element" === t ||
                      "model:element" === t)
                : "rootElement" === t ||
                    "model:rootElement" === t ||
                    "element" === t ||
                    "model:element" === t ||
                    "node" === t ||
                    "model:node" === t;
            }
            toJSON() {
              return this.rootName;
            }
          }
          class Nl {
            constructor(t, e) {
              (this.model = t), (this.batch = e);
            }
            createText(t, e) {
              return new Fa(t, e);
            }
            createElement(t, e) {
              return new Ua(t, e);
            }
            createDocumentFragment() {
              return new gl();
            }
            cloneElement(t, e = !0) {
              return t._clone(e);
            }
            insert(t, e, n = 0) {
              if (
                (this._assertWriterUsedCorrectly(),
                t instanceof Fa && "" == t.data)
              )
                return;
              const i = Ga._createAt(e, n);
              if (t.parent) {
                if (Ol(t.root, i.root))
                  return void this.move(Qa._createOn(t), i);
                if (t.root.document)
                  throw new c("model-writer-insert-forbidden-move", this);
                this.remove(t);
              }
              const o = i.root.document ? i.root.document.version : null,
                r = new El(i, t, o);
              if (
                (t instanceof Fa && (r.shouldReceiveAttributes = !0),
                this.batch.addOperation(r),
                this.model.applyOperation(r),
                t instanceof gl)
              )
                for (const [e, n] of t.markers) {
                  const t = Ga._createAt(n.root, 0),
                    o = {
                      range: new Qa(
                        n.start._getCombined(t, i),
                        n.end._getCombined(t, i)
                      ),
                      usingOperation: !0,
                      affectsData: !0,
                    };
                  this.model.markers.has(e)
                    ? this.updateMarker(e, o)
                    : this.addMarker(e, o);
                }
            }
            insertText(t, e, n, i) {
              e instanceof gl || e instanceof Ua || e instanceof Ga
                ? this.insert(this.createText(t), e, n)
                : this.insert(this.createText(t, e), n, i);
            }
            insertElement(t, e, n, i) {
              e instanceof gl || e instanceof Ua || e instanceof Ga
                ? this.insert(this.createElement(t), e, n)
                : this.insert(this.createElement(t, e), n, i);
            }
            append(t, e) {
              this.insert(t, e, "end");
            }
            appendText(t, e, n) {
              e instanceof gl || e instanceof Ua
                ? this.insert(this.createText(t), e, "end")
                : this.insert(this.createText(t, e), n, "end");
            }
            appendElement(t, e, n) {
              e instanceof gl || e instanceof Ua
                ? this.insert(this.createElement(t), e, "end")
                : this.insert(this.createElement(t, e), n, "end");
            }
            setAttribute(t, e, n) {
              if ((this._assertWriterUsedCorrectly(), n instanceof Qa)) {
                const i = n.getMinimalFlatRanges();
                for (const n of i) zl(this, t, e, n);
              } else Pl(this, t, e, n);
            }
            setAttributes(t, e) {
              for (const [n, i] of Vi(t)) this.setAttribute(n, i, e);
            }
            removeAttribute(t, e) {
              if ((this._assertWriterUsedCorrectly(), e instanceof Qa)) {
                const n = e.getMinimalFlatRanges();
                for (const e of n) zl(this, t, null, e);
              } else Pl(this, t, null, e);
            }
            clearAttributes(t) {
              this._assertWriterUsedCorrectly();
              const e = (t) => {
                for (const e of t.getAttributeKeys())
                  this.removeAttribute(e, t);
              };
              if (t instanceof Qa) for (const n of t.getItems()) e(n);
              else e(t);
            }
            move(t, e, n) {
              if ((this._assertWriterUsedCorrectly(), !(t instanceof Qa)))
                throw new c("writer-move-invalid-range", this);
              if (!t.isFlat) throw new c("writer-move-range-not-flat", this);
              const i = Ga._createAt(e, n);
              if (i.isEqual(t.start)) return;
              if (
                (this._addOperationForAffectedMarkers("move", t),
                !Ol(t.root, i.root))
              )
                throw new c("writer-move-different-document", this);
              const o = t.root.document ? t.root.document.version : null,
                r = new xl(t.start, t.end.offset - t.start.offset, i, o);
              this.batch.addOperation(r), this.model.applyOperation(r);
            }
            remove(t) {
              this._assertWriterUsedCorrectly();
              const e = (t instanceof Qa ? t : Qa._createOn(t))
                .getMinimalFlatRanges()
                .reverse();
              for (const t of e)
                this._addOperationForAffectedMarkers("move", t),
                  Rl(
                    t.start,
                    t.end.offset - t.start.offset,
                    this.batch,
                    this.model
                  );
            }
            merge(t) {
              this._assertWriterUsedCorrectly();
              const e = t.nodeBefore,
                n = t.nodeAfter;
              if (
                (this._addOperationForAffectedMarkers("merge", t),
                !(e instanceof Ua))
              )
                throw new c("writer-merge-no-element-before", this);
              if (!(n instanceof Ua))
                throw new c("writer-merge-no-element-after", this);
              t.root.document ? this._merge(t) : this._mergeDetached(t);
            }
            createPositionFromPath(t, e, n) {
              return this.model.createPositionFromPath(t, e, n);
            }
            createPositionAt(t, e) {
              return this.model.createPositionAt(t, e);
            }
            createPositionAfter(t) {
              return this.model.createPositionAfter(t);
            }
            createPositionBefore(t) {
              return this.model.createPositionBefore(t);
            }
            createRange(t, e) {
              return this.model.createRange(t, e);
            }
            createRangeIn(t) {
              return this.model.createRangeIn(t);
            }
            createRangeOn(t) {
              return this.model.createRangeOn(t);
            }
            createSelection(t, e, n) {
              return this.model.createSelection(t, e, n);
            }
            _mergeDetached(t) {
              const e = t.nodeBefore,
                n = t.nodeAfter;
              this.move(Qa._createIn(n), Ga._createAt(e, "end")),
                this.remove(n);
            }
            _merge(t) {
              const e = Ga._createAt(t.nodeBefore, "end"),
                n = Ga._createAt(t.nodeAfter, 0),
                i = t.root.document.graveyard,
                o = new Ga(i, [0]),
                r = t.root.document.version,
                s = new Tl(n, t.nodeAfter.maxOffset, e, o, r);
              this.batch.addOperation(s), this.model.applyOperation(s);
            }
            rename(t, e) {
              if ((this._assertWriterUsedCorrectly(), !(t instanceof Ua)))
                throw new c("writer-rename-not-element-instance", this);
              const n = t.root.document ? t.root.document.version : null,
                i = new Sl(Ga._createBefore(t), t.name, e, n);
              this.batch.addOperation(i), this.model.applyOperation(i);
            }
            split(t, e) {
              this._assertWriterUsedCorrectly();
              let n,
                i,
                o = t.parent;
              if (!o.parent)
                throw new c("writer-split-element-no-parent", this);
              if (
                (e || (e = o.parent),
                !t.parent.getAncestors({ includeSelf: !0 }).includes(e))
              )
                throw new c("writer-split-invalid-limit-element", this);
              do {
                const e = o.root.document ? o.root.document.version : null,
                  r = o.maxOffset - t.offset,
                  s = Ml.getInsertionPosition(t),
                  a = new Ml(t, r, s, null, e);
                this.batch.addOperation(a),
                  this.model.applyOperation(a),
                  n || i || ((n = o), (i = t.parent.nextSibling)),
                  (o = (t = this.createPositionAfter(t.parent)).parent);
              } while (o !== e);
              return {
                position: t,
                range: new Qa(Ga._createAt(n, "end"), Ga._createAt(i, 0)),
              };
            }
            wrap(t, e) {
              if ((this._assertWriterUsedCorrectly(), !t.isFlat))
                throw new c("writer-wrap-range-not-flat", this);
              const n = e instanceof Ua ? e : new Ua(e);
              if (n.childCount > 0)
                throw new c("writer-wrap-element-not-empty", this);
              if (null !== n.parent)
                throw new c("writer-wrap-element-attached", this);
              this.insert(n, t.start);
              const i = new Qa(t.start.getShiftedBy(1), t.end.getShiftedBy(1));
              this.move(i, Ga._createAt(n, 0));
            }
            unwrap(t) {
              if ((this._assertWriterUsedCorrectly(), null === t.parent))
                throw new c("writer-unwrap-element-no-parent", this);
              this.move(Qa._createIn(t), this.createPositionAfter(t)),
                this.remove(t);
            }
            addMarker(t, e) {
              if (
                (this._assertWriterUsedCorrectly(),
                !e || "boolean" != typeof e.usingOperation)
              )
                throw new c("writer-addmarker-no-usingoperation", this);
              const n = e.usingOperation,
                i = e.range,
                o = void 0 !== e.affectsData && e.affectsData;
              if (this.model.markers.has(t))
                throw new c("writer-addmarker-marker-exists", this);
              if (!i) throw new c("writer-addmarker-no-range", this);
              return n
                ? (Ll(this, t, null, i, o), this.model.markers.get(t))
                : this.model.markers._set(t, i, n, o);
            }
            updateMarker(t, e) {
              this._assertWriterUsedCorrectly();
              const n = "string" == typeof t ? t : t.name,
                i = this.model.markers.get(n);
              if (!i)
                throw new c("writer-updatemarker-marker-not-exists", this);
              if (!e)
                return (
                  l("writer-updatemarker-reconvert-using-editingcontroller", {
                    markerName: n,
                  }),
                  void this.model.markers._refresh(i)
                );
              const o = "boolean" == typeof e.usingOperation,
                r = "boolean" == typeof e.affectsData,
                s = r ? e.affectsData : i.affectsData;
              if (!o && !e.range && !r)
                throw new c("writer-updatemarker-wrong-options", this);
              const a = i.getRange(),
                d = e.range ? e.range : a;
              o && e.usingOperation !== i.managedUsingOperations
                ? e.usingOperation
                  ? Ll(this, n, null, d, s)
                  : (Ll(this, n, a, null, s),
                    this.model.markers._set(n, d, void 0, s))
                : i.managedUsingOperations
                ? Ll(this, n, a, d, s)
                : this.model.markers._set(n, d, void 0, s);
            }
            removeMarker(t) {
              this._assertWriterUsedCorrectly();
              const e = "string" == typeof t ? t : t.name;
              if (!this.model.markers.has(e))
                throw new c("writer-removemarker-no-marker", this);
              const n = this.model.markers.get(e);
              if (!n.managedUsingOperations)
                return void this.model.markers._remove(e);
              Ll(this, e, n.getRange(), null, n.affectsData);
            }
            setSelection(t, e, n) {
              this._assertWriterUsedCorrectly(),
                this.model.document.selection._setTo(t, e, n);
            }
            setSelectionFocus(t, e) {
              this._assertWriterUsedCorrectly(),
                this.model.document.selection._setFocus(t, e);
            }
            setSelectionAttribute(t, e) {
              if ((this._assertWriterUsedCorrectly(), "string" == typeof t))
                this._setSelectionAttribute(t, e);
              else
                for (const [e, n] of Vi(t)) this._setSelectionAttribute(e, n);
            }
            removeSelectionAttribute(t) {
              if ((this._assertWriterUsedCorrectly(), "string" == typeof t))
                this._removeSelectionAttribute(t);
              else for (const e of t) this._removeSelectionAttribute(e);
            }
            overrideSelectionGravity() {
              return this.model.document.selection._overrideGravity();
            }
            restoreSelectionGravity(t) {
              this.model.document.selection._restoreGravity(t);
            }
            _setSelectionAttribute(t, e) {
              const n = this.model.document.selection;
              if (n.isCollapsed && n.anchor.parent.isEmpty) {
                const i = uc._getStoreAttributeKey(t);
                this.setAttribute(i, e, n.anchor.parent);
              }
              n._setAttribute(t, e);
            }
            _removeSelectionAttribute(t) {
              const e = this.model.document.selection;
              if (e.isCollapsed && e.anchor.parent.isEmpty) {
                const n = uc._getStoreAttributeKey(t);
                this.removeAttribute(n, e.anchor.parent);
              }
              e._removeAttribute(t);
            }
            _assertWriterUsedCorrectly() {
              if (this.model._currentWriter !== this)
                throw new c("writer-incorrect-use", this);
            }
            _addOperationForAffectedMarkers(t, e) {
              for (const n of this.model.markers) {
                if (!n.managedUsingOperations) continue;
                const i = n.getRange();
                let o = !1;
                if ("move" === t)
                  o =
                    e.containsPosition(i.start) ||
                    e.start.isEqual(i.start) ||
                    e.containsPosition(i.end) ||
                    e.end.isEqual(i.end);
                else {
                  const t = e.nodeBefore,
                    n = e.nodeAfter,
                    r = i.start.parent == t && i.start.isAtEnd,
                    s = i.end.parent == n && 0 == i.end.offset,
                    a = i.end.nodeAfter == n,
                    c = i.start.nodeAfter == n;
                  o = r || s || a || c;
                }
                o && this.updateMarker(n.name, { range: i });
              }
            }
          }
          function zl(t, e, n, i) {
            const o = t.model,
              r = o.document;
            let s,
              a,
              c,
              l = i.start;
            for (const t of i.getWalker({ shallow: !0 }))
              (c = t.item.getAttribute(e)),
                s && a != c && (a != n && d(), (l = s)),
                (s = t.nextPosition),
                (a = c);
            function d() {
              const i = new Qa(l, s),
                c = i.root.document ? r.version : null,
                d = new vl(i, e, a, n, c);
              t.batch.addOperation(d), o.applyOperation(d);
            }
            s instanceof Ga && s != l && a != n && d();
          }
          function Pl(t, e, n, i) {
            const o = t.model,
              r = o.document,
              s = i.getAttribute(e);
            let a, c;
            if (s != n) {
              if (i.root === i) {
                const t = i.document ? r.version : null;
                c = new Il(i, e, s, n, t);
              } else {
                a = new Qa(Ga._createBefore(i), t.createPositionAfter(i));
                const o = a.root.document ? r.version : null;
                c = new vl(a, e, s, n, o);
              }
              t.batch.addOperation(c), o.applyOperation(c);
            }
          }
          function Ll(t, e, n, i, o) {
            const r = t.model,
              s = r.document,
              a = new Dl(e, n, i, r.markers, o, s.version);
            t.batch.addOperation(a), r.applyOperation(a);
          }
          function Rl(t, e, n, i) {
            let o;
            if (t.root.document) {
              const n = i.document,
                r = new Ga(n.graveyard, [0]);
              o = new xl(t, e, r, n.version);
            } else o = new yl(t, e);
            n.addOperation(o), i.applyOperation(o);
          }
          function Ol(t, e) {
            return t === e || (t instanceof Bl && e instanceof Bl);
          }
          class jl {
            constructor(t) {
              (this._markerCollection = t),
                (this._changesInElement = new Map()),
                (this._elementSnapshots = new Map()),
                (this._changedMarkers = new Map()),
                (this._changeCount = 0),
                (this._cachedChanges = null),
                (this._cachedChangesWithGraveyard = null),
                (this._refreshedItems = new Set());
            }
            get isEmpty() {
              return (
                0 == this._changesInElement.size &&
                0 == this._changedMarkers.size
              );
            }
            bufferOperation(t) {
              switch (t.type) {
                case "insert":
                  if (this._isInInsertedElement(t.position.parent)) return;
                  this._markInsert(
                    t.position.parent,
                    t.position.offset,
                    t.nodes.maxOffset
                  );
                  break;
                case "addAttribute":
                case "removeAttribute":
                case "changeAttribute":
                  for (const e of t.range.getItems({ shallow: !0 }))
                    this._isInInsertedElement(e.parent) ||
                      this._markAttribute(e);
                  break;
                case "remove":
                case "move":
                case "reinsert": {
                  if (
                    t.sourcePosition.isEqual(t.targetPosition) ||
                    t.sourcePosition
                      .getShiftedBy(t.howMany)
                      .isEqual(t.targetPosition)
                  )
                    return;
                  const e = this._isInInsertedElement(t.sourcePosition.parent),
                    n = this._isInInsertedElement(t.targetPosition.parent);
                  e ||
                    this._markRemove(
                      t.sourcePosition.parent,
                      t.sourcePosition.offset,
                      t.howMany
                    ),
                    n ||
                      this._markInsert(
                        t.targetPosition.parent,
                        t.getMovedRangeStart().offset,
                        t.howMany
                      );
                  break;
                }
                case "rename": {
                  if (this._isInInsertedElement(t.position.parent)) return;
                  this._markRemove(t.position.parent, t.position.offset, 1),
                    this._markInsert(t.position.parent, t.position.offset, 1);
                  const e = Qa._createFromPositionAndShift(t.position, 1);
                  for (const t of this._markerCollection.getMarkersIntersectingRange(
                    e
                  )) {
                    const e = t.getData();
                    this.bufferMarkerChange(t.name, e, e);
                  }
                  break;
                }
                case "split": {
                  const e = t.splitPosition.parent;
                  this._isInInsertedElement(e) ||
                    this._markRemove(e, t.splitPosition.offset, t.howMany),
                    this._isInInsertedElement(t.insertionPosition.parent) ||
                      this._markInsert(
                        t.insertionPosition.parent,
                        t.insertionPosition.offset,
                        1
                      ),
                    t.graveyardPosition &&
                      this._markRemove(
                        t.graveyardPosition.parent,
                        t.graveyardPosition.offset,
                        1
                      );
                  break;
                }
                case "merge": {
                  const e = t.sourcePosition.parent;
                  this._isInInsertedElement(e.parent) ||
                    this._markRemove(e.parent, e.startOffset, 1);
                  const n = t.graveyardPosition.parent;
                  this._markInsert(n, t.graveyardPosition.offset, 1);
                  const i = t.targetPosition.parent;
                  this._isInInsertedElement(i) ||
                    this._markInsert(i, t.targetPosition.offset, e.maxOffset);
                  break;
                }
              }
              this._cachedChanges = null;
            }
            bufferMarkerChange(t, e, n) {
              const i = this._changedMarkers.get(t);
              i
                ? ((i.newMarkerData = n),
                  null == i.oldMarkerData.range &&
                    null == n.range &&
                    this._changedMarkers.delete(t))
                : this._changedMarkers.set(t, {
                    newMarkerData: n,
                    oldMarkerData: e,
                  });
            }
            getMarkersToRemove() {
              const t = [];
              for (const [e, n] of this._changedMarkers)
                null != n.oldMarkerData.range &&
                  t.push({ name: e, range: n.oldMarkerData.range });
              return t;
            }
            getMarkersToAdd() {
              const t = [];
              for (const [e, n] of this._changedMarkers)
                null != n.newMarkerData.range &&
                  t.push({ name: e, range: n.newMarkerData.range });
              return t;
            }
            getChangedMarkers() {
              return Array.from(this._changedMarkers).map(([t, e]) => ({
                name: t,
                data: {
                  oldRange: e.oldMarkerData.range,
                  newRange: e.newMarkerData.range,
                },
              }));
            }
            hasDataChanges() {
              if (this._changesInElement.size > 0) return !0;
              for (const {
                newMarkerData: t,
                oldMarkerData: e,
              } of this._changedMarkers.values()) {
                if (t.affectsData !== e.affectsData) return !0;
                if (t.affectsData) {
                  const n = t.range && !e.range,
                    i = !t.range && e.range,
                    o = t.range && e.range && !t.range.isEqual(e.range);
                  if (n || i || o) return !0;
                }
              }
              return !1;
            }
            getChanges(t = { includeChangesInGraveyard: !1 }) {
              if (this._cachedChanges)
                return t.includeChangesInGraveyard
                  ? this._cachedChangesWithGraveyard.slice()
                  : this._cachedChanges.slice();
              let e = [];
              for (const t of this._changesInElement.keys()) {
                const n = this._changesInElement
                    .get(t)
                    .sort((t, e) =>
                      t.offset === e.offset
                        ? t.type != e.type
                          ? "remove" == t.type
                            ? -1
                            : 1
                          : 0
                        : t.offset < e.offset
                        ? -1
                        : 1
                    ),
                  i = this._elementSnapshots.get(t),
                  o = Fl(t.getChildren()),
                  r = Vl(i.length, n);
                let s = 0,
                  a = 0;
                for (const n of r)
                  if ("i" === n) e.push(this._getInsertDiff(t, s, o[s])), s++;
                  else if ("r" === n)
                    e.push(this._getRemoveDiff(t, s, i[a])), a++;
                  else if ("a" === n) {
                    const n = o[s].attributes,
                      r = i[a].attributes;
                    let c;
                    if ("$text" == o[s].name)
                      c = new Qa(Ga._createAt(t, s), Ga._createAt(t, s + 1));
                    else {
                      const e = t.offsetToIndex(s);
                      c = new Qa(
                        Ga._createAt(t, s),
                        Ga._createAt(t.getChild(e), 0)
                      );
                    }
                    e.push(...this._getAttributesDiff(c, r, n)), s++, a++;
                  } else s++, a++;
              }
              e.sort((t, e) =>
                t.position.root != e.position.root
                  ? t.position.root.rootName < e.position.root.rootName
                    ? -1
                    : 1
                  : t.position.isEqual(e.position)
                  ? t.changeCount - e.changeCount
                  : t.position.isBefore(e.position)
                  ? -1
                  : 1
              );
              for (let t = 1, n = 0; t < e.length; t++) {
                const i = e[n],
                  o = e[t],
                  r =
                    "remove" == i.type &&
                    "remove" == o.type &&
                    "$text" == i.name &&
                    "$text" == o.name &&
                    i.position.isEqual(o.position),
                  s =
                    "insert" == i.type &&
                    "insert" == o.type &&
                    "$text" == i.name &&
                    "$text" == o.name &&
                    i.position.parent == o.position.parent &&
                    i.position.offset + i.length == o.position.offset,
                  a =
                    "attribute" == i.type &&
                    "attribute" == o.type &&
                    i.position.parent == o.position.parent &&
                    i.range.isFlat &&
                    o.range.isFlat &&
                    i.position.offset + i.length == o.position.offset &&
                    i.attributeKey == o.attributeKey &&
                    i.attributeOldValue == o.attributeOldValue &&
                    i.attributeNewValue == o.attributeNewValue;
                r || s || a
                  ? (i.length++,
                    a && (i.range.end = i.range.end.getShiftedBy(1)),
                    (e[t] = null))
                  : (n = t);
              }
              e = e.filter((t) => t);
              for (const t of e)
                delete t.changeCount,
                  "attribute" == t.type && (delete t.position, delete t.length);
              return (
                (this._changeCount = 0),
                (this._cachedChangesWithGraveyard = e),
                (this._cachedChanges = e.filter(Hl)),
                t.includeChangesInGraveyard
                  ? this._cachedChangesWithGraveyard.slice()
                  : this._cachedChanges.slice()
              );
            }
            getRefreshedItems() {
              return new Set(this._refreshedItems);
            }
            reset() {
              this._changesInElement.clear(),
                this._elementSnapshots.clear(),
                this._changedMarkers.clear(),
                (this._refreshedItems = new Set()),
                (this._cachedChanges = null);
            }
            _refreshItem(t) {
              if (this._isInInsertedElement(t.parent)) return;
              this._markRemove(t.parent, t.startOffset, t.offsetSize),
                this._markInsert(t.parent, t.startOffset, t.offsetSize),
                this._refreshedItems.add(t);
              const e = Qa._createOn(t);
              for (const t of this._markerCollection.getMarkersIntersectingRange(
                e
              )) {
                const e = t.getData();
                this.bufferMarkerChange(t.name, e, e);
              }
              this._cachedChanges = null;
            }
            _markInsert(t, e, n) {
              const i = {
                type: "insert",
                offset: e,
                howMany: n,
                count: this._changeCount++,
              };
              this._markChange(t, i);
            }
            _markRemove(t, e, n) {
              const i = {
                type: "remove",
                offset: e,
                howMany: n,
                count: this._changeCount++,
              };
              this._markChange(t, i), this._removeAllNestedChanges(t, e, n);
            }
            _markAttribute(t) {
              const e = {
                type: "attribute",
                offset: t.startOffset,
                howMany: t.offsetSize,
                count: this._changeCount++,
              };
              this._markChange(t.parent, e);
            }
            _markChange(t, e) {
              this._makeSnapshot(t);
              const n = this._getChangesForElement(t);
              this._handleChange(e, n), n.push(e);
              for (let t = 0; t < n.length; t++)
                n[t].howMany < 1 && (n.splice(t, 1), t--);
            }
            _getChangesForElement(t) {
              let e;
              return (
                this._changesInElement.has(t)
                  ? (e = this._changesInElement.get(t))
                  : ((e = []), this._changesInElement.set(t, e)),
                e
              );
            }
            _makeSnapshot(t) {
              this._elementSnapshots.has(t) ||
                this._elementSnapshots.set(t, Fl(t.getChildren()));
            }
            _handleChange(t, e) {
              t.nodesToHandle = t.howMany;
              for (const n of e) {
                const i = t.offset + t.howMany,
                  o = n.offset + n.howMany;
                if (
                  "insert" == t.type &&
                  ("insert" == n.type &&
                    (t.offset <= n.offset
                      ? (n.offset += t.howMany)
                      : t.offset < o &&
                        ((n.howMany += t.nodesToHandle),
                        (t.nodesToHandle = 0))),
                  "remove" == n.type &&
                    t.offset < n.offset &&
                    (n.offset += t.howMany),
                  "attribute" == n.type)
                )
                  if (t.offset <= n.offset) n.offset += t.howMany;
                  else if (t.offset < o) {
                    const o = n.howMany;
                    (n.howMany = t.offset - n.offset),
                      e.unshift({
                        type: "attribute",
                        offset: i,
                        howMany: o - n.howMany,
                        count: this._changeCount++,
                      });
                  }
                if ("remove" == t.type) {
                  if ("insert" == n.type)
                    if (i <= n.offset) n.offset -= t.howMany;
                    else if (i <= o)
                      if (t.offset < n.offset) {
                        const e = i - n.offset;
                        (n.offset = t.offset),
                          (n.howMany -= e),
                          (t.nodesToHandle -= e);
                      } else
                        (n.howMany -= t.nodesToHandle), (t.nodesToHandle = 0);
                    else if (t.offset <= n.offset)
                      (t.nodesToHandle -= n.howMany), (n.howMany = 0);
                    else if (t.offset < o) {
                      const e = o - t.offset;
                      (n.howMany -= e), (t.nodesToHandle -= e);
                    }
                  if (
                    ("remove" == n.type &&
                      (i <= n.offset
                        ? (n.offset -= t.howMany)
                        : t.offset < n.offset &&
                          ((t.nodesToHandle += n.howMany), (n.howMany = 0))),
                    "attribute" == n.type)
                  )
                    if (i <= n.offset) n.offset -= t.howMany;
                    else if (t.offset < n.offset) {
                      const e = i - n.offset;
                      (n.offset = t.offset), (n.howMany -= e);
                    } else if (t.offset < o)
                      if (i <= o) {
                        const i = n.howMany;
                        n.howMany = t.offset - n.offset;
                        const o = i - n.howMany - t.nodesToHandle;
                        e.unshift({
                          type: "attribute",
                          offset: t.offset,
                          howMany: o,
                          count: this._changeCount++,
                        });
                      } else n.howMany -= o - t.offset;
                }
                if ("attribute" == t.type) {
                  if ("insert" == n.type)
                    if (t.offset < n.offset && i > n.offset) {
                      if (i > o) {
                        const t = {
                          type: "attribute",
                          offset: o,
                          howMany: i - o,
                          count: this._changeCount++,
                        };
                        this._handleChange(t, e), e.push(t);
                      }
                      (t.nodesToHandle = n.offset - t.offset),
                        (t.howMany = t.nodesToHandle);
                    } else
                      t.offset >= n.offset &&
                        t.offset < o &&
                        (i > o
                          ? ((t.nodesToHandle = i - o), (t.offset = o))
                          : (t.nodesToHandle = 0));
                  if (
                    "remove" == n.type &&
                    t.offset < n.offset &&
                    i > n.offset
                  ) {
                    const o = {
                      type: "attribute",
                      offset: n.offset,
                      howMany: i - n.offset,
                      count: this._changeCount++,
                    };
                    this._handleChange(o, e),
                      e.push(o),
                      (t.nodesToHandle = n.offset - t.offset),
                      (t.howMany = t.nodesToHandle);
                  }
                  "attribute" == n.type &&
                    (t.offset >= n.offset && i <= o
                      ? ((t.nodesToHandle = 0), (t.howMany = 0), (t.offset = 0))
                      : t.offset <= n.offset && i >= o && (n.howMany = 0));
                }
              }
              (t.howMany = t.nodesToHandle), delete t.nodesToHandle;
            }
            _getInsertDiff(t, e, n) {
              return {
                type: "insert",
                position: Ga._createAt(t, e),
                name: n.name,
                attributes: new Map(n.attributes),
                length: 1,
                changeCount: this._changeCount++,
              };
            }
            _getRemoveDiff(t, e, n) {
              return {
                type: "remove",
                position: Ga._createAt(t, e),
                name: n.name,
                attributes: new Map(n.attributes),
                length: 1,
                changeCount: this._changeCount++,
              };
            }
            _getAttributesDiff(t, e, n) {
              const i = [];
              n = new Map(n);
              for (const [o, r] of e) {
                const e = n.has(o) ? n.get(o) : null;
                e !== r &&
                  i.push({
                    type: "attribute",
                    position: t.start,
                    range: t.clone(),
                    length: 1,
                    attributeKey: o,
                    attributeOldValue: r,
                    attributeNewValue: e,
                    changeCount: this._changeCount++,
                  }),
                  n.delete(o);
              }
              for (const [e, o] of n)
                i.push({
                  type: "attribute",
                  position: t.start,
                  range: t.clone(),
                  length: 1,
                  attributeKey: e,
                  attributeOldValue: null,
                  attributeNewValue: o,
                  changeCount: this._changeCount++,
                });
              return i;
            }
            _isInInsertedElement(t) {
              const e = t.parent;
              if (!e) return !1;
              const n = this._changesInElement.get(e),
                i = t.startOffset;
              if (n)
                for (const t of n)
                  if (
                    "insert" == t.type &&
                    i >= t.offset &&
                    i < t.offset + t.howMany
                  )
                    return !0;
              return this._isInInsertedElement(e);
            }
            _removeAllNestedChanges(t, e, n) {
              const i = new Qa(Ga._createAt(t, e), Ga._createAt(t, e + n));
              for (const t of i.getItems({ shallow: !0 }))
                t.is("element") &&
                  (this._elementSnapshots.delete(t),
                  this._changesInElement.delete(t),
                  this._removeAllNestedChanges(t, 0, t.maxOffset));
            }
          }
          function Fl(t) {
            const e = [];
            for (const n of t)
              if (n.is("$text"))
                for (let t = 0; t < n.data.length; t++)
                  e.push({
                    name: "$text",
                    attributes: new Map(n.getAttributes()),
                  });
              else
                e.push({
                  name: n.name,
                  attributes: new Map(n.getAttributes()),
                });
            return e;
          }
          function Vl(t, e) {
            const n = [];
            let i = 0,
              o = 0;
            for (const t of e) {
              if (t.offset > i) {
                for (let e = 0; e < t.offset - i; e++) n.push("e");
                o += t.offset - i;
              }
              if ("insert" == t.type) {
                for (let e = 0; e < t.howMany; e++) n.push("i");
                i = t.offset + t.howMany;
              } else if ("remove" == t.type) {
                for (let e = 0; e < t.howMany; e++) n.push("r");
                (i = t.offset), (o += t.howMany);
              } else
                n.push(..."a".repeat(t.howMany).split("")),
                  (i = t.offset + t.howMany),
                  (o += t.howMany);
            }
            if (o < t) for (let e = 0; e < t - o - i; e++) n.push("e");
            return n;
          }
          function Hl(t) {
            const e = t.position && "$graveyard" == t.position.root.rootName,
              n = t.range && "$graveyard" == t.range.root.rootName;
            return !e && !n;
          }
          class Ul {
            constructor() {
              (this._operations = []),
                (this._undoPairs = new Map()),
                (this._undoneOperations = new Set()),
                (this._baseVersionToOperationIndex = new Map()),
                (this._version = 0),
                (this._gaps = new Map());
            }
            get version() {
              return this._version;
            }
            set version(t) {
              this._operations.length &&
                t > this._version + 1 &&
                this._gaps.set(this._version, t),
                (this._version = t);
            }
            get lastOperation() {
              return this._operations[this._operations.length - 1];
            }
            addOperation(t) {
              if (t.baseVersion !== this.version)
                throw new c(
                  "model-document-history-addoperation-incorrect-version",
                  this,
                  { operation: t, historyVersion: this.version }
                );
              this._operations.push(t),
                this._version++,
                this._baseVersionToOperationIndex.set(
                  t.baseVersion,
                  this._operations.length - 1
                );
            }
            getOperations(t, e = this.version) {
              if (!this._operations.length) return [];
              const n = this._operations[0];
              void 0 === t && (t = n.baseVersion);
              let i = e - 1;
              for (const [e, n] of this._gaps)
                t > e && t < n && (t = n), i > e && i < n && (i = e - 1);
              if (i < n.baseVersion || t > this.lastOperation.baseVersion)
                return [];
              let o = this._baseVersionToOperationIndex.get(t);
              void 0 === o && (o = 0);
              let r = this._baseVersionToOperationIndex.get(i);
              return (
                void 0 === r && (r = this._operations.length - 1),
                this._operations.slice(o, r + 1)
              );
            }
            getOperation(t) {
              const e = this._baseVersionToOperationIndex.get(t);
              if (void 0 !== e) return this._operations[e];
            }
            setOperationAsUndone(t, e) {
              this._undoPairs.set(e, t), this._undoneOperations.add(t);
            }
            isUndoingOperation(t) {
              return this._undoPairs.has(t);
            }
            isUndoneOperation(t) {
              return this._undoneOperations.has(t);
            }
            getUndoneOperation(t) {
              return this._undoPairs.get(t);
            }
            reset() {
              (this._version = 0),
                (this._undoPairs = new Map()),
                (this._operations = []),
                (this._undoneOperations = new Set()),
                (this._gaps = new Map()),
                (this._baseVersionToOperationIndex = new Map());
            }
          }
          function $l(t, e) {
            return (
              !!(n = t.charAt(e - 1)) &&
              1 == n.length &&
              /[\ud800-\udbff]/.test(n) &&
              (function (t) {
                return !!t && 1 == t.length && /[\udc00-\udfff]/.test(t);
              })(t.charAt(e))
            );
            var n;
          }
          function ql(t, e) {
            return (
              !!(n = t.charAt(e)) &&
              1 == n.length &&
              /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(
                n
              )
            );
            var n;
          }
          const Gl = (function () {
            const t = /\p{Regional_Indicator}{2}/u.source,
              e =
                "(?:" +
                [
                  /\p{Emoji}[\u{E0020}-\u{E007E}]+\u{E007F}/u,
                  /\p{Emoji}\u{FE0F}?\u{20E3}/u,
                  /\p{Emoji}\u{FE0F}/u,
                  /(?=\p{General_Category=Other_Symbol})\p{Emoji}\p{Emoji_Modifier}*/u,
                ]
                  .map((t) => t.source)
                  .join("|") +
                ")";
            return new RegExp(`${t}|${e}(?:‍${e})*`, "ug");
          })();
          function Wl(t, e) {
            const n = String(t).matchAll(Gl);
            return Array.from(n).some(
              (t) => t.index < e && e < t.index + t[0].length
            );
          }
          const Yl = "$graveyard";
          class Kl {
            constructor(t) {
              (this.model = t),
                (this.history = new Ul()),
                (this.selection = new uc(this)),
                (this.roots = new Di({ idProperty: "rootName" })),
                (this.differ = new jl(t.markers)),
                (this._postFixers = new Set()),
                (this._hasSelectionChangedFromTheLastChangeBlock = !1),
                this.createRoot("$root", Yl),
                this.listenTo(
                  t,
                  "applyOperation",
                  (t, e) => {
                    const n = e[0];
                    n.isDocumentOperation && this.differ.bufferOperation(n);
                  },
                  { priority: "high" }
                ),
                this.listenTo(
                  t,
                  "applyOperation",
                  (t, e) => {
                    const n = e[0];
                    n.isDocumentOperation && this.history.addOperation(n);
                  },
                  { priority: "low" }
                ),
                this.listenTo(this.selection, "change", () => {
                  this._hasSelectionChangedFromTheLastChangeBlock = !0;
                }),
                this.listenTo(t.markers, "update", (t, e, n, i, o) => {
                  const r = { ...e.getData(), range: i };
                  this.differ.bufferMarkerChange(e.name, o, r),
                    null === n &&
                      e.on("change", (t, n) => {
                        const i = e.getData();
                        this.differ.bufferMarkerChange(
                          e.name,
                          { ...i, range: n },
                          i
                        );
                      });
                });
            }
            get version() {
              return this.history.version;
            }
            set version(t) {
              this.history.version = t;
            }
            get graveyard() {
              return this.getRoot(Yl);
            }
            createRoot(t = "$root", e = "main") {
              if (this.roots.get(e))
                throw new c("model-document-createroot-name-exists", this, {
                  name: e,
                });
              const n = new Bl(this, t, e);
              return this.roots.add(n), n;
            }
            destroy() {
              this.selection.destroy(), this.stopListening();
            }
            getRoot(t = "main") {
              return this.roots.get(t);
            }
            getRootNames() {
              return Array.from(this.roots, (t) => t.rootName).filter(
                (t) => t != Yl
              );
            }
            registerPostFixer(t) {
              this._postFixers.add(t);
            }
            toJSON() {
              const t = Ri(this);
              return (
                (t.selection = "[engine.model.DocumentSelection]"),
                (t.model = "[engine.model.Model]"),
                t
              );
            }
            _handleChangeBlock(t) {
              this._hasDocumentChangedFromTheLastChangeBlock() &&
                (this._callPostFixers(t),
                this.selection.refresh(),
                this.differ.hasDataChanges()
                  ? this.fire("change:data", t.batch)
                  : this.fire("change", t.batch),
                this.selection.refresh(),
                this.differ.reset()),
                (this._hasSelectionChangedFromTheLastChangeBlock = !1);
            }
            _hasDocumentChangedFromTheLastChangeBlock() {
              return (
                !this.differ.isEmpty ||
                this._hasSelectionChangedFromTheLastChangeBlock
              );
            }
            _getDefaultRoot() {
              for (const t of this.roots) if (t !== this.graveyard) return t;
              return this.graveyard;
            }
            _getDefaultRange() {
              const t = this._getDefaultRoot(),
                e = this.model,
                n = e.schema,
                i = e.createPositionFromPath(t, [0]);
              return n.getNearestSelectionRange(i) || e.createRange(i);
            }
            _validateSelectionRange(t) {
              return Ql(t.start) && Ql(t.end);
            }
            _callPostFixers(t) {
              let e = !1;
              do {
                for (const n of this._postFixers)
                  if ((this.selection.refresh(), (e = n(t)), e)) break;
              } while (e);
            }
          }
          function Ql(t) {
            const e = t.textNode;
            if (e) {
              const n = e.data,
                i = t.offset - e.startOffset;
              return !$l(n, i) && !ql(n, i);
            }
            return !0;
          }
          he(Kl, k);
          class Zl {
            constructor() {
              this._markers = new Map();
            }
            [Symbol.iterator]() {
              return this._markers.values();
            }
            has(t) {
              const e = t instanceof Jl ? t.name : t;
              return this._markers.has(e);
            }
            get(t) {
              return this._markers.get(t) || null;
            }
            _set(t, e, n = !1, i = !1) {
              const o = t instanceof Jl ? t.name : t;
              if (o.includes(","))
                throw new c("markercollection-incorrect-marker-name", this);
              const r = this._markers.get(o);
              if (r) {
                const t = r.getData(),
                  s = r.getRange();
                let a = !1;
                return (
                  s.isEqual(e) ||
                    (r._attachLiveRange(cc.fromRange(e)), (a = !0)),
                  n != r.managedUsingOperations &&
                    ((r._managedUsingOperations = n), (a = !0)),
                  "boolean" == typeof i &&
                    i != r.affectsData &&
                    ((r._affectsData = i), (a = !0)),
                  a && this.fire("update:" + o, r, s, e, t),
                  r
                );
              }
              const s = cc.fromRange(e),
                a = new Jl(o, s, n, i);
              return (
                this._markers.set(o, a),
                this.fire("update:" + o, a, null, e, {
                  ...a.getData(),
                  range: null,
                }),
                a
              );
            }
            _remove(t) {
              const e = t instanceof Jl ? t.name : t,
                n = this._markers.get(e);
              return (
                !!n &&
                (this._markers.delete(e),
                this.fire("update:" + e, n, n.getRange(), null, n.getData()),
                this._destroyMarker(n),
                !0)
              );
            }
            _refresh(t) {
              const e = t instanceof Jl ? t.name : t,
                n = this._markers.get(e);
              if (!n)
                throw new c("markercollection-refresh-marker-not-exists", this);
              const i = n.getRange();
              this.fire("update:" + e, n, i, i, n.getData());
            }
            *getMarkersAtPosition(t) {
              for (const e of this)
                e.getRange().containsPosition(t) && (yield e);
            }
            *getMarkersIntersectingRange(t) {
              for (const e of this)
                null !== e.getRange().getIntersection(t) && (yield e);
            }
            destroy() {
              for (const t of this._markers.values()) this._destroyMarker(t);
              (this._markers = null), this.stopListening();
            }
            *getMarkersGroup(t) {
              for (const e of this._markers.values())
                e.name.startsWith(t + ":") && (yield e);
            }
            _destroyMarker(t) {
              t.stopListening(), t._detachLiveRange();
            }
          }
          he(Zl, k);
          class Jl {
            constructor(t, e, n, i) {
              (this.name = t),
                (this._liveRange = this._attachLiveRange(e)),
                (this._managedUsingOperations = n),
                (this._affectsData = i);
            }
            get managedUsingOperations() {
              if (!this._liveRange) throw new c("marker-destroyed", this);
              return this._managedUsingOperations;
            }
            get affectsData() {
              if (!this._liveRange) throw new c("marker-destroyed", this);
              return this._affectsData;
            }
            getData() {
              return {
                range: this.getRange(),
                affectsData: this.affectsData,
                managedUsingOperations: this.managedUsingOperations,
              };
            }
            getStart() {
              if (!this._liveRange) throw new c("marker-destroyed", this);
              return this._liveRange.start.clone();
            }
            getEnd() {
              if (!this._liveRange) throw new c("marker-destroyed", this);
              return this._liveRange.end.clone();
            }
            getRange() {
              if (!this._liveRange) throw new c("marker-destroyed", this);
              return this._liveRange.toRange();
            }
            is(t) {
              return "marker" === t || "model:marker" === t;
            }
            _attachLiveRange(t) {
              return (
                this._liveRange && this._detachLiveRange(),
                t.delegate("change:range").to(this),
                t.delegate("change:content").to(this),
                (this._liveRange = t),
                t
              );
            }
            _detachLiveRange() {
              this._liveRange.stopDelegating("change:range", this),
                this._liveRange.stopDelegating("change:content", this),
                this._liveRange.detach(),
                (this._liveRange = null);
            }
          }
          he(Jl, k);
          class Xl extends ml {
            get type() {
              return "noop";
            }
            clone() {
              return new Xl(this.baseVersion);
            }
            getReversed() {
              return new Xl(this.baseVersion + 1);
            }
            _execute() {}
            static get className() {
              return "NoOperation";
            }
          }
          const td = {};
          (td[vl.className] = vl),
            (td[El.className] = El),
            (td[Dl.className] = Dl),
            (td[xl.className] = xl),
            (td[Xl.className] = Xl),
            (td[ml.className] = ml),
            (td[Sl.className] = Sl),
            (td[Il.className] = Il),
            (td[Ml.className] = Ml),
            (td[Tl.className] = Tl);
          class ed extends Ga {
            constructor(t, e, n = "toNone") {
              if ((super(t, e, n), !this.root.is("rootElement")))
                throw new c("model-liveposition-root-not-rootelement", t);
              nd.call(this);
            }
            detach() {
              this.stopListening();
            }
            is(t) {
              return (
                "livePosition" === t ||
                "model:livePosition" === t ||
                "position" == t ||
                "model:position" === t
              );
            }
            toPosition() {
              return new Ga(this.root, this.path.slice(), this.stickiness);
            }
            static fromPosition(t, e) {
              return new this(t.root, t.path.slice(), e || t.stickiness);
            }
          }
          function nd() {
            this.listenTo(
              this.root.document.model,
              "applyOperation",
              (t, e) => {
                const n = e[0];
                n.isDocumentOperation && id.call(this, n);
              },
              { priority: "low" }
            );
          }
          function id(t) {
            const e = this.getTransformedByOperation(t);
            if (!this.isEqual(e)) {
              const t = this.toPosition();
              (this.path = e.path),
                (this.root = e.root),
                this.fire("change", t);
            }
          }
          he(ed, k);
          class od {
            constructor(t, e, n) {
              (this.model = t),
                (this.writer = e),
                (this.position = n),
                (this.canMergeWith = new Set([this.position.parent])),
                (this.schema = t.schema),
                (this._documentFragment = e.createDocumentFragment()),
                (this._documentFragmentPosition = e.createPositionAt(
                  this._documentFragment,
                  0
                )),
                (this._firstNode = null),
                (this._lastNode = null),
                (this._lastAutoParagraph = null),
                (this._filterAttributesOf = []),
                (this._affectedStart = null),
                (this._affectedEnd = null);
            }
            handleNodes(t) {
              for (const e of Array.from(t)) this._handleNode(e);
              this._insertPartialFragment(),
                this._lastAutoParagraph &&
                  this._updateLastNodeFromAutoParagraph(
                    this._lastAutoParagraph
                  ),
                this._mergeOnRight(),
                this.schema.removeDisallowedAttributes(
                  this._filterAttributesOf,
                  this.writer
                ),
                (this._filterAttributesOf = []);
            }
            _updateLastNodeFromAutoParagraph(t) {
              const e = this.writer.createPositionAfter(this._lastNode),
                n = this.writer.createPositionAfter(t);
              if (n.isAfter(e)) {
                if (
                  ((this._lastNode = t),
                  this.position.parent != t || !this.position.isAtEnd)
                )
                  throw new c("insertcontent-invalid-insertion-position", this);
                (this.position = n), this._setAffectedBoundaries(this.position);
              }
            }
            getSelectionRange() {
              return this.nodeToSelect
                ? Qa._createOn(this.nodeToSelect)
                : this.model.schema.getNearestSelectionRange(this.position);
            }
            getAffectedRange() {
              return this._affectedStart
                ? new Qa(this._affectedStart, this._affectedEnd)
                : null;
            }
            destroy() {
              this._affectedStart && this._affectedStart.detach(),
                this._affectedEnd && this._affectedEnd.detach();
            }
            _handleNode(t) {
              if (this.schema.isObject(t)) return void this._handleObject(t);
              let e = this._checkAndAutoParagraphToAllowedPosition(t);
              e || ((e = this._checkAndSplitToAllowedPosition(t)), e)
                ? (this._appendToFragment(t),
                  this._firstNode || (this._firstNode = t),
                  (this._lastNode = t))
                : this._handleDisallowedNode(t);
            }
            _insertPartialFragment() {
              if (this._documentFragment.isEmpty) return;
              const t = ed.fromPosition(this.position, "toNext");
              this._setAffectedBoundaries(this.position),
                this._documentFragment.getChild(0) == this._firstNode &&
                  (this.writer.insert(this._firstNode, this.position),
                  this._mergeOnLeft(),
                  (this.position = t.toPosition())),
                this._documentFragment.isEmpty ||
                  this.writer.insert(this._documentFragment, this.position),
                (this._documentFragmentPosition = this.writer.createPositionAt(
                  this._documentFragment,
                  0
                )),
                (this.position = t.toPosition()),
                t.detach();
            }
            _handleObject(t) {
              this._checkAndSplitToAllowedPosition(t)
                ? this._appendToFragment(t)
                : this._tryAutoparagraphing(t);
            }
            _handleDisallowedNode(t) {
              t.is("element")
                ? this.handleNodes(t.getChildren())
                : this._tryAutoparagraphing(t);
            }
            _appendToFragment(t) {
              if (!this.schema.checkChild(this.position, t))
                throw new c("insertcontent-wrong-position", this, {
                  node: t,
                  position: this.position,
                });
              this.writer.insert(t, this._documentFragmentPosition),
                (this._documentFragmentPosition =
                  this._documentFragmentPosition.getShiftedBy(t.offsetSize)),
                this.schema.isObject(t) &&
                !this.schema.checkChild(this.position, "$text")
                  ? (this.nodeToSelect = t)
                  : (this.nodeToSelect = null),
                this._filterAttributesOf.push(t);
            }
            _setAffectedBoundaries(t) {
              this._affectedStart ||
                (this._affectedStart = ed.fromPosition(t, "toPrevious")),
                (this._affectedEnd && !this._affectedEnd.isBefore(t)) ||
                  (this._affectedEnd && this._affectedEnd.detach(),
                  (this._affectedEnd = ed.fromPosition(t, "toNext")));
            }
            _mergeOnLeft() {
              const t = this._firstNode;
              if (!(t instanceof Ua)) return;
              if (!this._canMergeLeft(t)) return;
              const e = ed._createBefore(t);
              e.stickiness = "toNext";
              const n = ed.fromPosition(this.position, "toNext");
              this._affectedStart.isEqual(e) &&
                (this._affectedStart.detach(),
                (this._affectedStart = ed._createAt(
                  e.nodeBefore,
                  "end",
                  "toPrevious"
                ))),
                this._firstNode === this._lastNode &&
                  ((this._firstNode = e.nodeBefore),
                  (this._lastNode = e.nodeBefore)),
                this.writer.merge(e),
                e.isEqual(this._affectedEnd) &&
                  this._firstNode === this._lastNode &&
                  (this._affectedEnd.detach(),
                  (this._affectedEnd = ed._createAt(
                    e.nodeBefore,
                    "end",
                    "toNext"
                  ))),
                (this.position = n.toPosition()),
                n.detach(),
                this._filterAttributesOf.push(this.position.parent),
                e.detach();
            }
            _mergeOnRight() {
              const t = this._lastNode;
              if (!(t instanceof Ua)) return;
              if (!this._canMergeRight(t)) return;
              const e = ed._createAfter(t);
              if (((e.stickiness = "toNext"), !this.position.isEqual(e)))
                throw new c("insertcontent-invalid-insertion-position", this);
              this.position = Ga._createAt(e.nodeBefore, "end");
              const n = ed.fromPosition(this.position, "toPrevious");
              this._affectedEnd.isEqual(e) &&
                (this._affectedEnd.detach(),
                (this._affectedEnd = ed._createAt(
                  e.nodeBefore,
                  "end",
                  "toNext"
                ))),
                this._firstNode === this._lastNode &&
                  ((this._firstNode = e.nodeBefore),
                  (this._lastNode = e.nodeBefore)),
                this.writer.merge(e),
                e.getShiftedBy(-1).isEqual(this._affectedStart) &&
                  this._firstNode === this._lastNode &&
                  (this._affectedStart.detach(),
                  (this._affectedStart = ed._createAt(
                    e.nodeBefore,
                    0,
                    "toPrevious"
                  ))),
                (this.position = n.toPosition()),
                n.detach(),
                this._filterAttributesOf.push(this.position.parent),
                e.detach();
            }
            _canMergeLeft(t) {
              const e = t.previousSibling;
              return (
                e instanceof Ua &&
                this.canMergeWith.has(e) &&
                this.model.schema.checkMerge(e, t)
              );
            }
            _canMergeRight(t) {
              const e = t.nextSibling;
              return (
                e instanceof Ua &&
                this.canMergeWith.has(e) &&
                this.model.schema.checkMerge(t, e)
              );
            }
            _tryAutoparagraphing(t) {
              const e = this.writer.createElement("paragraph");
              this._getAllowedIn(this.position.parent, e) &&
                this.schema.checkChild(e, t) &&
                (e._appendChild(t), this._handleNode(e));
            }
            _checkAndAutoParagraphToAllowedPosition(t) {
              if (this.schema.checkChild(this.position.parent, t)) return !0;
              if (
                !this.schema.checkChild(this.position.parent, "paragraph") ||
                !this.schema.checkChild("paragraph", t)
              )
                return !1;
              this._insertPartialFragment();
              const e = this.writer.createElement("paragraph");
              return (
                this.writer.insert(e, this.position),
                this._setAffectedBoundaries(this.position),
                (this._lastAutoParagraph = e),
                (this.position = this.writer.createPositionAt(e, 0)),
                !0
              );
            }
            _checkAndSplitToAllowedPosition(t) {
              const e = this._getAllowedIn(this.position.parent, t);
              if (!e) return !1;
              for (
                e != this.position.parent && this._insertPartialFragment();
                e != this.position.parent;

              )
                if (this.position.isAtStart) {
                  const t = this.position.parent;
                  (this.position = this.writer.createPositionBefore(t)),
                    t.isEmpty && t.parent === e && this.writer.remove(t);
                } else if (this.position.isAtEnd)
                  this.position = this.writer.createPositionAfter(
                    this.position.parent
                  );
                else {
                  const t = this.writer.createPositionAfter(
                    this.position.parent
                  );
                  this._setAffectedBoundaries(this.position),
                    this.writer.split(this.position),
                    (this.position = t),
                    this.canMergeWith.add(this.position.nodeAfter);
                }
              return !0;
            }
            _getAllowedIn(t, e) {
              return this.schema.checkChild(t, e)
                ? t
                : this.schema.isLimit(t)
                ? null
                : this._getAllowedIn(t.parent, e);
            }
          }
          function rd(t, e, n = "auto") {
            const i = t.getSelectedElement();
            if (i && e.schema.isObject(i) && !e.schema.isInline(i))
              return ["before", "after"].includes(n)
                ? e.createRange(e.createPositionAt(i, n))
                : e.createRangeOn(i);
            const o = Na(t.getSelectedBlocks());
            if (!o) return e.createRange(t.focus);
            if (o.isEmpty) return e.createRange(e.createPositionAt(o, 0));
            const r = e.createPositionAfter(o);
            return t.focus.isTouching(r)
              ? e.createRange(r)
              : e.createRange(e.createPositionBefore(o));
          }
          function sd(t, e, n, i, o = {}) {
            if (!t.schema.isObject(e))
              throw new c("insertobject-element-not-an-object", t, {
                object: e,
              });
            let r;
            r = n
              ? n.is("selection")
                ? n
                : t.createSelection(n, i)
              : t.document.selection;
            let s = r;
            o.findOptimalPosition &&
              t.schema.isBlock(e) &&
              (s = t.createSelection(rd(r, t, o.findOptimalPosition)));
            const a = Na(r.getSelectedBlocks()),
              l = {};
            return (
              a &&
                Object.assign(
                  l,
                  t.schema.getAttributesWithProperty(a, "copyOnReplace", !0)
                ),
              t.change((n) => {
                s.isCollapsed || t.deleteContent(s, { doNotAutoparagraph: !0 });
                let i = e;
                const r = s.anchor.parent;
                !t.schema.checkChild(r, e) &&
                  t.schema.checkChild(r, "paragraph") &&
                  t.schema.checkChild("paragraph", e) &&
                  ((i = n.createElement("paragraph")), n.insert(e, i)),
                  t.schema.setAllowedAttributes(i, l, n);
                const a = t.insertContent(i, s);
                return (
                  a.isCollapsed ||
                    (o.setSelection &&
                      (function (t, e, n, i) {
                        const o = t.model;
                        if ("after" == n) {
                          let n = e.nextSibling;
                          !(n && o.schema.checkChild(n, "$text")) &&
                            o.schema.checkChild(e.parent, "paragraph") &&
                            ((n = t.createElement("paragraph")),
                            o.schema.setAllowedAttributes(n, i, t),
                            o.insertContent(n, t.createPositionAfter(e))),
                            n && t.setSelection(n, 0);
                        } else {
                          if ("on" != n)
                            throw new c(
                              "insertobject-invalid-place-parameter-value",
                              o
                            );
                          t.setSelection(e, "on");
                        }
                      })(n, e, o.setSelection, l)),
                  a
                );
              })
            );
          }
          function ad(t, e, n = {}) {
            if (e.isCollapsed) return;
            const i = e.getFirstRange();
            if ("$graveyard" == i.root.rootName) return;
            const o = t.schema;
            t.change((t) => {
              if (
                !n.doNotResetEntireContent &&
                (function (t, e) {
                  const n = t.getLimitElement(e);
                  if (!e.containsEntireContent(n)) return !1;
                  const i = e.getFirstRange();
                  if (i.start.parent == i.end.parent) return !1;
                  return t.checkChild(n, "paragraph");
                })(o, e)
              )
                return void (function (t, e) {
                  const n = t.model.schema.getLimitElement(e);
                  t.remove(t.createRangeIn(n)),
                    hd(t, t.createPositionAt(n, 0), e);
                })(t, e);
              const r = {};
              if (!n.doNotAutoparagraph) {
                const t = e.getSelectedElement();
                t &&
                  Object.assign(
                    r,
                    o.getAttributesWithProperty(t, "copyOnReplace", !0)
                  );
              }
              const [s, a] = (function (t) {
                const e = t.root.document.model,
                  n = t.start;
                let i = t.end;
                if (e.hasContent(t, { ignoreMarkers: !0 })) {
                  const n = (function (t) {
                    const e = t.parent,
                      n = e.root.document.model.schema,
                      i = e.getAncestors({ parentFirst: !0, includeSelf: !0 });
                    for (const t of i) {
                      if (n.isLimit(t)) return null;
                      if (n.isBlock(t)) return t;
                    }
                  })(i);
                  if (n && i.isTouching(e.createPositionAt(n, 0))) {
                    const n = e.createSelection(t);
                    e.modifySelection(n, { direction: "backward" });
                    const o = n.getLastPosition(),
                      r = e.createRange(o, i);
                    e.hasContent(r, { ignoreMarkers: !0 }) || (i = o);
                  }
                }
                return [
                  ed.fromPosition(n, "toPrevious"),
                  ed.fromPosition(i, "toNext"),
                ];
              })(i);
              s.isTouching(a) || t.remove(t.createRange(s, a)),
                n.leaveUnmerged ||
                  (!(function (t, e, n) {
                    const i = t.model;
                    if (!dd(t.model.schema, e, n)) return;
                    const [o, r] = (function (t, e) {
                      const n = t.getAncestors(),
                        i = e.getAncestors();
                      let o = 0;
                      for (; n[o] && n[o] == i[o]; ) o++;
                      return [n[o], i[o]];
                    })(e, n);
                    if (!o || !r) return;
                    !i.hasContent(o, { ignoreMarkers: !0 }) &&
                    i.hasContent(r, { ignoreMarkers: !0 })
                      ? ld(t, e, n, o.parent)
                      : cd(t, e, n, o.parent);
                  })(t, s, a),
                  o.removeDisallowedAttributes(s.parent.getChildren(), t)),
                ud(t, e, s),
                !n.doNotAutoparagraph &&
                  (function (t, e) {
                    const n = t.checkChild(e, "$text"),
                      i = t.checkChild(e, "paragraph");
                    return !n && i;
                  })(o, s) &&
                  hd(t, s, e, r),
                s.detach(),
                a.detach();
            });
          }
          function cd(t, e, n, i) {
            const o = e.parent,
              r = n.parent;
            if (o != i && r != i) {
              for (
                e = t.createPositionAfter(o),
                  (n = t.createPositionBefore(r)).isEqual(e) || t.insert(r, e),
                  t.merge(e);
                n.parent.isEmpty;

              ) {
                const e = n.parent;
                (n = t.createPositionBefore(e)), t.remove(e);
              }
              dd(t.model.schema, e, n) && cd(t, e, n, i);
            }
          }
          function ld(t, e, n, i) {
            const o = e.parent,
              r = n.parent;
            if (o != i && r != i) {
              for (
                e = t.createPositionAfter(o),
                  (n = t.createPositionBefore(r)).isEqual(e) || t.insert(o, n);
                e.parent.isEmpty;

              ) {
                const n = e.parent;
                (e = t.createPositionBefore(n)), t.remove(n);
              }
              (n = t.createPositionBefore(r)),
                (function (t, e) {
                  const n = e.nodeBefore,
                    i = e.nodeAfter;
                  n.name != i.name && t.rename(n, i.name);
                  t.clearAttributes(n),
                    t.setAttributes(Object.fromEntries(i.getAttributes()), n),
                    t.merge(e);
                })(t, n),
                dd(t.model.schema, e, n) && ld(t, e, n, i);
            }
          }
          function dd(t, e, n) {
            const i = e.parent,
              o = n.parent;
            return (
              i != o &&
              !t.isLimit(i) &&
              !t.isLimit(o) &&
              (function (t, e, n) {
                const i = new Qa(t, e);
                for (const t of i.getWalker()) if (n.isLimit(t.item)) return !1;
                return !0;
              })(e, n, t)
            );
          }
          function hd(t, e, n, i = {}) {
            const o = t.createElement("paragraph");
            t.model.schema.setAllowedAttributes(o, i, t),
              t.insert(o, e),
              ud(t, n, t.createPositionAt(o, 0));
          }
          function ud(t, e, n) {
            e instanceof uc ? t.setSelection(n) : e.setTo(n);
          }
          const md = ' ,.?!:;"-()';
          function gd(t, e) {
            const {
                isForward: n,
                walker: i,
                unit: o,
                schema: r,
                treatEmojiAsSingleUnit: s,
              } = t,
              { type: a, item: c, nextPosition: l } = e;
            if ("text" == a)
              return "word" === t.unit
                ? (function (t, e) {
                    let n = t.position.textNode;
                    if (n) {
                      let i = t.position.offset - n.startOffset;
                      for (; !fd(n.data, i, e) && !kd(n, i, e); ) {
                        t.next();
                        const o = e
                          ? t.position.nodeAfter
                          : t.position.nodeBefore;
                        if (o && o.is("$text")) {
                          const i = o.data.charAt(e ? 0 : o.data.length - 1);
                          md.includes(i) ||
                            (t.next(), (n = t.position.textNode));
                        }
                        i = t.position.offset - n.startOffset;
                      }
                    }
                    return t.position;
                  })(i, n)
                : (function (t, e, n) {
                    const i = t.position.textNode;
                    if (i) {
                      const o = i.data;
                      let r = t.position.offset - i.startOffset;
                      for (
                        ;
                        $l(o, r) ||
                        ("character" == e && ql(o, r)) ||
                        (n && Wl(o, r));

                      )
                        t.next(), (r = t.position.offset - i.startOffset);
                    }
                    return t.position;
                  })(i, o, s);
            if (a == (n ? "elementStart" : "elementEnd")) {
              if (r.isSelectable(c))
                return Ga._createAt(c, n ? "after" : "before");
              if (r.checkChild(l, "$text")) return l;
            } else {
              if (r.isLimit(c)) return void i.skip(() => !0);
              if (r.checkChild(l, "$text")) return l;
            }
          }
          function pd(t, e) {
            const n = t.root,
              i = Ga._createAt(n, e ? "end" : 0);
            return e ? new Qa(t, i) : new Qa(i, t);
          }
          function fd(t, e, n) {
            const i = e + (n ? 0 : -1);
            return md.includes(t.charAt(i));
          }
          function kd(t, e, n) {
            return e === (n ? t.endOffset : 0);
          }
          function bd(t, e) {
            const n = [];
            Array.from(t.getItems({ direction: "backward" }))
              .map((t) => e.createRangeOn(t))
              .filter(
                (e) =>
                  (e.start.isAfter(t.start) || e.start.isEqual(t.start)) &&
                  (e.end.isBefore(t.end) || e.end.isEqual(t.end))
              )
              .forEach((t) => {
                n.push(t.start.parent), e.remove(t);
              }),
              n.forEach((t) => {
                let n = t;
                for (; n.parent && n.isEmpty; ) {
                  const t = e.createRangeOn(n);
                  (n = n.parent), e.remove(t);
                }
              });
          }
          function wd(t) {
            t.document.registerPostFixer((e) =>
              (function (t, e) {
                const n = e.document.selection,
                  i = e.schema,
                  o = [];
                let r = !1;
                for (const t of n.getRanges()) {
                  const e = Ad(t, i);
                  e && !e.isEqual(t) ? (o.push(e), (r = !0)) : o.push(t);
                }
                r &&
                  t.setSelection(
                    (function (t) {
                      const e = [...t],
                        n = new Set();
                      let i = 1;
                      for (; i < e.length; ) {
                        const t = e[i],
                          o = e.slice(0, i);
                        for (const [r, s] of o.entries())
                          if (!n.has(r))
                            if (t.isEqual(s)) n.add(r);
                            else if (t.isIntersecting(s)) {
                              n.add(r), n.add(i);
                              const o = t.getJoined(s);
                              e.push(o);
                            }
                        i++;
                      }
                      return e.filter((t, e) => !n.has(e));
                    })(o),
                    { backward: n.isBackward }
                  );
              })(e, t)
            );
          }
          function Ad(t, e) {
            return t.isCollapsed
              ? (function (t, e) {
                  const n = t.start,
                    i = e.getNearestSelectionRange(n);
                  if (!i) {
                    const t = n
                      .getAncestors()
                      .reverse()
                      .find((t) => e.isObject(t));
                    return t ? Qa._createOn(t) : null;
                  }
                  if (!i.isCollapsed) return i;
                  const o = i.start;
                  if (n.isEqual(o)) return null;
                  return new Qa(o);
                })(t, e)
              : (function (t, e) {
                  const { start: n, end: i } = t,
                    o = e.checkChild(n, "$text"),
                    r = e.checkChild(i, "$text"),
                    s = e.getLimitElement(n),
                    a = e.getLimitElement(i);
                  if (s === a) {
                    if (o && r) return null;
                    if (
                      (function (t, e, n) {
                        const i =
                            (t.nodeAfter && !n.isLimit(t.nodeAfter)) ||
                            n.checkChild(t, "$text"),
                          o =
                            (e.nodeBefore && !n.isLimit(e.nodeBefore)) ||
                            n.checkChild(e, "$text");
                        return i || o;
                      })(n, i, e)
                    ) {
                      const t =
                          n.nodeAfter && e.isSelectable(n.nodeAfter)
                            ? null
                            : e.getNearestSelectionRange(n, "forward"),
                        o =
                          i.nodeBefore && e.isSelectable(i.nodeBefore)
                            ? null
                            : e.getNearestSelectionRange(i, "backward"),
                        r = t ? t.start : n,
                        s = o ? o.end : i;
                      return new Qa(r, s);
                    }
                  }
                  const c = s && !s.is("rootElement"),
                    l = a && !a.is("rootElement");
                  if (c || l) {
                    const t =
                        n.nodeAfter &&
                        i.nodeBefore &&
                        n.nodeAfter.parent === i.nodeBefore.parent,
                      o = c && (!t || !Cd(n.nodeAfter, e)),
                      r = l && (!t || !Cd(i.nodeBefore, e));
                    let d = n,
                      h = i;
                    return (
                      o && (d = Ga._createBefore(_d(s, e))),
                      r && (h = Ga._createAfter(_d(a, e))),
                      new Qa(d, h)
                    );
                  }
                  return null;
                })(t, e);
          }
          function _d(t, e) {
            let n = t,
              i = n;
            for (; e.isLimit(i) && i.parent; ) (n = i), (i = i.parent);
            return n;
          }
          function Cd(t, e) {
            return t && e.isSelectable(t);
          }
          class vd {
            constructor() {
              (this.markers = new Zl()),
                (this.document = new Kl(this)),
                (this.schema = new $c()),
                (this._pendingChanges = []),
                (this._currentWriter = null),
                [
                  "insertContent",
                  "insertObject",
                  "deleteContent",
                  "modifySelection",
                  "getSelectedContent",
                  "applyOperation",
                ].forEach((t) => this.decorate(t)),
                this.on(
                  "applyOperation",
                  (t, e) => {
                    e[0]._validate();
                  },
                  { priority: "highest" }
                ),
                this.schema.register("$root", { isLimit: !0 }),
                this.schema.register("$container", {
                  allowIn: ["$root", "$container"],
                }),
                this.schema.register("$block", {
                  allowIn: ["$root", "$container"],
                  isBlock: !0,
                }),
                this.schema.register("$blockObject", {
                  allowWhere: "$block",
                  isBlock: !0,
                  isObject: !0,
                }),
                this.schema.register("$inlineObject", {
                  allowWhere: "$text",
                  allowAttributesOf: "$text",
                  isInline: !0,
                  isObject: !0,
                }),
                this.schema.register("$text", {
                  allowIn: "$block",
                  isInline: !0,
                  isContent: !0,
                }),
                this.schema.register("$clipboardHolder", {
                  allowContentOf: "$root",
                  allowChildren: "$text",
                  isLimit: !0,
                }),
                this.schema.register("$documentFragment", {
                  allowContentOf: "$root",
                  allowChildren: "$text",
                  isLimit: !0,
                }),
                this.schema.register("$marker"),
                this.schema.addChildCheck((t, e) => {
                  if ("$marker" === e.name) return !0;
                }),
                wd(this),
                this.document.registerPostFixer(Tc);
            }
            change(t) {
              try {
                return 0 === this._pendingChanges.length
                  ? (this._pendingChanges.push({
                      batch: new ul(),
                      callback: t,
                    }),
                    this._runPendingChanges()[0])
                  : t(this._currentWriter);
              } catch (t) {
                c.rethrowUnexpectedError(t, this);
              }
            }
            enqueueChange(t, e) {
              try {
                t
                  ? "function" == typeof t
                    ? ((e = t), (t = new ul()))
                    : t instanceof ul || (t = new ul(t))
                  : (t = new ul()),
                  this._pendingChanges.push({ batch: t, callback: e }),
                  1 == this._pendingChanges.length && this._runPendingChanges();
              } catch (t) {
                c.rethrowUnexpectedError(t, this);
              }
            }
            applyOperation(t) {
              t._execute();
            }
            insertContent(t, e, n) {
              return (function (t, e, n, i) {
                return t.change((o) => {
                  let r;
                  (r = n
                    ? n instanceof ic || n instanceof uc
                      ? n
                      : o.createSelection(n, i)
                    : t.document.selection),
                    r.isCollapsed ||
                      t.deleteContent(r, { doNotAutoparagraph: !0 });
                  const s = new od(t, o, r.anchor);
                  let a;
                  (a = e.is("documentFragment") ? e.getChildren() : [e]),
                    s.handleNodes(a);
                  const c = s.getSelectionRange();
                  c && (r instanceof uc ? o.setSelection(c) : r.setTo(c));
                  const l = s.getAffectedRange() || t.createRange(r.anchor);
                  return s.destroy(), l;
                });
              })(this, t, e, n);
            }
            insertObject(t, e, n, i) {
              return sd(this, t, e, n, i);
            }
            deleteContent(t, e) {
              ad(this, t, e);
            }
            modifySelection(t, e) {
              !(function (t, e, n = {}) {
                const i = t.schema,
                  o = "backward" != n.direction,
                  r = n.unit ? n.unit : "character",
                  s = !!n.treatEmojiAsSingleUnit,
                  a = e.focus,
                  c = new $a({
                    boundaries: pd(a, o),
                    singleCharacters: !0,
                    direction: o ? "forward" : "backward",
                  }),
                  l = {
                    walker: c,
                    schema: i,
                    isForward: o,
                    unit: r,
                    treatEmojiAsSingleUnit: s,
                  };
                let d;
                for (; (d = c.next()); ) {
                  if (d.done) return;
                  const n = gd(l, d.value);
                  if (n)
                    return void (e instanceof uc
                      ? t.change((t) => {
                          t.setSelectionFocus(n);
                        })
                      : e.setFocus(n));
                }
              })(this, t, e);
            }
            getSelectedContent(t) {
              return (function (t, e) {
                return t.change((t) => {
                  const n = t.createDocumentFragment(),
                    i = e.getFirstRange();
                  if (!i || i.isCollapsed) return n;
                  const o = i.start.root,
                    r = i.start.getCommonPath(i.end),
                    s = o.getNodeByPath(r);
                  let a;
                  a =
                    i.start.parent == i.end.parent
                      ? i
                      : t.createRange(
                          t.createPositionAt(s, i.start.path[r.length]),
                          t.createPositionAt(s, i.end.path[r.length] + 1)
                        );
                  const c = a.end.offset - a.start.offset;
                  for (const e of a.getItems({ shallow: !0 }))
                    e.is("$textProxy")
                      ? t.appendText(e.data, e.getAttributes(), n)
                      : t.append(t.cloneElement(e, !0), n);
                  if (a != i) {
                    const e = i._getTransformedByMove(
                        a.start,
                        t.createPositionAt(n, 0),
                        c
                      )[0],
                      o = t.createRange(t.createPositionAt(n, 0), e.start);
                    bd(t.createRange(e.end, t.createPositionAt(n, "end")), t),
                      bd(o, t);
                  }
                  return n;
                });
              })(this, t);
            }
            hasContent(t, e = {}) {
              const n = t instanceof Ua ? Qa._createIn(t) : t;
              if (n.isCollapsed) return !1;
              const { ignoreWhitespaces: i = !1, ignoreMarkers: o = !1 } = e;
              if (!o)
                for (const t of this.markers.getMarkersIntersectingRange(n))
                  if (t.affectsData) return !0;
              for (const t of n.getItems())
                if (this.schema.isContent(t)) {
                  if (!t.is("$textProxy")) return !0;
                  if (!i) return !0;
                  if (-1 !== t.data.search(/\S/)) return !0;
                }
              return !1;
            }
            createPositionFromPath(t, e, n) {
              return new Ga(t, e, n);
            }
            createPositionAt(t, e) {
              return Ga._createAt(t, e);
            }
            createPositionAfter(t) {
              return Ga._createAfter(t);
            }
            createPositionBefore(t) {
              return Ga._createBefore(t);
            }
            createRange(t, e) {
              return new Qa(t, e);
            }
            createRangeIn(t) {
              return Qa._createIn(t);
            }
            createRangeOn(t) {
              return Qa._createOn(t);
            }
            createSelection(t, e, n) {
              return new ic(t, e, n);
            }
            createBatch(t) {
              return new ul(t);
            }
            createOperationFromJSON(t) {
              return class {
                static fromJSON(t, e) {
                  return td[t.__className].fromJSON(t, e);
                }
              }.fromJSON(t, this.document);
            }
            destroy() {
              this.document.destroy(), this.stopListening();
            }
            _runPendingChanges() {
              const t = [];
              for (this.fire("_beforeChanges"); this._pendingChanges.length; ) {
                const e = this._pendingChanges[0].batch;
                this._currentWriter = new Nl(this, e);
                const n = this._pendingChanges[0].callback(this._currentWriter);
                t.push(n),
                  this.document._handleChangeBlock(this._currentWriter),
                  this._pendingChanges.shift(),
                  (this._currentWriter = null);
              }
              return this.fire("_afterChanges"), t;
            }
          }
          he(vd, re);
          class yd extends Pa {
            constructor(t) {
              super(), (this.editor = t);
            }
            set(t, e, n = {}) {
              if ("string" == typeof e) {
                const t = e;
                e = (e, n) => {
                  this.editor.execute(t), n();
                };
              }
              super.set(t, e, n);
            }
          }
          class xd {
            constructor(t = {}) {
              const e =
                t.language ||
                (this.constructor.defaultConfig &&
                  this.constructor.defaultConfig.language);
              (this._context = t.context || new zi({ language: e })),
                this._context._addEditor(this, !t.context);
              const n = Array.from(this.constructor.builtinPlugins || []);
              (this.config = new vi(t, this.constructor.defaultConfig)),
                this.config.define("plugins", n),
                this.config.define(this._context._getEditorConfig()),
                (this.plugins = new Si(this, n, this._context.plugins)),
                (this.locale = this._context.locale),
                (this.t = this.locale.t),
                (this._readOnlyLocks = new Set()),
                (this.commands = new Vc()),
                this.set("state", "initializing"),
                this.once("ready", () => (this.state = "ready"), {
                  priority: "high",
                }),
                this.once("destroy", () => (this.state = "destroyed"), {
                  priority: "high",
                }),
                (this.model = new vd());
              const i = new Do();
              (this.data = new cl(this.model, i)),
                (this.editing = new Fc(this.model, i)),
                this.editing.view.document.bind("isReadOnly").to(this),
                (this.conversion = new ll(
                  [
                    this.editing.downcastDispatcher,
                    this.data.downcastDispatcher,
                  ],
                  this.data.upcastDispatcher
                )),
                this.conversion.addAlias(
                  "dataDowncast",
                  this.data.downcastDispatcher
                ),
                this.conversion.addAlias(
                  "editingDowncast",
                  this.editing.downcastDispatcher
                ),
                (this.keystrokes = new yd(this)),
                this.keystrokes.listenTo(this.editing.view.document);
            }
            get isReadOnly() {
              return this._readOnlyLocks.size > 0;
            }
            set isReadOnly(t) {
              throw new c("editor-isreadonly-has-no-setter");
            }
            enableReadOnlyMode(t) {
              if ("string" != typeof t && "symbol" != typeof t)
                throw new c("editor-read-only-lock-id-invalid", null, {
                  lockId: t,
                });
              this._readOnlyLocks.has(t) ||
                (this._readOnlyLocks.add(t),
                1 === this._readOnlyLocks.size &&
                  this.fire("change:isReadOnly", "isReadOnly", !0, !1));
            }
            disableReadOnlyMode(t) {
              if ("string" != typeof t && "symbol" != typeof t)
                throw new c("editor-read-only-lock-id-invalid", null, {
                  lockId: t,
                });
              this._readOnlyLocks.has(t) &&
                (this._readOnlyLocks.delete(t),
                0 === this._readOnlyLocks.size &&
                  this.fire("change:isReadOnly", "isReadOnly", !1, !0));
            }
            initPlugins() {
              const t = this.config,
                e = t.get("plugins"),
                n = t.get("removePlugins") || [],
                i = t.get("extraPlugins") || [],
                o = t.get("substitutePlugins") || [];
              return this.plugins.init(e.concat(i), n, o);
            }
            destroy() {
              let t = Promise.resolve();
              return (
                "initializing" == this.state &&
                  (t = new Promise((t) => this.once("ready", t))),
                t
                  .then(() => {
                    this.fire("destroy"),
                      this.stopListening(),
                      this.commands.destroy();
                  })
                  .then(() => this.plugins.destroy())
                  .then(() => {
                    this.model.destroy(),
                      this.data.destroy(),
                      this.editing.destroy(),
                      this.keystrokes.destroy();
                  })
                  .then(() => this._context._removeEditor(this))
              );
            }
            execute(...t) {
              try {
                return this.commands.execute(...t);
              } catch (t) {
                c.rethrowUnexpectedError(t, this);
              }
            }
            focus() {
              this.editing.view.focus();
            }
          }
          he(xd, re);
          class Ed {
            constructor(t) {
              (this.editor = t), (this._components = new Map());
            }
            *names() {
              for (const t of this._components.values()) yield t.originalName;
            }
            add(t, e) {
              this._components.set(Dd(t), { callback: e, originalName: t });
            }
            create(t) {
              if (!this.has(t))
                throw new c("componentfactory-item-missing", this, { name: t });
              return this._components.get(Dd(t)).callback(this.editor.locale);
            }
            has(t) {
              return this._components.has(Dd(t));
            }
          }
          function Dd(t) {
            return String(t).toLowerCase();
          }
          class Sd {
            constructor(t) {
              (this.editor = t),
                (this.componentFactory = new Ed(t)),
                (this.focusTracker = new za()),
                this.set(
                  "viewportOffset",
                  this._readViewportOffsetFromConfig()
                ),
                (this._editableElementsMap = new Map()),
                this.listenTo(t.editing.view.document, "layoutChanged", () =>
                  this.update()
                );
            }
            get element() {
              return null;
            }
            update() {
              this.fire("update");
            }
            destroy() {
              this.stopListening(), this.focusTracker.destroy();
              for (const t of this._editableElementsMap.values())
                t.ckeditorInstance = null;
              this._editableElementsMap = new Map();
            }
            setEditableElement(t, e) {
              this._editableElementsMap.set(t, e),
                e.ckeditorInstance || (e.ckeditorInstance = this.editor);
            }
            getEditableElement(t = "main") {
              return this._editableElementsMap.get(t);
            }
            getEditableElementsNames() {
              return this._editableElementsMap.keys();
            }
            get _editableElements() {
              return (
                console.warn(
                  "editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.",
                  { editorUI: this }
                ),
                this._editableElementsMap
              );
            }
            _readViewportOffsetFromConfig() {
              const t = this.editor,
                e = t.config.get("ui.viewportOffset");
              if (e) return e;
              const n = t.config.get("toolbar.viewportTopOffset");
              return n
                ? (console.warn(
                    "editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."
                  ),
                  { top: n })
                : { top: 0 };
            }
          }
          he(Sd, re);
          const Id = {
              setData(t) {
                this.data.set(t);
              },
              getData(t) {
                return this.data.get(t);
              },
            },
            Td = Id;
          const Md = {
            updateSourceElement() {
              if (!this.sourceElement)
                throw new c("editor-missing-sourceelement", this);
              var t, e;
              (t = this.sourceElement),
                (e = this.data.get()),
                t instanceof HTMLTextAreaElement && (t.value = e),
                (t.innerHTML = e);
            },
          };
          class Bd extends Pi {
            static get pluginName() {
              return "PendingActions";
            }
            init() {
              this.set("hasAny", !1),
                (this._actions = new Di({ idProperty: "_id" })),
                this._actions.delegate("add", "remove").to(this);
            }
            add(t) {
              if ("string" != typeof t)
                throw new c("pendingactions-add-invalid-message", this);
              const e = Object.create(re);
              return (
                e.set("message", t), this._actions.add(e), (this.hasAny = !0), e
              );
            }
            remove(t) {
              this._actions.remove(t), (this.hasAny = !!this._actions.length);
            }
            get first() {
              return this._actions.get(0);
            }
            [Symbol.iterator]() {
              return this._actions[Symbol.iterator]();
            }
          }
          const Nd =
              '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>',
            zd = {
              cancel:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>',
              caption:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>',
              check:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>',
              cog: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>',
              eraser:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>',
              lowVision:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>',
              image:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>',
              alignBottom:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>',
              alignMiddle:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>',
              alignTop:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>',
              alignLeft:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>',
              alignCenter:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>',
              alignRight:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>',
              alignJustify:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>',
              objectLeft:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
              objectCenter:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>',
              objectRight:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>',
              objectFullWidth:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>',
              objectInline:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
              objectBlockLeft:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>',
              objectBlockRight:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>',
              objectSizeFull:
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>',
              objectSizeLarge:
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>',
              objectSizeSmall:
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>',
              objectSizeMedium:
                '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>',
              pencil:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>',
              pilcrow:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>',
              quote:
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>',
              threeVerticalDots: Nd,
            };
          function Pd({
            emitter: t,
            activator: e,
            callback: n,
            contextElements: i,
          }) {
            t.listenTo(document, "mousedown", (t, o) => {
              if (!e()) return;
              const r =
                "function" == typeof o.composedPath ? o.composedPath() : [];
              for (const t of i)
                if (t.contains(o.target) || r.includes(t)) return;
              n();
            });
          }
          function Ld(t) {
            t.set("_isCssTransitionsDisabled", !1),
              (t.disableCssTransitions = () => {
                t._isCssTransitionsDisabled = !0;
              }),
              (t.enableCssTransitions = () => {
                t._isCssTransitionsDisabled = !1;
              }),
              t.extendTemplate({
                attributes: {
                  class: [
                    t.bindTemplate.if(
                      "_isCssTransitionsDisabled",
                      "ck-transitions-disabled"
                    ),
                  ],
                },
              });
          }
          function Rd({ view: t }) {
            t.listenTo(
              t.element,
              "submit",
              (e, n) => {
                n.preventDefault(), t.fire("submit");
              },
              { useCapture: !0 }
            );
          }
          class Od extends Di {
            constructor(t = []) {
              super(t, { idProperty: "viewUid" }),
                this.on("add", (t, e, n) => {
                  this._renderViewIntoCollectionParent(e, n);
                }),
                this.on("remove", (t, e) => {
                  e.element && this._parentElement && e.element.remove();
                }),
                (this._parentElement = null);
            }
            destroy() {
              this.map((t) => t.destroy());
            }
            setParent(t) {
              this._parentElement = t;
              for (const t of this) this._renderViewIntoCollectionParent(t);
            }
            delegate(...t) {
              if (!t.length || !t.every((t) => "string" == typeof t))
                throw new c("ui-viewcollection-delegate-wrong-events", this);
              return {
                to: (e) => {
                  for (const n of this) for (const i of t) n.delegate(i).to(e);
                  this.on("add", (n, i) => {
                    for (const n of t) i.delegate(n).to(e);
                  }),
                    this.on("remove", (n, i) => {
                      for (const n of t) i.stopDelegating(n, e);
                    });
                },
              };
            }
            _renderViewIntoCollectionParent(t, e) {
              t.isRendered || t.render(),
                t.element &&
                  this._parentElement &&
                  this._parentElement.insertBefore(
                    t.element,
                    this._parentElement.children[e]
                  );
            }
          }
          var jd = n(6150),
            Fd = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(jd.Z, Fd);
          jd.Z.locals;
          class Vd {
            constructor(t) {
              (this.element = null),
                (this.isRendered = !1),
                (this.locale = t),
                (this.t = t && t.t),
                (this._viewCollections = new Di()),
                (this._unboundChildren = this.createCollection()),
                this._viewCollections.on("add", (e, n) => {
                  n.locale = t;
                }),
                this.decorate("render");
            }
            get bindTemplate() {
              return this._bindTemplate
                ? this._bindTemplate
                : (this._bindTemplate = Hd.bind(this, this));
            }
            createCollection(t) {
              const e = new Od(t);
              return this._viewCollections.add(e), e;
            }
            registerChild(t) {
              Ei(t) || (t = [t]);
              for (const e of t) this._unboundChildren.add(e);
            }
            deregisterChild(t) {
              Ei(t) || (t = [t]);
              for (const e of t) this._unboundChildren.remove(e);
            }
            setTemplate(t) {
              this.template = new Hd(t);
            }
            extendTemplate(t) {
              Hd.extend(this.template, t);
            }
            render() {
              if (this.isRendered)
                throw new c("ui-view-render-already-rendered", this);
              this.template &&
                ((this.element = this.template.render()),
                this.registerChild(this.template.getViews())),
                (this.isRendered = !0);
            }
            destroy() {
              this.stopListening(),
                this._viewCollections.map((t) => t.destroy()),
                this.template &&
                  this.template._revertData &&
                  this.template.revert(this.element);
            }
          }
          he(Vd, bs), he(Vd, re);
          class Hd {
            constructor(t) {
              Object.assign(this, Jd(Zd(t))),
                (this._isRendered = !1),
                (this._revertData = null);
            }
            render() {
              const t = this._renderNode({ intoFragment: !0 });
              return (this._isRendered = !0), t;
            }
            apply(t) {
              return (
                (this._revertData = {
                  children: [],
                  bindings: [],
                  attributes: {},
                }),
                this._renderNode({
                  node: t,
                  isApplying: !0,
                  revertData: this._revertData,
                }),
                t
              );
            }
            revert(t) {
              if (!this._revertData)
                throw new c("ui-template-revert-not-applied", [this, t]);
              this._revertTemplateFromNode(t, this._revertData);
            }
            *getViews() {
              yield* (function* t(e) {
                if (e.children)
                  for (const n of e.children)
                    oh(n) ? yield n : rh(n) && (yield* t(n));
              })(this);
            }
            static bind(t, e) {
              return {
                to: (n, i) =>
                  new $d({
                    eventNameOrFunction: n,
                    attribute: n,
                    observable: t,
                    emitter: e,
                    callback: i,
                  }),
                if: (n, i, o) =>
                  new qd({
                    observable: t,
                    emitter: e,
                    attribute: n,
                    valueIfTrue: i,
                    callback: o,
                  }),
              };
            }
            static extend(t, e) {
              if (t._isRendered)
                throw new c("template-extend-render", [this, t]);
              nh(t, Jd(Zd(e)));
            }
            _renderNode(t) {
              let e;
              if (
                ((e = t.node
                  ? this.tag && this.text
                  : this.tag
                  ? this.text
                  : !this.text),
                e)
              )
                throw new c("ui-template-wrong-syntax", this);
              return this.text ? this._renderText(t) : this._renderElement(t);
            }
            _renderElement(t) {
              let e = t.node;
              return (
                e ||
                  (e = t.node =
                    document.createElementNS(
                      this.ns || "http://www.w3.org/1999/xhtml",
                      this.tag
                    )),
                this._renderAttributes(t),
                this._renderElementChildren(t),
                this._setUpListeners(t),
                e
              );
            }
            _renderText(t) {
              let e = t.node;
              return (
                e
                  ? (t.revertData.text = e.textContent)
                  : (e = t.node = document.createTextNode("")),
                Gd(this.text)
                  ? this._bindToObservable({
                      schema: this.text,
                      updater: Yd(e),
                      data: t,
                    })
                  : (e.textContent = this.text.join("")),
                e
              );
            }
            _renderAttributes(t) {
              let e, n, i, o;
              if (!this.attributes) return;
              const r = t.node,
                s = t.revertData;
              for (e in this.attributes)
                if (
                  ((i = r.getAttribute(e)),
                  (n = this.attributes[e]),
                  s && (s.attributes[e] = i),
                  (o = x(n[0]) && n[0].ns ? n[0].ns : null),
                  Gd(n))
                ) {
                  const a = o ? n[0].value : n;
                  s && ah(e) && a.unshift(i),
                    this._bindToObservable({
                      schema: a,
                      updater: Kd(r, e, o),
                      data: t,
                    });
                } else
                  "style" == e && "string" != typeof n[0]
                    ? this._renderStyleAttribute(n[0], t)
                    : (s && i && ah(e) && n.unshift(i),
                      (n = n
                        .map((t) => (t && t.value) || t)
                        .reduce((t, e) => t.concat(e), [])
                        .reduce(th, "")),
                      ih(n) || r.setAttributeNS(o, e, n));
            }
            _renderStyleAttribute(t, e) {
              const n = e.node;
              for (const i in t) {
                const o = t[i];
                Gd(o)
                  ? this._bindToObservable({
                      schema: [o],
                      updater: Qd(n, i),
                      data: e,
                    })
                  : (n.style[i] = o);
              }
            }
            _renderElementChildren(t) {
              const e = t.node,
                n = t.intoFragment ? document.createDocumentFragment() : e,
                i = t.isApplying;
              let o = 0;
              for (const r of this.children)
                if (sh(r)) {
                  if (!i) {
                    r.setParent(e);
                    for (const t of r) n.appendChild(t.element);
                  }
                } else if (oh(r))
                  i || (r.isRendered || r.render(), n.appendChild(r.element));
                else if (Kr(r)) n.appendChild(r);
                else if (i) {
                  const e = { children: [], bindings: [], attributes: {} };
                  t.revertData.children.push(e),
                    r._renderNode({
                      node: n.childNodes[o++],
                      isApplying: !0,
                      revertData: e,
                    });
                } else n.appendChild(r.render());
              t.intoFragment && e.appendChild(n);
            }
            _setUpListeners(t) {
              if (this.eventListeners)
                for (const e in this.eventListeners) {
                  const n = this.eventListeners[e].map((n) => {
                    const [i, o] = e.split("@");
                    return n.activateDomEventListener(i, o, t);
                  });
                  t.revertData && t.revertData.bindings.push(n);
                }
            }
            _bindToObservable({ schema: t, updater: e, data: n }) {
              const i = n.revertData;
              Wd(t, e, n);
              const o = t
                .filter((t) => !ih(t))
                .filter((t) => t.observable)
                .map((i) => i.activateAttributeListener(t, e, n));
              i && i.bindings.push(o);
            }
            _revertTemplateFromNode(t, e) {
              for (const t of e.bindings) for (const e of t) e();
              if (e.text) t.textContent = e.text;
              else {
                for (const n in e.attributes) {
                  const i = e.attributes[n];
                  null === i ? t.removeAttribute(n) : t.setAttribute(n, i);
                }
                for (let n = 0; n < e.children.length; ++n)
                  this._revertTemplateFromNode(t.childNodes[n], e.children[n]);
              }
            }
          }
          he(Hd, k);
          class Ud {
            constructor(t) {
              Object.assign(this, t);
            }
            getValue(t) {
              const e = this.observable[this.attribute];
              return this.callback ? this.callback(e, t) : e;
            }
            activateAttributeListener(t, e, n) {
              const i = () => Wd(t, e, n);
              return (
                this.emitter.listenTo(
                  this.observable,
                  "change:" + this.attribute,
                  i
                ),
                () => {
                  this.emitter.stopListening(
                    this.observable,
                    "change:" + this.attribute,
                    i
                  );
                }
              );
            }
          }
          class $d extends Ud {
            activateDomEventListener(t, e, n) {
              const i = (t, n) => {
                (e && !n.target.matches(e)) ||
                  ("function" == typeof this.eventNameOrFunction
                    ? this.eventNameOrFunction(n)
                    : this.observable.fire(this.eventNameOrFunction, n));
              };
              return (
                this.emitter.listenTo(n.node, t, i),
                () => {
                  this.emitter.stopListening(n.node, t, i);
                }
              );
            }
          }
          class qd extends Ud {
            getValue(t) {
              return !ih(super.getValue(t)) && (this.valueIfTrue || !0);
            }
          }
          function Gd(t) {
            return (
              !!t &&
              (t.value && (t = t.value),
              Array.isArray(t) ? t.some(Gd) : t instanceof Ud)
            );
          }
          function Wd(t, e, { node: n }) {
            let i = (function (t, e) {
              return t.map((t) => (t instanceof Ud ? t.getValue(e) : t));
            })(t, n);
            (i = 1 == t.length && t[0] instanceof qd ? i[0] : i.reduce(th, "")),
              ih(i) ? e.remove() : e.set(i);
          }
          function Yd(t) {
            return {
              set(e) {
                t.textContent = e;
              },
              remove() {
                t.textContent = "";
              },
            };
          }
          function Kd(t, e, n) {
            return {
              set(i) {
                t.setAttributeNS(n, e, i);
              },
              remove() {
                t.removeAttributeNS(n, e);
              },
            };
          }
          function Qd(t, e) {
            return {
              set(n) {
                t.style[e] = n;
              },
              remove() {
                t.style[e] = null;
              },
            };
          }
          function Zd(t) {
            return _i(t, (t) => {
              if (t && (t instanceof Ud || rh(t) || oh(t) || sh(t))) return t;
            });
          }
          function Jd(t) {
            if (
              ("string" == typeof t
                ? (t = (function (t) {
                    return { text: [t] };
                  })(t))
                : t.text &&
                  (function (t) {
                    t.text = Ii(t.text);
                  })(t),
              t.on &&
                ((t.eventListeners = (function (t) {
                  for (const e in t) Xd(t, e);
                  return t;
                })(t.on)),
                delete t.on),
              !t.text)
            ) {
              t.attributes &&
                (function (t) {
                  for (const e in t)
                    t[e].value && (t[e].value = Ii(t[e].value)), Xd(t, e);
                })(t.attributes);
              const e = [];
              if (t.children)
                if (sh(t.children)) e.push(t.children);
                else
                  for (const n of t.children)
                    rh(n) || oh(n) || Kr(n) ? e.push(n) : e.push(new Hd(n));
              t.children = e;
            }
            return t;
          }
          function Xd(t, e) {
            t[e] = Ii(t[e]);
          }
          function th(t, e) {
            return ih(e) ? t : ih(t) ? e : `${t} ${e}`;
          }
          function eh(t, e) {
            for (const n in e) t[n] ? t[n].push(...e[n]) : (t[n] = e[n]);
          }
          function nh(t, e) {
            if (
              (e.attributes &&
                (t.attributes || (t.attributes = {}),
                eh(t.attributes, e.attributes)),
              e.eventListeners &&
                (t.eventListeners || (t.eventListeners = {}),
                eh(t.eventListeners, e.eventListeners)),
              e.text && t.text.push(...e.text),
              e.children && e.children.length)
            ) {
              if (t.children.length != e.children.length)
                throw new c("ui-template-extend-children-mismatch", t);
              let n = 0;
              for (const i of e.children) nh(t.children[n++], i);
            }
          }
          function ih(t) {
            return !t && 0 !== t;
          }
          function oh(t) {
            return t instanceof Vd;
          }
          function rh(t) {
            return t instanceof Hd;
          }
          function sh(t) {
            return t instanceof Od;
          }
          function ah(t) {
            return "class" == t || "style" == t;
          }
          class ch extends Od {
            constructor(t, e = []) {
              super(e), (this.locale = t);
            }
            attachToDom() {
              this._bodyCollectionContainer = new Hd({
                tag: "div",
                attributes: {
                  class: [
                    "ck",
                    "ck-reset_all",
                    "ck-body",
                    "ck-rounded-corners",
                  ],
                  dir: this.locale.uiLanguageDirection,
                },
                children: this,
              }).render();
              let t = document.querySelector(".ck-body-wrapper");
              t ||
                ((t = ma(document, "div", { class: "ck-body-wrapper" })),
                document.body.appendChild(t)),
                t.appendChild(this._bodyCollectionContainer);
            }
            detachFromDom() {
              super.destroy(),
                this._bodyCollectionContainer &&
                  this._bodyCollectionContainer.remove();
              const t = document.querySelector(".ck-body-wrapper");
              t && 0 == t.childElementCount && t.remove();
            }
          }
          var lh = n(1174),
            dh = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(lh.Z, dh);
          lh.Z.locals;
          class hh extends Vd {
            constructor() {
              super();
              const t = this.bindTemplate;
              this.set("content", ""),
                this.set("viewBox", "0 0 20 20"),
                this.set("fillColor", ""),
                this.setTemplate({
                  tag: "svg",
                  ns: "http://www.w3.org/2000/svg",
                  attributes: {
                    class: ["ck", "ck-icon"],
                    viewBox: t.to("viewBox"),
                  },
                });
            }
            render() {
              super.render(),
                this._updateXMLContent(),
                this._colorFillPaths(),
                this.on("change:content", () => {
                  this._updateXMLContent(), this._colorFillPaths();
                }),
                this.on("change:fillColor", () => {
                  this._colorFillPaths();
                });
            }
            _updateXMLContent() {
              if (this.content) {
                const t = new DOMParser()
                    .parseFromString(this.content.trim(), "image/svg+xml")
                    .querySelector("svg"),
                  e = t.getAttribute("viewBox");
                for (
                  e && (this.viewBox = e), this.element.innerHTML = "";
                  t.childNodes.length > 0;

                )
                  this.element.appendChild(t.childNodes[0]);
              }
            }
            _colorFillPaths() {
              this.fillColor &&
                this.element.querySelectorAll(".ck-icon__fill").forEach((t) => {
                  t.style.fill = this.fillColor;
                });
            }
          }
          var uh = n(9948),
            mh = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(uh.Z, mh);
          uh.Z.locals;
          class gh extends Vd {
            constructor(t) {
              super(t), this.set("text", ""), this.set("position", "s");
              const e = this.bindTemplate;
              this.setTemplate({
                tag: "span",
                attributes: {
                  class: [
                    "ck",
                    "ck-tooltip",
                    e.to("position", (t) => "ck-tooltip_" + t),
                    e.if("text", "ck-hidden", (t) => !t.trim()),
                  ],
                },
                children: [
                  {
                    tag: "span",
                    attributes: { class: ["ck", "ck-tooltip__text"] },
                    children: [{ text: e.to("text") }],
                  },
                ],
              });
            }
          }
          var ph = n(4499),
            fh = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(ph.Z, fh);
          ph.Z.locals;
          class kh extends Vd {
            constructor(t) {
              super(t);
              const e = this.bindTemplate,
                n = r();
              this.set("class"),
                this.set("labelStyle"),
                this.set("icon"),
                this.set("isEnabled", !0),
                this.set("isOn", !1),
                this.set("isVisible", !0),
                this.set("isToggleable", !1),
                this.set("keystroke"),
                this.set("label"),
                this.set("tabindex", -1),
                this.set("tooltip"),
                this.set("tooltipPosition", "s"),
                this.set("type", "button"),
                this.set("withText", !1),
                this.set("withKeystroke", !1),
                (this.children = this.createCollection()),
                (this.tooltipView = this._createTooltipView()),
                (this.labelView = this._createLabelView(n)),
                (this.iconView = new hh()),
                this.iconView.extendTemplate({
                  attributes: { class: "ck-button__icon" },
                }),
                (this.keystrokeView = this._createKeystrokeView()),
                this.bind("_tooltipString").to(
                  this,
                  "tooltip",
                  this,
                  "label",
                  this,
                  "keystroke",
                  this._getTooltipString.bind(this)
                ),
                this.setTemplate({
                  tag: "button",
                  attributes: {
                    class: [
                      "ck",
                      "ck-button",
                      e.to("class"),
                      e.if("isEnabled", "ck-disabled", (t) => !t),
                      e.if("isVisible", "ck-hidden", (t) => !t),
                      e.to("isOn", (t) => (t ? "ck-on" : "ck-off")),
                      e.if("withText", "ck-button_with-text"),
                      e.if("withKeystroke", "ck-button_with-keystroke"),
                    ],
                    type: e.to("type", (t) => t || "button"),
                    tabindex: e.to("tabindex"),
                    "aria-labelledby": `ck-editor__aria-label_${n}`,
                    "aria-disabled": e.if("isEnabled", !0, (t) => !t),
                    "aria-pressed": e.to(
                      "isOn",
                      (t) => !!this.isToggleable && String(t)
                    ),
                  },
                  children: this.children,
                  on: {
                    mousedown: e.to((t) => {
                      t.preventDefault();
                    }),
                    click: e.to((t) => {
                      this.isEnabled
                        ? this.fire("execute")
                        : t.preventDefault();
                    }),
                  },
                });
            }
            render() {
              super.render(),
                this.icon &&
                  (this.iconView.bind("content").to(this, "icon"),
                  this.children.add(this.iconView)),
                this.children.add(this.tooltipView),
                this.children.add(this.labelView),
                this.withKeystroke &&
                  this.keystroke &&
                  this.children.add(this.keystrokeView);
            }
            focus() {
              this.element.focus();
            }
            _createTooltipView() {
              const t = new gh();
              return (
                t.bind("text").to(this, "_tooltipString"),
                t.bind("position").to(this, "tooltipPosition"),
                t
              );
            }
            _createLabelView(t) {
              const e = new Vd(),
                n = this.bindTemplate;
              return (
                e.setTemplate({
                  tag: "span",
                  attributes: {
                    class: ["ck", "ck-button__label"],
                    style: n.to("labelStyle"),
                    id: `ck-editor__aria-label_${t}`,
                  },
                  children: [{ text: this.bindTemplate.to("label") }],
                }),
                e
              );
            }
            _createKeystrokeView() {
              const t = new Vd();
              return (
                t.setTemplate({
                  tag: "span",
                  attributes: { class: ["ck", "ck-button__keystroke"] },
                  children: [
                    { text: this.bindTemplate.to("keystroke", (t) => gr(t)) },
                  ],
                }),
                t
              );
            }
            _getTooltipString(t, e, n) {
              return t
                ? "string" == typeof t
                  ? t
                  : (n && (n = gr(n)),
                    t instanceof Function
                      ? t(e, n)
                      : `${e}${n ? ` (${n})` : ""}`)
                : "";
            }
          }
          var bh = n(9681),
            wh = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(bh.Z, wh);
          bh.Z.locals;
          class Ah extends kh {
            constructor(t) {
              super(t),
                (this.isToggleable = !0),
                (this.toggleSwitchView = this._createToggleView()),
                this.extendTemplate({
                  attributes: { class: "ck-switchbutton" },
                });
            }
            render() {
              super.render(), this.children.add(this.toggleSwitchView);
            }
            _createToggleView() {
              const t = new Vd();
              return (
                t.setTemplate({
                  tag: "span",
                  attributes: { class: ["ck", "ck-button__toggle"] },
                  children: [
                    {
                      tag: "span",
                      attributes: { class: ["ck", "ck-button__toggle__inner"] },
                    },
                  ],
                }),
                t
              );
            }
          }
          function _h(t) {
            return "string" == typeof t
              ? {
                  model: t,
                  label: t,
                  hasBorder: !1,
                  view: { name: "span", styles: { color: t } },
                }
              : {
                  model: t.color,
                  label: t.label || t.color,
                  hasBorder: void 0 !== t.hasBorder && t.hasBorder,
                  view: { name: "span", styles: { color: `${t.color}` } },
                };
          }
          class Ch extends kh {
            constructor(t) {
              super(t);
              const e = this.bindTemplate;
              this.set("color"),
                this.set("hasBorder"),
                (this.icon =
                  '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z"/><path d="M14.814 6.035 8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>'),
                this.extendTemplate({
                  attributes: {
                    style: { backgroundColor: e.to("color") },
                    class: [
                      "ck",
                      "ck-color-grid__tile",
                      e.if("hasBorder", "ck-color-table__color-tile_bordered"),
                    ],
                  },
                });
            }
            render() {
              super.render(), (this.iconView.fillColor = "hsl(0, 0%, 100%)");
            }
          }
          class vh {
            constructor(t) {
              if ((Object.assign(this, t), t.actions && t.keystrokeHandler))
                for (const e in t.actions) {
                  let n = t.actions[e];
                  "string" == typeof n && (n = [n]);
                  for (const i of n)
                    t.keystrokeHandler.set(i, (t, n) => {
                      this[e](), n();
                    });
                }
            }
            get first() {
              return this.focusables.find(yh) || null;
            }
            get last() {
              return this.focusables.filter(yh).slice(-1)[0] || null;
            }
            get next() {
              return this._getFocusableItem(1);
            }
            get previous() {
              return this._getFocusableItem(-1);
            }
            get current() {
              let t = null;
              return null === this.focusTracker.focusedElement
                ? null
                : (this.focusables.find((e, n) => {
                    const i = e.element === this.focusTracker.focusedElement;
                    return i && (t = n), i;
                  }),
                  t);
            }
            focusFirst() {
              this._focus(this.first);
            }
            focusLast() {
              this._focus(this.last);
            }
            focusNext() {
              this._focus(this.next);
            }
            focusPrevious() {
              this._focus(this.previous);
            }
            _focus(t) {
              t && t.focus();
            }
            _getFocusableItem(t) {
              const e = this.current,
                n = this.focusables.length;
              if (!n) return null;
              if (null === e) return this[1 === t ? "first" : "last"];
              let i = (e + n + t) % n;
              do {
                const e = this.focusables.get(i);
                if (yh(e)) return e;
                i = (i + n + t) % n;
              } while (i !== e);
              return null;
            }
          }
          function yh(t) {
            return !(!t.focus || !Ca(t.element));
          }
          var xh = n(4923),
            Eh = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(xh.Z, Eh);
          xh.Z.locals;
          class Dh extends Vd {
            constructor(t, e) {
              super(t);
              const n = (e && e.colorDefinitions) || [],
                i = {};
              e &&
                e.columns &&
                (i.gridTemplateColumns = `repeat( ${e.columns}, 1fr)`),
                this.set("selectedColor"),
                (this.items = this.createCollection()),
                (this.focusTracker = new za()),
                (this.keystrokes = new Pa()),
                (this._focusCycler = new vh({
                  focusables: this.items,
                  focusTracker: this.focusTracker,
                  keystrokeHandler: this.keystrokes,
                  actions: {
                    focusPrevious: "arrowleft",
                    focusNext: "arrowright",
                  },
                })),
                this.items.on("add", (t, e) => {
                  e.isOn = e.color === this.selectedColor;
                }),
                n.forEach((t) => {
                  const e = new Ch();
                  e.set({
                    color: t.color,
                    label: t.label,
                    tooltip: !0,
                    hasBorder: t.options.hasBorder,
                  }),
                    e.on("execute", () => {
                      this.fire("execute", {
                        value: t.color,
                        hasBorder: t.options.hasBorder,
                        label: t.label,
                      });
                    }),
                    this.items.add(e);
                }),
                this.setTemplate({
                  tag: "div",
                  children: this.items,
                  attributes: { class: ["ck", "ck-color-grid"], style: i },
                }),
                this.on("change:selectedColor", (t, e, n) => {
                  for (const t of this.items) t.isOn = t.color === n;
                });
            }
            focus() {
              this.items.length && this.items.first.focus();
            }
            focusLast() {
              this.items.length && this.items.last.focus();
            }
            render() {
              super.render();
              for (const t of this.items) this.focusTracker.add(t.element);
              this.items.on("add", (t, e) => {
                this.focusTracker.add(e.element);
              }),
                this.items.on("remove", (t, e) => {
                  this.focusTracker.remove(e.element);
                }),
                this.keystrokes.listenTo(this.element);
            }
            destroy() {
              super.destroy(),
                this.focusTracker.destroy(),
                this.keystrokes.destroy();
            }
          }
          const Sh =
            '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
          class Ih extends kh {
            constructor(t) {
              super(t),
                (this.arrowView = this._createArrowView()),
                this.extendTemplate({ attributes: { "aria-haspopup": !0 } }),
                this.delegate("execute").to(this, "open");
            }
            render() {
              super.render(), this.children.add(this.arrowView);
            }
            _createArrowView() {
              const t = new hh();
              return (
                (t.content = Sh),
                t.extendTemplate({
                  attributes: { class: "ck-dropdown__arrow" },
                }),
                t
              );
            }
          }
          var Th = n(66),
            Mh = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Th.Z, Mh);
          Th.Z.locals;
          class Bh extends Vd {
            constructor(t) {
              super(t);
              const e = this.bindTemplate;
              this.set("class"),
                this.set("icon"),
                this.set("isEnabled", !0),
                this.set("isOn", !1),
                this.set("isToggleable", !1),
                this.set("isVisible", !0),
                this.set("keystroke"),
                this.set("label"),
                this.set("tabindex", -1),
                this.set("tooltip"),
                this.set("tooltipPosition", "s"),
                this.set("type", "button"),
                this.set("withText", !1),
                (this.children = this.createCollection()),
                (this.actionView = this._createActionView()),
                (this.arrowView = this._createArrowView()),
                (this.keystrokes = new Pa()),
                (this.focusTracker = new za()),
                this.setTemplate({
                  tag: "div",
                  attributes: {
                    class: [
                      "ck",
                      "ck-splitbutton",
                      e.to("class"),
                      e.if("isVisible", "ck-hidden", (t) => !t),
                      this.arrowView.bindTemplate.if(
                        "isOn",
                        "ck-splitbutton_open"
                      ),
                    ],
                  },
                  children: this.children,
                });
            }
            render() {
              super.render(),
                this.children.add(this.actionView),
                this.children.add(this.arrowView),
                this.focusTracker.add(this.actionView.element),
                this.focusTracker.add(this.arrowView.element),
                this.keystrokes.listenTo(this.element),
                this.keystrokes.set("arrowright", (t, e) => {
                  this.focusTracker.focusedElement ===
                    this.actionView.element && (this.arrowView.focus(), e());
                }),
                this.keystrokes.set("arrowleft", (t, e) => {
                  this.focusTracker.focusedElement === this.arrowView.element &&
                    (this.actionView.focus(), e());
                });
            }
            destroy() {
              super.destroy(),
                this.focusTracker.destroy(),
                this.keystrokes.destroy();
            }
            focus() {
              this.actionView.focus();
            }
            _createActionView() {
              const t = new kh();
              return (
                t
                  .bind(
                    "icon",
                    "isEnabled",
                    "isOn",
                    "isToggleable",
                    "keystroke",
                    "label",
                    "tabindex",
                    "tooltip",
                    "tooltipPosition",
                    "type",
                    "withText"
                  )
                  .to(this),
                t.extendTemplate({
                  attributes: { class: "ck-splitbutton__action" },
                }),
                t.delegate("execute").to(this),
                t
              );
            }
            _createArrowView() {
              const t = new kh(),
                e = t.bindTemplate;
              return (
                (t.icon = Sh),
                t.extendTemplate({
                  attributes: {
                    class: "ck-splitbutton__arrow",
                    "aria-haspopup": !0,
                    "aria-expanded": e.to("isOn", (t) => String(t)),
                  },
                }),
                t.bind("isEnabled").to(this),
                t.bind("label").to(this),
                t.bind("tooltip").to(this),
                t.delegate("execute").to(this, "open"),
                t
              );
            }
          }
          class Nh extends Vd {
            constructor(t) {
              super(t);
              const e = this.bindTemplate;
              this.set("isVisible", !1),
                this.set("position", "se"),
                (this.children = this.createCollection()),
                this.setTemplate({
                  tag: "div",
                  attributes: {
                    class: [
                      "ck",
                      "ck-reset",
                      "ck-dropdown__panel",
                      e.to("position", (t) => `ck-dropdown__panel_${t}`),
                      e.if("isVisible", "ck-dropdown__panel-visible"),
                    ],
                  },
                  children: this.children,
                  on: { selectstart: e.to((t) => t.preventDefault()) },
                });
            }
            focus() {
              this.children.length && this.children.first.focus();
            }
            focusLast() {
              if (this.children.length) {
                const t = this.children.last;
                "function" == typeof t.focusLast ? t.focusLast() : t.focus();
              }
            }
          }
          var zh = n(3488),
            Ph = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(zh.Z, Ph);
          zh.Z.locals;
          function Lh({
            element: t,
            target: e,
            positions: n,
            limiter: i,
            fitInViewport: o,
            viewportOffsetConfig: r,
          }) {
            j(e) && (e = e()), j(i) && (i = i());
            const s = (function (t) {
                return t && t.parentNode
                  ? t.offsetParent === os.document.body
                    ? null
                    : t.offsetParent
                  : null;
              })(t),
              a = new ka(t);
            let c;
            const l = {
              targetRect: new ka(e),
              elementRect: a,
              positionedElementAncestor: s,
            };
            if (i || o) {
              const t = i && new ka(i).getVisible(),
                e =
                  o &&
                  (function (t) {
                    t = Object.assign(
                      { top: 0, bottom: 0, left: 0, right: 0 },
                      t
                    );
                    const e = new ka(os.window);
                    return (
                      (e.top += t.top),
                      (e.height -= t.top),
                      (e.bottom -= t.bottom),
                      (e.height -= t.bottom),
                      e
                    );
                  })(r);
              Object.assign(l, { limiterRect: t, viewportRect: e }),
                (c =
                  (function (t, e) {
                    const { elementRect: n } = e,
                      i = n.getArea(),
                      o = t.map((t) => new Oh(t, e)).filter((t) => !!t.name);
                    let r = 0,
                      s = null;
                    for (const t of o) {
                      const {
                        _limiterIntersectionArea: e,
                        _viewportIntersectionArea: n,
                      } = t;
                      if (e === i) return t;
                      const o = n ** 2 + e ** 2;
                      o > r && ((r = o), (s = t));
                    }
                    return s;
                  })(n, l) || new Oh(n[0], l));
            } else c = new Oh(n[0], l);
            return c;
          }
          function Rh(t) {
            const { scrollX: e, scrollY: n } = os.window;
            return t.clone().moveBy(e, n);
          }
          class Oh {
            constructor(t, e) {
              const n = t(e.targetRect, e.elementRect, e.viewportRect);
              if (!n) return;
              const { left: i, top: o, name: r, config: s } = n;
              Object.assign(this, { name: r, config: s }),
                (this._positioningFunctionCorrdinates = { left: i, top: o }),
                (this._options = e);
            }
            get left() {
              return this._absoluteRect.left;
            }
            get top() {
              return this._absoluteRect.top;
            }
            get _limiterIntersectionArea() {
              const t = this._options.limiterRect;
              if (t) {
                const e = this._options.viewportRect;
                if (!e) return t.getIntersectionArea(this._rect);
                {
                  const n = t.getIntersection(e);
                  if (n) return n.getIntersectionArea(this._rect);
                }
              }
              return 0;
            }
            get _viewportIntersectionArea() {
              const t = this._options.viewportRect;
              return t ? t.getIntersectionArea(this._rect) : 0;
            }
            get _rect() {
              return (
                this._cachedRect ||
                  (this._cachedRect = this._options.elementRect
                    .clone()
                    .moveTo(
                      this._positioningFunctionCorrdinates.left,
                      this._positioningFunctionCorrdinates.top
                    )),
                this._cachedRect
              );
            }
            get _absoluteRect() {
              return (
                this._cachedAbsoluteRect ||
                  ((this._cachedAbsoluteRect = Rh(this._rect)),
                  this._options.positionedElementAncestor &&
                    (function (t, e) {
                      const n = Rh(new ka(e)),
                        i = pa(e);
                      let o = 0,
                        r = 0;
                      (o -= n.left),
                        (r -= n.top),
                        (o += e.scrollLeft),
                        (r += e.scrollTop),
                        (o -= i.left),
                        (r -= i.top),
                        t.moveBy(o, r);
                    })(
                      this._cachedAbsoluteRect,
                      this._options.positionedElementAncestor
                    )),
                this._cachedAbsoluteRect
              );
            }
          }
          class jh extends Vd {
            constructor(t, e, n) {
              super(t);
              const i = this.bindTemplate;
              (this.buttonView = e),
                (this.panelView = n),
                this.set("isOpen", !1),
                this.set("isEnabled", !0),
                this.set("class"),
                this.set("id"),
                this.set("panelPosition", "auto"),
                (this.keystrokes = new Pa()),
                this.setTemplate({
                  tag: "div",
                  attributes: {
                    class: [
                      "ck",
                      "ck-dropdown",
                      i.to("class"),
                      i.if("isEnabled", "ck-disabled", (t) => !t),
                    ],
                    id: i.to("id"),
                    "aria-describedby": i.to("ariaDescribedById"),
                  },
                  children: [e, n],
                }),
                e.extendTemplate({
                  attributes: { class: ["ck-dropdown__button"] },
                });
            }
            render() {
              super.render(),
                this.listenTo(this.buttonView, "open", () => {
                  this.isOpen = !this.isOpen;
                }),
                this.panelView.bind("isVisible").to(this, "isOpen"),
                this.on("change:isOpen", () => {
                  this.isOpen &&
                    ("auto" === this.panelPosition
                      ? (this.panelView.position = jh._getOptimalPosition({
                          element: this.panelView.element,
                          target: this.buttonView.element,
                          fitInViewport: !0,
                          positions: this._panelPositions,
                        }).name)
                      : (this.panelView.position = this.panelPosition));
                }),
                this.keystrokes.listenTo(this.element);
              const t = (t, e) => {
                this.isOpen &&
                  (this.buttonView.focus(), (this.isOpen = !1), e());
              };
              this.keystrokes.set("arrowdown", (t, e) => {
                this.buttonView.isEnabled &&
                  !this.isOpen &&
                  ((this.isOpen = !0), e());
              }),
                this.keystrokes.set("arrowright", (t, e) => {
                  this.isOpen && e();
                }),
                this.keystrokes.set("arrowleft", t),
                this.keystrokes.set("esc", t);
            }
            focus() {
              this.buttonView.focus();
            }
            get _panelPositions() {
              const {
                south: t,
                north: e,
                southEast: n,
                southWest: i,
                northEast: o,
                northWest: r,
                southMiddleEast: s,
                southMiddleWest: a,
                northMiddleEast: c,
                northMiddleWest: l,
              } = jh.defaultPanelPositions;
              return "rtl" !== this.locale.uiLanguageDirection
                ? [n, i, s, a, t, o, r, c, l, e]
                : [i, n, a, s, t, r, o, l, c, e];
            }
          }
          (jh.defaultPanelPositions = {
            south: (t, e) => ({
              top: t.bottom,
              left: t.left - (e.width - t.width) / 2,
              name: "s",
            }),
            southEast: (t) => ({ top: t.bottom, left: t.left, name: "se" }),
            southWest: (t, e) => ({
              top: t.bottom,
              left: t.left - e.width + t.width,
              name: "sw",
            }),
            southMiddleEast: (t, e) => ({
              top: t.bottom,
              left: t.left - (e.width - t.width) / 4,
              name: "sme",
            }),
            southMiddleWest: (t, e) => ({
              top: t.bottom,
              left: t.left - (3 * (e.width - t.width)) / 4,
              name: "smw",
            }),
            north: (t, e) => ({
              top: t.top - e.height,
              left: t.left - (e.width - t.width) / 2,
              name: "n",
            }),
            northEast: (t, e) => ({
              top: t.top - e.height,
              left: t.left,
              name: "ne",
            }),
            northWest: (t, e) => ({
              top: t.top - e.height,
              left: t.left - e.width + t.width,
              name: "nw",
            }),
            northMiddleEast: (t, e) => ({
              top: t.top - e.height,
              left: t.left - (e.width - t.width) / 4,
              name: "nme",
            }),
            northMiddleWest: (t, e) => ({
              top: t.top - e.height,
              left: t.left - (3 * (e.width - t.width)) / 4,
              name: "nmw",
            }),
          }),
            (jh._getOptimalPosition = Lh);
          class Fh extends Vd {
            constructor(t) {
              super(t),
                this.setTemplate({
                  tag: "span",
                  attributes: { class: ["ck", "ck-toolbar__separator"] },
                });
            }
          }
          class Vh extends Vd {
            constructor(t) {
              super(t),
                this.setTemplate({
                  tag: "span",
                  attributes: { class: ["ck", "ck-toolbar__line-break"] },
                });
            }
          }
          function Hh(t) {
            return Array.isArray(t)
              ? { items: t, removeItems: [] }
              : t
              ? Object.assign({ items: [], removeItems: [] }, t)
              : { items: [], removeItems: [] };
          }
          var Uh = n(5571),
            $h = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Uh.Z, $h);
          Uh.Z.locals;
          class qh extends Vd {
            constructor(t, e) {
              super(t);
              const n = this.bindTemplate,
                i = this.t;
              (this.options = e || {}),
                this.set("ariaLabel", i("Editor toolbar")),
                this.set("maxWidth", "auto"),
                (this.items = this.createCollection()),
                (this.focusTracker = new za()),
                (this.keystrokes = new Pa()),
                this.set("class"),
                this.set("isCompact", !1),
                (this.itemsView = new Gh(t)),
                (this.children = this.createCollection()),
                this.children.add(this.itemsView),
                (this.focusables = this.createCollection());
              const o = "rtl" === t.uiLanguageDirection;
              this._focusCycler = new vh({
                focusables: this.focusables,
                focusTracker: this.focusTracker,
                keystrokeHandler: this.keystrokes,
                actions: {
                  focusPrevious: [o ? "arrowright" : "arrowleft", "arrowup"],
                  focusNext: [o ? "arrowleft" : "arrowright", "arrowdown"],
                },
              });
              const r = [
                "ck",
                "ck-toolbar",
                n.to("class"),
                n.if("isCompact", "ck-toolbar_compact"),
              ];
              var s;
              this.options.shouldGroupWhenFull &&
                this.options.isFloating &&
                r.push("ck-toolbar_floating"),
                this.setTemplate({
                  tag: "div",
                  attributes: {
                    class: r,
                    role: "toolbar",
                    "aria-label": n.to("ariaLabel"),
                    style: { maxWidth: n.to("maxWidth") },
                  },
                  children: this.children,
                  on: {
                    mousedown:
                      ((s = this),
                      s.bindTemplate.to((t) => {
                        t.target === s.element && t.preventDefault();
                      })),
                  },
                }),
                (this._behavior = this.options.shouldGroupWhenFull
                  ? new Yh(this)
                  : new Wh(this));
            }
            render() {
              super.render();
              for (const t of this.items) this.focusTracker.add(t.element);
              this.items.on("add", (t, e) => {
                this.focusTracker.add(e.element);
              }),
                this.items.on("remove", (t, e) => {
                  this.focusTracker.remove(e.element);
                }),
                this.keystrokes.listenTo(this.element),
                this._behavior.render(this);
            }
            destroy() {
              return (
                this._behavior.destroy(),
                this.focusTracker.destroy(),
                this.keystrokes.destroy(),
                super.destroy()
              );
            }
            focus() {
              this._focusCycler.focusFirst();
            }
            focusLast() {
              this._focusCycler.focusLast();
            }
            fillFromConfig(t, e) {
              const n = Hh(t),
                i = n.items.filter(
                  (t, i, o) =>
                    "|" === t ||
                    (-1 === n.removeItems.indexOf(t) &&
                      ("-" === t
                        ? !this.options.shouldGroupWhenFull ||
                          (l(
                            "toolbarview-line-break-ignored-when-grouping-items",
                            o
                          ),
                          !1)
                        : !!e.has(t) ||
                          (l("toolbarview-item-unavailable", { name: t }), !1)))
                ),
                o = this._cleanSeparators(i).map((t) =>
                  "|" === t ? new Fh() : "-" === t ? new Vh() : e.create(t)
                );
              this.items.addMany(o);
            }
            _cleanSeparators(t) {
              const e = (t) => "-" !== t && "|" !== t,
                n = t.length,
                i = t.findIndex(e),
                o = n - t.slice().reverse().findIndex(e);
              return t.slice(i, o).filter((t, n, i) => {
                if (e(t)) return !0;
                return !(n > 0 && i[n - 1] === t);
              });
            }
          }
          class Gh extends Vd {
            constructor(t) {
              super(t),
                (this.children = this.createCollection()),
                this.setTemplate({
                  tag: "div",
                  attributes: { class: ["ck", "ck-toolbar__items"] },
                  children: this.children,
                });
            }
          }
          class Wh {
            constructor(t) {
              const e = t.bindTemplate;
              t.set("isVertical", !1),
                t.itemsView.children.bindTo(t.items).using((t) => t),
                t.focusables.bindTo(t.items).using((t) => t),
                t.extendTemplate({
                  attributes: {
                    class: [e.if("isVertical", "ck-toolbar_vertical")],
                  },
                });
            }
            render() {}
            destroy() {}
          }
          class Yh {
            constructor(t) {
              (this.view = t),
                (this.viewChildren = t.children),
                (this.viewFocusables = t.focusables),
                (this.viewItemsView = t.itemsView),
                (this.viewFocusTracker = t.focusTracker),
                (this.viewLocale = t.locale),
                (this.ungroupedItems = t.createCollection()),
                (this.groupedItems = t.createCollection()),
                (this.groupedItemsDropdown =
                  this._createGroupedItemsDropdown()),
                (this.resizeObserver = null),
                (this.cachedPadding = null),
                (this.shouldUpdateGroupingOnNextResize = !1),
                t.itemsView.children
                  .bindTo(this.ungroupedItems)
                  .using((t) => t),
                this.ungroupedItems.on(
                  "add",
                  this._updateFocusCycleableItems.bind(this)
                ),
                this.ungroupedItems.on(
                  "remove",
                  this._updateFocusCycleableItems.bind(this)
                ),
                t.children.on(
                  "add",
                  this._updateFocusCycleableItems.bind(this)
                ),
                t.children.on(
                  "remove",
                  this._updateFocusCycleableItems.bind(this)
                ),
                t.items.on("change", (t, e) => {
                  const n = e.index;
                  for (const t of e.removed)
                    n >= this.ungroupedItems.length
                      ? this.groupedItems.remove(t)
                      : this.ungroupedItems.remove(t);
                  for (let t = n; t < n + e.added.length; t++) {
                    const i = e.added[t - n];
                    t > this.ungroupedItems.length
                      ? this.groupedItems.add(i, t - this.ungroupedItems.length)
                      : this.ungroupedItems.add(i, t);
                  }
                  this._updateGrouping();
                }),
                t.extendTemplate({
                  attributes: { class: ["ck-toolbar_grouping"] },
                });
            }
            render(t) {
              (this.viewElement = t.element),
                this._enableGroupingOnResize(),
                this._enableGroupingOnMaxWidthChange(t);
            }
            destroy() {
              this.groupedItemsDropdown.destroy(),
                this.resizeObserver.destroy();
            }
            _updateGrouping() {
              if (
                !this.viewElement.ownerDocument.body.contains(this.viewElement)
              )
                return;
              if (!Ca(this.viewElement))
                return void (this.shouldUpdateGroupingOnNextResize = !0);
              const t = this.groupedItems.length;
              let e;
              for (; this._areItemsOverflowing; )
                this._groupLastItem(), (e = !0);
              if (!e && this.groupedItems.length) {
                for (; this.groupedItems.length && !this._areItemsOverflowing; )
                  this._ungroupFirstItem();
                this._areItemsOverflowing && this._groupLastItem();
              }
              this.groupedItems.length !== t &&
                this.view.fire("groupedItemsUpdate");
            }
            get _areItemsOverflowing() {
              if (!this.ungroupedItems.length) return !1;
              const t = this.viewElement,
                e = this.viewLocale.uiLanguageDirection,
                n = new ka(t.lastChild),
                i = new ka(t);
              if (!this.cachedPadding) {
                const n = os.window.getComputedStyle(t),
                  i = "ltr" === e ? "paddingRight" : "paddingLeft";
                this.cachedPadding = Number.parseInt(n[i]);
              }
              return "ltr" === e
                ? n.right > i.right - this.cachedPadding
                : n.left < i.left + this.cachedPadding;
            }
            _enableGroupingOnResize() {
              let t;
              (this.resizeObserver = new Aa(this.viewElement, (e) => {
                (t &&
                  t === e.contentRect.width &&
                  !this.shouldUpdateGroupingOnNextResize) ||
                  ((this.shouldUpdateGroupingOnNextResize = !1),
                  this._updateGrouping(),
                  (t = e.contentRect.width));
              })),
                this._updateGrouping();
            }
            _enableGroupingOnMaxWidthChange(t) {
              t.on("change:maxWidth", () => {
                this._updateGrouping();
              });
            }
            _groupLastItem() {
              this.groupedItems.length ||
                (this.viewChildren.add(new Fh()),
                this.viewChildren.add(this.groupedItemsDropdown),
                this.viewFocusTracker.add(this.groupedItemsDropdown.element)),
                this.groupedItems.add(
                  this.ungroupedItems.remove(this.ungroupedItems.last),
                  0
                );
            }
            _ungroupFirstItem() {
              this.ungroupedItems.add(
                this.groupedItems.remove(this.groupedItems.first)
              ),
                this.groupedItems.length ||
                  (this.viewChildren.remove(this.groupedItemsDropdown),
                  this.viewChildren.remove(this.viewChildren.last),
                  this.viewFocusTracker.remove(
                    this.groupedItemsDropdown.element
                  ));
            }
            _createGroupedItemsDropdown() {
              const t = this.viewLocale,
                e = t.t,
                n = ou(t);
              return (
                (n.class = "ck-toolbar__grouped-dropdown"),
                (n.panelPosition =
                  "ltr" === t.uiLanguageDirection ? "sw" : "se"),
                ru(n, []),
                n.buttonView.set({
                  label: e("Show more items"),
                  tooltip: !0,
                  tooltipPosition:
                    "rtl" === t.uiLanguageDirection ? "se" : "sw",
                  icon: Nd,
                }),
                n.toolbarView.items.bindTo(this.groupedItems).using((t) => t),
                n
              );
            }
            _updateFocusCycleableItems() {
              this.viewFocusables.clear(),
                this.ungroupedItems.map((t) => {
                  this.viewFocusables.add(t);
                }),
                this.groupedItems.length &&
                  this.viewFocusables.add(this.groupedItemsDropdown);
            }
          }
          var Kh = n(1162),
            Qh = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Kh.Z, Qh);
          Kh.Z.locals;
          class Zh extends Vd {
            constructor() {
              super(),
                (this.items = this.createCollection()),
                (this.focusTracker = new za()),
                (this.keystrokes = new Pa()),
                (this._focusCycler = new vh({
                  focusables: this.items,
                  focusTracker: this.focusTracker,
                  keystrokeHandler: this.keystrokes,
                  actions: { focusPrevious: "arrowup", focusNext: "arrowdown" },
                })),
                this.setTemplate({
                  tag: "ul",
                  attributes: { class: ["ck", "ck-reset", "ck-list"] },
                  children: this.items,
                });
            }
            render() {
              super.render();
              for (const t of this.items) this.focusTracker.add(t.element);
              this.items.on("add", (t, e) => {
                this.focusTracker.add(e.element);
              }),
                this.items.on("remove", (t, e) => {
                  this.focusTracker.remove(e.element);
                }),
                this.keystrokes.listenTo(this.element);
            }
            destroy() {
              super.destroy(),
                this.focusTracker.destroy(),
                this.keystrokes.destroy();
            }
            focus() {
              this._focusCycler.focusFirst();
            }
            focusLast() {
              this._focusCycler.focusLast();
            }
          }
          class Jh extends Vd {
            constructor(t) {
              super(t),
                (this.children = this.createCollection()),
                this.setTemplate({
                  tag: "li",
                  attributes: { class: ["ck", "ck-list__item"] },
                  children: this.children,
                });
            }
            focus() {
              this.children.first.focus();
            }
          }
          class Xh extends Vd {
            constructor(t) {
              super(t),
                this.setTemplate({
                  tag: "li",
                  attributes: { class: ["ck", "ck-list__separator"] },
                });
            }
          }
          var tu = n(5075),
            eu = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(tu.Z, eu);
          tu.Z.locals;
          var nu = n(6875),
            iu = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(nu.Z, iu);
          nu.Z.locals;
          function ou(t, e = Ih) {
            const n = new e(t),
              i = new Nh(t),
              o = new jh(t, n, i);
            return (
              n.bind("isEnabled").to(o),
              n instanceof Ih
                ? n.bind("isOn").to(o, "isOpen")
                : n.arrowView.bind("isOn").to(o, "isOpen"),
              (function (t) {
                (function (t) {
                  t.on("render", () => {
                    Pd({
                      emitter: t,
                      activator: () => t.isOpen,
                      callback: () => {
                        t.isOpen = !1;
                      },
                      contextElements: [t.element],
                    });
                  });
                })(t),
                  (function (t) {
                    t.on("execute", (e) => {
                      e.source instanceof Ah || (t.isOpen = !1);
                    });
                  })(t),
                  (function (t) {
                    t.keystrokes.set("arrowdown", (e, n) => {
                      t.isOpen && (t.panelView.focus(), n());
                    }),
                      t.keystrokes.set("arrowup", (e, n) => {
                        t.isOpen && (t.panelView.focusLast(), n());
                      });
                  })(t);
              })(o),
              o
            );
          }
          function ru(t, e) {
            const n = t.locale,
              i = n.t,
              o = (t.toolbarView = new qh(n));
            o.set("ariaLabel", i("Dropdown toolbar")),
              t.extendTemplate({
                attributes: { class: ["ck-toolbar-dropdown"] },
              }),
              e.map((t) => o.items.add(t)),
              t.panelView.children.add(o),
              o.items.delegate("execute").to(t);
          }
          function su(t, e) {
            const n = t.locale,
              i = (t.listView = new Zh(n));
            i.items.bindTo(e).using(({ type: t, model: e }) => {
              if ("separator" === t) return new Xh(n);
              if ("button" === t || "switchbutton" === t) {
                const i = new Jh(n);
                let o;
                return (
                  (o = "button" === t ? new kh(n) : new Ah(n)),
                  o.bind(...Object.keys(e)).to(e),
                  o.delegate("execute").to(i),
                  i.children.add(o),
                  i
                );
              }
            }),
              t.panelView.children.add(i),
              i.items.delegate("execute").to(t);
          }
          var au = n(4547),
            cu = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(au.Z, cu);
          au.Z.locals;
          class lu extends Vd {
            constructor(t) {
              super(t), (this.body = new ch(t));
            }
            render() {
              super.render(), this.body.attachToDom();
            }
            destroy() {
              return this.body.detachFromDom(), super.destroy();
            }
          }
          var du = n(2751),
            hu = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(du.Z, hu);
          du.Z.locals;
          class uu extends Vd {
            constructor(t) {
              super(t),
                this.set("text"),
                this.set("for"),
                (this.id = `ck-editor__label_${r()}`);
              const e = this.bindTemplate;
              this.setTemplate({
                tag: "label",
                attributes: {
                  class: ["ck", "ck-label"],
                  id: this.id,
                  for: e.to("for"),
                },
                children: [{ text: e.to("text") }],
              });
            }
          }
          class mu extends lu {
            constructor(t) {
              super(t),
                (this.top = this.createCollection()),
                (this.main = this.createCollection()),
                (this._voiceLabelView = this._createVoiceLabel()),
                this.setTemplate({
                  tag: "div",
                  attributes: {
                    class: [
                      "ck",
                      "ck-reset",
                      "ck-editor",
                      "ck-rounded-corners",
                    ],
                    role: "application",
                    dir: t.uiLanguageDirection,
                    lang: t.uiLanguage,
                    "aria-labelledby": this._voiceLabelView.id,
                  },
                  children: [
                    this._voiceLabelView,
                    {
                      tag: "div",
                      attributes: {
                        class: ["ck", "ck-editor__top", "ck-reset_all"],
                        role: "presentation",
                      },
                      children: this.top,
                    },
                    {
                      tag: "div",
                      attributes: {
                        class: ["ck", "ck-editor__main"],
                        role: "presentation",
                      },
                      children: this.main,
                    },
                  ],
                });
            }
            _createVoiceLabel() {
              const t = this.t,
                e = new uu();
              return (
                (e.text = t("Rich Text Editor")),
                e.extendTemplate({ attributes: { class: "ck-voice-label" } }),
                e
              );
            }
          }
          class gu extends Vd {
            constructor(t, e, n) {
              super(t),
                this.setTemplate({
                  tag: "div",
                  attributes: {
                    class: [
                      "ck",
                      "ck-content",
                      "ck-editor__editable",
                      "ck-rounded-corners",
                    ],
                    lang: t.contentLanguage,
                    dir: t.contentLanguageDirection,
                  },
                }),
                (this.name = null),
                this.set("isFocused", !1),
                (this._editableElement = n),
                (this._hasExternalElement = !!this._editableElement),
                (this._editingView = e);
            }
            render() {
              super.render(),
                this._hasExternalElement
                  ? this.template.apply((this.element = this._editableElement))
                  : (this._editableElement = this.element),
                this.on("change:isFocused", () =>
                  this._updateIsFocusedClasses()
                ),
                this._updateIsFocusedClasses();
            }
            destroy() {
              this._hasExternalElement &&
                this.template.revert(this._editableElement),
                super.destroy();
            }
            _updateIsFocusedClasses() {
              const t = this._editingView;
              function e(e) {
                t.change((n) => {
                  const i = t.document.getRoot(e.name);
                  n.addClass(e.isFocused ? "ck-focused" : "ck-blurred", i),
                    n.removeClass(e.isFocused ? "ck-blurred" : "ck-focused", i);
                });
              }
              t.isRenderingInProgress
                ? (function n(i) {
                    t.once("change:isRenderingInProgress", (t, o, r) => {
                      r ? n(i) : e(i);
                    });
                  })(this)
                : e(this);
            }
          }
          class pu extends gu {
            constructor(t, e, n) {
              super(t, e, n),
                this.extendTemplate({
                  attributes: {
                    role: "textbox",
                    class: "ck-editor__editable_inline",
                  },
                });
            }
            render() {
              super.render();
              const t = this._editingView,
                e = this.t;
              t.change((n) => {
                const i = t.document.getRoot(this.name);
                n.setAttribute(
                  "aria-label",
                  e("Rich Text Editor, %0", this.name),
                  i
                );
              });
            }
          }
          var fu = n(5523),
            ku = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(fu.Z, ku);
          fu.Z.locals;
          class bu extends Vd {
            constructor(t, e = {}) {
              super(t);
              const n = this.bindTemplate;
              this.set("label", e.label || ""),
                this.set("class", e.class || null),
                (this.children = this.createCollection()),
                this.setTemplate({
                  tag: "div",
                  attributes: {
                    class: ["ck", "ck-form__header", n.to("class")],
                  },
                  children: this.children,
                });
              const i = new Vd(t);
              i.setTemplate({
                tag: "span",
                attributes: { class: ["ck", "ck-form__header__label"] },
                children: [{ text: n.to("label") }],
              }),
                this.children.add(i);
            }
          }
          var wu = n(6985),
            Au = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(wu.Z, Au);
          wu.Z.locals;
          class _u extends Vd {
            constructor(t) {
              super(t),
                this.set("value"),
                this.set("id"),
                this.set("placeholder"),
                this.set("isReadOnly", !1),
                this.set("hasError", !1),
                this.set("ariaDescribedById"),
                (this.focusTracker = new za()),
                this.bind("isFocused").to(this.focusTracker),
                this.set("isEmpty", !0),
                this.set("inputMode", "text");
              const e = this.bindTemplate;
              this.setTemplate({
                tag: "input",
                attributes: {
                  class: [
                    "ck",
                    "ck-input",
                    e.if("isFocused", "ck-input_focused"),
                    e.if("isEmpty", "ck-input-text_empty"),
                    e.if("hasError", "ck-error"),
                  ],
                  id: e.to("id"),
                  placeholder: e.to("placeholder"),
                  readonly: e.to("isReadOnly"),
                  inputmode: e.to("inputMode"),
                  "aria-invalid": e.if("hasError", !0),
                  "aria-describedby": e.to("ariaDescribedById"),
                },
                on: {
                  input: e.to((...t) => {
                    this.fire("input", ...t), this._updateIsEmpty();
                  }),
                  change: e.to(this._updateIsEmpty.bind(this)),
                },
              });
            }
            render() {
              super.render(),
                this.focusTracker.add(this.element),
                this._setDomElementValue(this.value),
                this._updateIsEmpty(),
                this.on("change:value", (t, e, n) => {
                  this._setDomElementValue(n), this._updateIsEmpty();
                });
            }
            destroy() {
              super.destroy(), this.focusTracker.destroy();
            }
            select() {
              this.element.select();
            }
            focus() {
              this.element.focus();
            }
            _updateIsEmpty() {
              this.isEmpty = !this.element.value;
            }
            _setDomElementValue(t) {
              this.element.value = t || 0 === t ? t : "";
            }
          }
          class Cu extends _u {
            constructor(t) {
              super(t),
                this.extendTemplate({
                  attributes: { type: "text", class: ["ck-input-text"] },
                });
            }
          }
          var vu = n(8111),
            yu = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(vu.Z, yu);
          vu.Z.locals;
          class xu extends Vd {
            constructor(t, e) {
              super(t);
              const n = `ck-labeled-field-view-${r()}`,
                i = `ck-labeled-field-view-status-${r()}`;
              (this.fieldView = e(this, n, i)),
                this.set("label"),
                this.set("isEnabled", !0),
                this.set("isEmpty", !0),
                this.set("isFocused", !1),
                this.set("errorText", null),
                this.set("infoText", null),
                this.set("class"),
                this.set("placeholder"),
                (this.labelView = this._createLabelView(n)),
                (this.statusView = this._createStatusView(i)),
                this.bind("_statusText").to(
                  this,
                  "errorText",
                  this,
                  "infoText",
                  (t, e) => t || e
                );
              const o = this.bindTemplate;
              this.setTemplate({
                tag: "div",
                attributes: {
                  class: [
                    "ck",
                    "ck-labeled-field-view",
                    o.to("class"),
                    o.if("isEnabled", "ck-disabled", (t) => !t),
                    o.if("isEmpty", "ck-labeled-field-view_empty"),
                    o.if("isFocused", "ck-labeled-field-view_focused"),
                    o.if("placeholder", "ck-labeled-field-view_placeholder"),
                    o.if("errorText", "ck-error"),
                  ],
                },
                children: [
                  {
                    tag: "div",
                    attributes: {
                      class: ["ck", "ck-labeled-field-view__input-wrapper"],
                    },
                    children: [this.fieldView, this.labelView],
                  },
                  this.statusView,
                ],
              });
            }
            _createLabelView(t) {
              const e = new uu(this.locale);
              return (e.for = t), e.bind("text").to(this, "label"), e;
            }
            _createStatusView(t) {
              const e = new Vd(this.locale),
                n = this.bindTemplate;
              return (
                e.setTemplate({
                  tag: "div",
                  attributes: {
                    class: [
                      "ck",
                      "ck-labeled-field-view__status",
                      n.if("errorText", "ck-labeled-field-view__status_error"),
                      n.if("_statusText", "ck-hidden", (t) => !t),
                    ],
                    id: t,
                    role: n.if("errorText", "alert"),
                  },
                  children: [{ text: n.to("_statusText") }],
                }),
                e
              );
            }
            focus() {
              this.fieldView.focus();
            }
          }
          function Eu(t, e, n) {
            const i = new Cu(t.locale);
            return (
              i.set({ id: e, ariaDescribedById: n }),
              i.bind("isReadOnly").to(t, "isEnabled", (t) => !t),
              i.bind("hasError").to(t, "errorText", (t) => !!t),
              i.on("input", () => {
                t.errorText = null;
              }),
              t.bind("isEmpty", "isFocused", "placeholder").to(i),
              i
            );
          }
          class Du extends Pi {
            static get pluginName() {
              return "Notification";
            }
            init() {
              this.on(
                "show:warning",
                (t, e) => {
                  window.alert(e.message);
                },
                { priority: "lowest" }
              );
            }
            showSuccess(t, e = {}) {
              this._showNotification({
                message: t,
                type: "success",
                namespace: e.namespace,
                title: e.title,
              });
            }
            showInfo(t, e = {}) {
              this._showNotification({
                message: t,
                type: "info",
                namespace: e.namespace,
                title: e.title,
              });
            }
            showWarning(t, e = {}) {
              this._showNotification({
                message: t,
                type: "warning",
                namespace: e.namespace,
                title: e.title,
              });
            }
            _showNotification(t) {
              const e =
                `show:${t.type}` + (t.namespace ? `:${t.namespace}` : "");
              this.fire(e, {
                message: t.message,
                type: t.type,
                title: t.title || "",
              });
            }
          }
          class Su {
            constructor(t, e) {
              e && Jt(this, e), t && this.set(t);
            }
          }
          function Iu(t) {
            return (e) => e + t;
          }
          he(Su, re);
          var Tu = n(8245),
            Mu = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Tu.Z, Mu);
          Tu.Z.locals;
          const Bu = Iu("px"),
            Nu = os.document.body;
          class zu extends Vd {
            constructor(t) {
              super(t);
              const e = this.bindTemplate;
              this.set("top", 0),
                this.set("left", 0),
                this.set("position", "arrow_nw"),
                this.set("isVisible", !1),
                this.set("withArrow", !0),
                this.set("class"),
                (this.content = this.createCollection()),
                this.setTemplate({
                  tag: "div",
                  attributes: {
                    class: [
                      "ck",
                      "ck-balloon-panel",
                      e.to("position", (t) => `ck-balloon-panel_${t}`),
                      e.if("isVisible", "ck-balloon-panel_visible"),
                      e.if("withArrow", "ck-balloon-panel_with-arrow"),
                      e.to("class"),
                    ],
                    style: { top: e.to("top", Bu), left: e.to("left", Bu) },
                  },
                  children: this.content,
                });
            }
            show() {
              this.isVisible = !0;
            }
            hide() {
              this.isVisible = !1;
            }
            attachTo(t) {
              this.show();
              const e = zu.defaultPositions,
                n = Object.assign(
                  {},
                  {
                    element: this.element,
                    positions: [
                      e.southArrowNorth,
                      e.southArrowNorthMiddleWest,
                      e.southArrowNorthMiddleEast,
                      e.southArrowNorthWest,
                      e.southArrowNorthEast,
                      e.northArrowSouth,
                      e.northArrowSouthMiddleWest,
                      e.northArrowSouthMiddleEast,
                      e.northArrowSouthWest,
                      e.northArrowSouthEast,
                      e.viewportStickyNorth,
                    ],
                    limiter: Nu,
                    fitInViewport: !0,
                  },
                  t
                ),
                i = zu._getOptimalPosition(n),
                o = parseInt(i.left),
                r = parseInt(i.top),
                { name: s, config: a = {} } = i,
                { withArrow: c = !0 } = a;
              Object.assign(this, {
                top: r,
                left: o,
                position: s,
                withArrow: c,
              });
            }
            pin(t) {
              this.unpin(),
                (this._pinWhenIsVisibleCallback = () => {
                  this.isVisible ? this._startPinning(t) : this._stopPinning();
                }),
                this._startPinning(t),
                this.listenTo(
                  this,
                  "change:isVisible",
                  this._pinWhenIsVisibleCallback
                );
            }
            unpin() {
              this._pinWhenIsVisibleCallback &&
                (this._stopPinning(),
                this.stopListening(
                  this,
                  "change:isVisible",
                  this._pinWhenIsVisibleCallback
                ),
                (this._pinWhenIsVisibleCallback = null),
                this.hide());
            }
            _startPinning(t) {
              this.attachTo(t);
              const e = Pu(t.target),
                n = t.limiter ? Pu(t.limiter) : Nu;
              this.listenTo(
                os.document,
                "scroll",
                (i, o) => {
                  const r = o.target,
                    s = e && r.contains(e),
                    a = n && r.contains(n);
                  (!s && !a && e && n) || this.attachTo(t);
                },
                { useCapture: !0 }
              ),
                this.listenTo(os.window, "resize", () => {
                  this.attachTo(t);
                });
            }
            _stopPinning() {
              this.stopListening(os.document, "scroll"),
                this.stopListening(os.window, "resize");
            }
          }
          function Pu(t) {
            return Ci(t)
              ? t
              : ga(t)
              ? t.commonAncestorContainer
              : "function" == typeof t
              ? Pu(t())
              : null;
          }
          (zu.arrowHorizontalOffset = 25),
            (zu.arrowVerticalOffset = 10),
            (zu.stickyVerticalOffset = 20),
            (zu._getOptimalPosition = Lh),
            (zu.defaultPositions = (function ({
              horizontalOffset: t = zu.arrowHorizontalOffset,
              verticalOffset: e = zu.arrowVerticalOffset,
              stickyVerticalOffset: n = zu.stickyVerticalOffset,
              config: i,
            } = {}) {
              return {
                northWestArrowSouthWest: (e, n) => ({
                  top: o(e, n),
                  left: e.left - t,
                  name: "arrow_sw",
                  ...(i && { config: i }),
                }),
                northWestArrowSouthMiddleWest: (e, n) => ({
                  top: o(e, n),
                  left: e.left - 0.25 * n.width - t,
                  name: "arrow_smw",
                  ...(i && { config: i }),
                }),
                northWestArrowSouth: (t, e) => ({
                  top: o(t, e),
                  left: t.left - e.width / 2,
                  name: "arrow_s",
                  ...(i && { config: i }),
                }),
                northWestArrowSouthMiddleEast: (e, n) => ({
                  top: o(e, n),
                  left: e.left - 0.75 * n.width + t,
                  name: "arrow_sme",
                  ...(i && { config: i }),
                }),
                northWestArrowSouthEast: (e, n) => ({
                  top: o(e, n),
                  left: e.left - n.width + t,
                  name: "arrow_se",
                  ...(i && { config: i }),
                }),
                northArrowSouthWest: (e, n) => ({
                  top: o(e, n),
                  left: e.left + e.width / 2 - t,
                  name: "arrow_sw",
                  ...(i && { config: i }),
                }),
                northArrowSouthMiddleWest: (e, n) => ({
                  top: o(e, n),
                  left: e.left + e.width / 2 - 0.25 * n.width - t,
                  name: "arrow_smw",
                  ...(i && { config: i }),
                }),
                northArrowSouth: (t, e) => ({
                  top: o(t, e),
                  left: t.left + t.width / 2 - e.width / 2,
                  name: "arrow_s",
                  ...(i && { config: i }),
                }),
                northArrowSouthMiddleEast: (e, n) => ({
                  top: o(e, n),
                  left: e.left + e.width / 2 - 0.75 * n.width + t,
                  name: "arrow_sme",
                  ...(i && { config: i }),
                }),
                northArrowSouthEast: (e, n) => ({
                  top: o(e, n),
                  left: e.left + e.width / 2 - n.width + t,
                  name: "arrow_se",
                  ...(i && { config: i }),
                }),
                northEastArrowSouthWest: (e, n) => ({
                  top: o(e, n),
                  left: e.right - t,
                  name: "arrow_sw",
                  ...(i && { config: i }),
                }),
                northEastArrowSouthMiddleWest: (e, n) => ({
                  top: o(e, n),
                  left: e.right - 0.25 * n.width - t,
                  name: "arrow_smw",
                  ...(i && { config: i }),
                }),
                northEastArrowSouth: (t, e) => ({
                  top: o(t, e),
                  left: t.right - e.width / 2,
                  name: "arrow_s",
                  ...(i && { config: i }),
                }),
                northEastArrowSouthMiddleEast: (e, n) => ({
                  top: o(e, n),
                  left: e.right - 0.75 * n.width + t,
                  name: "arrow_sme",
                  ...(i && { config: i }),
                }),
                northEastArrowSouthEast: (e, n) => ({
                  top: o(e, n),
                  left: e.right - n.width + t,
                  name: "arrow_se",
                  ...(i && { config: i }),
                }),
                southWestArrowNorthWest: (e, n) => ({
                  top: r(e),
                  left: e.left - t,
                  name: "arrow_nw",
                  ...(i && { config: i }),
                }),
                southWestArrowNorthMiddleWest: (e, n) => ({
                  top: r(e),
                  left: e.left - 0.25 * n.width - t,
                  name: "arrow_nmw",
                  ...(i && { config: i }),
                }),
                southWestArrowNorth: (t, e) => ({
                  top: r(t),
                  left: t.left - e.width / 2,
                  name: "arrow_n",
                  ...(i && { config: i }),
                }),
                southWestArrowNorthMiddleEast: (e, n) => ({
                  top: r(e),
                  left: e.left - 0.75 * n.width + t,
                  name: "arrow_nme",
                  ...(i && { config: i }),
                }),
                southWestArrowNorthEast: (e, n) => ({
                  top: r(e),
                  left: e.left - n.width + t,
                  name: "arrow_ne",
                  ...(i && { config: i }),
                }),
                southArrowNorthWest: (e, n) => ({
                  top: r(e),
                  left: e.left + e.width / 2 - t,
                  name: "arrow_nw",
                  ...(i && { config: i }),
                }),
                southArrowNorthMiddleWest: (e, n) => ({
                  top: r(e),
                  left: e.left + e.width / 2 - 0.25 * n.width - t,
                  name: "arrow_nmw",
                  ...(i && { config: i }),
                }),
                southArrowNorth: (t, e) => ({
                  top: r(t),
                  left: t.left + t.width / 2 - e.width / 2,
                  name: "arrow_n",
                  ...(i && { config: i }),
                }),
                southArrowNorthMiddleEast: (e, n) => ({
                  top: r(e),
                  left: e.left + e.width / 2 - 0.75 * n.width + t,
                  name: "arrow_nme",
                  ...(i && { config: i }),
                }),
                southArrowNorthEast: (e, n) => ({
                  top: r(e),
                  left: e.left + e.width / 2 - n.width + t,
                  name: "arrow_ne",
                  ...(i && { config: i }),
                }),
                southEastArrowNorthWest: (e, n) => ({
                  top: r(e),
                  left: e.right - t,
                  name: "arrow_nw",
                  ...(i && { config: i }),
                }),
                southEastArrowNorthMiddleWest: (e, n) => ({
                  top: r(e),
                  left: e.right - 0.25 * n.width - t,
                  name: "arrow_nmw",
                  ...(i && { config: i }),
                }),
                southEastArrowNorth: (t, e) => ({
                  top: r(t),
                  left: t.right - e.width / 2,
                  name: "arrow_n",
                  ...(i && { config: i }),
                }),
                southEastArrowNorthMiddleEast: (e, n) => ({
                  top: r(e),
                  left: e.right - 0.75 * n.width + t,
                  name: "arrow_nme",
                  ...(i && { config: i }),
                }),
                southEastArrowNorthEast: (e, n) => ({
                  top: r(e),
                  left: e.right - n.width + t,
                  name: "arrow_ne",
                  ...(i && { config: i }),
                }),
                viewportStickyNorth: (t, e, o) =>
                  t.getIntersection(o)
                    ? {
                        top: o.top + n,
                        left: t.left + t.width / 2 - e.width / 2,
                        name: "arrowless",
                        config: { withArrow: !1, ...i },
                      }
                    : null,
              };
              function o(t, n) {
                return t.top - n.height - e;
              }
              function r(t) {
                return t.bottom + e;
              }
            })());
          const Lu =
            '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>';
          var Ru = n(1757),
            Ou = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Ru.Z, Ou);
          Ru.Z.locals;
          var ju = n(3553),
            Fu = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(ju.Z, Fu);
          ju.Z.locals;
          const Vu = Iu("px");
          class Hu extends ue {
            static get pluginName() {
              return "ContextualBalloon";
            }
            constructor(t) {
              super(t),
                (this.positionLimiter = () => {
                  const t = this.editor.editing.view,
                    e = t.document.selection.editableElement;
                  return e ? t.domConverter.mapViewToDom(e.root) : null;
                }),
                this.set("visibleView", null),
                (this.view = new zu(t.locale)),
                t.ui.view.body.add(this.view),
                t.ui.focusTracker.add(this.view.element),
                (this._viewToStack = new Map()),
                (this._idToStack = new Map()),
                this.set("_numberOfStacks", 0),
                this.set("_singleViewMode", !1),
                (this._rotatorView = this._createRotatorView()),
                (this._fakePanelsView = this._createFakePanelsView());
            }
            destroy() {
              super.destroy(),
                this.view.destroy(),
                this._rotatorView.destroy(),
                this._fakePanelsView.destroy();
            }
            hasView(t) {
              return Array.from(this._viewToStack.keys()).includes(t);
            }
            add(t) {
              if (this.hasView(t.view))
                throw new c("contextualballoon-add-view-exist", [this, t]);
              const e = t.stackId || "main";
              if (!this._idToStack.has(e))
                return (
                  this._idToStack.set(e, new Map([[t.view, t]])),
                  this._viewToStack.set(t.view, this._idToStack.get(e)),
                  (this._numberOfStacks = this._idToStack.size),
                  void (
                    (this._visibleStack && !t.singleViewMode) ||
                    this.showStack(e)
                  )
                );
              const n = this._idToStack.get(e);
              t.singleViewMode && this.showStack(e),
                n.set(t.view, t),
                this._viewToStack.set(t.view, n),
                n === this._visibleStack && this._showView(t);
            }
            remove(t) {
              if (!this.hasView(t))
                throw new c("contextualballoon-remove-view-not-exist", [
                  this,
                  t,
                ]);
              const e = this._viewToStack.get(t);
              this._singleViewMode &&
                this.visibleView === t &&
                (this._singleViewMode = !1),
                this.visibleView === t &&
                  (1 === e.size
                    ? this._idToStack.size > 1
                      ? this._showNextStack()
                      : (this.view.hide(),
                        (this.visibleView = null),
                        this._rotatorView.hideView())
                    : this._showView(Array.from(e.values())[e.size - 2])),
                1 === e.size
                  ? (this._idToStack.delete(this._getStackId(e)),
                    (this._numberOfStacks = this._idToStack.size))
                  : e.delete(t),
                this._viewToStack.delete(t);
            }
            updatePosition(t) {
              t && (this._visibleStack.get(this.visibleView).position = t),
                this.view.pin(this._getBalloonPosition()),
                this._fakePanelsView.updatePosition();
            }
            showStack(t) {
              this.visibleStack = t;
              const e = this._idToStack.get(t);
              if (!e)
                throw new c(
                  "contextualballoon-showstack-stack-not-exist",
                  this
                );
              this._visibleStack !== e &&
                this._showView(Array.from(e.values()).pop());
            }
            get _visibleStack() {
              return this._viewToStack.get(this.visibleView);
            }
            _getStackId(t) {
              return Array.from(this._idToStack.entries()).find(
                (e) => e[1] === t
              )[0];
            }
            _showNextStack() {
              const t = Array.from(this._idToStack.values());
              let e = t.indexOf(this._visibleStack) + 1;
              t[e] || (e = 0), this.showStack(this._getStackId(t[e]));
            }
            _showPrevStack() {
              const t = Array.from(this._idToStack.values());
              let e = t.indexOf(this._visibleStack) - 1;
              t[e] || (e = t.length - 1),
                this.showStack(this._getStackId(t[e]));
            }
            _createRotatorView() {
              const t = new Uu(this.editor.locale),
                e = this.editor.locale.t;
              return (
                this.view.content.add(t),
                t
                  .bind("isNavigationVisible")
                  .to(
                    this,
                    "_numberOfStacks",
                    this,
                    "_singleViewMode",
                    (t, e) => !e && t > 1
                  ),
                t.on(
                  "change:isNavigationVisible",
                  () => this.updatePosition(),
                  { priority: "low" }
                ),
                t
                  .bind("counter")
                  .to(this, "visibleView", this, "_numberOfStacks", (t, n) => {
                    if (n < 2) return "";
                    const i =
                      Array.from(this._idToStack.values()).indexOf(
                        this._visibleStack
                      ) + 1;
                    return e("%0 of %1", [i, n]);
                  }),
                t.buttonNextView.on("execute", () => {
                  t.focusTracker.isFocused && this.editor.editing.view.focus(),
                    this._showNextStack();
                }),
                t.buttonPrevView.on("execute", () => {
                  t.focusTracker.isFocused && this.editor.editing.view.focus(),
                    this._showPrevStack();
                }),
                t
              );
            }
            _createFakePanelsView() {
              const t = new $u(this.editor.locale, this.view);
              return (
                t
                  .bind("numberOfPanels")
                  .to(
                    this,
                    "_numberOfStacks",
                    this,
                    "_singleViewMode",
                    (t, e) => (!e && t >= 2 ? Math.min(t - 1, 2) : 0)
                  ),
                t.listenTo(this.view, "change:top", () => t.updatePosition()),
                t.listenTo(this.view, "change:left", () => t.updatePosition()),
                this.editor.ui.view.body.add(t),
                t
              );
            }
            _showView({
              view: t,
              balloonClassName: e = "",
              withArrow: n = !0,
              singleViewMode: i = !1,
            }) {
              (this.view.class = e),
                (this.view.withArrow = n),
                this._rotatorView.showView(t),
                (this.visibleView = t),
                this.view.pin(this._getBalloonPosition()),
                this._fakePanelsView.updatePosition(),
                i && (this._singleViewMode = !0);
            }
            _getBalloonPosition() {
              let t = Array.from(this._visibleStack.values()).pop().position;
              return (
                t &&
                  (t.limiter ||
                    (t = Object.assign({}, t, {
                      limiter: this.positionLimiter,
                    })),
                  (t = Object.assign({}, t, {
                    viewportOffsetConfig: this.editor.ui.viewportOffset,
                  }))),
                t
              );
            }
          }
          class Uu extends Vd {
            constructor(t) {
              super(t);
              const e = t.t,
                n = this.bindTemplate;
              this.set("isNavigationVisible", !0),
                (this.focusTracker = new za()),
                (this.buttonPrevView = this._createButtonView(
                  e("Previous"),
                  Lu
                )),
                (this.buttonNextView = this._createButtonView(
                  e("Next"),
                  '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>'
                )),
                (this.content = this.createCollection()),
                this.setTemplate({
                  tag: "div",
                  attributes: {
                    class: ["ck", "ck-balloon-rotator"],
                    "z-index": "-1",
                  },
                  children: [
                    {
                      tag: "div",
                      attributes: {
                        class: [
                          "ck-balloon-rotator__navigation",
                          n.to("isNavigationVisible", (t) =>
                            t ? "" : "ck-hidden"
                          ),
                        ],
                      },
                      children: [
                        this.buttonPrevView,
                        {
                          tag: "span",
                          attributes: {
                            class: ["ck-balloon-rotator__counter"],
                          },
                          children: [{ text: n.to("counter") }],
                        },
                        this.buttonNextView,
                      ],
                    },
                    {
                      tag: "div",
                      attributes: { class: "ck-balloon-rotator__content" },
                      children: this.content,
                    },
                  ],
                });
            }
            render() {
              super.render(), this.focusTracker.add(this.element);
            }
            destroy() {
              super.destroy(), this.focusTracker.destroy();
            }
            showView(t) {
              this.hideView(), this.content.add(t);
            }
            hideView() {
              this.content.clear();
            }
            _createButtonView(t, e) {
              const n = new kh(this.locale);
              return n.set({ label: t, icon: e, tooltip: !0 }), n;
            }
          }
          class $u extends Vd {
            constructor(t, e) {
              super(t);
              const n = this.bindTemplate;
              this.set("top", 0),
                this.set("left", 0),
                this.set("height", 0),
                this.set("width", 0),
                this.set("numberOfPanels", 0),
                (this.content = this.createCollection()),
                (this._balloonPanelView = e),
                this.setTemplate({
                  tag: "div",
                  attributes: {
                    class: [
                      "ck-fake-panel",
                      n.to("numberOfPanels", (t) => (t ? "" : "ck-hidden")),
                    ],
                    style: {
                      top: n.to("top", Vu),
                      left: n.to("left", Vu),
                      width: n.to("width", Vu),
                      height: n.to("height", Vu),
                    },
                  },
                  children: this.content,
                }),
                this.on("change:numberOfPanels", (t, e, n, i) => {
                  n > i ? this._addPanels(n - i) : this._removePanels(i - n),
                    this.updatePosition();
                });
            }
            _addPanels(t) {
              for (; t--; ) {
                const t = new Vd();
                t.setTemplate({ tag: "div" }),
                  this.content.add(t),
                  this.registerChild(t);
              }
            }
            _removePanels(t) {
              for (; t--; ) {
                const t = this.content.last;
                this.content.remove(t), this.deregisterChild(t), t.destroy();
              }
            }
            updatePosition() {
              if (this.numberOfPanels) {
                const { top: t, left: e } = this._balloonPanelView,
                  { width: n, height: i } = new ka(
                    this._balloonPanelView.element
                  );
                Object.assign(this, { top: t, left: e, width: n, height: i });
              }
            }
          }
          var qu = n(3609),
            Gu = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(qu.Z, Gu);
          qu.Z.locals;
          const Wu = Iu("px");
          class Yu extends Vd {
            constructor(t) {
              super(t);
              const e = this.bindTemplate;
              this.set("isActive", !1),
                this.set("isSticky", !1),
                this.set("limiterElement", null),
                this.set("limiterBottomOffset", 50),
                this.set("viewportTopOffset", 0),
                this.set("_marginLeft", null),
                this.set("_isStickyToTheLimiter", !1),
                this.set("_hasViewportTopOffset", !1),
                (this.content = this.createCollection()),
                (this._contentPanelPlaceholder = new Hd({
                  tag: "div",
                  attributes: {
                    class: ["ck", "ck-sticky-panel__placeholder"],
                    style: {
                      display: e.to("isSticky", (t) => (t ? "block" : "none")),
                      height: e.to("isSticky", (t) =>
                        t ? Wu(this._panelRect.height) : null
                      ),
                    },
                  },
                }).render()),
                (this._contentPanel = new Hd({
                  tag: "div",
                  attributes: {
                    class: [
                      "ck",
                      "ck-sticky-panel__content",
                      e.if("isSticky", "ck-sticky-panel__content_sticky"),
                      e.if(
                        "_isStickyToTheLimiter",
                        "ck-sticky-panel__content_sticky_bottom-limit"
                      ),
                    ],
                    style: {
                      width: e.to("isSticky", (t) =>
                        t
                          ? Wu(
                              this._contentPanelPlaceholder.getBoundingClientRect()
                                .width
                            )
                          : null
                      ),
                      top: e.to("_hasViewportTopOffset", (t) =>
                        t ? Wu(this.viewportTopOffset) : null
                      ),
                      bottom: e.to("_isStickyToTheLimiter", (t) =>
                        t ? Wu(this.limiterBottomOffset) : null
                      ),
                      marginLeft: e.to("_marginLeft"),
                    },
                  },
                  children: this.content,
                }).render()),
                this.setTemplate({
                  tag: "div",
                  attributes: { class: ["ck", "ck-sticky-panel"] },
                  children: [this._contentPanelPlaceholder, this._contentPanel],
                });
            }
            render() {
              super.render(),
                this._checkIfShouldBeSticky(),
                this.listenTo(os.window, "scroll", () => {
                  this._checkIfShouldBeSticky();
                }),
                this.listenTo(this, "change:isActive", () => {
                  this._checkIfShouldBeSticky();
                });
            }
            _checkIfShouldBeSticky() {
              const t = (this._panelRect =
                this._contentPanel.getBoundingClientRect());
              let e;
              this.limiterElement
                ? ((e = this._limiterRect =
                    this.limiterElement.getBoundingClientRect()),
                  (this.isSticky =
                    this.isActive &&
                    e.top < this.viewportTopOffset &&
                    this._panelRect.height + this.limiterBottomOffset <
                      e.height))
                : (this.isSticky = !1),
                this.isSticky
                  ? ((this._isStickyToTheLimiter =
                      e.bottom <
                      t.height +
                        this.limiterBottomOffset +
                        this.viewportTopOffset),
                    (this._hasViewportTopOffset =
                      !this._isStickyToTheLimiter && !!this.viewportTopOffset),
                    (this._marginLeft = this._isStickyToTheLimiter
                      ? null
                      : Wu(-os.window.scrollX)))
                  : ((this._isStickyToTheLimiter = !1),
                    (this._hasViewportTopOffset = !1),
                    (this._marginLeft = null));
            }
          }
          Iu("px");
          var Ku = n(6706),
            Qu = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Ku.Z, Qu);
          Ku.Z.locals, Iu("px");
          Iu("px");
          var Zu = n(8894),
            Ju = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Zu.Z, Ju);
          Zu.Z.locals;
          const Xu = new WeakMap();
          function tm(t) {
            const {
                view: e,
                element: n,
                text: i,
                isDirectHost: o = !0,
                keepOnFocus: r = !1,
              } = t,
              s = e.document;
            Xu.has(s) ||
              (Xu.set(s, new Map()), s.registerPostFixer((t) => nm(s, t))),
              Xu.get(s).set(n, {
                text: i,
                isDirectHost: o,
                keepOnFocus: r,
                hostElement: o ? n : null,
              }),
              e.change((t) => nm(s, t));
          }
          function em(t, e) {
            return (
              !!e.hasClass("ck-placeholder") &&
              (t.removeClass("ck-placeholder", e), !0)
            );
          }
          function nm(t, e) {
            const n = Xu.get(t),
              i = [];
            let o = !1;
            for (const [t, r] of n)
              r.isDirectHost && (i.push(t), im(e, t, r) && (o = !0));
            for (const [t, r] of n) {
              if (r.isDirectHost) continue;
              const n = om(t);
              n &&
                (i.includes(n) ||
                  ((r.hostElement = n), im(e, t, r) && (o = !0)));
            }
            return o;
          }
          function im(t, e, n) {
            const { text: i, isDirectHost: o, hostElement: r } = n;
            let s = !1;
            r.getAttribute("data-placeholder") !== i &&
              (t.setAttribute("data-placeholder", i, r), (s = !0));
            return (
              (o || 1 == e.childCount) &&
              (function (t, e) {
                if (!t.isAttached()) return !1;
                const n = Array.from(t.getChildren()).some(
                  (t) => !t.is("uiElement")
                );
                if (n) return !1;
                if (e) return !0;
                const i = t.document;
                if (!i.isFocused) return !0;
                const o = i.selection.anchor;
                return o && o.parent !== t;
              })(r, n.keepOnFocus)
                ? (function (t, e) {
                    return (
                      !e.hasClass("ck-placeholder") &&
                      (t.addClass("ck-placeholder", e), !0)
                    );
                  })(t, r) && (s = !0)
                : em(t, r) && (s = !0),
              s
            );
          }
          function om(t) {
            if (t.childCount) {
              const e = t.getChild(0);
              if (
                e.is("element") &&
                !e.is("uiElement") &&
                !e.is("attributeElement")
              )
                return e;
            }
            return null;
          }
          const rm = new Map();
          function sm(t, e, n) {
            let i = rm.get(t);
            i || ((i = new Map()), rm.set(t, i)), i.set(e, n);
          }
          function am(t) {
            return [t];
          }
          function cm(t, e, n = {}) {
            const i = (function (t, e) {
              const n = rm.get(t);
              return n && n.has(e) ? n.get(e) : am;
            })(t.constructor, e.constructor);
            try {
              return i((t = t.clone()), e, n);
            } catch (t) {
              throw t;
            }
          }
          function lm(t, e, n) {
            (t = t.slice()), (e = e.slice());
            const i = new dm(n.document, n.useRelations, n.forceWeakRemove);
            i.setOriginalOperations(t), i.setOriginalOperations(e);
            const o = i.originalOperations;
            if (0 == t.length || 0 == e.length)
              return { operationsA: t, operationsB: e, originalOperations: o };
            const r = new WeakMap();
            for (const e of t) r.set(e, 0);
            const s = {
              nextBaseVersionA: t[t.length - 1].baseVersion + 1,
              nextBaseVersionB: e[e.length - 1].baseVersion + 1,
              originalOperationsACount: t.length,
              originalOperationsBCount: e.length,
            };
            let a = 0;
            for (; a < t.length; ) {
              const n = t[a],
                o = r.get(n);
              if (o == e.length) {
                a++;
                continue;
              }
              const s = e[o],
                c = cm(n, s, i.getContext(n, s, !0)),
                l = cm(s, n, i.getContext(s, n, !1));
              i.updateRelation(n, s),
                i.setOriginalOperations(c, n),
                i.setOriginalOperations(l, s);
              for (const t of c) r.set(t, o + l.length);
              t.splice(a, 1, ...c), e.splice(o, 1, ...l);
            }
            if (n.padWithNoOps) {
              const n = t.length - s.originalOperationsACount,
                i = e.length - s.originalOperationsBCount;
              um(t, i - n), um(e, n - i);
            }
            return (
              hm(t, s.nextBaseVersionB),
              hm(e, s.nextBaseVersionA),
              { operationsA: t, operationsB: e, originalOperations: o }
            );
          }
          class dm {
            constructor(t, e, n = !1) {
              (this.originalOperations = new Map()),
                (this._history = t.history),
                (this._useRelations = e),
                (this._forceWeakRemove = !!n),
                (this._relations = new Map());
            }
            setOriginalOperations(t, e = null) {
              const n = e ? this.originalOperations.get(e) : null;
              for (const e of t) this.originalOperations.set(e, n || e);
            }
            updateRelation(t, e) {
              switch (t.constructor) {
                case xl:
                  switch (e.constructor) {
                    case Tl:
                      t.targetPosition.isEqual(e.sourcePosition) ||
                      e.movedRange.containsPosition(t.targetPosition)
                        ? this._setRelation(t, e, "insertAtSource")
                        : t.targetPosition.isEqual(e.deletionPosition)
                        ? this._setRelation(t, e, "insertBetween")
                        : t.targetPosition.isAfter(e.sourcePosition) &&
                          this._setRelation(t, e, "moveTargetAfter");
                      break;
                    case xl:
                      t.targetPosition.isEqual(e.sourcePosition) ||
                      t.targetPosition.isBefore(e.sourcePosition)
                        ? this._setRelation(t, e, "insertBefore")
                        : this._setRelation(t, e, "insertAfter");
                  }
                  break;
                case Ml:
                  switch (e.constructor) {
                    case Tl:
                      t.splitPosition.isBefore(e.sourcePosition) &&
                        this._setRelation(t, e, "splitBefore");
                      break;
                    case xl:
                      if (
                        t.splitPosition.isEqual(e.sourcePosition) ||
                        t.splitPosition.isBefore(e.sourcePosition)
                      )
                        this._setRelation(t, e, "splitBefore");
                      else {
                        const n = Qa._createFromPositionAndShift(
                          e.sourcePosition,
                          e.howMany
                        );
                        if (
                          t.splitPosition.hasSameParentAs(e.sourcePosition) &&
                          n.containsPosition(t.splitPosition)
                        ) {
                          const i = n.end.offset - t.splitPosition.offset,
                            o = t.splitPosition.offset - n.start.offset;
                          this._setRelation(t, e, { howMany: i, offset: o });
                        }
                      }
                  }
                  break;
                case Tl:
                  switch (e.constructor) {
                    case Tl:
                      t.targetPosition.isEqual(e.sourcePosition) ||
                        this._setRelation(t, e, "mergeTargetNotMoved"),
                        t.sourcePosition.isEqual(e.targetPosition) &&
                          this._setRelation(t, e, "mergeSourceNotMoved"),
                        t.sourcePosition.isEqual(e.sourcePosition) &&
                          this._setRelation(t, e, "mergeSameElement");
                      break;
                    case Ml:
                      t.sourcePosition.isEqual(e.splitPosition) &&
                        this._setRelation(t, e, "splitAtSource");
                  }
                  break;
                case Dl: {
                  const n = t.newRange;
                  if (!n) return;
                  switch (e.constructor) {
                    case xl: {
                      const i = Qa._createFromPositionAndShift(
                          e.sourcePosition,
                          e.howMany
                        ),
                        o =
                          i.containsPosition(n.start) ||
                          i.start.isEqual(n.start),
                        r = i.containsPosition(n.end) || i.end.isEqual(n.end);
                      (!o && !r) ||
                        i.containsRange(n) ||
                        this._setRelation(t, e, {
                          side: o ? "left" : "right",
                          path: o ? n.start.path.slice() : n.end.path.slice(),
                        });
                      break;
                    }
                    case Tl: {
                      const i = n.start.isEqual(e.targetPosition),
                        o = n.start.isEqual(e.deletionPosition),
                        r = n.end.isEqual(e.deletionPosition),
                        s = n.end.isEqual(e.sourcePosition);
                      (i || o || r || s) &&
                        this._setRelation(t, e, {
                          wasInLeftElement: i,
                          wasStartBeforeMergedElement: o,
                          wasEndBeforeMergedElement: r,
                          wasInRightElement: s,
                        });
                      break;
                    }
                  }
                  break;
                }
              }
            }
            getContext(t, e, n) {
              return {
                aIsStrong: n,
                aWasUndone: this._wasUndone(t),
                bWasUndone: this._wasUndone(e),
                abRelation: this._useRelations ? this._getRelation(t, e) : null,
                baRelation: this._useRelations ? this._getRelation(e, t) : null,
                forceWeakRemove: this._forceWeakRemove,
              };
            }
            _wasUndone(t) {
              const e = this.originalOperations.get(t);
              return e.wasUndone || this._history.isUndoneOperation(e);
            }
            _getRelation(t, e) {
              const n = this.originalOperations.get(e),
                i = this._history.getUndoneOperation(n);
              if (!i) return null;
              const o = this.originalOperations.get(t),
                r = this._relations.get(o);
              return (r && r.get(i)) || null;
            }
            _setRelation(t, e, n) {
              const i = this.originalOperations.get(t),
                o = this.originalOperations.get(e);
              let r = this._relations.get(i);
              r || ((r = new Map()), this._relations.set(i, r)), r.set(o, n);
            }
          }
          function hm(t, e) {
            for (const n of t) n.baseVersion = e++;
          }
          function um(t, e) {
            for (let n = 0; n < e; n++) t.push(new Xl(0));
          }
          function mm(t, e, n) {
            const i = t.nodes.getNode(0).getAttribute(e);
            if (i == n) return null;
            const o = new Qa(t.position, t.position.getShiftedBy(t.howMany));
            return new vl(o, e, i, n, 0);
          }
          function gm(t, e) {
            return (
              null ===
              t.targetPosition._getTransformedByDeletion(
                e.sourcePosition,
                e.howMany
              )
            );
          }
          function pm(t, e) {
            const n = [];
            for (let i = 0; i < t.length; i++) {
              const o = t[i],
                r = new xl(o.start, o.end.offset - o.start.offset, e, 0);
              n.push(r);
              for (let e = i + 1; e < t.length; e++)
                t[e] = t[e]._getTransformedByMove(
                  r.sourcePosition,
                  r.targetPosition,
                  r.howMany
                )[0];
              e = e._getTransformedByMove(
                r.sourcePosition,
                r.targetPosition,
                r.howMany
              );
            }
            return n;
          }
          sm(vl, vl, (t, e, n) => {
            if (
              t.key === e.key &&
              t.range.start.hasSameParentAs(e.range.start)
            ) {
              const i = t.range
                  .getDifference(e.range)
                  .map((e) => new vl(e, t.key, t.oldValue, t.newValue, 0)),
                o = t.range.getIntersection(e.range);
              return (
                o &&
                  n.aIsStrong &&
                  i.push(new vl(o, e.key, e.newValue, t.newValue, 0)),
                0 == i.length ? [new Xl(0)] : i
              );
            }
            return [t];
          }),
            sm(vl, El, (t, e) => {
              if (
                t.range.start.hasSameParentAs(e.position) &&
                t.range.containsPosition(e.position)
              ) {
                const n = t.range
                  ._getTransformedByInsertion(
                    e.position,
                    e.howMany,
                    !e.shouldReceiveAttributes
                  )
                  .map(
                    (e) =>
                      new vl(e, t.key, t.oldValue, t.newValue, t.baseVersion)
                  );
                if (e.shouldReceiveAttributes) {
                  const i = mm(e, t.key, t.oldValue);
                  i && n.unshift(i);
                }
                return n;
              }
              return (
                (t.range = t.range._getTransformedByInsertion(
                  e.position,
                  e.howMany,
                  !1
                )[0]),
                [t]
              );
            }),
            sm(vl, Tl, (t, e) => {
              const n = [];
              t.range.start.hasSameParentAs(e.deletionPosition) &&
                (t.range.containsPosition(e.deletionPosition) ||
                  t.range.start.isEqual(e.deletionPosition)) &&
                n.push(Qa._createFromPositionAndShift(e.graveyardPosition, 1));
              const i = t.range._getTransformedByMergeOperation(e);
              return (
                i.isCollapsed || n.push(i),
                n.map(
                  (e) => new vl(e, t.key, t.oldValue, t.newValue, t.baseVersion)
                )
              );
            }),
            sm(vl, xl, (t, e) => {
              const n = (function (t, e) {
                const n = Qa._createFromPositionAndShift(
                  e.sourcePosition,
                  e.howMany
                );
                let i = null,
                  o = [];
                n.containsRange(t, !0)
                  ? (i = t)
                  : t.start.hasSameParentAs(n.start)
                  ? ((o = t.getDifference(n)), (i = t.getIntersection(n)))
                  : (o = [t]);
                const r = [];
                for (let t of o) {
                  t = t._getTransformedByDeletion(e.sourcePosition, e.howMany);
                  const n = e.getMovedRangeStart(),
                    i = t.start.hasSameParentAs(n);
                  (t = t._getTransformedByInsertion(n, e.howMany, i)),
                    r.push(...t);
                }
                i &&
                  r.push(
                    i._getTransformedByMove(
                      e.sourcePosition,
                      e.targetPosition,
                      e.howMany,
                      !1
                    )[0]
                  );
                return r;
              })(t.range, e);
              return n.map(
                (e) => new vl(e, t.key, t.oldValue, t.newValue, t.baseVersion)
              );
            }),
            sm(vl, Ml, (t, e) => {
              if (t.range.end.isEqual(e.insertionPosition))
                return e.graveyardPosition || t.range.end.offset++, [t];
              if (
                t.range.start.hasSameParentAs(e.splitPosition) &&
                t.range.containsPosition(e.splitPosition)
              ) {
                const n = t.clone();
                return (
                  (n.range = new Qa(
                    e.moveTargetPosition.clone(),
                    t.range.end._getCombined(
                      e.splitPosition,
                      e.moveTargetPosition
                    )
                  )),
                  (t.range.end = e.splitPosition.clone()),
                  (t.range.end.stickiness = "toPrevious"),
                  [t, n]
                );
              }
              return (
                (t.range = t.range._getTransformedBySplitOperation(e)), [t]
              );
            }),
            sm(El, vl, (t, e) => {
              const n = [t];
              if (
                t.shouldReceiveAttributes &&
                t.position.hasSameParentAs(e.range.start) &&
                e.range.containsPosition(t.position)
              ) {
                const i = mm(t, e.key, e.newValue);
                i && n.push(i);
              }
              return n;
            }),
            sm(
              El,
              El,
              (t, e, n) => (
                (t.position.isEqual(e.position) && n.aIsStrong) ||
                  (t.position = t.position._getTransformedByInsertOperation(e)),
                [t]
              )
            ),
            sm(
              El,
              xl,
              (t, e) => (
                (t.position = t.position._getTransformedByMoveOperation(e)), [t]
              )
            ),
            sm(
              El,
              Ml,
              (t, e) => (
                (t.position = t.position._getTransformedBySplitOperation(e)),
                [t]
              )
            ),
            sm(
              El,
              Tl,
              (t, e) => (
                (t.position = t.position._getTransformedByMergeOperation(e)),
                [t]
              )
            ),
            sm(
              Dl,
              El,
              (t, e) => (
                t.oldRange &&
                  (t.oldRange =
                    t.oldRange._getTransformedByInsertOperation(e)[0]),
                t.newRange &&
                  (t.newRange =
                    t.newRange._getTransformedByInsertOperation(e)[0]),
                [t]
              )
            ),
            sm(Dl, Dl, (t, e, n) => {
              if (t.name == e.name) {
                if (!n.aIsStrong) return [new Xl(0)];
                t.oldRange = e.newRange ? e.newRange.clone() : null;
              }
              return [t];
            }),
            sm(
              Dl,
              Tl,
              (t, e) => (
                t.oldRange &&
                  (t.oldRange = t.oldRange._getTransformedByMergeOperation(e)),
                t.newRange &&
                  (t.newRange = t.newRange._getTransformedByMergeOperation(e)),
                [t]
              )
            ),
            sm(Dl, xl, (t, e, n) => {
              if (
                (t.oldRange &&
                  (t.oldRange = Qa._createFromRanges(
                    t.oldRange._getTransformedByMoveOperation(e)
                  )),
                t.newRange)
              ) {
                if (n.abRelation) {
                  const i = Qa._createFromRanges(
                    t.newRange._getTransformedByMoveOperation(e)
                  );
                  if (
                    "left" == n.abRelation.side &&
                    e.targetPosition.isEqual(t.newRange.start)
                  )
                    return (
                      (t.newRange.start.path = n.abRelation.path),
                      (t.newRange.end = i.end),
                      [t]
                    );
                  if (
                    "right" == n.abRelation.side &&
                    e.targetPosition.isEqual(t.newRange.end)
                  )
                    return (
                      (t.newRange.start = i.start),
                      (t.newRange.end.path = n.abRelation.path),
                      [t]
                    );
                }
                t.newRange = Qa._createFromRanges(
                  t.newRange._getTransformedByMoveOperation(e)
                );
              }
              return [t];
            }),
            sm(Dl, Ml, (t, e, n) => {
              if (
                (t.oldRange &&
                  (t.oldRange = t.oldRange._getTransformedBySplitOperation(e)),
                t.newRange)
              ) {
                if (n.abRelation) {
                  const i = t.newRange._getTransformedBySplitOperation(e);
                  return (
                    t.newRange.start.isEqual(e.splitPosition) &&
                    n.abRelation.wasStartBeforeMergedElement
                      ? (t.newRange.start = Ga._createAt(e.insertionPosition))
                      : t.newRange.start.isEqual(e.splitPosition) &&
                        !n.abRelation.wasInLeftElement &&
                        (t.newRange.start = Ga._createAt(e.moveTargetPosition)),
                    t.newRange.end.isEqual(e.splitPosition) &&
                    n.abRelation.wasInRightElement
                      ? (t.newRange.end = Ga._createAt(e.moveTargetPosition))
                      : t.newRange.end.isEqual(e.splitPosition) &&
                        n.abRelation.wasEndBeforeMergedElement
                      ? (t.newRange.end = Ga._createAt(e.insertionPosition))
                      : (t.newRange.end = i.end),
                    [t]
                  );
                }
                t.newRange = t.newRange._getTransformedBySplitOperation(e);
              }
              return [t];
            }),
            sm(
              Tl,
              El,
              (t, e) => (
                t.sourcePosition.hasSameParentAs(e.position) &&
                  (t.howMany += e.howMany),
                (t.sourcePosition =
                  t.sourcePosition._getTransformedByInsertOperation(e)),
                (t.targetPosition =
                  t.targetPosition._getTransformedByInsertOperation(e)),
                [t]
              )
            ),
            sm(Tl, Tl, (t, e, n) => {
              if (
                t.sourcePosition.isEqual(e.sourcePosition) &&
                t.targetPosition.isEqual(e.targetPosition)
              ) {
                if (n.bWasUndone) {
                  const n = e.graveyardPosition.path.slice();
                  return (
                    n.push(0),
                    (t.sourcePosition = new Ga(e.graveyardPosition.root, n)),
                    (t.howMany = 0),
                    [t]
                  );
                }
                return [new Xl(0)];
              }
              if (
                t.sourcePosition.isEqual(e.sourcePosition) &&
                !t.targetPosition.isEqual(e.targetPosition) &&
                !n.bWasUndone &&
                "splitAtSource" != n.abRelation
              ) {
                const i = "$graveyard" == t.targetPosition.root.rootName,
                  o = "$graveyard" == e.targetPosition.root.rootName,
                  r = i && !o;
                if ((o && !i) || (!r && n.aIsStrong)) {
                  const n = e.targetPosition._getTransformedByMergeOperation(e),
                    i = t.targetPosition._getTransformedByMergeOperation(e);
                  return [new xl(n, t.howMany, i, 0)];
                }
                return [new Xl(0)];
              }
              return (
                t.sourcePosition.hasSameParentAs(e.targetPosition) &&
                  (t.howMany += e.howMany),
                (t.sourcePosition =
                  t.sourcePosition._getTransformedByMergeOperation(e)),
                (t.targetPosition =
                  t.targetPosition._getTransformedByMergeOperation(e)),
                (t.graveyardPosition.isEqual(e.graveyardPosition) &&
                  n.aIsStrong) ||
                  (t.graveyardPosition =
                    t.graveyardPosition._getTransformedByMergeOperation(e)),
                [t]
              );
            }),
            sm(Tl, xl, (t, e, n) => {
              const i = Qa._createFromPositionAndShift(
                e.sourcePosition,
                e.howMany
              );
              return "remove" == e.type &&
                !n.bWasUndone &&
                !n.forceWeakRemove &&
                t.deletionPosition.hasSameParentAs(e.sourcePosition) &&
                i.containsPosition(t.sourcePosition)
                ? [new Xl(0)]
                : (t.sourcePosition.hasSameParentAs(e.targetPosition) &&
                    (t.howMany += e.howMany),
                  t.sourcePosition.hasSameParentAs(e.sourcePosition) &&
                    (t.howMany -= e.howMany),
                  (t.sourcePosition =
                    t.sourcePosition._getTransformedByMoveOperation(e)),
                  (t.targetPosition =
                    t.targetPosition._getTransformedByMoveOperation(e)),
                  t.graveyardPosition.isEqual(e.targetPosition) ||
                    (t.graveyardPosition =
                      t.graveyardPosition._getTransformedByMoveOperation(e)),
                  [t]);
            }),
            sm(Tl, Ml, (t, e, n) => {
              if (
                (e.graveyardPosition &&
                  ((t.graveyardPosition =
                    t.graveyardPosition._getTransformedByDeletion(
                      e.graveyardPosition,
                      1
                    )),
                  t.deletionPosition.isEqual(e.graveyardPosition) &&
                    (t.howMany = e.howMany)),
                t.targetPosition.isEqual(e.splitPosition))
              ) {
                const i = 0 != e.howMany,
                  o =
                    e.graveyardPosition &&
                    t.deletionPosition.isEqual(e.graveyardPosition);
                if (i || o || "mergeTargetNotMoved" == n.abRelation)
                  return (
                    (t.sourcePosition =
                      t.sourcePosition._getTransformedBySplitOperation(e)),
                    [t]
                  );
              }
              if (t.sourcePosition.isEqual(e.splitPosition)) {
                if ("mergeSourceNotMoved" == n.abRelation)
                  return (
                    (t.howMany = 0),
                    (t.targetPosition =
                      t.targetPosition._getTransformedBySplitOperation(e)),
                    [t]
                  );
                if (
                  "mergeSameElement" == n.abRelation ||
                  t.sourcePosition.offset > 0
                )
                  return (
                    (t.sourcePosition = e.moveTargetPosition.clone()),
                    (t.targetPosition =
                      t.targetPosition._getTransformedBySplitOperation(e)),
                    [t]
                  );
              }
              return (
                t.sourcePosition.hasSameParentAs(e.splitPosition) &&
                  (t.howMany = e.splitPosition.offset),
                (t.sourcePosition =
                  t.sourcePosition._getTransformedBySplitOperation(e)),
                (t.targetPosition =
                  t.targetPosition._getTransformedBySplitOperation(e)),
                [t]
              );
            }),
            sm(xl, El, (t, e) => {
              const n = Qa._createFromPositionAndShift(
                t.sourcePosition,
                t.howMany
              )._getTransformedByInsertOperation(e, !1)[0];
              return (
                (t.sourcePosition = n.start),
                (t.howMany = n.end.offset - n.start.offset),
                t.targetPosition.isEqual(e.position) ||
                  (t.targetPosition =
                    t.targetPosition._getTransformedByInsertOperation(e)),
                [t]
              );
            }),
            sm(xl, xl, (t, e, n) => {
              const i = Qa._createFromPositionAndShift(
                  t.sourcePosition,
                  t.howMany
                ),
                o = Qa._createFromPositionAndShift(e.sourcePosition, e.howMany);
              let r,
                s = n.aIsStrong,
                a = !n.aIsStrong;
              if (
                ("insertBefore" == n.abRelation || "insertAfter" == n.baRelation
                  ? (a = !0)
                  : ("insertAfter" != n.abRelation &&
                      "insertBefore" != n.baRelation) ||
                    (a = !1),
                (r =
                  t.targetPosition.isEqual(e.targetPosition) && a
                    ? t.targetPosition._getTransformedByDeletion(
                        e.sourcePosition,
                        e.howMany
                      )
                    : t.targetPosition._getTransformedByMove(
                        e.sourcePosition,
                        e.targetPosition,
                        e.howMany
                      )),
                gm(t, e) && gm(e, t))
              )
                return [e.getReversed()];
              if (
                i.containsPosition(e.targetPosition) &&
                i.containsRange(o, !0)
              )
                return (
                  (i.start = i.start._getTransformedByMove(
                    e.sourcePosition,
                    e.targetPosition,
                    e.howMany
                  )),
                  (i.end = i.end._getTransformedByMove(
                    e.sourcePosition,
                    e.targetPosition,
                    e.howMany
                  )),
                  pm([i], r)
                );
              if (
                o.containsPosition(t.targetPosition) &&
                o.containsRange(i, !0)
              )
                return (
                  (i.start = i.start._getCombined(
                    e.sourcePosition,
                    e.getMovedRangeStart()
                  )),
                  (i.end = i.end._getCombined(
                    e.sourcePosition,
                    e.getMovedRangeStart()
                  )),
                  pm([i], r)
                );
              const c = Li(
                t.sourcePosition.getParentPath(),
                e.sourcePosition.getParentPath()
              );
              if ("prefix" == c || "extension" == c)
                return (
                  (i.start = i.start._getTransformedByMove(
                    e.sourcePosition,
                    e.targetPosition,
                    e.howMany
                  )),
                  (i.end = i.end._getTransformedByMove(
                    e.sourcePosition,
                    e.targetPosition,
                    e.howMany
                  )),
                  pm([i], r)
                );
              "remove" != t.type ||
              "remove" == e.type ||
              n.aWasUndone ||
              n.forceWeakRemove
                ? "remove" == t.type ||
                  "remove" != e.type ||
                  n.bWasUndone ||
                  n.forceWeakRemove ||
                  (s = !1)
                : (s = !0);
              const l = [],
                d = i.getDifference(o);
              for (const t of d) {
                (t.start = t.start._getTransformedByDeletion(
                  e.sourcePosition,
                  e.howMany
                )),
                  (t.end = t.end._getTransformedByDeletion(
                    e.sourcePosition,
                    e.howMany
                  ));
                const n =
                    "same" ==
                    Li(
                      t.start.getParentPath(),
                      e.getMovedRangeStart().getParentPath()
                    ),
                  i = t._getTransformedByInsertion(
                    e.getMovedRangeStart(),
                    e.howMany,
                    n
                  );
                l.push(...i);
              }
              const h = i.getIntersection(o);
              return (
                null !== h &&
                  s &&
                  ((h.start = h.start._getCombined(
                    e.sourcePosition,
                    e.getMovedRangeStart()
                  )),
                  (h.end = h.end._getCombined(
                    e.sourcePosition,
                    e.getMovedRangeStart()
                  )),
                  0 === l.length
                    ? l.push(h)
                    : 1 == l.length
                    ? o.start.isBefore(i.start) || o.start.isEqual(i.start)
                      ? l.unshift(h)
                      : l.push(h)
                    : l.splice(1, 0, h)),
                0 === l.length ? [new Xl(t.baseVersion)] : pm(l, r)
              );
            }),
            sm(xl, Ml, (t, e, n) => {
              let i = t.targetPosition.clone();
              (t.targetPosition.isEqual(e.insertionPosition) &&
                e.graveyardPosition &&
                "moveTargetAfter" != n.abRelation) ||
                (i = t.targetPosition._getTransformedBySplitOperation(e));
              const o = Qa._createFromPositionAndShift(
                t.sourcePosition,
                t.howMany
              );
              if (o.end.isEqual(e.insertionPosition))
                return (
                  e.graveyardPosition || t.howMany++,
                  (t.targetPosition = i),
                  [t]
                );
              if (
                o.start.hasSameParentAs(e.splitPosition) &&
                o.containsPosition(e.splitPosition)
              ) {
                let t = new Qa(e.splitPosition, o.end);
                t = t._getTransformedBySplitOperation(e);
                return pm([new Qa(o.start, e.splitPosition), t], i);
              }
              t.targetPosition.isEqual(e.splitPosition) &&
                "insertAtSource" == n.abRelation &&
                (i = e.moveTargetPosition),
                t.targetPosition.isEqual(e.insertionPosition) &&
                  "insertBetween" == n.abRelation &&
                  (i = t.targetPosition);
              const r = [o._getTransformedBySplitOperation(e)];
              if (e.graveyardPosition) {
                const i =
                  o.start.isEqual(e.graveyardPosition) ||
                  o.containsPosition(e.graveyardPosition);
                t.howMany > 1 &&
                  i &&
                  !n.aWasUndone &&
                  r.push(
                    Qa._createFromPositionAndShift(e.insertionPosition, 1)
                  );
              }
              return pm(r, i);
            }),
            sm(xl, Tl, (t, e, n) => {
              const i = Qa._createFromPositionAndShift(
                t.sourcePosition,
                t.howMany
              );
              if (
                e.deletionPosition.hasSameParentAs(t.sourcePosition) &&
                i.containsPosition(e.sourcePosition)
              )
                if ("remove" != t.type || n.forceWeakRemove) {
                  if (1 == t.howMany)
                    return n.bWasUndone
                      ? ((t.sourcePosition = e.graveyardPosition.clone()),
                        (t.targetPosition =
                          t.targetPosition._getTransformedByMergeOperation(e)),
                        [t])
                      : [new Xl(0)];
                } else if (!n.aWasUndone) {
                  const n = [];
                  let i = e.graveyardPosition.clone(),
                    o = e.targetPosition._getTransformedByMergeOperation(e);
                  t.howMany > 1 &&
                    (n.push(
                      new xl(
                        t.sourcePosition,
                        t.howMany - 1,
                        t.targetPosition,
                        0
                      )
                    ),
                    (i = i._getTransformedByMove(
                      t.sourcePosition,
                      t.targetPosition,
                      t.howMany - 1
                    )),
                    (o = o._getTransformedByMove(
                      t.sourcePosition,
                      t.targetPosition,
                      t.howMany - 1
                    )));
                  const r = e.deletionPosition._getCombined(
                      t.sourcePosition,
                      t.targetPosition
                    ),
                    s = new xl(i, 1, r, 0),
                    a = s.getMovedRangeStart().path.slice();
                  a.push(0);
                  const c = new Ga(s.targetPosition.root, a);
                  o = o._getTransformedByMove(i, r, 1);
                  const l = new xl(o, e.howMany, c, 0);
                  return n.push(s), n.push(l), n;
                }
              const o = Qa._createFromPositionAndShift(
                t.sourcePosition,
                t.howMany
              )._getTransformedByMergeOperation(e);
              return (
                (t.sourcePosition = o.start),
                (t.howMany = o.end.offset - o.start.offset),
                (t.targetPosition =
                  t.targetPosition._getTransformedByMergeOperation(e)),
                [t]
              );
            }),
            sm(
              Sl,
              El,
              (t, e) => (
                (t.position = t.position._getTransformedByInsertOperation(e)),
                [t]
              )
            ),
            sm(Sl, Tl, (t, e) =>
              t.position.isEqual(e.deletionPosition)
                ? ((t.position = e.graveyardPosition.clone()),
                  (t.position.stickiness = "toNext"),
                  [t])
                : ((t.position = t.position._getTransformedByMergeOperation(e)),
                  [t])
            ),
            sm(
              Sl,
              xl,
              (t, e) => (
                (t.position = t.position._getTransformedByMoveOperation(e)), [t]
              )
            ),
            sm(Sl, Sl, (t, e, n) => {
              if (t.position.isEqual(e.position)) {
                if (!n.aIsStrong) return [new Xl(0)];
                t.oldName = e.newName;
              }
              return [t];
            }),
            sm(Sl, Ml, (t, e) => {
              if (
                "same" ==
                  Li(t.position.path, e.splitPosition.getParentPath()) &&
                !e.graveyardPosition
              ) {
                const e = new Sl(
                  t.position.getShiftedBy(1),
                  t.oldName,
                  t.newName,
                  0
                );
                return [t, e];
              }
              return (
                (t.position = t.position._getTransformedBySplitOperation(e)),
                [t]
              );
            }),
            sm(Il, Il, (t, e, n) => {
              if (t.root === e.root && t.key === e.key) {
                if (!n.aIsStrong || t.newValue === e.newValue)
                  return [new Xl(0)];
                t.oldValue = e.newValue;
              }
              return [t];
            }),
            sm(
              Ml,
              El,
              (t, e) => (
                t.splitPosition.hasSameParentAs(e.position) &&
                  t.splitPosition.offset < e.position.offset &&
                  (t.howMany += e.howMany),
                (t.splitPosition =
                  t.splitPosition._getTransformedByInsertOperation(e)),
                (t.insertionPosition =
                  t.insertionPosition._getTransformedByInsertOperation(e)),
                [t]
              )
            ),
            sm(Ml, Tl, (t, e, n) => {
              if (
                !t.graveyardPosition &&
                !n.bWasUndone &&
                t.splitPosition.hasSameParentAs(e.sourcePosition)
              ) {
                const n = e.graveyardPosition.path.slice();
                n.push(0);
                const i = new Ga(e.graveyardPosition.root, n),
                  o = Ml.getInsertionPosition(
                    new Ga(e.graveyardPosition.root, n)
                  ),
                  r = new Ml(i, 0, o, null, 0);
                return (
                  (t.splitPosition =
                    t.splitPosition._getTransformedByMergeOperation(e)),
                  (t.insertionPosition = Ml.getInsertionPosition(
                    t.splitPosition
                  )),
                  (t.graveyardPosition = r.insertionPosition.clone()),
                  (t.graveyardPosition.stickiness = "toNext"),
                  [r, t]
                );
              }
              return (
                t.splitPosition.hasSameParentAs(e.deletionPosition) &&
                  !t.splitPosition.isAfter(e.deletionPosition) &&
                  t.howMany--,
                t.splitPosition.hasSameParentAs(e.targetPosition) &&
                  (t.howMany += e.howMany),
                (t.splitPosition =
                  t.splitPosition._getTransformedByMergeOperation(e)),
                (t.insertionPosition = Ml.getInsertionPosition(
                  t.splitPosition
                )),
                t.graveyardPosition &&
                  (t.graveyardPosition =
                    t.graveyardPosition._getTransformedByMergeOperation(e)),
                [t]
              );
            }),
            sm(Ml, xl, (t, e, n) => {
              const i = Qa._createFromPositionAndShift(
                e.sourcePosition,
                e.howMany
              );
              if (t.graveyardPosition) {
                const o =
                  i.start.isEqual(t.graveyardPosition) ||
                  i.containsPosition(t.graveyardPosition);
                if (!n.bWasUndone && o) {
                  const n = t.splitPosition._getTransformedByMoveOperation(e),
                    i = t.graveyardPosition._getTransformedByMoveOperation(e),
                    o = i.path.slice();
                  o.push(0);
                  const r = new Ga(i.root, o);
                  return [new xl(n, t.howMany, r, 0)];
                }
                t.graveyardPosition =
                  t.graveyardPosition._getTransformedByMoveOperation(e);
              }
              const o = t.splitPosition.isEqual(e.targetPosition);
              if (
                o &&
                ("insertAtSource" == n.baRelation ||
                  "splitBefore" == n.abRelation)
              )
                return (
                  (t.howMany += e.howMany),
                  (t.splitPosition = t.splitPosition._getTransformedByDeletion(
                    e.sourcePosition,
                    e.howMany
                  )),
                  (t.insertionPosition = Ml.getInsertionPosition(
                    t.splitPosition
                  )),
                  [t]
                );
              if (o && n.abRelation && n.abRelation.howMany) {
                const { howMany: e, offset: i } = n.abRelation;
                return (
                  (t.howMany += e),
                  (t.splitPosition = t.splitPosition.getShiftedBy(i)),
                  [t]
                );
              }
              if (
                t.splitPosition.hasSameParentAs(e.sourcePosition) &&
                i.containsPosition(t.splitPosition)
              ) {
                const n =
                  e.howMany -
                  (t.splitPosition.offset - e.sourcePosition.offset);
                return (
                  (t.howMany -= n),
                  t.splitPosition.hasSameParentAs(e.targetPosition) &&
                    t.splitPosition.offset < e.targetPosition.offset &&
                    (t.howMany += e.howMany),
                  (t.splitPosition = e.sourcePosition.clone()),
                  (t.insertionPosition = Ml.getInsertionPosition(
                    t.splitPosition
                  )),
                  [t]
                );
              }
              return (
                e.sourcePosition.isEqual(e.targetPosition) ||
                  (t.splitPosition.hasSameParentAs(e.sourcePosition) &&
                    t.splitPosition.offset <= e.sourcePosition.offset &&
                    (t.howMany -= e.howMany),
                  t.splitPosition.hasSameParentAs(e.targetPosition) &&
                    t.splitPosition.offset < e.targetPosition.offset &&
                    (t.howMany += e.howMany)),
                (t.splitPosition.stickiness = "toNone"),
                (t.splitPosition =
                  t.splitPosition._getTransformedByMoveOperation(e)),
                (t.splitPosition.stickiness = "toNext"),
                t.graveyardPosition
                  ? (t.insertionPosition =
                      t.insertionPosition._getTransformedByMoveOperation(e))
                  : (t.insertionPosition = Ml.getInsertionPosition(
                      t.splitPosition
                    )),
                [t]
              );
            }),
            sm(Ml, Ml, (t, e, n) => {
              if (t.splitPosition.isEqual(e.splitPosition)) {
                if (!t.graveyardPosition && !e.graveyardPosition)
                  return [new Xl(0)];
                if (
                  t.graveyardPosition &&
                  e.graveyardPosition &&
                  t.graveyardPosition.isEqual(e.graveyardPosition)
                )
                  return [new Xl(0)];
                if ("splitBefore" == n.abRelation)
                  return (
                    (t.howMany = 0),
                    (t.graveyardPosition =
                      t.graveyardPosition._getTransformedBySplitOperation(e)),
                    [t]
                  );
              }
              if (
                t.graveyardPosition &&
                e.graveyardPosition &&
                t.graveyardPosition.isEqual(e.graveyardPosition)
              ) {
                const i = "$graveyard" == t.splitPosition.root.rootName,
                  o = "$graveyard" == e.splitPosition.root.rootName,
                  r = i && !o;
                if ((o && !i) || (!r && n.aIsStrong)) {
                  const n = [];
                  return (
                    e.howMany &&
                      n.push(
                        new xl(
                          e.moveTargetPosition,
                          e.howMany,
                          e.splitPosition,
                          0
                        )
                      ),
                    t.howMany &&
                      n.push(
                        new xl(
                          t.splitPosition,
                          t.howMany,
                          t.moveTargetPosition,
                          0
                        )
                      ),
                    n
                  );
                }
                return [new Xl(0)];
              }
              if (
                (t.graveyardPosition &&
                  (t.graveyardPosition =
                    t.graveyardPosition._getTransformedBySplitOperation(e)),
                t.splitPosition.isEqual(e.insertionPosition) &&
                  "splitBefore" == n.abRelation)
              )
                return t.howMany++, [t];
              if (
                e.splitPosition.isEqual(t.insertionPosition) &&
                "splitBefore" == n.baRelation
              ) {
                const n = e.insertionPosition.path.slice();
                n.push(0);
                const i = new Ga(e.insertionPosition.root, n);
                return [t, new xl(t.insertionPosition, 1, i, 0)];
              }
              return (
                t.splitPosition.hasSameParentAs(e.splitPosition) &&
                  t.splitPosition.offset < e.splitPosition.offset &&
                  (t.howMany -= e.howMany),
                (t.splitPosition =
                  t.splitPosition._getTransformedBySplitOperation(e)),
                (t.insertionPosition = Ml.getInsertionPosition(
                  t.splitPosition
                )),
                [t]
              );
            });
          class fm extends qs {
            constructor(t) {
              super(t), (this.domEventType = "click");
            }
            onDomEvent(t) {
              this.fire(t.type, t);
            }
          }
          class km extends qs {
            constructor(t) {
              super(t),
                (this.domEventType = [
                  "mousedown",
                  "mouseup",
                  "mouseover",
                  "mouseout",
                ]);
            }
            onDomEvent(t) {
              this.fire(t.type, t);
            }
          }
          class bm {
            constructor(t) {
              this.document = t;
            }
            createDocumentFragment(t) {
              return new _r(this.document, t);
            }
            createElement(t, e, n) {
              return new To(this.document, t, e, n);
            }
            createText(t) {
              return new ji(this.document, t);
            }
            clone(t, e = !1) {
              return t._clone(e);
            }
            appendChild(t, e) {
              return e._appendChild(t);
            }
            insertChild(t, e, n) {
              return n._insertChild(t, e);
            }
            removeChildren(t, e, n) {
              return n._removeChildren(t, e);
            }
            remove(t) {
              const e = t.parent;
              return e ? this.removeChildren(e.getChildIndex(t), 1, e) : [];
            }
            replace(t, e) {
              const n = t.parent;
              if (n) {
                const i = n.getChildIndex(t);
                return (
                  this.removeChildren(i, 1, n), this.insertChild(i, e, n), !0
                );
              }
              return !1;
            }
            unwrapElement(t) {
              const e = t.parent;
              if (e) {
                const n = e.getChildIndex(t);
                this.remove(t), this.insertChild(n, t.getChildren(), e);
              }
            }
            rename(t, e) {
              const n = new To(
                this.document,
                t,
                e.getAttributes(),
                e.getChildren()
              );
              return this.replace(e, n) ? n : null;
            }
            setAttribute(t, e, n) {
              n._setAttribute(t, e);
            }
            removeAttribute(t, e) {
              e._removeAttribute(t);
            }
            addClass(t, e) {
              e._addClass(t);
            }
            removeClass(t, e) {
              e._removeClass(t);
            }
            setStyle(t, e, n) {
              ye(t) && void 0 === n && (n = e), n._setStyle(t, e);
            }
            removeStyle(t, e) {
              e._removeStyle(t);
            }
            setCustomProperty(t, e, n) {
              n._setCustomProperty(t, e);
            }
            removeCustomProperty(t, e) {
              return e._removeCustomProperty(t);
            }
            createPositionAt(t, e) {
              return Oo._createAt(t, e);
            }
            createPositionAfter(t) {
              return Oo._createAfter(t);
            }
            createPositionBefore(t) {
              return Oo._createBefore(t);
            }
            createRange(t, e) {
              return new jo(t, e);
            }
            createRangeOn(t) {
              return jo._createOn(t);
            }
            createRangeIn(t) {
              return jo._createIn(t);
            }
            createSelection(t, e, n) {
              return new Ho(t, e, n);
            }
          }
          const wm = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i,
            Am = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i,
            _m =
              /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i,
            Cm =
              /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i,
            vm =
              /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i,
            ym = new Set([
              "black",
              "silver",
              "gray",
              "white",
              "maroon",
              "red",
              "purple",
              "fuchsia",
              "green",
              "lime",
              "olive",
              "yellow",
              "navy",
              "blue",
              "teal",
              "aqua",
              "orange",
              "aliceblue",
              "antiquewhite",
              "aquamarine",
              "azure",
              "beige",
              "bisque",
              "blanchedalmond",
              "blueviolet",
              "brown",
              "burlywood",
              "cadetblue",
              "chartreuse",
              "chocolate",
              "coral",
              "cornflowerblue",
              "cornsilk",
              "crimson",
              "cyan",
              "darkblue",
              "darkcyan",
              "darkgoldenrod",
              "darkgray",
              "darkgreen",
              "darkgrey",
              "darkkhaki",
              "darkmagenta",
              "darkolivegreen",
              "darkorange",
              "darkorchid",
              "darkred",
              "darksalmon",
              "darkseagreen",
              "darkslateblue",
              "darkslategray",
              "darkslategrey",
              "darkturquoise",
              "darkviolet",
              "deeppink",
              "deepskyblue",
              "dimgray",
              "dimgrey",
              "dodgerblue",
              "firebrick",
              "floralwhite",
              "forestgreen",
              "gainsboro",
              "ghostwhite",
              "gold",
              "goldenrod",
              "greenyellow",
              "grey",
              "honeydew",
              "hotpink",
              "indianred",
              "indigo",
              "ivory",
              "khaki",
              "lavender",
              "lavenderblush",
              "lawngreen",
              "lemonchiffon",
              "lightblue",
              "lightcoral",
              "lightcyan",
              "lightgoldenrodyellow",
              "lightgray",
              "lightgreen",
              "lightgrey",
              "lightpink",
              "lightsalmon",
              "lightseagreen",
              "lightskyblue",
              "lightslategray",
              "lightslategrey",
              "lightsteelblue",
              "lightyellow",
              "limegreen",
              "linen",
              "magenta",
              "mediumaquamarine",
              "mediumblue",
              "mediumorchid",
              "mediumpurple",
              "mediumseagreen",
              "mediumslateblue",
              "mediumspringgreen",
              "mediumturquoise",
              "mediumvioletred",
              "midnightblue",
              "mintcream",
              "mistyrose",
              "moccasin",
              "navajowhite",
              "oldlace",
              "olivedrab",
              "orangered",
              "orchid",
              "palegoldenrod",
              "palegreen",
              "paleturquoise",
              "palevioletred",
              "papayawhip",
              "peachpuff",
              "peru",
              "pink",
              "plum",
              "powderblue",
              "rosybrown",
              "royalblue",
              "saddlebrown",
              "salmon",
              "sandybrown",
              "seagreen",
              "seashell",
              "sienna",
              "skyblue",
              "slateblue",
              "slategray",
              "slategrey",
              "snow",
              "springgreen",
              "steelblue",
              "tan",
              "thistle",
              "tomato",
              "turquoise",
              "violet",
              "wheat",
              "whitesmoke",
              "yellowgreen",
              "activeborder",
              "activecaption",
              "appworkspace",
              "background",
              "buttonface",
              "buttonhighlight",
              "buttonshadow",
              "buttontext",
              "captiontext",
              "graytext",
              "highlight",
              "highlighttext",
              "inactiveborder",
              "inactivecaption",
              "inactivecaptiontext",
              "infobackground",
              "infotext",
              "menu",
              "menutext",
              "scrollbar",
              "threeddarkshadow",
              "threedface",
              "threedhighlight",
              "threedlightshadow",
              "threedshadow",
              "window",
              "windowframe",
              "windowtext",
              "rebeccapurple",
              "currentcolor",
              "transparent",
            ]);
          function xm(t) {
            return t.startsWith("#")
              ? wm.test(t)
              : t.startsWith("rgb")
              ? Am.test(t) || _m.test(t)
              : t.startsWith("hsl")
              ? Cm.test(t) || vm.test(t)
              : ym.has(t.toLowerCase());
          }
          const Em = [
            "repeat-x",
            "repeat-y",
            "repeat",
            "space",
            "round",
            "no-repeat",
          ];
          const Dm = ["center", "top", "bottom", "left", "right"];
          function Sm(t) {
            return Dm.includes(t);
          }
          const Im = ["fixed", "scroll", "local"];
          function Tm(t) {
            return Im.includes(t);
          }
          const Mm = /^url\(/;
          function Bm(t) {
            return Mm.test(t);
          }
          function Nm(t = "") {
            if ("" === t)
              return {
                top: void 0,
                right: void 0,
                bottom: void 0,
                left: void 0,
              };
            const e = Pm(t),
              n = e[0],
              i = e[2] || n,
              o = e[1] || n;
            return { top: n, bottom: i, right: o, left: e[3] || o };
          }
          function zm({ top: t, right: e, bottom: n, left: i }) {
            const o = [];
            return (
              i !== e
                ? o.push(t, e, n, i)
                : n !== t
                ? o.push(t, e, n)
                : e !== t
                ? o.push(t, e)
                : o.push(t),
              o.join(" ")
            );
          }
          function Pm(t) {
            return t
              .replace(/, /g, ",")
              .split(" ")
              .map((t) => t.replace(/,/g, ", "));
          }
          function Lm(t) {
            t.setNormalizer("background", Rm),
              t.setNormalizer("background-color", (t) => ({
                path: "background.color",
                value: t,
              })),
              t.setReducer("background", (t) => {
                const e = [];
                return e.push(["background-color", t.color]), e;
              }),
              t.setStyleRelation("background", ["background-color"]);
          }
          function Rm(t) {
            const e = {},
              n = Pm(t);
            for (const t of n)
              (i = t),
                Em.includes(i)
                  ? ((e.repeat = e.repeat || []), e.repeat.push(t))
                  : Sm(t)
                  ? ((e.position = e.position || []), e.position.push(t))
                  : Tm(t)
                  ? (e.attachment = t)
                  : xm(t)
                  ? (e.color = t)
                  : Bm(t) && (e.image = t);
            var i;
            return { path: "background", value: e };
          }
          function Om(t) {
            var e, n;
            t.setNormalizer(
              "margin",
              ((e = "margin"), (t) => ({ path: e, value: Nm(t) }))
            ),
              t.setNormalizer("margin-top", (t) => ({
                path: "margin.top",
                value: t,
              })),
              t.setNormalizer("margin-right", (t) => ({
                path: "margin.right",
                value: t,
              })),
              t.setNormalizer("margin-bottom", (t) => ({
                path: "margin.bottom",
                value: t,
              })),
              t.setNormalizer("margin-left", (t) => ({
                path: "margin.left",
                value: t,
              })),
              t.setReducer(
                "margin",
                ((n = "margin"),
                (t) => {
                  const { top: e, right: i, bottom: o, left: r } = t,
                    s = [];
                  return (
                    [e, i, r, o].every((t) => !!t)
                      ? s.push([n, zm(t)])
                      : (e && s.push([n + "-top", e]),
                        i && s.push([n + "-right", i]),
                        o && s.push([n + "-bottom", o]),
                        r && s.push([n + "-left", r])),
                    s
                  );
                })
              ),
              t.setStyleRelation("margin", [
                "margin-top",
                "margin-right",
                "margin-bottom",
                "margin-left",
              ]);
          }
          class jm extends Sd {
            constructor(t, e) {
              super(t),
                (this.view = e),
                (this._toolbarConfig = Hh(t.config.get("toolbar"))),
                (this._elementReplacer = new ha());
            }
            get element() {
              return this.view.element;
            }
            init(t) {
              const e = this.editor,
                n = this.view,
                i = e.editing.view,
                o = n.editable,
                r = i.document.getRoot();
              (o.name = r.rootName), n.render();
              const s = o.element;
              this.setEditableElement(o.name, s),
                this.focusTracker.add(s),
                n.editable.bind("isFocused").to(this.focusTracker),
                i.attachDomRoot(s),
                t && this._elementReplacer.replace(t, this.element),
                this._initPlaceholder(),
                this._initToolbar(),
                this.fire("ready");
            }
            destroy() {
              const t = this.view,
                e = this.editor.editing.view;
              this._elementReplacer.restore(),
                e.detachDomRoot(t.editable.name),
                t.destroy(),
                super.destroy();
            }
            _initToolbar() {
              const t = this.editor,
                e = this.view,
                n = t.editing.view;
              e.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused"),
                (e.stickyPanel.limiterElement = e.element),
                e.stickyPanel
                  .bind("viewportTopOffset")
                  .to(this, "viewportOffset", ({ top: t }) => t),
                e.toolbar.fillFromConfig(
                  this._toolbarConfig,
                  this.componentFactory
                ),
                (function ({
                  origin: t,
                  originKeystrokeHandler: e,
                  originFocusTracker: n,
                  toolbar: i,
                  beforeFocus: o,
                  afterBlur: r,
                }) {
                  n.add(i.element),
                    e.set("Alt+F10", (t, e) => {
                      n.isFocused &&
                        !i.focusTracker.isFocused &&
                        (o && o(), i.focus(), e());
                    }),
                    i.keystrokes.set("Esc", (e, n) => {
                      i.focusTracker.isFocused && (t.focus(), r && r(), n());
                    });
                })({
                  origin: n,
                  originFocusTracker: this.focusTracker,
                  originKeystrokeHandler: t.keystrokes,
                  toolbar: e.toolbar,
                });
            }
            _initPlaceholder() {
              const t = this.editor,
                e = t.editing.view,
                n = e.document.getRoot(),
                i = t.sourceElement,
                o =
                  t.config.get("placeholder") ||
                  (i &&
                    "textarea" === i.tagName.toLowerCase() &&
                    i.getAttribute("placeholder"));
              o &&
                tm({
                  view: e,
                  element: n,
                  text: o,
                  isDirectHost: !1,
                  keepOnFocus: !0,
                });
            }
          }
          var Fm = n(3638),
            Vm = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Fm.Z, Vm);
          Fm.Z.locals;
          class Hm extends mu {
            constructor(t, e, n = {}) {
              super(t),
                (this.stickyPanel = new Yu(t)),
                (this.toolbar = new qh(t, {
                  shouldGroupWhenFull: n.shouldToolbarGroupWhenFull,
                })),
                (this.editable = new pu(t, e));
            }
            render() {
              super.render(),
                this.stickyPanel.content.add(this.toolbar),
                this.top.add(this.stickyPanel),
                this.main.add(this.editable);
            }
          }
          class Um extends xd {
            constructor(t, e = {}) {
              if (!Ci(t) && void 0 !== e.initialData)
                throw new c("editor-create-initial-data", null);
              super(e),
                void 0 === this.config.get("initialData") &&
                  this.config.set(
                    "initialData",
                    (function (t) {
                      return Ci(t)
                        ? ((e = t),
                          e instanceof HTMLTextAreaElement
                            ? e.value
                            : e.innerHTML)
                        : t;
                      var e;
                    })(t)
                  ),
                Ci(t) && (this.sourceElement = t),
                this.model.document.createRoot();
              const n = !this.config.get("toolbar.shouldNotGroupWhenFull"),
                i = new Hm(this.locale, this.editing.view, {
                  shouldToolbarGroupWhenFull: n,
                });
              (this.ui = new jm(this, i)),
                (function (t) {
                  if (!j(t.updateSourceElement))
                    throw new c("attachtoform-missing-elementapi-interface", t);
                  const e = t.sourceElement;
                  if (e && "textarea" === e.tagName.toLowerCase() && e.form) {
                    let n;
                    const i = e.form,
                      o = () => t.updateSourceElement();
                    j(i.submit) &&
                      ((n = i.submit),
                      (i.submit = () => {
                        o(), n.apply(i);
                      })),
                      i.addEventListener("submit", o),
                      t.on("destroy", () => {
                        i.removeEventListener("submit", o), n && (i.submit = n);
                      });
                  }
                })(this);
            }
            destroy() {
              return (
                this.sourceElement && this.updateSourceElement(),
                this.ui.destroy(),
                super.destroy()
              );
            }
            static create(t, e = {}) {
              return new Promise((n) => {
                const i = new this(t, e);
                n(
                  i
                    .initPlugins()
                    .then(() => i.ui.init(Ci(t) ? t : null))
                    .then(() => i.data.init(i.config.get("initialData")))
                    .then(() => i.fire("ready"))
                    .then(() => i)
                );
              });
            }
          }
          he(Um, Td), he(Um, Md);
          class $m {
            constructor(t, e = 20) {
              (this.model = t),
                (this.size = 0),
                (this.limit = e),
                (this.isLocked = !1),
                (this._changeCallback = (t, e) => {
                  e.isLocal &&
                    e.isUndoable &&
                    e !== this._batch &&
                    this._reset(!0);
                }),
                (this._selectionChangeCallback = () => {
                  this._reset();
                }),
                this.model.document.on("change", this._changeCallback),
                this.model.document.selection.on(
                  "change:range",
                  this._selectionChangeCallback
                ),
                this.model.document.selection.on(
                  "change:attribute",
                  this._selectionChangeCallback
                );
            }
            get batch() {
              return (
                this._batch ||
                  (this._batch = this.model.createBatch({ isTyping: !0 })),
                this._batch
              );
            }
            input(t) {
              (this.size += t), this.size >= this.limit && this._reset(!0);
            }
            lock() {
              this.isLocked = !0;
            }
            unlock() {
              this.isLocked = !1;
            }
            destroy() {
              this.model.document.off("change", this._changeCallback),
                this.model.document.selection.off(
                  "change:range",
                  this._selectionChangeCallback
                ),
                this.model.document.selection.off(
                  "change:attribute",
                  this._selectionChangeCallback
                );
            }
            _reset(t) {
              (this.isLocked && !t) || ((this._batch = null), (this.size = 0));
            }
          }
          class qm extends ge {
            constructor(t, e) {
              super(t), (this._buffer = new $m(t.model, e));
            }
            get buffer() {
              return this._buffer;
            }
            destroy() {
              super.destroy(), this._buffer.destroy();
            }
            execute(t = {}) {
              const e = this.editor.model,
                n = e.document,
                i = t.text || "",
                o = i.length,
                r = t.range ? e.createSelection(t.range) : n.selection,
                s = t.resultRange;
              e.enqueueChange(this._buffer.batch, (t) => {
                this._buffer.lock(),
                  e.deleteContent(r),
                  i &&
                    e.insertContent(
                      t.createText(i, n.selection.getAttributes()),
                      r
                    ),
                  s
                    ? t.setSelection(s)
                    : r.is("documentSelection") || t.setSelection(r),
                  this._buffer.unlock(),
                  this._buffer.input(o);
              });
            }
          }
          function Gm(t) {
            if (t.newChildren.length - t.oldChildren.length != 1) return;
            const e = (function (t, e) {
              const n = [];
              let i,
                o = 0;
              return (
                t.forEach((t) => {
                  "equal" == t
                    ? (r(), o++)
                    : "insert" == t
                    ? (s("insert")
                        ? i.values.push(e[o])
                        : (r(),
                          (i = { type: "insert", index: o, values: [e[o]] })),
                      o++)
                    : s("delete")
                    ? i.howMany++
                    : (r(), (i = { type: "delete", index: o, howMany: 1 }));
                }),
                r(),
                n
              );
              function r() {
                i && (n.push(i), (i = null));
              }
              function s(t) {
                return i && i.type == t;
              }
            })(qr(t.oldChildren, t.newChildren, Wm), t.newChildren);
            if (e.length > 1) return;
            const n = e[0];
            return n.values[0] && n.values[0].is("$text") ? n : void 0;
          }
          function Wm(t, e) {
            return t && t.is("$text") && e && e.is("$text")
              ? t.data === e.data
              : t === e;
          }
          function Ym(t, e) {
            const n = e.selection,
              i = t.shiftKey && t.keyCode === dr.delete,
              o = !n.isCollapsed;
            return i && o;
          }
          const Km = [
            ur("arrowUp"),
            ur("arrowRight"),
            ur("arrowDown"),
            ur("arrowLeft"),
            9,
            16,
            17,
            18,
            19,
            20,
            27,
            33,
            34,
            35,
            36,
            45,
            91,
            93,
            144,
            145,
            173,
            174,
            175,
            176,
            177,
            178,
            179,
            255,
          ];
          for (let t = 112; t <= 135; t++) Km.push(t);
          function Qm(t) {
            return !(!t.ctrlKey && !t.metaKey) || Km.includes(t.keyCode);
          }
          class Zm {
            constructor(t) {
              (this.editor = t), (this.editing = this.editor.editing);
            }
            handle(t, e) {
              if (
                (function (t) {
                  if (0 == t.length) return !1;
                  for (const e of t)
                    if ("children" === e.type && !Gm(e)) return !0;
                  return !1;
                })(t)
              )
                this._handleContainerChildrenMutations(t, e);
              else
                for (const n of t)
                  this._handleTextMutation(n, e),
                    this._handleTextNodeInsertion(n);
            }
            _handleContainerChildrenMutations(t, e) {
              const n = (function (t) {
                const e = t
                  .map((t) => t.node)
                  .reduce((t, e) =>
                    t.getCommonAncestor(e, { includeSelf: !0 })
                  );
                if (!e) return;
                return e
                  .getAncestors({ includeSelf: !0, parentFirst: !0 })
                  .find((t) => t.is("containerElement") || t.is("rootElement"));
              })(t);
              if (!n) return;
              const i = this.editor.editing.view.domConverter.mapViewToDom(n),
                o = new us(this.editor.editing.view.document),
                r = this.editor.data.toModel(o.domToView(i)).getChild(0),
                s = this.editor.editing.mapper.toModelElement(n);
              if (!s) return;
              const a = Array.from(r.getChildren()),
                c = Array.from(s.getChildren()),
                l = a[a.length - 1],
                d = c[c.length - 1],
                h = l && l.is("element", "softBreak"),
                u = d && !d.is("element", "softBreak");
              h && u && a.pop();
              const m = this.editor.model.schema;
              if (!Jm(a, m) || !Jm(c, m)) return;
              const g = a
                  .map((t) => (t.is("$text") ? t.data : "@"))
                  .join("")
                  .replace(/\u00A0/g, " "),
                p = c
                  .map((t) => (t.is("$text") ? t.data : "@"))
                  .join("")
                  .replace(/\u00A0/g, " ");
              if (p === g) return;
              const f = qr(p, g),
                { firstChangeAt: k, insertions: b, deletions: w } = Xm(f);
              let A = null;
              e && (A = this.editing.mapper.toModelRange(e.getFirstRange()));
              const _ = g.substr(k, b),
                C = this.editor.model.createRange(
                  this.editor.model.createPositionAt(s, k),
                  this.editor.model.createPositionAt(s, k + w)
                );
              this.editor.execute("input", {
                text: _,
                range: C,
                resultRange: A,
              });
            }
            _handleTextMutation(t, e) {
              if ("text" != t.type) return;
              const n = t.newText.replace(/\u00A0/g, " "),
                i = t.oldText.replace(/\u00A0/g, " ");
              if (i === n) return;
              const o = qr(i, n),
                { firstChangeAt: r, insertions: s, deletions: a } = Xm(o);
              let c = null;
              e && (c = this.editing.mapper.toModelRange(e.getFirstRange()));
              const l = this.editing.view.createPositionAt(t.node, r),
                d = this.editing.mapper.toModelPosition(l),
                h = this.editor.model.createRange(d, d.getShiftedBy(a)),
                u = n.substr(r, s);
              this.editor.execute("input", {
                text: u,
                range: h,
                resultRange: c,
              });
            }
            _handleTextNodeInsertion(t) {
              if ("children" != t.type) return;
              const e = Gm(t),
                n = this.editing.view.createPositionAt(t.node, e.index),
                i = this.editing.mapper.toModelPosition(n),
                o = e.values[0].data;
              this.editor.execute("input", {
                text: o.replace(/\u00A0/g, " "),
                range: this.editor.model.createRange(i),
              });
            }
          }
          function Jm(t, e) {
            return t.every((t) => e.isInline(t));
          }
          function Xm(t) {
            let e = null,
              n = null;
            for (let i = 0; i < t.length; i++) {
              "equal" != t[i] && ((e = null === e ? i : e), (n = i));
            }
            let i = 0,
              o = 0;
            for (let r = e; r <= n; r++)
              "insert" != t[r] && i++, "delete" != t[r] && o++;
            return { insertions: o, deletions: i, firstChangeAt: e };
          }
          class tg extends ue {
            static get pluginName() {
              return "Input";
            }
            init() {
              const t = this.editor,
                e = new qm(t, t.config.get("typing.undoStep") || 20);
              t.commands.add("input", e),
                (function (t) {
                  let e = null;
                  const n = t.model,
                    i = t.editing.view,
                    o = t.commands.get("input");
                  function r(t) {
                    if (sr.isWindows && Ym(t, i.document)) return;
                    const r = n.document,
                      a = i.document.isComposing,
                      c = e && e.isEqual(r.selection);
                    (e = null),
                      o.isEnabled &&
                        (Qm(t) ||
                          r.selection.isCollapsed ||
                          (a && 229 === t.keyCode) ||
                          (!a && 229 === t.keyCode && c) ||
                          s());
                  }
                  function s() {
                    const t = o.buffer;
                    t.lock();
                    const e = t.batch;
                    n.enqueueChange(e, () => {
                      n.deleteContent(n.document.selection);
                    }),
                      t.unlock();
                  }
                  sr.isAndroid
                    ? i.document.on("beforeinput", (t, e) => r(e), {
                        priority: "lowest",
                      })
                    : i.document.on("keydown", (t, e) => r(e), {
                        priority: "lowest",
                      }),
                    i.document.on(
                      "compositionstart",
                      function () {
                        const t = n.document,
                          e =
                            1 !== t.selection.rangeCount ||
                            t.selection.getFirstRange().isFlat;
                        t.selection.isCollapsed || e || s();
                      },
                      { priority: "lowest" }
                    ),
                    i.document.on(
                      "compositionend",
                      () => {
                        e = n.createSelection(n.document.selection);
                      },
                      { priority: "lowest" }
                    );
                })(t),
                (function (t) {
                  t.editing.view.document.on("mutations", (e, n, i) => {
                    new Zm(t).handle(n, i);
                  });
                })(t);
            }
          }
          class eg extends ge {
            constructor(t, e) {
              super(t),
                (this.direction = e),
                (this._buffer = new $m(
                  t.model,
                  t.config.get("typing.undoStep")
                ));
            }
            get buffer() {
              return this._buffer;
            }
            execute(t = {}) {
              const e = this.editor.model,
                n = e.document;
              e.enqueueChange(this._buffer.batch, (i) => {
                this._buffer.lock();
                const o = i.createSelection(t.selection || n.selection),
                  r = t.sequence || 1,
                  s = o.isCollapsed;
                if (
                  (o.isCollapsed &&
                    e.modifySelection(o, {
                      direction: this.direction,
                      unit: t.unit,
                      treatEmojiAsSingleUnit: !0,
                    }),
                  this._shouldEntireContentBeReplacedWithParagraph(r))
                )
                  return void this._replaceEntireContentWithParagraph(i);
                if (this._shouldReplaceFirstBlockWithParagraph(o, r))
                  return void this.editor.execute("paragraph", {
                    selection: o,
                  });
                if (o.isCollapsed) return;
                let a = 0;
                o
                  .getFirstRange()
                  .getMinimalFlatRanges()
                  .forEach((t) => {
                    a += Vo(
                      t.getWalker({
                        singleCharacters: !0,
                        ignoreElementEnd: !0,
                        shallow: !0,
                      })
                    );
                  }),
                  e.deleteContent(o, {
                    doNotResetEntireContent: s,
                    direction: this.direction,
                  }),
                  this._buffer.input(a),
                  i.setSelection(o),
                  this._buffer.unlock();
              });
            }
            _shouldEntireContentBeReplacedWithParagraph(t) {
              if (t > 1) return !1;
              const e = this.editor.model,
                n = e.document.selection,
                i = e.schema.getLimitElement(n);
              if (!(n.isCollapsed && n.containsEntireContent(i))) return !1;
              if (!e.schema.checkChild(i, "paragraph")) return !1;
              const o = i.getChild(0);
              return !o || "paragraph" !== o.name;
            }
            _replaceEntireContentWithParagraph(t) {
              const e = this.editor.model,
                n = e.document.selection,
                i = e.schema.getLimitElement(n),
                o = t.createElement("paragraph");
              t.remove(t.createRangeIn(i)),
                t.insert(o, i),
                t.setSelection(o, 0);
            }
            _shouldReplaceFirstBlockWithParagraph(t, e) {
              const n = this.editor.model;
              if (e > 1 || "backward" != this.direction) return !1;
              if (!t.isCollapsed) return !1;
              const i = t.getFirstPosition(),
                o = n.schema.getLimitElement(i),
                r = o.getChild(0);
              return (
                i.parent == r &&
                !!t.containsEntireContent(r) &&
                !!n.schema.checkChild(o, "paragraph") &&
                "paragraph" != r.name
              );
            }
          }
          class ng extends _s {
            constructor(t) {
              super(t);
              const e = t.document;
              let n = 0;
              function i(t, n, i) {
                const o = new $o(e, "delete", e.selection.getFirstRange());
                e.fire(o, new $s(e, n, i)), o.stop.called && t.stop();
              }
              e.on("keyup", (t, e) => {
                (e.keyCode != dr.delete && e.keyCode != dr.backspace) ||
                  (n = 0);
              }),
                e.on("keydown", (t, o) => {
                  if (sr.isWindows && Ym(o, e)) return;
                  const r = {};
                  if (o.keyCode == dr.delete)
                    (r.direction = "forward"), (r.unit = "character");
                  else {
                    if (o.keyCode != dr.backspace) return;
                    (r.direction = "backward"), (r.unit = "codePoint");
                  }
                  const s = sr.isMac ? o.altKey : o.ctrlKey;
                  (r.unit = s ? "word" : r.unit),
                    (r.sequence = ++n),
                    i(t, o.domEvent, r);
                }),
                sr.isAndroid &&
                  e.on("beforeinput", (e, n) => {
                    if ("deleteContentBackward" != n.domEvent.inputType) return;
                    const o = {
                        unit: "codepoint",
                        direction: "backward",
                        sequence: 1,
                      },
                      r = n.domTarget.ownerDocument.defaultView.getSelection();
                    r.anchorNode == r.focusNode &&
                      r.anchorOffset + 1 != r.focusOffset &&
                      (o.selectionToRemove =
                        t.domConverter.domSelectionToView(r)),
                      i(e, n.domEvent, o);
                  });
            }
            observe() {}
          }
          class ig extends ue {
            static get pluginName() {
              return "Delete";
            }
            init() {
              const t = this.editor,
                e = t.editing.view,
                n = e.document,
                i = t.model.document;
              e.addObserver(ng), (this._undoOnBackspace = !1);
              const o = new eg(t, "forward");
              if (
                (t.commands.add("deleteForward", o),
                t.commands.add("forwardDelete", o),
                t.commands.add("delete", new eg(t, "backward")),
                this.listenTo(
                  n,
                  "delete",
                  (n, i) => {
                    const o = { unit: i.unit, sequence: i.sequence };
                    if (i.selectionToRemove) {
                      const e = t.model.createSelection(),
                        n = [];
                      for (const e of i.selectionToRemove.getRanges())
                        n.push(t.editing.mapper.toModelRange(e));
                      e.setTo(n), (o.selection = e);
                    }
                    t.execute(
                      "forward" == i.direction ? "deleteForward" : "delete",
                      o
                    ),
                      i.preventDefault(),
                      e.scrollToTheSelection();
                  },
                  { priority: "low" }
                ),
                sr.isAndroid)
              ) {
                let t = null;
                this.listenTo(
                  n,
                  "delete",
                  (e, n) => {
                    const i =
                      n.domTarget.ownerDocument.defaultView.getSelection();
                    t = {
                      anchorNode: i.anchorNode,
                      anchorOffset: i.anchorOffset,
                      focusNode: i.focusNode,
                      focusOffset: i.focusOffset,
                    };
                  },
                  { priority: "lowest" }
                ),
                  this.listenTo(n, "keyup", (e, n) => {
                    if (t) {
                      const e =
                        n.domTarget.ownerDocument.defaultView.getSelection();
                      e.collapse(t.anchorNode, t.anchorOffset),
                        e.extend(t.focusNode, t.focusOffset),
                        (t = null);
                    }
                  });
              }
              this.editor.plugins.has("UndoEditing") &&
                (this.listenTo(
                  n,
                  "delete",
                  (e, n) => {
                    this._undoOnBackspace &&
                      "backward" == n.direction &&
                      1 == n.sequence &&
                      "codePoint" == n.unit &&
                      ((this._undoOnBackspace = !1),
                      t.execute("undo"),
                      n.preventDefault(),
                      e.stop());
                  },
                  { context: "$capture" }
                ),
                this.listenTo(i, "change", () => {
                  this._undoOnBackspace = !1;
                }));
            }
            requestUndoOnBackspace() {
              this.editor.plugins.has("UndoEditing") &&
                (this._undoOnBackspace = !0);
            }
          }
          class og extends ue {
            static get requires() {
              return [tg, ig];
            }
            static get pluginName() {
              return "Typing";
            }
          }
          function rg(t, e) {
            let n = t.start;
            return {
              text: Array.from(t.getItems()).reduce(
                (t, i) =>
                  i.is("$text") || i.is("$textProxy")
                    ? t + i.data
                    : ((n = e.createPositionAfter(i)), ""),
                ""
              ),
              range: e.createRange(n, t.end),
            };
          }
          class sg {
            constructor(t, e) {
              (this.model = t),
                (this.testCallback = e),
                (this.hasMatch = !1),
                this.set("isEnabled", !0),
                this.on("change:isEnabled", () => {
                  this.isEnabled
                    ? this._startListening()
                    : (this.stopListening(t.document.selection),
                      this.stopListening(t.document));
                }),
                this._startListening();
            }
            _startListening() {
              const t = this.model.document;
              this.listenTo(
                t.selection,
                "change:range",
                (e, { directChange: n }) => {
                  n &&
                    (t.selection.isCollapsed
                      ? this._evaluateTextBeforeSelection("selection")
                      : this.hasMatch &&
                        (this.fire("unmatched"), (this.hasMatch = !1)));
                }
              ),
                this.listenTo(t, "change:data", (t, e) => {
                  !e.isUndo &&
                    e.isLocal &&
                    this._evaluateTextBeforeSelection("data", { batch: e });
                });
            }
            _evaluateTextBeforeSelection(t, e = {}) {
              const n = this.model,
                i = n.document.selection,
                o = n.createRange(
                  n.createPositionAt(i.focus.parent, 0),
                  i.focus
                ),
                { text: r, range: s } = rg(o, n),
                a = this.testCallback(r);
              if (
                (!a && this.hasMatch && this.fire("unmatched"),
                (this.hasMatch = !!a),
                a)
              ) {
                const n = Object.assign(e, { text: r, range: s });
                "object" == typeof a && Object.assign(n, a),
                  this.fire(`matched:${t}`, n);
              }
            }
          }
          he(sg, re);
          class ag extends ue {
            static get pluginName() {
              return "TwoStepCaretMovement";
            }
            constructor(t) {
              super(t),
                (this.attributes = new Set()),
                (this._overrideUid = null);
            }
            init() {
              const t = this.editor,
                e = t.model,
                n = t.editing.view,
                i = t.locale,
                o = e.document.selection;
              this.listenTo(
                n.document,
                "arrowKey",
                (t, e) => {
                  if (!o.isCollapsed) return;
                  if (e.shiftKey || e.altKey || e.ctrlKey) return;
                  const n = e.keyCode == dr.arrowright,
                    r = e.keyCode == dr.arrowleft;
                  if (!n && !r) return;
                  const s = i.contentLanguageDirection;
                  let a = !1;
                  (a =
                    ("ltr" === s && n) || ("rtl" === s && r)
                      ? this._handleForwardMovement(e)
                      : this._handleBackwardMovement(e)),
                    !0 === a && t.stop();
                },
                { context: "$text", priority: "highest" }
              ),
                (this._isNextGravityRestorationSkipped = !1),
                this.listenTo(o, "change:range", (t, e) => {
                  this._isNextGravityRestorationSkipped
                    ? (this._isNextGravityRestorationSkipped = !1)
                    : this._isGravityOverridden &&
                      ((!e.directChange &&
                        hg(o.getFirstPosition(), this.attributes)) ||
                        this._restoreGravity());
                });
            }
            registerAttribute(t) {
              this.attributes.add(t);
            }
            _handleForwardMovement(t) {
              const e = this.attributes,
                n = this.editor.model.document.selection,
                i = n.getFirstPosition();
              return (
                !this._isGravityOverridden &&
                (!i.isAtStart || !cg(n, e)) &&
                (hg(i, e) ? (dg(t), this._overrideGravity(), !0) : void 0)
              );
            }
            _handleBackwardMovement(t) {
              const e = this.attributes,
                n = this.editor.model,
                i = n.document.selection,
                o = i.getFirstPosition();
              return this._isGravityOverridden
                ? (dg(t), this._restoreGravity(), lg(n, e, o), !0)
                : o.isAtStart
                ? !!cg(i, e) && (dg(t), lg(n, e, o), !0)
                : (function (t, e) {
                    return hg(t.getShiftedBy(-1), e);
                  })(o, e)
                ? o.isAtEnd && !cg(i, e) && hg(o, e)
                  ? (dg(t), lg(n, e, o), !0)
                  : ((this._isNextGravityRestorationSkipped = !0),
                    this._overrideGravity(),
                    !1)
                : void 0;
            }
            get _isGravityOverridden() {
              return !!this._overrideUid;
            }
            _overrideGravity() {
              this._overrideUid = this.editor.model.change((t) =>
                t.overrideSelectionGravity()
              );
            }
            _restoreGravity() {
              this.editor.model.change((t) => {
                t.restoreSelectionGravity(this._overrideUid),
                  (this._overrideUid = null);
              });
            }
          }
          function cg(t, e) {
            for (const n of e) if (t.hasAttribute(n)) return !0;
            return !1;
          }
          function lg(t, e, n) {
            const i = n.nodeBefore;
            t.change((t) => {
              i
                ? t.setSelectionAttribute(i.getAttributes())
                : t.removeSelectionAttribute(e);
            });
          }
          function dg(t) {
            t.preventDefault();
          }
          function hg(t, e) {
            const { nodeBefore: n, nodeAfter: i } = t;
            for (const t of e) {
              const e = n ? n.getAttribute(t) : void 0;
              if ((i ? i.getAttribute(t) : void 0) !== e) return !0;
            }
            return !1;
          }
          var ug = /[\\^$.*+?()[\]{}|]/g,
            mg = RegExp(ug.source);
          const gg = function (t) {
              return (t = ro(t)) && mg.test(t) ? t.replace(ug, "\\$&") : t;
            },
            pg = {
              copyright: { from: "(c)", to: "©" },
              registeredTrademark: { from: "(r)", to: "®" },
              trademark: { from: "(tm)", to: "™" },
              oneHalf: {
                from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i,
                to: [null, "½", null],
              },
              oneThird: {
                from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i,
                to: [null, "⅓", null],
              },
              twoThirds: {
                from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i,
                to: [null, "⅔", null],
              },
              oneForth: {
                from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i,
                to: [null, "¼", null],
              },
              threeQuarters: {
                from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i,
                to: [null, "¾", null],
              },
              lessThanOrEqual: { from: "<=", to: "≤" },
              greaterThanOrEqual: { from: ">=", to: "≥" },
              notEqual: { from: "!=", to: "≠" },
              arrowLeft: { from: "<-", to: "←" },
              arrowRight: { from: "->", to: "→" },
              horizontalEllipsis: { from: "...", to: "…" },
              enDash: { from: /(^| )(--)( )$/, to: [null, "–", null] },
              emDash: { from: /(^| )(---)( )$/, to: [null, "—", null] },
              quotesPrimary: { from: _g('"'), to: [null, "“", null, "”"] },
              quotesSecondary: { from: _g("'"), to: [null, "‘", null, "’"] },
              quotesPrimaryEnGb: { from: _g("'"), to: [null, "‘", null, "’"] },
              quotesSecondaryEnGb: {
                from: _g('"'),
                to: [null, "“", null, "”"],
              },
              quotesPrimaryPl: { from: _g('"'), to: [null, "„", null, "”"] },
              quotesSecondaryPl: { from: _g("'"), to: [null, "‚", null, "’"] },
            },
            fg = {
              symbols: ["copyright", "registeredTrademark", "trademark"],
              mathematical: [
                "oneHalf",
                "oneThird",
                "twoThirds",
                "oneForth",
                "threeQuarters",
                "lessThanOrEqual",
                "greaterThanOrEqual",
                "notEqual",
                "arrowLeft",
                "arrowRight",
              ],
              typography: ["horizontalEllipsis", "enDash", "emDash"],
              quotes: ["quotesPrimary", "quotesSecondary"],
            },
            kg = ["symbols", "mathematical", "typography", "quotes"];
          function bg(t) {
            return "string" == typeof t ? new RegExp(`(${gg(t)})$`) : t;
          }
          function wg(t) {
            return "string" == typeof t
              ? () => [t]
              : t instanceof Array
              ? () => t
              : t;
          }
          function Ag(t) {
            return (t.textNode ? t.textNode : t.nodeAfter).getAttributes();
          }
          function _g(t) {
            return new RegExp(`(^|\\s)(${t})([^${t}]*)(${t})$`);
          }
          function Cg(t, e, n, i) {
            return i.createRange(vg(t, e, n, !0, i), vg(t, e, n, !1, i));
          }
          function vg(t, e, n, i, o) {
            let r = t.textNode || (i ? t.nodeBefore : t.nodeAfter),
              s = null;
            for (; r && r.getAttribute(e) == n; )
              (s = r), (r = i ? r.previousSibling : r.nextSibling);
            return s ? o.createPositionAt(s, i ? "before" : "after") : t;
          }
          function yg(t, e, n, i) {
            const o = t.editing.view,
              r = new Set();
            o.document.registerPostFixer((o) => {
              const s = t.model.document.selection;
              let a = !1;
              if (s.hasAttribute(e)) {
                const c = Cg(
                    s.getFirstPosition(),
                    e,
                    s.getAttribute(e),
                    t.model
                  ),
                  l = t.editing.mapper.toViewRange(c);
                for (const t of l.getItems())
                  t.is("element", n) &&
                    !t.hasClass(i) &&
                    (o.addClass(i, t), r.add(t), (a = !0));
              }
              return a;
            }),
              t.conversion.for("editingDowncast").add((t) => {
                function e() {
                  o.change((t) => {
                    for (const e of r.values())
                      t.removeClass(i, e), r.delete(e);
                  });
                }
                t.on("insert", e, { priority: "highest" }),
                  t.on("remove", e, { priority: "highest" }),
                  t.on("attribute", e, { priority: "highest" }),
                  t.on("selection", e, { priority: "highest" });
              });
          }
          function xg(t, e, n, i) {
            let o,
              r = null;
            "function" == typeof i
              ? (o = i)
              : ((r = t.commands.get(i)),
                (o = () => {
                  t.execute(i);
                })),
              t.model.document.on("change:data", (s, a) => {
                if ((r && !r.isEnabled) || !e.isEnabled) return;
                const c = Na(t.model.document.selection.getRanges());
                if (!c.isCollapsed) return;
                if (a.isUndo || !a.isLocal) return;
                const l = Array.from(t.model.document.differ.getChanges()),
                  d = l[0];
                if (
                  1 != l.length ||
                  "insert" !== d.type ||
                  "$text" != d.name ||
                  1 != d.length
                )
                  return;
                const h = d.position.parent;
                if (h.is("element", "codeBlock")) return;
                if (
                  h.is("element", "listItem") &&
                  "function" != typeof i &&
                  !["numberedList", "bulletedList", "todoList"].includes(i)
                )
                  return;
                if (r && !0 === r.value) return;
                const u = h.getChild(0),
                  m = t.model.createRangeOn(u);
                if (!m.containsRange(c) && !c.end.isEqual(m.end)) return;
                const g = n.exec(u.data.substr(0, c.end.offset));
                g &&
                  t.model.enqueueChange((e) => {
                    const n = e.createPositionAt(h, 0),
                      i = e.createPositionAt(h, g[0].length),
                      r = new cc(n, i);
                    if (!1 !== o({ match: g })) {
                      e.remove(r);
                      const n = t.model.document.selection.getFirstRange(),
                        i = e.createRangeIn(h);
                      !h.isEmpty ||
                        i.isEqual(n) ||
                        i.containsRange(n, !0) ||
                        e.remove(h);
                    }
                    r.detach(),
                      t.model.enqueueChange(() => {
                        t.plugins.get("Delete").requestUndoOnBackspace();
                      });
                  });
              });
          }
          function Eg(t, e, n, i) {
            let o, r;
            n instanceof RegExp ? (o = n) : (r = n),
              (r =
                r ||
                ((t) => {
                  let e;
                  const n = [],
                    i = [];
                  for (; null !== (e = o.exec(t)) && !(e && e.length < 4); ) {
                    let { index: t, 1: o, 2: r, 3: s } = e;
                    const a = o + r + s;
                    t += e[0].length - a.length;
                    const c = [t, t + o.length],
                      l = [
                        t + o.length + r.length,
                        t + o.length + r.length + s.length,
                      ];
                    n.push(c),
                      n.push(l),
                      i.push([t + o.length, t + o.length + r.length]);
                  }
                  return { remove: n, format: i };
                })),
              t.model.document.on("change:data", (n, o) => {
                if (o.isUndo || !o.isLocal || !e.isEnabled) return;
                const s = t.model,
                  a = s.document.selection;
                if (!a.isCollapsed) return;
                const c = Array.from(s.document.differ.getChanges()),
                  l = c[0];
                if (
                  1 != c.length ||
                  "insert" !== l.type ||
                  "$text" != l.name ||
                  1 != l.length
                )
                  return;
                const d = a.focus,
                  h = d.parent,
                  { text: u, range: m } = (function (t, e) {
                    let n = t.start;
                    return {
                      text: Array.from(t.getItems()).reduce(
                        (t, i) =>
                          (!i.is("$text") && !i.is("$textProxy")) ||
                          i.getAttribute("code")
                            ? ((n = e.createPositionAfter(i)), "")
                            : t + i.data,
                        ""
                      ),
                      range: e.createRange(n, t.end),
                    };
                  })(s.createRange(s.createPositionAt(h, 0), d), s),
                  g = r(u),
                  p = Dg(m.start, g.format, s),
                  f = Dg(m.start, g.remove, s);
                p.length &&
                  f.length &&
                  s.enqueueChange((e) => {
                    if (!1 !== i(e, p)) {
                      for (const t of f.reverse()) e.remove(t);
                      s.enqueueChange(() => {
                        t.plugins.get("Delete").requestUndoOnBackspace();
                      });
                    }
                  });
              });
          }
          function Dg(t, e, n) {
            return e
              .filter((t) => void 0 !== t[0] && void 0 !== t[1])
              .map((e) =>
                n.createRange(t.getShiftedBy(e[0]), t.getShiftedBy(e[1]))
              );
          }
          function Sg(t, e) {
            return (n, i) => {
              if (!t.commands.get(e).isEnabled) return !1;
              const o = t.model.schema.getValidRanges(i, e);
              for (const t of o) n.setAttribute(e, !0, t);
              n.removeSelectionAttribute(e);
            };
          }
          class Ig {
            constructor(t) {
              (this.files = (function (t) {
                const e = Array.from(t.files || []),
                  n = Array.from(t.items || []);
                if (e.length) return e;
                return n
                  .filter((t) => "file" === t.kind)
                  .map((t) => t.getAsFile());
              })(t)),
                (this._native = t);
            }
            get types() {
              return this._native.types;
            }
            getData(t) {
              return this._native.getData(t);
            }
            setData(t, e) {
              this._native.setData(t, e);
            }
            set effectAllowed(t) {
              this._native.effectAllowed = t;
            }
            get effectAllowed() {
              return this._native.effectAllowed;
            }
            set dropEffect(t) {
              this._native.dropEffect = t;
            }
            get dropEffect() {
              return this._native.dropEffect;
            }
            get isCanceled() {
              return (
                "none" == this._native.dropEffect ||
                !!this._native.mozUserCancelled
              );
            }
          }
          class Tg extends qs {
            constructor(t) {
              super(t);
              const n = this.document;
              function i(t) {
                return (i, o) => {
                  o.preventDefault();
                  const r = o.dropRange ? [o.dropRange] : null,
                    s = new e(n, t);
                  n.fire(s, {
                    dataTransfer: o.dataTransfer,
                    method: i.name,
                    targetRanges: r,
                    target: o.target,
                  }),
                    s.stop.called && o.stopPropagation();
                };
              }
              (this.domEventType = [
                "paste",
                "copy",
                "cut",
                "drop",
                "dragover",
                "dragstart",
                "dragend",
                "dragenter",
                "dragleave",
              ]),
                this.listenTo(n, "paste", i("clipboardInput"), {
                  priority: "low",
                }),
                this.listenTo(n, "drop", i("clipboardInput"), {
                  priority: "low",
                }),
                this.listenTo(n, "dragover", i("dragging"), {
                  priority: "low",
                });
            }
            onDomEvent(t) {
              const e = {
                dataTransfer: new Ig(
                  t.clipboardData ? t.clipboardData : t.dataTransfer
                ),
              };
              ("drop" != t.type && "dragover" != t.type) ||
                (e.dropRange = (function (t, e) {
                  const n = e.target.ownerDocument,
                    i = e.clientX,
                    o = e.clientY;
                  let r;
                  n.caretRangeFromPoint && n.caretRangeFromPoint(i, o)
                    ? (r = n.caretRangeFromPoint(i, o))
                    : e.rangeParent &&
                      ((r = n.createRange()),
                      r.setStart(e.rangeParent, e.rangeOffset),
                      r.collapse(!0));
                  if (r) return t.domConverter.domRangeToView(r);
                  return null;
                })(this.view, t)),
                this.fire(t.type, t, e);
            }
          }
          const Mg = ["figcaption", "li"];
          function Bg(t) {
            let e = "";
            if (t.is("$text") || t.is("$textProxy")) e = t.data;
            else if (t.is("element", "img") && t.hasAttribute("alt"))
              e = t.getAttribute("alt");
            else if (t.is("element", "br")) e = "\n";
            else {
              let n = null;
              for (const i of t.getChildren()) {
                const t = Bg(i);
                n &&
                  (n.is("containerElement") || i.is("containerElement")) &&
                  (Mg.includes(n.name) || Mg.includes(i.name)
                    ? (e += "\n")
                    : (e += "\n\n")),
                  (e += t),
                  (n = i);
              }
            }
            return e;
          }
          class Ng extends ue {
            static get pluginName() {
              return "ClipboardPipeline";
            }
            init() {
              this.editor.editing.view.addObserver(Tg),
                this._setupPasteDrop(),
                this._setupCopyCut();
            }
            _setupPasteDrop() {
              const t = this.editor,
                n = t.model,
                i = t.editing.view,
                o = i.document;
              this.listenTo(
                o,
                "clipboardInput",
                (e) => {
                  t.isReadOnly && e.stop();
                },
                { priority: "highest" }
              ),
                this.listenTo(
                  o,
                  "clipboardInput",
                  (t, n) => {
                    const o = n.dataTransfer;
                    let r = n.content || "";
                    var s;
                    r ||
                      (o.getData("text/html")
                        ? (r = (function (t) {
                            return t
                              .replace(
                                /<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g,
                                (t, e) => (1 == e.length ? " " : e)
                              )
                              .replace(/<!--[\s\S]*?-->/g, "");
                          })(o.getData("text/html")))
                        : o.getData("text/plain") &&
                          (((s = (s = o.getData("text/plain"))
                            .replace(/</g, "&lt;")
                            .replace(/>/g, "&gt;")
                            .replace(/\r?\n\r?\n/g, "</p><p>")
                            .replace(/\r?\n/g, "<br>")
                            .replace(/^\s/, "&nbsp;")
                            .replace(/\s$/, "&nbsp;")
                            .replace(/\s\s/g, " &nbsp;")).includes("</p><p>") ||
                            s.includes("<br>")) &&
                            (s = `<p>${s}</p>`),
                          (r = s)),
                      (r = this.editor.data.htmlProcessor.toView(r)));
                    const a = new e(this, "inputTransformation");
                    this.fire(a, {
                      content: r,
                      dataTransfer: o,
                      targetRanges: n.targetRanges,
                      method: n.method,
                    }),
                      a.stop.called && t.stop(),
                      i.scrollToTheSelection();
                  },
                  { priority: "low" }
                ),
                this.listenTo(
                  this,
                  "inputTransformation",
                  (t, e) => {
                    if (e.content.isEmpty) return;
                    const i = this.editor.data.toModel(
                      e.content,
                      "$clipboardHolder"
                    );
                    0 != i.childCount &&
                      (t.stop(),
                      n.change(() => {
                        this.fire("contentInsertion", {
                          content: i,
                          method: e.method,
                          dataTransfer: e.dataTransfer,
                          targetRanges: e.targetRanges,
                        });
                      }));
                  },
                  { priority: "low" }
                ),
                this.listenTo(
                  this,
                  "contentInsertion",
                  (t, e) => {
                    e.resultRange = n.insertContent(e.content);
                  },
                  { priority: "low" }
                );
            }
            _setupCopyCut() {
              const t = this.editor,
                e = t.model.document,
                n = t.editing.view.document;
              function i(i, o) {
                const r = o.dataTransfer;
                o.preventDefault();
                const s = t.data.toView(
                  t.model.getSelectedContent(e.selection)
                );
                n.fire("clipboardOutput", {
                  dataTransfer: r,
                  content: s,
                  method: i.name,
                });
              }
              this.listenTo(n, "copy", i, { priority: "low" }),
                this.listenTo(
                  n,
                  "cut",
                  (e, n) => {
                    t.isReadOnly ? n.preventDefault() : i(e, n);
                  },
                  { priority: "low" }
                ),
                this.listenTo(
                  n,
                  "clipboardOutput",
                  (n, i) => {
                    i.content.isEmpty ||
                      (i.dataTransfer.setData(
                        "text/html",
                        this.editor.data.htmlProcessor.toData(i.content)
                      ),
                      i.dataTransfer.setData("text/plain", Bg(i.content))),
                      "cut" == i.method && t.model.deleteContent(e.selection);
                  },
                  { priority: "low" }
                );
            }
          }
          function* zg(t, e) {
            for (const n of e)
              n && t.getAttributeProperties(n[0]).copyOnEnter && (yield n);
          }
          class Pg extends ge {
            execute() {
              const t = this.editor.model,
                e = t.document;
              t.change((n) => {
                !(function (t, e, n, i) {
                  const o = n.isCollapsed,
                    r = n.getFirstRange(),
                    s = r.start.parent,
                    a = r.end.parent;
                  if (i.isLimit(s) || i.isLimit(a))
                    return void (o || s != a || t.deleteContent(n));
                  if (o) {
                    const t = zg(e.model.schema, n.getAttributes());
                    Lg(e, r.start), e.setSelectionAttribute(t);
                  } else {
                    const i = !(r.start.isAtStart && r.end.isAtEnd),
                      o = s == a;
                    t.deleteContent(n, { leaveUnmerged: i }),
                      i && (o ? Lg(e, n.focus) : e.setSelection(a, 0));
                  }
                })(this.editor.model, n, e.selection, t.schema),
                  this.fire("afterExecute", { writer: n });
              });
            }
          }
          function Lg(t, e) {
            t.split(e), t.setSelection(e.parent.nextSibling, 0);
          }
          class Rg extends _s {
            constructor(t) {
              super(t);
              const e = this.document;
              e.on("keydown", (t, n) => {
                if (this.isEnabled && n.keyCode == dr.enter) {
                  const i = new $o(e, "enter", e.selection.getFirstRange());
                  e.fire(i, new $s(e, n.domEvent, { isSoft: n.shiftKey })),
                    i.stop.called && t.stop();
                }
              });
            }
            observe() {}
          }
          class Og extends ue {
            static get pluginName() {
              return "Enter";
            }
            init() {
              const t = this.editor,
                e = t.editing.view,
                n = e.document;
              e.addObserver(Rg),
                t.commands.add("enter", new Pg(t)),
                this.listenTo(
                  n,
                  "enter",
                  (n, i) => {
                    i.preventDefault(),
                      i.isSoft ||
                        (t.execute("enter"), e.scrollToTheSelection());
                  },
                  { priority: "low" }
                );
            }
          }
          class jg {
            constructor() {
              this._stack = [];
            }
            add(t, e) {
              const n = this._stack,
                i = n[0];
              this._insertDescriptor(t);
              const o = n[0];
              i === o ||
                Fg(i, o) ||
                this.fire("change:top", {
                  oldDescriptor: i,
                  newDescriptor: o,
                  writer: e,
                });
            }
            remove(t, e) {
              const n = this._stack,
                i = n[0];
              this._removeDescriptor(t);
              const o = n[0];
              i === o ||
                Fg(i, o) ||
                this.fire("change:top", {
                  oldDescriptor: i,
                  newDescriptor: o,
                  writer: e,
                });
            }
            _insertDescriptor(t) {
              const e = this._stack,
                n = e.findIndex((e) => e.id === t.id);
              if (Fg(t, e[n])) return;
              n > -1 && e.splice(n, 1);
              let i = 0;
              for (; e[i] && Vg(e[i], t); ) i++;
              e.splice(i, 0, t);
            }
            _removeDescriptor(t) {
              const e = this._stack,
                n = e.findIndex((e) => e.id === t);
              n > -1 && e.splice(n, 1);
            }
          }
          function Fg(t, e) {
            return (
              t &&
              e &&
              t.priority == e.priority &&
              Hg(t.classes) == Hg(e.classes)
            );
          }
          function Vg(t, e) {
            return (
              t.priority > e.priority ||
              (!(t.priority < e.priority) && Hg(t.classes) > Hg(e.classes))
            );
          }
          function Hg(t) {
            return Array.isArray(t) ? t.sort().join(",") : t;
          }
          he(jg, k);
          const Ug =
              '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>',
            $g = "ck-widget_selected";
          function qg(t) {
            return !!t.is("element") && !!t.getCustomProperty("widget");
          }
          function Gg(t, e, n = {}) {
            if (!t.is("containerElement"))
              throw new c("widget-to-widget-wrong-element-type", null, {
                element: t,
              });
            return (
              e.setAttribute("contenteditable", "false", t),
              e.addClass("ck-widget", t),
              e.setCustomProperty("widget", !0, t),
              (t.getFillerOffset = Xg),
              n.label &&
                (function (t, e, n) {
                  n.setCustomProperty("widgetLabel", e, t);
                })(t, n.label, e),
              n.hasSelectionHandle &&
                (function (t, e) {
                  const n = e.createUIElement(
                    "div",
                    { class: "ck ck-widget__selection-handle" },
                    function (t) {
                      const e = this.toDomElement(t),
                        n = new hh();
                      return (
                        n.set("content", Ug),
                        n.render(),
                        e.appendChild(n.element),
                        e
                      );
                    }
                  );
                  e.insert(e.createPositionAt(t, 0), n),
                    e.addClass(["ck-widget_with-selection-handle"], t);
                })(t, e),
              Kg(t, e),
              t
            );
          }
          function Wg(t, e, n) {
            if ((e.classes && n.addClass(Ii(e.classes), t), e.attributes))
              for (const i in e.attributes)
                n.setAttribute(i, e.attributes[i], t);
          }
          function Yg(t, e, n) {
            if ((e.classes && n.removeClass(Ii(e.classes), t), e.attributes))
              for (const i in e.attributes) n.removeAttribute(i, t);
          }
          function Kg(t, e, n = Wg, i = Yg) {
            const o = new jg();
            o.on("change:top", (e, o) => {
              o.oldDescriptor && i(t, o.oldDescriptor, o.writer),
                o.newDescriptor && n(t, o.newDescriptor, o.writer);
            }),
              e.setCustomProperty("addHighlight", (t, e, n) => o.add(e, n), t),
              e.setCustomProperty(
                "removeHighlight",
                (t, e, n) => o.remove(e, n),
                t
              );
          }
          function Qg(t) {
            const e = t.getCustomProperty("widgetLabel");
            return e ? ("function" == typeof e ? e() : e) : "";
          }
          function Zg(t, e) {
            return (
              e.addClass(
                ["ck-editor__editable", "ck-editor__nested-editable"],
                t
              ),
              e.setAttribute(
                "contenteditable",
                t.isReadOnly ? "false" : "true",
                t
              ),
              t.on("change:isReadOnly", (n, i, o) => {
                e.setAttribute("contenteditable", o ? "false" : "true", t);
              }),
              t.on("change:isFocused", (n, i, o) => {
                o
                  ? e.addClass("ck-editor__nested-editable_focused", t)
                  : e.removeClass("ck-editor__nested-editable_focused", t);
              }),
              Kg(t, e),
              t
            );
          }
          function Jg(t, e) {
            const n = t.getSelectedElement();
            if (n) {
              const i = np(t);
              if (i) return e.createRange(e.createPositionAt(n, i));
            }
            return rd(t, e);
          }
          function Xg() {
            return null;
          }
          const tp = "widget-type-around";
          function ep(t, e, n) {
            return t && qg(t) && !n.isInline(e);
          }
          function np(t) {
            return t.getAttribute(tp);
          }
          var ip = n(5137),
            op = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(ip.Z, op);
          ip.Z.locals;
          const rp = ["before", "after"],
            sp = new DOMParser().parseFromString(
              '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>',
              "image/svg+xml"
            ).firstChild,
            ap = "ck-widget__type-around_disabled";
          class cp extends ue {
            static get pluginName() {
              return "WidgetTypeAround";
            }
            static get requires() {
              return [Og, ig];
            }
            constructor(t) {
              super(t), (this._currentFakeCaretModelElement = null);
            }
            init() {
              const t = this.editor,
                e = t.editing.view;
              this.on("change:isEnabled", (n, i, o) => {
                e.change((t) => {
                  for (const n of e.document.roots)
                    o ? t.removeClass(ap, n) : t.addClass(ap, n);
                }),
                  o ||
                    t.model.change((t) => {
                      t.removeSelectionAttribute(tp);
                    });
              }),
                this._enableTypeAroundUIInjection(),
                this._enableInsertingParagraphsOnButtonClick(),
                this._enableInsertingParagraphsOnEnterKeypress(),
                this._enableInsertingParagraphsOnTypingKeystroke(),
                this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(),
                this._enableDeleteIntegration(),
                this._enableInsertContentIntegration(),
                this._enableInsertObjectIntegration(),
                this._enableDeleteContentIntegration();
            }
            destroy() {
              this._currentFakeCaretModelElement = null;
            }
            _insertParagraph(t, e) {
              const n = this.editor,
                i = n.editing.view,
                o = n.model.schema.getAttributesWithProperty(
                  t,
                  "copyOnReplace",
                  !0
                );
              n.execute("insertParagraph", {
                position: n.model.createPositionAt(t, e),
                attributes: o,
              }),
                i.focus(),
                i.scrollToTheSelection();
            }
            _listenToIfEnabled(t, e, n, i) {
              this.listenTo(
                t,
                e,
                (...t) => {
                  this.isEnabled && n(...t);
                },
                i
              );
            }
            _insertParagraphAccordingToFakeCaretPosition() {
              const t = this.editor.model.document.selection,
                e = np(t);
              if (!e) return !1;
              const n = t.getSelectedElement();
              return this._insertParagraph(n, e), !0;
            }
            _enableTypeAroundUIInjection() {
              const t = this.editor,
                e = t.model.schema,
                n = t.locale.t,
                i = {
                  before: n("Insert paragraph before block"),
                  after: n("Insert paragraph after block"),
                };
              t.editing.downcastDispatcher.on(
                "insert",
                (t, n, o) => {
                  const r = o.mapper.toViewElement(n.item);
                  ep(r, n.item, e) &&
                    (function (t, e, n) {
                      const i = t.createUIElement(
                        "div",
                        { class: "ck ck-reset_all ck-widget__type-around" },
                        function (t) {
                          const n = this.toDomElement(t);
                          return (
                            (function (t, e) {
                              for (const n of rp) {
                                const i = new Hd({
                                  tag: "div",
                                  attributes: {
                                    class: [
                                      "ck",
                                      "ck-widget__type-around__button",
                                      `ck-widget__type-around__button_${n}`,
                                    ],
                                    title: e[n],
                                  },
                                  children: [
                                    t.ownerDocument.importNode(sp, !0),
                                  ],
                                });
                                t.appendChild(i.render());
                              }
                            })(n, e),
                            (function (t) {
                              const e = new Hd({
                                tag: "div",
                                attributes: {
                                  class: [
                                    "ck",
                                    "ck-widget__type-around__fake-caret",
                                  ],
                                },
                              });
                              t.appendChild(e.render());
                            })(n),
                            n
                          );
                        }
                      );
                      t.insert(t.createPositionAt(n, "end"), i);
                    })(o.writer, i, r);
                },
                { priority: "low" }
              );
            }
            _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
              const t = this.editor,
                e = t.model,
                n = e.document.selection,
                i = e.schema,
                o = t.editing.view;
              function r(t) {
                return `ck-widget_type-around_show-fake-caret_${t}`;
              }
              this._listenToIfEnabled(
                o.document,
                "arrowKey",
                (t, e) => {
                  this._handleArrowKeyPress(t, e);
                },
                { context: [qg, "$text"], priority: "high" }
              ),
                this._listenToIfEnabled(n, "change:range", (e, n) => {
                  n.directChange &&
                    t.model.change((t) => {
                      t.removeSelectionAttribute(tp);
                    });
                }),
                this._listenToIfEnabled(e.document, "change:data", () => {
                  const e = n.getSelectedElement();
                  if (e) {
                    if (ep(t.editing.mapper.toViewElement(e), e, i)) return;
                  }
                  t.model.change((t) => {
                    t.removeSelectionAttribute(tp);
                  });
                }),
                this._listenToIfEnabled(
                  t.editing.downcastDispatcher,
                  "selection",
                  (t, e, n) => {
                    const o = n.writer;
                    if (this._currentFakeCaretModelElement) {
                      const t = n.mapper.toViewElement(
                        this._currentFakeCaretModelElement
                      );
                      t &&
                        (o.removeClass(rp.map(r), t),
                        (this._currentFakeCaretModelElement = null));
                    }
                    const s = e.selection.getSelectedElement();
                    if (!s) return;
                    const a = n.mapper.toViewElement(s);
                    if (!ep(a, s, i)) return;
                    const c = np(e.selection);
                    c &&
                      (o.addClass(r(c), a),
                      (this._currentFakeCaretModelElement = s));
                  }
                ),
                this._listenToIfEnabled(
                  t.ui.focusTracker,
                  "change:isFocused",
                  (e, n, i) => {
                    i ||
                      t.model.change((t) => {
                        t.removeSelectionAttribute(tp);
                      });
                  }
                );
            }
            _handleArrowKeyPress(t, e) {
              const n = this.editor,
                i = n.model,
                o = i.document.selection,
                r = i.schema,
                s = n.editing.view,
                a = (function (t, e) {
                  const n = pr(t, e);
                  return "down" === n || "right" === n;
                })(e.keyCode, n.locale.contentLanguageDirection),
                c = s.document.selection.getSelectedElement();
              let l;
              ep(c, n.editing.mapper.toModelElement(c), r)
                ? (l = this._handleArrowKeyPressOnSelectedWidget(a))
                : o.isCollapsed
                ? (l = this._handleArrowKeyPressWhenSelectionNextToAWidget(a))
                : e.shiftKey ||
                  (l = this._handleArrowKeyPressWhenNonCollapsedSelection(a)),
                l && (e.preventDefault(), t.stop());
            }
            _handleArrowKeyPressOnSelectedWidget(t) {
              const e = this.editor.model,
                n = np(e.document.selection);
              return e.change((e) => {
                if (!n)
                  return (
                    e.setSelectionAttribute(tp, t ? "after" : "before"), !0
                  );
                if (!(n === (t ? "after" : "before")))
                  return e.removeSelectionAttribute(tp), !0;
                return !1;
              });
            }
            _handleArrowKeyPressWhenSelectionNextToAWidget(t) {
              const e = this.editor,
                n = e.model,
                i = n.schema,
                o = e.plugins.get("Widget"),
                r = o._getObjectElementNextToSelection(t);
              return (
                !!ep(e.editing.mapper.toViewElement(r), r, i) &&
                (n.change((e) => {
                  o._setSelectionOverElement(r),
                    e.setSelectionAttribute(tp, t ? "before" : "after");
                }),
                !0)
              );
            }
            _handleArrowKeyPressWhenNonCollapsedSelection(t) {
              const e = this.editor,
                n = e.model,
                i = n.schema,
                o = e.editing.mapper,
                r = n.document.selection,
                s = t
                  ? r.getLastPosition().nodeBefore
                  : r.getFirstPosition().nodeAfter;
              return (
                !!ep(o.toViewElement(s), s, i) &&
                (n.change((e) => {
                  e.setSelection(s, "on"),
                    e.setSelectionAttribute(tp, t ? "after" : "before");
                }),
                !0)
              );
            }
            _enableInsertingParagraphsOnButtonClick() {
              const t = this.editor,
                e = t.editing.view;
              this._listenToIfEnabled(e.document, "mousedown", (n, i) => {
                const o = i.domTarget.closest(
                  ".ck-widget__type-around__button"
                );
                if (!o) return;
                const r = (function (t) {
                    return t.classList.contains(
                      "ck-widget__type-around__button_before"
                    )
                      ? "before"
                      : "after";
                  })(o),
                  s = (function (t, e) {
                    const n = t.closest(".ck-widget");
                    return e.mapDomToView(n);
                  })(o, e.domConverter),
                  a = t.editing.mapper.toModelElement(s);
                this._insertParagraph(a, r), i.preventDefault(), n.stop();
              });
            }
            _enableInsertingParagraphsOnEnterKeypress() {
              const t = this.editor,
                e = t.model.document.selection,
                n = t.editing.view;
              this._listenToIfEnabled(
                n.document,
                "enter",
                (n, i) => {
                  if ("atTarget" != n.eventPhase) return;
                  const o = e.getSelectedElement(),
                    r = t.editing.mapper.toViewElement(o),
                    s = t.model.schema;
                  let a;
                  this._insertParagraphAccordingToFakeCaretPosition()
                    ? (a = !0)
                    : ep(r, o, s) &&
                      (this._insertParagraph(o, i.isSoft ? "before" : "after"),
                      (a = !0)),
                    a && (i.preventDefault(), n.stop());
                },
                { context: qg }
              );
            }
            _enableInsertingParagraphsOnTypingKeystroke() {
              const t = this.editor.editing.view,
                e = [dr.enter, dr.delete, dr.backspace];
              this._listenToIfEnabled(
                t.document,
                "keydown",
                (t, n) => {
                  e.includes(n.keyCode) ||
                    Qm(n) ||
                    this._insertParagraphAccordingToFakeCaretPosition();
                },
                { priority: "high" }
              );
            }
            _enableDeleteIntegration() {
              const t = this.editor,
                e = t.editing.view,
                n = t.model,
                i = n.schema;
              this._listenToIfEnabled(
                e.document,
                "delete",
                (e, o) => {
                  if ("atTarget" != e.eventPhase) return;
                  const r = np(n.document.selection);
                  if (!r) return;
                  const s = o.direction,
                    a = n.document.selection.getSelectedElement(),
                    c = "forward" == s;
                  if (("before" === r) === c)
                    t.execute("delete", {
                      selection: n.createSelection(a, "on"),
                    });
                  else {
                    const e = i.getNearestSelectionRange(
                      n.createPositionAt(a, r),
                      s
                    );
                    if (e)
                      if (e.isCollapsed) {
                        const o = n.createSelection(e.start);
                        if (
                          (n.modifySelection(o, { direction: s }),
                          o.focus.isEqual(e.start))
                        ) {
                          const t = (function (t, e) {
                            let n = e;
                            for (const i of e.getAncestors({
                              parentFirst: !0,
                            })) {
                              if (i.childCount > 1 || t.isLimit(i)) break;
                              n = i;
                            }
                            return n;
                          })(i, e.start.parent);
                          n.deleteContent(n.createSelection(t, "on"), {
                            doNotAutoparagraph: !0,
                          });
                        } else
                          n.change((n) => {
                            n.setSelection(e),
                              t.execute(c ? "deleteForward" : "delete");
                          });
                      } else
                        n.change((n) => {
                          n.setSelection(e),
                            t.execute(c ? "deleteForward" : "delete");
                        });
                  }
                  o.preventDefault(), e.stop();
                },
                { context: qg }
              );
            }
            _enableInsertContentIntegration() {
              const t = this.editor,
                e = this.editor.model,
                n = e.document.selection;
              this._listenToIfEnabled(
                t.model,
                "insertContent",
                (t, [i, o]) => {
                  if (o && !o.is("documentSelection")) return;
                  const r = np(n);
                  return r
                    ? (t.stop(),
                      e.change((t) => {
                        const o = n.getSelectedElement(),
                          s = e.createPositionAt(o, r),
                          a = t.createSelection(s),
                          c = e.insertContent(i, a);
                        return t.setSelection(a), c;
                      }))
                    : void 0;
                },
                { priority: "high" }
              );
            }
            _enableInsertObjectIntegration() {
              const t = this.editor,
                e = this.editor.model.document.selection;
              this._listenToIfEnabled(
                t.model,
                "insertObject",
                (t, n) => {
                  const [, i, , o = {}] = n;
                  if (i && !i.is("documentSelection")) return;
                  const r = np(e);
                  r && ((o.findOptimalPosition = r), (n[3] = o));
                },
                { priority: "high" }
              );
            }
            _enableDeleteContentIntegration() {
              const t = this.editor,
                e = this.editor.model.document.selection;
              this._listenToIfEnabled(
                t.model,
                "deleteContent",
                (t, [n]) => {
                  if (n && !n.is("documentSelection")) return;
                  np(e) && t.stop();
                },
                { priority: "high" }
              );
            }
          }
          function lp(t) {
            const e = t.model;
            return (n, i) => {
              const o = i.keyCode == dr.arrowup,
                r = i.keyCode == dr.arrowdown,
                s = i.shiftKey,
                a = e.document.selection;
              if (!o && !r) return;
              const c = r;
              if (
                s &&
                (function (t, e) {
                  return !t.isCollapsed && t.isBackward == e;
                })(a, c)
              )
                return;
              const l = (function (t, e, n) {
                const i = t.model;
                if (n) {
                  const t = e.isCollapsed ? e.focus : e.getLastPosition(),
                    n = dp(i, t, "forward");
                  if (!n) return null;
                  const o = i.createRange(t, n),
                    r = hp(i.schema, o, "backward");
                  return r ? i.createRange(t, r) : null;
                }
                {
                  const t = e.isCollapsed ? e.focus : e.getFirstPosition(),
                    n = dp(i, t, "backward");
                  if (!n) return null;
                  const o = i.createRange(n, t),
                    r = hp(i.schema, o, "forward");
                  return r ? i.createRange(r, t) : null;
                }
              })(t, a, c);
              if (l) {
                if (l.isCollapsed) {
                  if (a.isCollapsed) return;
                  if (s) return;
                }
                (l.isCollapsed ||
                  (function (t, e, n) {
                    const i = t.model,
                      o = t.view.domConverter;
                    if (n) {
                      const t = i.createSelection(e.start);
                      i.modifySelection(t),
                        t.focus.isAtEnd ||
                          e.start.isEqual(t.focus) ||
                          (e = i.createRange(t.focus, e.end));
                    }
                    const r = t.mapper.toViewRange(e),
                      s = o.viewRangeToDom(r),
                      a = ka.getDomRangeRects(s);
                    let c;
                    for (const t of a)
                      if (void 0 !== c) {
                        if (Math.round(t.top) >= c) return !1;
                        c = Math.max(c, Math.round(t.bottom));
                      } else c = Math.round(t.bottom);
                    return !0;
                  })(t, l, c)) &&
                  (e.change((t) => {
                    const n = c ? l.end : l.start;
                    if (s) {
                      const i = e.createSelection(a.anchor);
                      i.setFocus(n), t.setSelection(i);
                    } else t.setSelection(n);
                  }),
                  n.stop(),
                  i.preventDefault(),
                  i.stopPropagation());
              }
            };
          }
          function dp(t, e, n) {
            const i = t.schema,
              o = t.createRangeIn(e.root),
              r = "forward" == n ? "elementStart" : "elementEnd";
            for (const { previousPosition: t, item: s, type: a } of o.getWalker(
              { startPosition: e, direction: n }
            )) {
              if (i.isLimit(s) && !i.isInline(s)) return t;
              if (a == r && i.isBlock(s)) return null;
            }
            return null;
          }
          function hp(t, e, n) {
            const i = "backward" == n ? e.end : e.start;
            if (t.checkChild(i, "$text")) return i;
            for (const { nextPosition: i } of e.getWalker({ direction: n }))
              if (t.checkChild(i, "$text")) return i;
            return null;
          }
          var up = n(6507),
            mp = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(up.Z, mp);
          up.Z.locals;
          class gp extends ue {
            static get pluginName() {
              return "Widget";
            }
            static get requires() {
              return [cp, ig];
            }
            init() {
              const t = this.editor,
                e = t.editing.view,
                n = e.document;
              (this._previouslySelected = new Set()),
                this.editor.editing.downcastDispatcher.on(
                  "selection",
                  (e, n, i) => {
                    const o = i.writer,
                      r = n.selection;
                    if (r.isCollapsed) return;
                    const s = r.getSelectedElement();
                    if (!s) return;
                    const a = t.editing.mapper.toViewElement(s);
                    qg(a) &&
                      i.consumable.consume(r, "selection") &&
                      o.setSelection(o.createRangeOn(a), {
                        fake: !0,
                        label: Qg(a),
                      });
                  }
                ),
                this.editor.editing.downcastDispatcher.on(
                  "selection",
                  (t, e, n) => {
                    this._clearPreviouslySelectedWidgets(n.writer);
                    const i = n.writer,
                      o = i.document.selection;
                    let r = null;
                    for (const t of o.getRanges())
                      for (const e of t) {
                        const t = e.item;
                        qg(t) &&
                          !pp(t, r) &&
                          (i.addClass($g, t),
                          this._previouslySelected.add(t),
                          (r = t));
                      }
                  },
                  { priority: "low" }
                ),
                e.addObserver(km),
                this.listenTo(n, "mousedown", (...t) =>
                  this._onMousedown(...t)
                ),
                this.listenTo(
                  n,
                  "arrowKey",
                  (...t) => {
                    this._handleSelectionChangeOnArrowKeyPress(...t);
                  },
                  { context: [qg, "$text"] }
                ),
                this.listenTo(
                  n,
                  "arrowKey",
                  (...t) => {
                    this._preventDefaultOnArrowKeyPress(...t);
                  },
                  { context: "$root" }
                ),
                this.listenTo(n, "arrowKey", lp(this.editor.editing), {
                  context: "$text",
                }),
                this.listenTo(
                  n,
                  "delete",
                  (t, e) => {
                    this._handleDelete("forward" == e.direction) &&
                      (e.preventDefault(), t.stop());
                  },
                  { context: "$root" }
                );
            }
            _onMousedown(t, e) {
              const n = this.editor,
                i = n.editing.view,
                o = i.document;
              let r = e.target;
              if (
                (function (t) {
                  for (; t; ) {
                    if (t.is("editableElement") && !t.is("rootElement"))
                      return !0;
                    if (qg(t)) return !1;
                    t = t.parent;
                  }
                  return !1;
                })(r)
              ) {
                if ((sr.isSafari || sr.isGecko) && e.domEvent.detail >= 3) {
                  const t = n.editing.mapper,
                    i = r.is("attributeElement")
                      ? r.findAncestor((t) => !t.is("attributeElement"))
                      : r,
                    o = t.toModelElement(i);
                  e.preventDefault(),
                    this.editor.model.change((t) => {
                      t.setSelection(o, "in");
                    });
                }
                return;
              }
              if (!qg(r) && ((r = r.findAncestor(qg)), !r)) return;
              sr.isAndroid && e.preventDefault(), o.isFocused || i.focus();
              const s = n.editing.mapper.toModelElement(r);
              this._setSelectionOverElement(s);
            }
            _handleSelectionChangeOnArrowKeyPress(t, e) {
              const n = e.keyCode,
                i = this.editor.model,
                o = i.schema,
                r = i.document.selection,
                s = r.getSelectedElement(),
                a = pr(n, this.editor.locale.contentLanguageDirection),
                c = "down" == a || "right" == a,
                l = "up" == a || "down" == a;
              if (s && o.isObject(s)) {
                const n = c ? r.getLastPosition() : r.getFirstPosition(),
                  s = o.getNearestSelectionRange(n, c ? "forward" : "backward");
                return void (
                  s &&
                  (i.change((t) => {
                    t.setSelection(s);
                  }),
                  e.preventDefault(),
                  t.stop())
                );
              }
              if (!r.isCollapsed && !e.shiftKey) {
                const n = r.getFirstPosition(),
                  s = r.getLastPosition(),
                  a = n.nodeAfter,
                  l = s.nodeBefore;
                return void (
                  ((a && o.isObject(a)) || (l && o.isObject(l))) &&
                  (i.change((t) => {
                    t.setSelection(c ? s : n);
                  }),
                  e.preventDefault(),
                  t.stop())
                );
              }
              if (!r.isCollapsed) return;
              const d = this._getObjectElementNextToSelection(c);
              if (d && o.isObject(d)) {
                if (o.isInline(d) && l) return;
                this._setSelectionOverElement(d), e.preventDefault(), t.stop();
              }
            }
            _preventDefaultOnArrowKeyPress(t, e) {
              const n = this.editor.model,
                i = n.schema,
                o = n.document.selection.getSelectedElement();
              o && i.isObject(o) && (e.preventDefault(), t.stop());
            }
            _handleDelete(t) {
              if (this.editor.isReadOnly) return;
              const e = this.editor.model.document.selection;
              if (!e.isCollapsed) return;
              const n = this._getObjectElementNextToSelection(t);
              return n
                ? (this.editor.model.change((t) => {
                    let i = e.anchor.parent;
                    for (; i.isEmpty; ) {
                      const e = i;
                      (i = e.parent), t.remove(e);
                    }
                    this._setSelectionOverElement(n);
                  }),
                  !0)
                : void 0;
            }
            _setSelectionOverElement(t) {
              this.editor.model.change((e) => {
                e.setSelection(e.createRangeOn(t));
              });
            }
            _getObjectElementNextToSelection(t) {
              const e = this.editor.model,
                n = e.schema,
                i = e.document.selection,
                o = e.createSelection(i);
              if (
                (e.modifySelection(o, {
                  direction: t ? "forward" : "backward",
                }),
                o.isEqual(i))
              )
                return null;
              const r = t ? o.focus.nodeBefore : o.focus.nodeAfter;
              return r && n.isObject(r) ? r : null;
            }
            _clearPreviouslySelectedWidgets(t) {
              for (const e of this._previouslySelected) t.removeClass($g, e);
              this._previouslySelected.clear();
            }
          }
          function pp(t, e) {
            return !!e && Array.from(t.getAncestors()).includes(e);
          }
          const fp = function (t, e, n) {
            var i = !0,
              o = !0;
            if ("function" != typeof t)
              throw new TypeError("Expected a function");
            return (
              x(n) &&
                ((i = "leading" in n ? !!n.leading : i),
                (o = "trailing" in n ? !!n.trailing : o)),
              ra(t, e, { leading: i, maxWait: e, trailing: o })
            );
          };
          var kp = n(390),
            bp = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(kp.Z, bp);
          kp.Z.locals;
          class wp extends ue {
            static get pluginName() {
              return "DragDrop";
            }
            static get requires() {
              return [Ng, gp];
            }
            init() {
              const t = this.editor,
                e = t.editing.view;
              (this._draggedRange = null),
                (this._draggingUid = ""),
                (this._draggableElement = null),
                (this._updateDropMarkerThrottled = fp(
                  (t) => this._updateDropMarker(t),
                  40
                )),
                (this._removeDropMarkerDelayed = Cp(
                  () => this._removeDropMarker(),
                  40
                )),
                (this._clearDraggableAttributesDelayed = Cp(
                  () => this._clearDraggableAttributes(),
                  40
                )),
                e.addObserver(Tg),
                e.addObserver(km),
                this._setupDragging(),
                this._setupContentInsertionIntegration(),
                this._setupClipboardInputIntegration(),
                this._setupDropMarker(),
                this._setupDraggableAttributeHandling(),
                this.listenTo(t, "change:isReadOnly", (t, e, n) => {
                  n
                    ? this.forceDisabled("readOnlyMode")
                    : this.clearForceDisabled("readOnlyMode");
                }),
                this.on("change:isEnabled", (t, e, n) => {
                  n || this._finalizeDragging(!1);
                }),
                sr.isAndroid && this.forceDisabled("noAndroidSupport");
            }
            destroy() {
              return (
                this._draggedRange &&
                  (this._draggedRange.detach(), (this._draggedRange = null)),
                this._updateDropMarkerThrottled.cancel(),
                this._removeDropMarkerDelayed.cancel(),
                this._clearDraggableAttributesDelayed.cancel(),
                super.destroy()
              );
            }
            _setupDragging() {
              const t = this.editor,
                e = t.model,
                n = e.document,
                i = t.editing.view,
                o = i.document;
              this.listenTo(
                o,
                "dragstart",
                (i, s) => {
                  const a = n.selection;
                  if (s.target && s.target.is("editableElement"))
                    return void s.preventDefault();
                  const c = s.target ? vp(s.target) : null;
                  if (c) {
                    const n = t.editing.mapper.toModelElement(c);
                    (this._draggedRange = cc.fromRange(e.createRangeOn(n))),
                      t.plugins.has("WidgetToolbarRepository") &&
                        t.plugins
                          .get("WidgetToolbarRepository")
                          .forceDisabled("dragDrop");
                  } else if (!o.selection.isCollapsed) {
                    const t = o.selection.getSelectedElement();
                    (t && qg(t)) ||
                      (this._draggedRange = cc.fromRange(a.getFirstRange()));
                  }
                  if (!this._draggedRange) return void s.preventDefault();
                  (this._draggingUid = r()),
                    (s.dataTransfer.effectAllowed = this.isEnabled
                      ? "copyMove"
                      : "copy"),
                    s.dataTransfer.setData(
                      "application/ckeditor5-dragging-uid",
                      this._draggingUid
                    );
                  const l = e.createSelection(this._draggedRange.toRange()),
                    d = t.data.toView(e.getSelectedContent(l));
                  o.fire("clipboardOutput", {
                    dataTransfer: s.dataTransfer,
                    content: d,
                    method: i.name,
                  }),
                    this.isEnabled ||
                      (this._draggedRange.detach(),
                      (this._draggedRange = null),
                      (this._draggingUid = ""));
                },
                { priority: "low" }
              ),
                this.listenTo(
                  o,
                  "dragend",
                  (t, e) => {
                    this._finalizeDragging(
                      !e.dataTransfer.isCanceled &&
                        "move" == e.dataTransfer.dropEffect
                    );
                  },
                  { priority: "low" }
                ),
                this.listenTo(o, "dragenter", () => {
                  this.isEnabled && i.focus();
                }),
                this.listenTo(o, "dragleave", () => {
                  this._removeDropMarkerDelayed();
                }),
                this.listenTo(
                  o,
                  "dragging",
                  (e, n) => {
                    if (!this.isEnabled)
                      return void (n.dataTransfer.dropEffect = "none");
                    this._removeDropMarkerDelayed.cancel();
                    const i = Ap(t, n.targetRanges, n.target);
                    this._draggedRange || (n.dataTransfer.dropEffect = "copy"),
                      sr.isGecko ||
                        ("copy" == n.dataTransfer.effectAllowed
                          ? (n.dataTransfer.dropEffect = "copy")
                          : ["all", "copyMove"].includes(
                              n.dataTransfer.effectAllowed
                            ) && (n.dataTransfer.dropEffect = "move")),
                      i && this._updateDropMarkerThrottled(i);
                  },
                  { priority: "low" }
                );
            }
            _setupClipboardInputIntegration() {
              const t = this.editor,
                e = t.editing.view.document;
              this.listenTo(
                e,
                "clipboardInput",
                (e, n) => {
                  if ("drop" != n.method) return;
                  const i = Ap(t, n.targetRanges, n.target);
                  if ((this._removeDropMarker(), !i))
                    return this._finalizeDragging(!1), void e.stop();
                  this._draggedRange &&
                    this._draggingUid !=
                      n.dataTransfer.getData(
                        "application/ckeditor5-dragging-uid"
                      ) &&
                    (this._draggedRange.detach(),
                    (this._draggedRange = null),
                    (this._draggingUid = ""));
                  if (
                    "move" == _p(n.dataTransfer) &&
                    this._draggedRange &&
                    this._draggedRange.containsRange(i, !0)
                  )
                    return this._finalizeDragging(!1), void e.stop();
                  n.targetRanges = [t.editing.mapper.toViewRange(i)];
                },
                { priority: "high" }
              );
            }
            _setupContentInsertionIntegration() {
              const t = this.editor.plugins.get(Ng);
              t.on(
                "contentInsertion",
                (t, e) => {
                  if (!this.isEnabled || "drop" !== e.method) return;
                  const n = e.targetRanges.map((t) =>
                    this.editor.editing.mapper.toModelRange(t)
                  );
                  this.editor.model.change((t) => t.setSelection(n));
                },
                { priority: "high" }
              ),
                t.on(
                  "contentInsertion",
                  (t, e) => {
                    if (!this.isEnabled || "drop" !== e.method) return;
                    const n = "move" == _p(e.dataTransfer),
                      i = !e.resultRange || !e.resultRange.isCollapsed;
                    this._finalizeDragging(i && n);
                  },
                  { priority: "lowest" }
                );
            }
            _setupDraggableAttributeHandling() {
              const t = this.editor,
                e = t.editing.view,
                n = e.document;
              this.listenTo(n, "mousedown", (i, o) => {
                if (sr.isAndroid || !o) return;
                this._clearDraggableAttributesDelayed.cancel();
                let r = vp(o.target);
                if (
                  sr.isBlink &&
                  !t.isReadOnly &&
                  !r &&
                  !n.selection.isCollapsed
                ) {
                  const t = n.selection.getSelectedElement();
                  (t && qg(t)) || (r = n.selection.editableElement);
                }
                r &&
                  (e.change((t) => {
                    t.setAttribute("draggable", "true", r);
                  }),
                  (this._draggableElement =
                    t.editing.mapper.toModelElement(r)));
              }),
                this.listenTo(n, "mouseup", () => {
                  sr.isAndroid || this._clearDraggableAttributesDelayed();
                });
            }
            _clearDraggableAttributes() {
              const t = this.editor.editing;
              t.view.change((e) => {
                this._draggableElement &&
                  "$graveyard" != this._draggableElement.root.rootName &&
                  e.removeAttribute(
                    "draggable",
                    t.mapper.toViewElement(this._draggableElement)
                  ),
                  (this._draggableElement = null);
              });
            }
            _setupDropMarker() {
              const t = this.editor;
              t.conversion
                .for("editingDowncast")
                .markerToHighlight({
                  model: "drop-target",
                  view: { classes: ["ck-clipboard-drop-target-range"] },
                }),
                t.conversion.for("editingDowncast").markerToElement({
                  model: "drop-target",
                  view: (e, { writer: n }) => {
                    if (t.model.schema.checkChild(e.markerRange.start, "$text"))
                      return n.createUIElement(
                        "span",
                        { class: "ck ck-clipboard-drop-target-position" },
                        function (t) {
                          const e = this.toDomElement(t);
                          return (
                            (e.innerHTML = "&NoBreak;<span></span>&NoBreak;"), e
                          );
                        }
                      );
                  },
                });
            }
            _updateDropMarker(t) {
              const e = this.editor,
                n = e.model.markers;
              e.model.change((e) => {
                n.has("drop-target")
                  ? n.get("drop-target").getRange().isEqual(t) ||
                    e.updateMarker("drop-target", { range: t })
                  : e.addMarker("drop-target", {
                      range: t,
                      usingOperation: !1,
                      affectsData: !1,
                    });
              });
            }
            _removeDropMarker() {
              const t = this.editor.model;
              this._removeDropMarkerDelayed.cancel(),
                this._updateDropMarkerThrottled.cancel(),
                t.markers.has("drop-target") &&
                  t.change((t) => {
                    t.removeMarker("drop-target");
                  });
            }
            _finalizeDragging(t) {
              const e = this.editor,
                n = e.model;
              this._removeDropMarker(),
                this._clearDraggableAttributes(),
                e.plugins.has("WidgetToolbarRepository") &&
                  e.plugins
                    .get("WidgetToolbarRepository")
                    .clearForceDisabled("dragDrop"),
                (this._draggingUid = ""),
                this._draggedRange &&
                  (t &&
                    this.isEnabled &&
                    n.deleteContent(n.createSelection(this._draggedRange), {
                      doNotAutoparagraph: !0,
                    }),
                  this._draggedRange.detach(),
                  (this._draggedRange = null));
            }
          }
          function Ap(t, e, n) {
            const i = t.model,
              o = t.editing.mapper;
            let r = null;
            const s = e ? e[0].start : null;
            if (
              (n.is("uiElement") && (n = n.parent),
              (r = (function (t, e) {
                const n = t.model,
                  i = t.editing.mapper;
                if (qg(e)) return n.createRangeOn(i.toModelElement(e));
                if (!e.is("editableElement")) {
                  const t = e.findAncestor(
                    (t) => qg(t) || t.is("editableElement")
                  );
                  if (qg(t)) return n.createRangeOn(i.toModelElement(t));
                }
                return null;
              })(t, n)),
              r)
            )
              return r;
            const a = (function (t, e) {
                const n = t.editing.mapper,
                  i = t.editing.view,
                  o = n.toModelElement(e);
                if (o) return o;
                const r = i.createPositionBefore(e),
                  s = n.findMappedViewAncestor(r);
                return n.toModelElement(s);
              })(t, n),
              c = s ? o.toModelPosition(s) : null;
            return c
              ? ((r = (function (t, e, n) {
                  const i = t.model;
                  if (!i.schema.checkChild(n, "$block")) return null;
                  const o = i.createPositionAt(n, 0),
                    r = e.path.slice(0, o.path.length),
                    s = i.createPositionFromPath(e.root, r).nodeAfter;
                  if (s && i.schema.isObject(s)) return i.createRangeOn(s);
                  return null;
                })(t, c, a)),
                r ||
                  ((r = i.schema.getNearestSelectionRange(
                    c,
                    sr.isGecko ? "forward" : "backward"
                  )),
                  r ||
                    (function (t, e) {
                      const n = t.model;
                      for (; e; ) {
                        if (n.schema.isObject(e)) return n.createRangeOn(e);
                        e = e.parent;
                      }
                    })(t, c.parent)))
              : (function (t, e) {
                  const n = t.model,
                    i = n.schema,
                    o = n.createPositionAt(e, 0);
                  return i.getNearestSelectionRange(o, "forward");
                })(t, a);
          }
          function _p(t) {
            return sr.isGecko
              ? t.dropEffect
              : ["all", "copyMove"].includes(t.effectAllowed)
              ? "move"
              : "copy";
          }
          function Cp(t, e) {
            let n;
            function i(...o) {
              i.cancel(), (n = setTimeout(() => t(...o), e));
            }
            return (
              (i.cancel = () => {
                clearTimeout(n);
              }),
              i
            );
          }
          function vp(t) {
            if (t.is("editableElement")) return null;
            if (t.hasClass("ck-widget__selection-handle"))
              return t.findAncestor(qg);
            if (qg(t)) return t;
            const e = t.findAncestor((t) => qg(t) || t.is("editableElement"));
            return qg(e) ? e : null;
          }
          class yp extends ue {
            static get pluginName() {
              return "PastePlainText";
            }
            static get requires() {
              return [Ng];
            }
            init() {
              const t = this.editor,
                e = t.model,
                n = t.editing.view,
                i = n.document,
                o = e.document.selection;
              let r = !1;
              n.addObserver(Tg),
                this.listenTo(i, "keydown", (t, e) => {
                  r = e.shiftKey;
                }),
                t.plugins.get(Ng).on("contentInsertion", (t, n) => {
                  (r ||
                    (function (t, e) {
                      if (t.childCount > 1) return !1;
                      const n = t.getChild(0);
                      if (e.isObject(n)) return !1;
                      return 0 == [...n.getAttributeKeys()].length;
                    })(n.content, e.schema)) &&
                    e.change((t) => {
                      const i = Array.from(o.getAttributes()).filter(
                        ([t]) => e.schema.getAttributeProperties(t).isFormatting
                      );
                      o.isCollapsed ||
                        e.deleteContent(o, { doNotAutoparagraph: !0 }),
                        i.push(...o.getAttributes());
                      const r = t.createRangeIn(n.content);
                      for (const e of r.getItems())
                        e.is("$textProxy") && t.setAttributes(i, e);
                    });
                });
            }
          }
          class xp extends ue {
            static get pluginName() {
              return "Clipboard";
            }
            static get requires() {
              return [Ng, wp, yp];
            }
          }
          class Ep extends ge {
            constructor(t) {
              super(t),
                (this._stack = []),
                (this._createdBatches = new WeakSet()),
                this.refresh(),
                this.listenTo(
                  t.data,
                  "set",
                  (t, e) => {
                    e[1] = { ...e[1] };
                    const n = e[1];
                    n.batchType || (n.batchType = { isUndoable: !1 });
                  },
                  { priority: "high" }
                ),
                this.listenTo(t.data, "set", (t, e) => {
                  e[1].batchType.isUndoable || this.clearStack();
                });
            }
            refresh() {
              this.isEnabled = this._stack.length > 0;
            }
            addBatch(t) {
              const e = this.editor.model.document.selection,
                n = {
                  ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [],
                  isBackward: e.isBackward,
                };
              this._stack.push({ batch: t, selection: n }), this.refresh();
            }
            clearStack() {
              (this._stack = []), this.refresh();
            }
            _restoreSelection(t, e, n) {
              const i = this.editor.model,
                o = i.document,
                r = [],
                s = t.map((t) => t.getTransformedByOperations(n)),
                a = s.flat();
              for (const t of s) {
                const e = t
                  .filter((t) => t.root != o.graveyard)
                  .filter((t) => !Sp(t, a));
                e.length && (Dp(e), r.push(e[0]));
              }
              r.length &&
                i.change((t) => {
                  t.setSelection(r, { backward: e });
                });
            }
            _undo(t, e) {
              const n = this.editor.model,
                i = n.document;
              this._createdBatches.add(e);
              const o = t.operations
                .slice()
                .filter((t) => t.isDocumentOperation);
              o.reverse();
              for (const t of o) {
                const o = t.baseVersion + 1,
                  r = Array.from(i.history.getOperations(o)),
                  s = lm([t.getReversed()], r, {
                    useRelations: !0,
                    document: this.editor.model.document,
                    padWithNoOps: !1,
                    forceWeakRemove: !0,
                  }).operationsA;
                for (const o of s)
                  e.addOperation(o),
                    n.applyOperation(o),
                    i.history.setOperationAsUndone(t, o);
              }
            }
          }
          function Dp(t) {
            t.sort((t, e) => (t.start.isBefore(e.start) ? -1 : 1));
            for (let e = 1; e < t.length; e++) {
              const n = t[e - 1].getJoined(t[e], !0);
              n && (e--, t.splice(e, 2, n));
            }
          }
          function Sp(t, e) {
            return e.some((e) => e !== t && e.containsRange(t, !0));
          }
          class Ip extends Ep {
            execute(t = null) {
              const e = t
                  ? this._stack.findIndex((e) => e.batch == t)
                  : this._stack.length - 1,
                n = this._stack.splice(e, 1)[0],
                i = this.editor.model.createBatch({ isUndo: !0 });
              this.editor.model.enqueueChange(i, () => {
                this._undo(n.batch, i);
                const t = this.editor.model.document.history.getOperations(
                  n.batch.baseVersion
                );
                this._restoreSelection(
                  n.selection.ranges,
                  n.selection.isBackward,
                  t
                ),
                  this.fire("revert", n.batch, i);
              }),
                this.refresh();
            }
          }
          class Tp extends Ep {
            execute() {
              const t = this._stack.pop(),
                e = this.editor.model.createBatch({ isUndo: !0 });
              this.editor.model.enqueueChange(e, () => {
                const n =
                    t.batch.operations[t.batch.operations.length - 1]
                      .baseVersion + 1,
                  i = this.editor.model.document.history.getOperations(n);
                this._restoreSelection(
                  t.selection.ranges,
                  t.selection.isBackward,
                  i
                ),
                  this._undo(t.batch, e);
              }),
                this.refresh();
            }
          }
          class Mp extends ue {
            static get pluginName() {
              return "UndoEditing";
            }
            constructor(t) {
              super(t), (this._batchRegistry = new WeakSet());
            }
            init() {
              const t = this.editor;
              (this._undoCommand = new Ip(t)),
                (this._redoCommand = new Tp(t)),
                t.commands.add("undo", this._undoCommand),
                t.commands.add("redo", this._redoCommand),
                this.listenTo(
                  t.model,
                  "applyOperation",
                  (t, e) => {
                    const n = e[0];
                    if (!n.isDocumentOperation) return;
                    const i = n.batch,
                      o = this._redoCommand._createdBatches.has(i),
                      r = this._undoCommand._createdBatches.has(i);
                    this._batchRegistry.has(i) ||
                      (this._batchRegistry.add(i),
                      i.isUndoable &&
                        (o
                          ? this._undoCommand.addBatch(i)
                          : r ||
                            (this._undoCommand.addBatch(i),
                            this._redoCommand.clearStack())));
                  },
                  { priority: "highest" }
                ),
                this.listenTo(this._undoCommand, "revert", (t, e, n) => {
                  this._redoCommand.addBatch(n);
                }),
                t.keystrokes.set("CTRL+Z", "undo"),
                t.keystrokes.set("CTRL+Y", "redo"),
                t.keystrokes.set("CTRL+SHIFT+Z", "redo");
            }
          }
          const Bp =
              '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>',
            Np =
              '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
          class zp extends ue {
            static get pluginName() {
              return "UndoUI";
            }
            init() {
              const t = this.editor,
                e = t.locale,
                n = t.t,
                i = "ltr" == e.uiLanguageDirection ? Bp : Np,
                o = "ltr" == e.uiLanguageDirection ? Np : Bp;
              this._addButton("undo", n("Undo"), "CTRL+Z", i),
                this._addButton("redo", n("Redo"), "CTRL+Y", o);
            }
            _addButton(t, e, n, i) {
              const o = this.editor;
              o.ui.componentFactory.add(t, (r) => {
                const s = o.commands.get(t),
                  a = new kh(r);
                return (
                  a.set({ label: e, icon: i, keystroke: n, tooltip: !0 }),
                  a.bind("isEnabled").to(s, "isEnabled"),
                  this.listenTo(a, "execute", () => {
                    o.execute(t), o.editing.view.focus();
                  }),
                  a
                );
              });
            }
          }
          class Pp extends ue {
            static get requires() {
              return [Mp, zp];
            }
            static get pluginName() {
              return "Undo";
            }
          }
          class Lp extends ue {
            static get requires() {
              return [Hu];
            }
            static get pluginName() {
              return "WidgetToolbarRepository";
            }
            init() {
              const t = this.editor;
              if (t.plugins.has("BalloonToolbar")) {
                const e = t.plugins.get("BalloonToolbar");
                this.listenTo(
                  e,
                  "show",
                  (e) => {
                    (function (t) {
                      const e = t.getSelectedElement();
                      return !(!e || !qg(e));
                    })(t.editing.view.document.selection) && e.stop();
                  },
                  { priority: "high" }
                );
              }
              (this._toolbarDefinitions = new Map()),
                (this._balloon = this.editor.plugins.get("ContextualBalloon")),
                this.on("change:isEnabled", () => {
                  this._updateToolbarsVisibility();
                }),
                this.listenTo(t.ui, "update", () => {
                  this._updateToolbarsVisibility();
                }),
                this.listenTo(
                  t.ui.focusTracker,
                  "change:isFocused",
                  () => {
                    this._updateToolbarsVisibility();
                  },
                  { priority: "low" }
                );
            }
            destroy() {
              super.destroy();
              for (const t of this._toolbarDefinitions.values())
                t.view.destroy();
            }
            register(
              t,
              {
                ariaLabel: e,
                items: n,
                getRelatedElement: i,
                balloonClassName: o = "ck-toolbar-container",
              }
            ) {
              if (!n.length)
                return void l("widget-toolbar-no-items", { toolbarId: t });
              const r = this.editor,
                s = r.t,
                a = new qh(r.locale);
              if (
                ((a.ariaLabel = e || s("Widget toolbar")),
                this._toolbarDefinitions.has(t))
              )
                throw new c("widget-toolbar-duplicated", this, {
                  toolbarId: t,
                });
              a.fillFromConfig(n, r.ui.componentFactory),
                this._toolbarDefinitions.set(t, {
                  view: a,
                  getRelatedElement: i,
                  balloonClassName: o,
                });
            }
            _updateToolbarsVisibility() {
              let t = 0,
                e = null,
                n = null;
              for (const i of this._toolbarDefinitions.values()) {
                const o = i.getRelatedElement(
                  this.editor.editing.view.document.selection
                );
                if (this.isEnabled && o)
                  if (this.editor.ui.focusTracker.isFocused) {
                    const r = o.getAncestors().length;
                    r > t && ((t = r), (e = o), (n = i));
                  } else this._isToolbarVisible(i) && this._hideToolbar(i);
                else this._isToolbarInBalloon(i) && this._hideToolbar(i);
              }
              n && this._showToolbar(n, e);
            }
            _hideToolbar(t) {
              this._balloon.remove(t.view),
                this.stopListening(this._balloon, "change:visibleView");
            }
            _showToolbar(t, e) {
              this._isToolbarVisible(t)
                ? Rp(this.editor, e)
                : this._isToolbarInBalloon(t) ||
                  (this._balloon.add({
                    view: t.view,
                    position: Op(this.editor, e),
                    balloonClassName: t.balloonClassName,
                  }),
                  this.listenTo(this._balloon, "change:visibleView", () => {
                    for (const t of this._toolbarDefinitions.values())
                      if (this._isToolbarVisible(t)) {
                        const e = t.getRelatedElement(
                          this.editor.editing.view.document.selection
                        );
                        Rp(this.editor, e);
                      }
                  }));
            }
            _isToolbarVisible(t) {
              return this._balloon.visibleView === t.view;
            }
            _isToolbarInBalloon(t) {
              return this._balloon.hasView(t.view);
            }
          }
          function Rp(t, e) {
            const n = t.plugins.get("ContextualBalloon"),
              i = Op(t, e);
            n.updatePosition(i);
          }
          function Op(t, e) {
            const n = t.editing.view,
              i = zu.defaultPositions;
            return {
              target: n.domConverter.mapViewToDom(e),
              positions: [
                i.northArrowSouth,
                i.northArrowSouthWest,
                i.northArrowSouthEast,
                i.southArrowNorth,
                i.southArrowNorthWest,
                i.southArrowNorthEast,
                i.viewportStickyNorth,
              ],
            };
          }
          class jp {
            constructor(t) {
              this.set("activeHandlePosition", null),
                this.set("proposedWidthPercents", null),
                this.set("proposedWidth", null),
                this.set("proposedHeight", null),
                this.set("proposedHandleHostWidth", null),
                this.set("proposedHandleHostHeight", null),
                (this._options = t),
                (this._referenceCoordinates = null);
            }
            begin(t, e, n) {
              const i = new ka(e);
              (this.activeHandlePosition = (function (t) {
                const e = [
                  "top-left",
                  "top-right",
                  "bottom-right",
                  "bottom-left",
                ];
                for (const n of e) if (t.classList.contains(Fp(n))) return n;
              })(t)),
                (this._referenceCoordinates = (function (t, e) {
                  const n = new ka(t),
                    i = e.split("-"),
                    o = {
                      x: "right" == i[1] ? n.right : n.left,
                      y: "bottom" == i[0] ? n.bottom : n.top,
                    };
                  return (
                    (o.x += t.ownerDocument.defaultView.scrollX),
                    (o.y += t.ownerDocument.defaultView.scrollY),
                    o
                  );
                })(
                  e,
                  (function (t) {
                    const e = t.split("-"),
                      n = {
                        top: "bottom",
                        bottom: "top",
                        left: "right",
                        right: "left",
                      };
                    return `${n[e[0]]}-${n[e[1]]}`;
                  })(this.activeHandlePosition)
                )),
                (this.originalWidth = i.width),
                (this.originalHeight = i.height),
                (this.aspectRatio = i.width / i.height);
              const o = n.style.width;
              o && o.match(/^\d+(\.\d*)?%$/)
                ? (this.originalWidthPercents = parseFloat(o))
                : (this.originalWidthPercents = (function (t, e) {
                    const n = t.parentElement,
                      i = parseFloat(
                        n.ownerDocument.defaultView.getComputedStyle(n).width
                      );
                    return (e.width / i) * 100;
                  })(n, i));
            }
            update(t) {
              (this.proposedWidth = t.width),
                (this.proposedHeight = t.height),
                (this.proposedWidthPercents = t.widthPercents),
                (this.proposedHandleHostWidth = t.handleHostWidth),
                (this.proposedHandleHostHeight = t.handleHostHeight);
            }
          }
          function Fp(t) {
            return `ck-widget__resizer__handle-${t}`;
          }
          he(jp, re);
          class Vp extends Vd {
            constructor() {
              super();
              const t = this.bindTemplate;
              this.setTemplate({
                tag: "div",
                attributes: {
                  class: [
                    "ck",
                    "ck-size-view",
                    t.to("_viewPosition", (t) =>
                      t ? `ck-orientation-${t}` : ""
                    ),
                  ],
                  style: { display: t.if("_isVisible", "none", (t) => !t) },
                },
                children: [{ text: t.to("_label") }],
              });
            }
            _bindToState(t, e) {
              this.bind("_isVisible").to(
                e,
                "proposedWidth",
                e,
                "proposedHeight",
                (t, e) => null !== t && null !== e
              ),
                this.bind("_label").to(
                  e,
                  "proposedHandleHostWidth",
                  e,
                  "proposedHandleHostHeight",
                  e,
                  "proposedWidthPercents",
                  (e, n, i) => ("px" === t.unit ? `${e}×${n}` : `${i}%`)
                ),
                this.bind("_viewPosition").to(
                  e,
                  "activeHandlePosition",
                  e,
                  "proposedHandleHostWidth",
                  e,
                  "proposedHandleHostHeight",
                  (t, e, n) => (e < 50 || n < 50 ? "above-center" : t)
                );
            }
            _dismiss() {
              this.unbind(), (this._isVisible = !1);
            }
          }
          class Hp {
            constructor(t) {
              (this._options = t),
                (this._viewResizerWrapper = null),
                this.set("isEnabled", !0),
                this.decorate("begin"),
                this.decorate("cancel"),
                this.decorate("commit"),
                this.decorate("updateSize"),
                this.on(
                  "commit",
                  (t) => {
                    this.state.proposedWidth ||
                      this.state.proposedWidthPercents ||
                      (this._cleanup(), t.stop());
                  },
                  { priority: "high" }
                ),
                this.on("change:isEnabled", () => {
                  this.isEnabled && this.redraw();
                });
            }
            attach() {
              const t = this,
                e = this._options.viewElement;
              this._options.editor.editing.view.change((n) => {
                const i = n.createUIElement(
                  "div",
                  { class: "ck ck-reset_all ck-widget__resizer" },
                  function (e) {
                    const n = this.toDomElement(e);
                    return (
                      t._appendHandles(n),
                      t._appendSizeUI(n),
                      t.on("change:isEnabled", (t, e, i) => {
                        n.style.display = i ? "" : "none";
                      }),
                      (n.style.display = t.isEnabled ? "" : "none"),
                      n
                    );
                  }
                );
                n.insert(n.createPositionAt(e, "end"), i),
                  n.addClass("ck-widget_with-resizer", e),
                  (this._viewResizerWrapper = i);
              });
            }
            begin(t) {
              (this.state = new jp(this._options)),
                this._sizeView._bindToState(this._options, this.state),
                (this._initialViewWidth =
                  this._options.viewElement.getStyle("width")),
                this.state.begin(
                  t,
                  this._getHandleHost(),
                  this._getResizeHost()
                );
            }
            updateSize(t) {
              const e = this._proposeNewSize(t);
              this._options.editor.editing.view.change((t) => {
                const n = this._options.unit || "%",
                  i = ("%" === n ? e.widthPercents : e.width) + n;
                t.setStyle("width", i, this._options.viewElement);
              });
              const n = this._getHandleHost(),
                i = new ka(n);
              (e.handleHostWidth = Math.round(i.width)),
                (e.handleHostHeight = Math.round(i.height));
              const o = new ka(n);
              (e.width = Math.round(o.width)),
                (e.height = Math.round(o.height)),
                this.redraw(i),
                this.state.update(e);
            }
            commit() {
              const t = this._options.unit || "%",
                e =
                  ("%" === t
                    ? this.state.proposedWidthPercents
                    : this.state.proposedWidth) + t;
              this._options.editor.editing.view.change(() => {
                this._cleanup(), this._options.onCommit(e);
              });
            }
            cancel() {
              this._cleanup();
            }
            destroy() {
              this.cancel();
            }
            redraw(t) {
              const e = this._domResizerWrapper;
              if (!((n = e) && n.ownerDocument && n.ownerDocument.contains(n)))
                return;
              var n;
              const i = e.parentElement,
                o = this._getHandleHost(),
                r = this._viewResizerWrapper,
                s = [
                  r.getStyle("width"),
                  r.getStyle("height"),
                  r.getStyle("left"),
                  r.getStyle("top"),
                ];
              let a;
              if (i.isSameNode(o)) {
                const e = t || new ka(o);
                a = [e.width + "px", e.height + "px", void 0, void 0];
              } else
                a = [
                  o.offsetWidth + "px",
                  o.offsetHeight + "px",
                  o.offsetLeft + "px",
                  o.offsetTop + "px",
                ];
              "same" !== Li(s, a) &&
                this._options.editor.editing.view.change((t) => {
                  t.setStyle(
                    { width: a[0], height: a[1], left: a[2], top: a[3] },
                    r
                  );
                });
            }
            containsHandle(t) {
              return this._domResizerWrapper.contains(t);
            }
            static isResizeHandle(t) {
              return t.classList.contains("ck-widget__resizer__handle");
            }
            _cleanup() {
              this._sizeView._dismiss();
              this._options.editor.editing.view.change((t) => {
                t.setStyle(
                  "width",
                  this._initialViewWidth,
                  this._options.viewElement
                );
              });
            }
            _proposeNewSize(t) {
              const e = this.state,
                n = { x: (i = t).pageX, y: i.pageY };
              var i;
              const o =
                  !this._options.isCentered || this._options.isCentered(this),
                r = {
                  x: e._referenceCoordinates.x - (n.x + e.originalWidth),
                  y: n.y - e.originalHeight - e._referenceCoordinates.y,
                };
              o &&
                e.activeHandlePosition.endsWith("-right") &&
                (r.x = n.x - (e._referenceCoordinates.x + e.originalWidth)),
                o && (r.x *= 2);
              const s = {
                width: Math.abs(e.originalWidth + r.x),
                height: Math.abs(e.originalHeight + r.y),
              };
              (s.dominant =
                s.width / e.aspectRatio > s.height ? "width" : "height"),
                (s.max = s[s.dominant]);
              const a = { width: s.width, height: s.height };
              return (
                "width" == s.dominant
                  ? (a.height = a.width / e.aspectRatio)
                  : (a.width = a.height * e.aspectRatio),
                {
                  width: Math.round(a.width),
                  height: Math.round(a.height),
                  widthPercents: Math.min(
                    Math.round(
                      (e.originalWidthPercents / e.originalWidth) *
                        a.width *
                        100
                    ) / 100,
                    100
                  ),
                }
              );
            }
            _getResizeHost() {
              const t = this._domResizerWrapper.parentElement;
              return this._options.getResizeHost(t);
            }
            _getHandleHost() {
              const t = this._domResizerWrapper.parentElement;
              return this._options.getHandleHost(t);
            }
            get _domResizerWrapper() {
              return this._options.editor.editing.view.domConverter.mapViewToDom(
                this._viewResizerWrapper
              );
            }
            _appendHandles(t) {
              const e = [
                "top-left",
                "top-right",
                "bottom-right",
                "bottom-left",
              ];
              for (const i of e)
                t.appendChild(
                  new Hd({
                    tag: "div",
                    attributes: {
                      class:
                        "ck-widget__resizer__handle " +
                        ((n = i), `ck-widget__resizer__handle-${n}`),
                    },
                  }).render()
                );
              var n;
            }
            _appendSizeUI(t) {
              (this._sizeView = new Vp()),
                this._sizeView.render(),
                t.appendChild(this._sizeView.element);
            }
          }
          he(Hp, re);
          var Up = n(2263),
            $p = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Up.Z, $p);
          Up.Z.locals;
          function qp(t) {
            return t.createContainerElement("figure", { class: "image" }, [
              t.createEmptyElement("img"),
              t.createSlot(),
            ]);
          }
          function Gp(t, e) {
            const n = t.plugins.get("ImageUtils"),
              i =
                t.plugins.has("ImageInlineEditing") &&
                t.plugins.has("ImageBlockEditing");
            return (t) => {
              if (!n.isInlineImageView(t)) return null;
              if (!i) return o(t);
              return (t.findAncestor(n.isBlockImageView)
                ? "imageBlock"
                : "imageInline") !== e
                ? null
                : o(t);
            };
            function o(t) {
              const e = { name: !0 };
              return t.hasAttribute("src") && (e.attributes = ["src"]), e;
            }
          }
          function Wp(t, e) {
            const n = Na(e.getSelectedBlocks());
            return !n || t.isObject(n) || (n.isEmpty && "listItem" != n.name)
              ? "imageBlock"
              : "imageInline";
          }
          he(
            class extends ue {
              static get pluginName() {
                return "WidgetResize";
              }
              init() {
                const t = this.editor.editing,
                  e = os.window.document;
                this.set("visibleResizer", null),
                  this.set("_activeResizer", null),
                  (this._resizers = new Map()),
                  t.view.addObserver(km),
                  (this._observer = Object.create(bs)),
                  this.listenTo(
                    t.view.document,
                    "mousedown",
                    this._mouseDownListener.bind(this),
                    { priority: "high" }
                  ),
                  this._observer.listenTo(
                    e,
                    "mousemove",
                    this._mouseMoveListener.bind(this)
                  ),
                  this._observer.listenTo(
                    e,
                    "mouseup",
                    this._mouseUpListener.bind(this)
                  );
                const n = () => {
                  this.visibleResizer && this.visibleResizer.redraw();
                };
                (this._redrawFocusedResizerThrottled = fp(n, 200)),
                  this.on("change:visibleResizer", n),
                  this.editor.ui.on(
                    "update",
                    this._redrawFocusedResizerThrottled
                  ),
                  this.editor.model.document.on(
                    "change",
                    () => {
                      for (const [t, e] of this._resizers)
                        t.isAttached() ||
                          (this._resizers.delete(t), e.destroy());
                    },
                    { priority: "lowest" }
                  ),
                  this._observer.listenTo(
                    os.window,
                    "resize",
                    this._redrawFocusedResizerThrottled
                  );
                const i = this.editor.editing.view.document.selection;
                i.on("change", () => {
                  const t = i.getSelectedElement();
                  this.visibleResizer = this.getResizerByViewElement(t) || null;
                });
              }
              destroy() {
                this._observer.stopListening();
                for (const t of this._resizers.values()) t.destroy();
                this._redrawFocusedResizerThrottled.cancel();
              }
              attachTo(t) {
                const e = new Hp(t),
                  n = this.editor.plugins;
                if ((e.attach(), n.has("WidgetToolbarRepository"))) {
                  const t = n.get("WidgetToolbarRepository");
                  e.on(
                    "begin",
                    () => {
                      t.forceDisabled("resize");
                    },
                    { priority: "lowest" }
                  ),
                    e.on(
                      "cancel",
                      () => {
                        t.clearForceDisabled("resize");
                      },
                      { priority: "highest" }
                    ),
                    e.on(
                      "commit",
                      () => {
                        t.clearForceDisabled("resize");
                      },
                      { priority: "highest" }
                    );
                }
                this._resizers.set(t.viewElement, e);
                const i =
                  this.editor.editing.view.document.selection.getSelectedElement();
                return (
                  this.getResizerByViewElement(i) == e &&
                    (this.visibleResizer = e),
                  e
                );
              }
              getResizerByViewElement(t) {
                return this._resizers.get(t);
              }
              _getResizerByHandle(t) {
                for (const e of this._resizers.values())
                  if (e.containsHandle(t)) return e;
              }
              _mouseDownListener(t, e) {
                const n = e.domTarget;
                Hp.isResizeHandle(n) &&
                  ((this._activeResizer = this._getResizerByHandle(n)),
                  this._activeResizer &&
                    (this._activeResizer.begin(n),
                    t.stop(),
                    e.preventDefault()));
              }
              _mouseMoveListener(t, e) {
                this._activeResizer && this._activeResizer.updateSize(e);
              }
              _mouseUpListener() {
                this._activeResizer &&
                  (this._activeResizer.commit(), (this._activeResizer = null));
              }
            },
            re
          );
          class Yp extends ue {
            static get pluginName() {
              return "ImageUtils";
            }
            isImage(t) {
              return this.isInlineImage(t) || this.isBlockImage(t);
            }
            isInlineImageView(t) {
              return !!t && t.is("element", "img");
            }
            isBlockImageView(t) {
              return !!t && t.is("element", "figure") && t.hasClass("image");
            }
            insertImage(t = {}, e = null, n = null) {
              const i = this.editor,
                o = i.model,
                r = o.document.selection;
              (n = Kp(i, e || r, n)),
                (t = { ...Object.fromEntries(r.getAttributes()), ...t });
              for (const e in t) o.schema.checkAttribute(n, e) || delete t[e];
              return o.change((i) => {
                const r = i.createElement(n, t);
                return (
                  o.insertObject(r, e, null, {
                    setSelection: "on",
                    findOptimalPosition: !e && "imageInline" != n,
                  }),
                  r.parent ? r : null
                );
              });
            }
            getClosestSelectedImageWidget(t) {
              const e = t.getSelectedElement();
              if (e && this.isImageWidget(e)) return e;
              let n = t.getFirstPosition().parent;
              for (; n; ) {
                if (n.is("element") && this.isImageWidget(n)) return n;
                n = n.parent;
              }
              return null;
            }
            getClosestSelectedImageElement(t) {
              const e = t.getSelectedElement();
              return this.isImage(e)
                ? e
                : t.getFirstPosition().findAncestor("imageBlock");
            }
            isImageAllowed() {
              const t = this.editor.model.document.selection;
              return (
                (function (t, e) {
                  if ("imageBlock" == Kp(t, e)) {
                    const n = (function (t, e) {
                      const n = Jg(t, e).start.parent;
                      if (n.isEmpty && !n.is("element", "$root"))
                        return n.parent;
                      return n;
                    })(e, t.model);
                    if (t.model.schema.checkChild(n, "imageBlock")) return !0;
                  } else if (t.model.schema.checkChild(e.focus, "imageInline"))
                    return !0;
                  return !1;
                })(this.editor, t) &&
                (function (t) {
                  return [...t.focus.getAncestors()].every(
                    (t) => !t.is("element", "imageBlock")
                  );
                })(t)
              );
            }
            toImageWidget(t, e, n) {
              e.setCustomProperty("image", !0, t);
              return Gg(t, e, {
                label: () => {
                  const e = this.findViewImgElement(t).getAttribute("alt");
                  return e ? `${e} ${n}` : n;
                },
              });
            }
            isImageWidget(t) {
              return !!t.getCustomProperty("image") && qg(t);
            }
            isBlockImage(t) {
              return !!t && t.is("element", "imageBlock");
            }
            isInlineImage(t) {
              return !!t && t.is("element", "imageInline");
            }
            findViewImgElement(t) {
              if (this.isInlineImageView(t)) return t;
              const e = this.editor.editing.view;
              for (const { item: n } of e.createRangeIn(t))
                if (this.isInlineImageView(n)) return n;
            }
          }
          function Kp(t, e, n) {
            const i = t.model.schema,
              o = t.config.get("image.insert.type");
            return t.plugins.has("ImageBlockEditing")
              ? t.plugins.has("ImageInlineEditing")
                ? n ||
                  ("inline" === o
                    ? "imageInline"
                    : "block" === o
                    ? "imageBlock"
                    : e.is("selection")
                    ? Wp(i, e)
                    : i.checkChild(e, "imageInline")
                    ? "imageInline"
                    : "imageBlock")
                : "imageBlock"
              : "imageInline";
          }
          const Qp = new RegExp(
            String(
              /^(http(s)?:\/\/)?[\w-]+\.[\w.~:/[\]@!$&'()*+,;=%-]+/.source +
                /\.(jpg|jpeg|png|gif|ico|webp|JPG|JPEG|PNG|GIF|ICO|WEBP)/
                  .source +
                /(\?[\w.~:/[\]@!$&'()*+,;=%-]*)?/.source +
                /(#[\w.~:/[\]@!$&'()*+,;=%-]*)?$/.source
            )
          );
          const Zp = function (t, e, n) {
            var i = t.length;
            return (n = void 0 === n ? i : n), !e && n >= i ? t : ho(t, e, n);
          };
          var Jp = RegExp(
            "[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]"
          );
          const Xp = function (t) {
            return Jp.test(t);
          };
          const tf = function (t) {
            return t.split("");
          };
          var ef = "[\\ud800-\\udfff]",
            nf = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]",
            of = "\\ud83c[\\udffb-\\udfff]",
            rf = "[^\\ud800-\\udfff]",
            sf = "(?:\\ud83c[\\udde6-\\uddff]){2}",
            af = "[\\ud800-\\udbff][\\udc00-\\udfff]",
            cf = "(?:" + nf + "|" + of + ")" + "?",
            lf = "[\\ufe0e\\ufe0f]?",
            df =
              lf +
              cf +
              ("(?:\\u200d(?:" + [rf, sf, af].join("|") + ")" + lf + cf + ")*"),
            hf = "(?:" + [rf + nf + "?", nf, sf, af, ef].join("|") + ")",
            uf = RegExp(of + "(?=" + of + ")|" + hf + df, "g");
          const mf = function (t) {
            return t.match(uf) || [];
          };
          const gf = function (t) {
            return Xp(t) ? mf(t) : tf(t);
          };
          const pf = (function (t) {
              return function (e) {
                e = ro(e);
                var n = Xp(e) ? gf(e) : void 0,
                  i = n ? n[0] : e.charAt(0),
                  o = n ? Zp(n, 1).join("") : e.slice(1);
                return i[t]() + o;
              };
            })("toUpperCase"),
            ff = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g,
            kf =
              /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i,
            bf =
              /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i,
            wf = /^((\w+:(\/{2,})?)|(\W))/i,
            Af = "Ctrl+K";
          function _f(t, { writer: e }) {
            const n = e.createAttributeElement(
              "a",
              { href: t },
              { priority: 5 }
            );
            return e.setCustomProperty("link", !0, n), n;
          }
          function Cf(t) {
            return (function (t) {
              return t.replace(ff, "").match(kf);
            })((t = String(t)))
              ? t
              : "#";
          }
          function vf(t, e) {
            return !!t && e.checkAttribute(t.name, "linkHref");
          }
          function yf(t, e) {
            const n = ((i = t), bf.test(i) ? "mailto:" : e);
            var i;
            const o = !!n && !wf.test(t);
            return t && o ? n + t : t;
          }
          function xf(t) {
            window.open(t, "_blank", "noopener");
          }
          const Ef = new RegExp(
            "(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$",
            "i"
          );
          class Df extends ue {
            static get requires() {
              return [ig];
            }
            static get pluginName() {
              return "AutoLink";
            }
            init() {
              const t = this.editor.model.document.selection;
              t.on("change:range", () => {
                this.isEnabled = !t.anchor.parent.is("element", "codeBlock");
              }),
                this._enableTypingHandling();
            }
            afterInit() {
              this._enableEnterHandling(), this._enableShiftEnterHandling();
            }
            _enableTypingHandling() {
              const t = this.editor,
                e = new sg(t.model, (t) => {
                  if (
                    !(function (t) {
                      return (
                        t.length > 4 &&
                        " " === t[t.length - 1] &&
                        " " !== t[t.length - 2]
                      );
                    })(t)
                  )
                    return;
                  const e = Sf(t.substr(0, t.length - 1));
                  return e ? { url: e } : void 0;
                });
              e.on("matched:data", (e, n) => {
                const { batch: i, range: o, url: r } = n;
                if (!i.isTyping) return;
                const s = o.end.getShiftedBy(-1),
                  a = s.getShiftedBy(-r.length),
                  c = t.model.createRange(a, s);
                this._applyAutoLink(r, c);
              }),
                e.bind("isEnabled").to(this);
            }
            _enableEnterHandling() {
              const t = this.editor,
                e = t.model,
                n = t.commands.get("enter");
              n &&
                n.on("execute", () => {
                  const t = e.document.selection.getFirstPosition();
                  if (!t.parent.previousSibling) return;
                  const n = e.createRangeIn(t.parent.previousSibling);
                  this._checkAndApplyAutoLinkOnRange(n);
                });
            }
            _enableShiftEnterHandling() {
              const t = this.editor,
                e = t.model,
                n = t.commands.get("shiftEnter");
              n &&
                n.on("execute", () => {
                  const t = e.document.selection.getFirstPosition(),
                    n = e.createRange(
                      e.createPositionAt(t.parent, 0),
                      t.getShiftedBy(-1)
                    );
                  this._checkAndApplyAutoLinkOnRange(n);
                });
            }
            _checkAndApplyAutoLinkOnRange(t) {
              const e = this.editor.model,
                { text: n, range: i } = rg(t, e),
                o = Sf(n);
              if (o) {
                const t = e.createRange(i.end.getShiftedBy(-o.length), i.end);
                this._applyAutoLink(o, t);
              }
            }
            _applyAutoLink(t, e) {
              const n = this.editor.model,
                i = this.editor.plugins.get("Delete");
              this.isEnabled &&
                (function (t, e) {
                  return e.schema.checkAttributeInSelection(
                    e.createSelection(t),
                    "linkHref"
                  );
                })(e, n) &&
                n.enqueueChange((o) => {
                  const r = this.editor.config.get("link.defaultProtocol"),
                    s = yf(t, r);
                  o.setAttribute("linkHref", s, e),
                    n.enqueueChange(() => {
                      i.requestUndoOnBackspace();
                    });
                });
            }
          }
          function Sf(t) {
            const e = Ef.exec(t);
            return e ? e[2] : null;
          }
          class If extends ge {
            execute() {
              const t = this.editor.model,
                e = t.document;
              t.change((n) => {
                !(function (t, e, n) {
                  const i = n.isCollapsed,
                    o = n.getFirstRange(),
                    r = o.start.parent,
                    s = o.end.parent,
                    a = r == s;
                  if (i) {
                    const i = zg(t.schema, n.getAttributes());
                    Tf(t, e, o.end),
                      e.removeSelectionAttribute(n.getAttributeKeys()),
                      e.setSelectionAttribute(i);
                  } else {
                    const i = !(o.start.isAtStart && o.end.isAtEnd);
                    t.deleteContent(n, { leaveUnmerged: i }),
                      a ? Tf(t, e, n.focus) : i && e.setSelection(s, 0);
                  }
                })(t, n, e.selection),
                  this.fire("afterExecute", { writer: n });
              });
            }
            refresh() {
              const t = this.editor.model,
                e = t.document;
              this.isEnabled = (function (t, e) {
                if (e.rangeCount > 1) return !1;
                const n = e.anchor;
                if (!n || !t.checkChild(n, "softBreak")) return !1;
                const i = e.getFirstRange(),
                  o = i.start.parent,
                  r = i.end.parent;
                if ((Mf(o, t) || Mf(r, t)) && o !== r) return !1;
                return !0;
              })(t.schema, e.selection);
            }
          }
          function Tf(t, e, n) {
            const i = e.createElement("softBreak");
            t.insertContent(i, n), e.setSelection(i, "after");
          }
          function Mf(t, e) {
            return !t.is("rootElement") && (e.isLimit(t) || Mf(t.parent, e));
          }
          class Bf extends ue {
            static get pluginName() {
              return "ShiftEnter";
            }
            init() {
              const t = this.editor,
                e = t.model.schema,
                n = t.conversion,
                i = t.editing.view,
                o = i.document;
              e.register("softBreak", { allowWhere: "$text", isInline: !0 }),
                n
                  .for("upcast")
                  .elementToElement({ model: "softBreak", view: "br" }),
                n
                  .for("downcast")
                  .elementToElement({
                    model: "softBreak",
                    view: (t, { writer: e }) => e.createEmptyElement("br"),
                  }),
                i.addObserver(Rg),
                t.commands.add("shiftEnter", new If(t)),
                this.listenTo(
                  o,
                  "enter",
                  (e, n) => {
                    n.preventDefault(),
                      n.isSoft &&
                        (t.execute("shiftEnter"), i.scrollToTheSelection());
                  },
                  { priority: "low" }
                );
            }
          }
          class Nf extends ge {
            refresh() {
              (this.value = this._getValue()),
                (this.isEnabled = this._checkEnabled());
            }
            execute(t = {}) {
              const e = this.editor.model,
                n = e.schema,
                i = e.document.selection,
                o = Array.from(i.getSelectedBlocks()),
                r = void 0 === t.forceValue ? !this.value : t.forceValue;
              e.change((t) => {
                if (r) {
                  const e = o.filter((t) => zf(t) || Lf(n, t));
                  this._applyQuote(t, e);
                } else this._removeQuote(t, o.filter(zf));
              });
            }
            _getValue() {
              const t = Na(
                this.editor.model.document.selection.getSelectedBlocks()
              );
              return !(!t || !zf(t));
            }
            _checkEnabled() {
              if (this.value) return !0;
              const t = this.editor.model.document.selection,
                e = this.editor.model.schema,
                n = Na(t.getSelectedBlocks());
              return !!n && Lf(e, n);
            }
            _removeQuote(t, e) {
              Pf(t, e)
                .reverse()
                .forEach((e) => {
                  if (e.start.isAtStart && e.end.isAtEnd)
                    return void t.unwrap(e.start.parent);
                  if (e.start.isAtStart) {
                    const n = t.createPositionBefore(e.start.parent);
                    return void t.move(e, n);
                  }
                  e.end.isAtEnd || t.split(e.end);
                  const n = t.createPositionAfter(e.end.parent);
                  t.move(e, n);
                });
            }
            _applyQuote(t, e) {
              const n = [];
              Pf(t, e)
                .reverse()
                .forEach((e) => {
                  let i = zf(e.start);
                  i || ((i = t.createElement("blockQuote")), t.wrap(e, i)),
                    n.push(i);
                }),
                n
                  .reverse()
                  .reduce((e, n) =>
                    e.nextSibling == n
                      ? (t.merge(t.createPositionAfter(e)), e)
                      : n
                  );
            }
          }
          function zf(t) {
            return "blockQuote" == t.parent.name ? t.parent : null;
          }
          function Pf(t, e) {
            let n,
              i = 0;
            const o = [];
            for (; i < e.length; ) {
              const r = e[i],
                s = e[i + 1];
              n || (n = t.createPositionBefore(r)),
                (s && r.nextSibling == s) ||
                  (o.push(t.createRange(n, t.createPositionAfter(r))),
                  (n = null)),
                i++;
            }
            return o;
          }
          function Lf(t, e) {
            const n = t.checkChild(e.parent, "blockQuote"),
              i = t.checkChild(["$root", "blockQuote"], e);
            return n && i;
          }
          class Rf extends ue {
            static get pluginName() {
              return "BlockQuoteEditing";
            }
            static get requires() {
              return [Og, ig];
            }
            init() {
              const t = this.editor,
                e = t.model.schema;
              t.commands.add("blockQuote", new Nf(t)),
                e.register("blockQuote", { inheritAllFrom: "$container" }),
                t.conversion.elementToElement({
                  model: "blockQuote",
                  view: "blockquote",
                }),
                t.model.document.registerPostFixer((n) => {
                  const i = t.model.document.differ.getChanges();
                  for (const t of i)
                    if ("insert" == t.type) {
                      const i = t.position.nodeAfter;
                      if (!i) continue;
                      if (i.is("element", "blockQuote") && i.isEmpty)
                        return n.remove(i), !0;
                      if (
                        i.is("element", "blockQuote") &&
                        !e.checkChild(t.position, i)
                      )
                        return n.unwrap(i), !0;
                      if (i.is("element")) {
                        const t = n.createRangeIn(i);
                        for (const i of t.getItems())
                          if (
                            i.is("element", "blockQuote") &&
                            !e.checkChild(n.createPositionBefore(i), i)
                          )
                            return n.unwrap(i), !0;
                      }
                    } else if ("remove" == t.type) {
                      const e = t.position.parent;
                      if (e.is("element", "blockQuote") && e.isEmpty)
                        return n.remove(e), !0;
                    }
                  return !1;
                });
              const n = this.editor.editing.view.document,
                i = t.model.document.selection,
                o = t.commands.get("blockQuote");
              this.listenTo(
                n,
                "enter",
                (e, n) => {
                  if (!i.isCollapsed || !o.value) return;
                  i.getLastPosition().parent.isEmpty &&
                    (t.execute("blockQuote"),
                    t.editing.view.scrollToTheSelection(),
                    n.preventDefault(),
                    e.stop());
                },
                { context: "blockquote" }
              ),
                this.listenTo(
                  n,
                  "delete",
                  (e, n) => {
                    if ("backward" != n.direction || !i.isCollapsed || !o.value)
                      return;
                    const r = i.getLastPosition().parent;
                    r.isEmpty &&
                      !r.previousSibling &&
                      (t.execute("blockQuote"),
                      t.editing.view.scrollToTheSelection(),
                      n.preventDefault(),
                      e.stop());
                  },
                  { context: "blockquote" }
                );
            }
          }
          var Of = n(636),
            jf = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Of.Z, jf);
          Of.Z.locals;
          class Ff extends ue {
            static get pluginName() {
              return "BlockQuoteUI";
            }
            init() {
              const t = this.editor,
                e = t.t;
              t.ui.componentFactory.add("blockQuote", (n) => {
                const i = t.commands.get("blockQuote"),
                  o = new kh(n);
                return (
                  o.set({
                    label: e("Block quote"),
                    icon: zd.quote,
                    tooltip: !0,
                    isToggleable: !0,
                  }),
                  o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"),
                  this.listenTo(o, "execute", () => {
                    t.execute("blockQuote"), t.editing.view.focus();
                  }),
                  o
                );
              });
            }
          }
          class Vf extends ge {
            constructor(t, e) {
              super(t), (this.attributeKey = e);
            }
            refresh() {
              const t = this.editor.model,
                e = t.document;
              (this.value = this._getValueFromFirstAllowedNode()),
                (this.isEnabled = t.schema.checkAttributeInSelection(
                  e.selection,
                  this.attributeKey
                ));
            }
            execute(t = {}) {
              const e = this.editor.model,
                n = e.document.selection,
                i = void 0 === t.forceValue ? !this.value : t.forceValue;
              e.change((t) => {
                if (n.isCollapsed)
                  i
                    ? t.setSelectionAttribute(this.attributeKey, !0)
                    : t.removeSelectionAttribute(this.attributeKey);
                else {
                  const o = e.schema.getValidRanges(
                    n.getRanges(),
                    this.attributeKey
                  );
                  for (const e of o)
                    i
                      ? t.setAttribute(this.attributeKey, i, e)
                      : t.removeAttribute(this.attributeKey, e);
                }
              });
            }
            _getValueFromFirstAllowedNode() {
              const t = this.editor.model,
                e = t.schema,
                n = t.document.selection;
              if (n.isCollapsed) return n.hasAttribute(this.attributeKey);
              for (const t of n.getRanges())
                for (const n of t.getItems())
                  if (e.checkAttribute(n, this.attributeKey))
                    return n.hasAttribute(this.attributeKey);
              return !1;
            }
          }
          const Hf = "bold";
          class Uf extends ue {
            static get pluginName() {
              return "BoldEditing";
            }
            init() {
              const t = this.editor;
              t.model.schema.extend("$text", { allowAttributes: Hf }),
                t.model.schema.setAttributeProperties(Hf, {
                  isFormatting: !0,
                  copyOnEnter: !0,
                }),
                t.conversion.attributeToElement({
                  model: Hf,
                  view: "strong",
                  upcastAlso: [
                    "b",
                    (t) => {
                      const e = t.getStyle("font-weight");
                      return e
                        ? "bold" == e || Number(e) >= 600
                          ? { name: !0, styles: ["font-weight"] }
                          : void 0
                        : null;
                    },
                  ],
                }),
                t.commands.add(Hf, new Vf(t, Hf)),
                t.keystrokes.set("CTRL+B", Hf);
            }
          }
          const $f = "bold";
          class qf extends ue {
            static get pluginName() {
              return "BoldUI";
            }
            init() {
              const t = this.editor,
                e = t.t;
              t.ui.componentFactory.add($f, (n) => {
                const i = t.commands.get($f),
                  o = new kh(n);
                return (
                  o.set({
                    label: e("Bold"),
                    icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>',
                    keystroke: "CTRL+B",
                    tooltip: !0,
                    isToggleable: !0,
                  }),
                  o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"),
                  this.listenTo(o, "execute", () => {
                    t.execute($f), t.editing.view.focus();
                  }),
                  o
                );
              });
            }
          }
          const Gf = { autoRefresh: !0 },
            Wf = 36e5;
          class Yf {
            constructor(t, e = Gf) {
              if (!t) throw new c("token-missing-token-url", this);
              e.initValue && this._validateTokenValue(e.initValue),
                this.set("value", e.initValue),
                (this._refresh =
                  "function" == typeof t
                    ? t
                    : () => {
                        return (
                          (e = t),
                          new Promise((t, n) => {
                            const i = new XMLHttpRequest();
                            i.open("GET", e),
                              i.addEventListener("load", () => {
                                const e = i.status,
                                  o = i.response;
                                return e < 200 || e > 299
                                  ? n(
                                      new c(
                                        "token-cannot-download-new-token",
                                        null
                                      )
                                    )
                                  : t(o);
                              }),
                              i.addEventListener("error", () =>
                                n(new Error("Network Error"))
                              ),
                              i.addEventListener("abort", () =>
                                n(new Error("Abort"))
                              ),
                              i.send();
                          })
                        );
                        var e;
                      }),
                (this._options = Object.assign({}, Gf, e));
            }
            init() {
              return new Promise((t, e) => {
                this.value
                  ? (this._options.autoRefresh &&
                      this._registerRefreshTokenTimeout(),
                    t(this))
                  : this.refreshToken().then(t).catch(e);
              });
            }
            refreshToken() {
              return this._refresh()
                .then((t) => {
                  this._validateTokenValue(t),
                    this.set("value", t),
                    this._options.autoRefresh &&
                      this._registerRefreshTokenTimeout();
                })
                .then(() => this);
            }
            destroy() {
              clearTimeout(this._tokenRefreshTimeout);
            }
            _validateTokenValue(t) {
              const e = "string" == typeof t,
                n = !/^".*"$/.test(t),
                i = e && 3 === t.split(".").length;
              if (!n || !i) throw new c("token-not-in-jwt-format", this);
            }
            _registerRefreshTokenTimeout() {
              const t = this._getTokenRefreshTimeoutTime();
              clearTimeout(this._tokenRefreshTimeout),
                (this._tokenRefreshTimeout = setTimeout(() => {
                  this.refreshToken();
                }, t));
            }
            _getTokenRefreshTimeoutTime() {
              try {
                const [, t] = this.value.split("."),
                  { exp: e } = JSON.parse(atob(t));
                if (!e) return Wf;
                return Math.floor((1e3 * e - Date.now()) / 2);
              } catch (t) {
                return Wf;
              }
            }
            static create(t, e = Gf) {
              return new Yf(t, e).init();
            }
          }
          he(Yf, re);
          const Kf = Yf,
            Qf = /^data:(\S*?);base64,/;
          class Zf {
            constructor(t, e, n) {
              if (!t) throw new c("fileuploader-missing-file", null);
              if (!e) throw new c("fileuploader-missing-token", null);
              if (!n) throw new c("fileuploader-missing-api-address", null);
              (this.file = (function (t) {
                if ("string" != typeof t) return !1;
                const e = t.match(Qf);
                return !(!e || !e.length);
              })(t)
                ? (function (t, e = 512) {
                    try {
                      const n = t.match(Qf)[1],
                        i = atob(t.replace(Qf, "")),
                        o = [];
                      for (let t = 0; t < i.length; t += e) {
                        const n = i.slice(t, t + e),
                          r = new Array(n.length);
                        for (let t = 0; t < n.length; t++)
                          r[t] = n.charCodeAt(t);
                        o.push(new Uint8Array(r));
                      }
                      return new Blob(o, { type: n });
                    } catch (t) {
                      throw new c(
                        "fileuploader-decoding-image-data-error",
                        null
                      );
                    }
                  })(t)
                : t),
                (this._token = e),
                (this._apiAddress = n);
            }
            onProgress(t) {
              return this.on("progress", (e, n) => t(n)), this;
            }
            onError(t) {
              return this.once("error", (e, n) => t(n)), this;
            }
            abort() {
              this.xhr.abort();
            }
            send() {
              return (
                this._prepareRequest(),
                this._attachXHRListeners(),
                this._sendRequest()
              );
            }
            _prepareRequest() {
              const t = new XMLHttpRequest();
              t.open("POST", this._apiAddress),
                t.setRequestHeader("Authorization", this._token.value),
                (t.responseType = "json"),
                (this.xhr = t);
            }
            _attachXHRListeners() {
              const t = this,
                e = this.xhr;
              function n(e) {
                return () => t.fire("error", e);
              }
              e.addEventListener("error", n("Network Error")),
                e.addEventListener("abort", n("Abort")),
                e.upload &&
                  e.upload.addEventListener("progress", (t) => {
                    t.lengthComputable &&
                      this.fire("progress", {
                        total: t.total,
                        uploaded: t.loaded,
                      });
                  }),
                e.addEventListener("load", () => {
                  const t = e.status,
                    n = e.response;
                  if (t < 200 || t > 299)
                    return this.fire("error", n.message || n.error);
                });
            }
            _sendRequest() {
              const t = new FormData(),
                e = this.xhr;
              return (
                t.append("file", this.file),
                new Promise((n, i) => {
                  e.addEventListener("load", () => {
                    const t = e.status,
                      o = e.response;
                    return t < 200 || t > 299
                      ? o.message
                        ? i(
                            new c("fileuploader-uploading-data-failed", this, {
                              message: o.message,
                            })
                          )
                        : i(o.error)
                      : n(o);
                  }),
                    e.addEventListener("error", () =>
                      i(new Error("Network Error"))
                    ),
                    e.addEventListener("abort", () => i(new Error("Abort"))),
                    e.send(t);
                })
              );
            }
          }
          he(Zf, k);
          class Jf {
            constructor(t, e) {
              if (!t) throw new c("uploadgateway-missing-token", null);
              if (!e) throw new c("uploadgateway-missing-api-address", null);
              (this._token = t), (this._apiAddress = e);
            }
            upload(t) {
              return new Zf(t, this._token, this._apiAddress);
            }
          }
          class Xf extends Pi {
            static get pluginName() {
              return "CloudServicesCore";
            }
            createToken(t, e) {
              return new Kf(t, e);
            }
            createUploadGateway(t, e) {
              return new Jf(t, e);
            }
          }
          const tk = "code";
          class ek extends ue {
            static get pluginName() {
              return "CodeEditing";
            }
            static get requires() {
              return [ag];
            }
            init() {
              const t = this.editor;
              t.model.schema.extend("$text", { allowAttributes: tk }),
                t.model.schema.setAttributeProperties(tk, {
                  isFormatting: !0,
                  copyOnEnter: !1,
                }),
                t.conversion.attributeToElement({
                  model: tk,
                  view: "code",
                  upcastAlso: { styles: { "word-wrap": "break-word" } },
                }),
                t.commands.add(tk, new Vf(t, tk)),
                t.plugins.get(ag).registerAttribute(tk),
                yg(t, tk, "code", "ck-code_selected");
            }
          }
          var nk = n(8180),
            ik = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(nk.Z, ik);
          nk.Z.locals;
          const ok = "code";
          class rk extends ue {
            static get pluginName() {
              return "CodeUI";
            }
            init() {
              const t = this.editor,
                e = t.t;
              t.ui.componentFactory.add(ok, (n) => {
                const i = t.commands.get(ok),
                  o = new kh(n);
                return (
                  o.set({
                    label: e("Code"),
                    icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.5 5.7 5.2 3.9v1.3l-5.6 4c-.1.2-.3.2-.5.2-.3-.1-.6-.7-.6-1l.3-.4 4.7-3.5L11.5 7l-.2-.2c-.1-.3-.1-.6 0-.8.2-.2.5-.4.8-.4a.8.8 0 0 1 .4.1zm-5.2 0L2 9.6v1.3l5.6 4c.1.2.3.2.5.2.3-.1.7-.7.6-1 0-.1 0-.3-.2-.4l-5-3.5L8.2 7l.2-.2c.1-.3.1-.6 0-.8-.2-.2-.5-.4-.8-.4a.8.8 0 0 0-.3.1z"/></svg>',
                    tooltip: !0,
                    isToggleable: !0,
                  }),
                  o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"),
                  this.listenTo(o, "execute", () => {
                    t.execute(ok), t.editing.view.focus();
                  }),
                  o
                );
              });
            }
          }
          function sk(t) {
            const e = t.t,
              n = t.config.get("codeBlock.languages");
            for (const t of n)
              "Plain text" === t.label && (t.label = e("Plain text")),
                void 0 === t.class && (t.class = `language-${t.language}`);
            return n;
          }
          function ak(t, e, n) {
            const i = {};
            for (const o of t)
              "class" === e
                ? (i[o[e].split(" ").shift()] = o[n])
                : (i[o[e]] = o[n]);
            return i;
          }
          function ck(t) {
            return t.data.match(/^(\s*)/)[0];
          }
          function lk(t) {
            const e = t.document.selection,
              n = [];
            if (e.isCollapsed) n.push(e.anchor);
            else {
              const i = e
                .getFirstRange()
                .getWalker({ ignoreElementEnd: !0, direction: "backward" });
              for (const { item: e } of i)
                if (e.is("$textProxy") && e.parent.is("element", "codeBlock")) {
                  const i = ck(e.textNode),
                    { parent: o, startOffset: r } = e.textNode,
                    s = t.createPositionAt(o, r + i.length);
                  n.push(s);
                }
            }
            return n;
          }
          function dk(t) {
            const e = Na(t.getSelectedBlocks());
            return e && e.is("element", "codeBlock");
          }
          function hk(t, e) {
            return (
              !e.is("rootElement") &&
              !t.isLimit(e) &&
              t.checkChild(e.parent, "codeBlock")
            );
          }
          class uk extends ge {
            constructor(t) {
              super(t), (this._lastLanguage = null);
            }
            refresh() {
              (this.value = this._getValue()),
                (this.isEnabled = this._checkEnabled());
            }
            execute(t = {}) {
              const e = this.editor,
                n = e.model,
                i = n.document.selection,
                o = sk(e)[0],
                r = Array.from(i.getSelectedBlocks()),
                s = void 0 === t.forceValue ? !this.value : t.forceValue,
                a = (function (t, e, n) {
                  if (t.language) return t.language;
                  if (t.usePreviousLanguageChoice && e) return e;
                  return n;
                })(t, this._lastLanguage, o.language);
              n.change((t) => {
                s ? this._applyCodeBlock(t, r, a) : this._removeCodeBlock(t, r);
              });
            }
            _getValue() {
              const t = Na(
                this.editor.model.document.selection.getSelectedBlocks()
              );
              return (
                !!!(!t || !t.is("element", "codeBlock")) &&
                t.getAttribute("language")
              );
            }
            _checkEnabled() {
              if (this.value) return !0;
              const t = this.editor.model.document.selection,
                e = this.editor.model.schema,
                n = Na(t.getSelectedBlocks());
              return !!n && hk(e, n);
            }
            _applyCodeBlock(t, e, n) {
              this._lastLanguage = n;
              const i = this.editor.model.schema,
                o = e.filter((t) => hk(i, t));
              for (const e of o)
                t.rename(e, "codeBlock"),
                  t.setAttribute("language", n, e),
                  i.removeDisallowedAttributes([e], t),
                  Array.from(e.getChildren())
                    .filter((t) => !i.checkChild(e, t))
                    .forEach((e) => t.remove(e));
              o.reverse().forEach((e, n) => {
                const i = o[n + 1];
                e.previousSibling === i &&
                  (t.appendElement("softBreak", i),
                  t.merge(t.createPositionBefore(e)));
              });
            }
            _removeCodeBlock(t, e) {
              const n = e.filter((t) => t.is("element", "codeBlock"));
              for (const e of n) {
                const n = t.createRangeOn(e);
                for (const e of Array.from(n.getItems()).reverse())
                  if (
                    e.is("element", "softBreak") &&
                    e.parent.is("element", "codeBlock")
                  ) {
                    const { position: n } = t.split(t.createPositionBefore(e));
                    t.rename(n.nodeAfter, "paragraph"),
                      t.removeAttribute("language", n.nodeAfter),
                      t.remove(e);
                  }
                t.rename(e, "paragraph"), t.removeAttribute("language", e);
              }
            }
          }
          class mk extends ge {
            constructor(t) {
              super(t),
                (this._indentSequence = t.config.get(
                  "codeBlock.indentSequence"
                ));
            }
            refresh() {
              this.isEnabled = this._checkEnabled();
            }
            execute() {
              const t = this.editor.model;
              t.change((e) => {
                const n = lk(t);
                for (const i of n) {
                  const n = e.createText(this._indentSequence);
                  t.insertContent(n, i);
                }
              });
            }
            _checkEnabled() {
              return (
                !!this._indentSequence &&
                dk(this.editor.model.document.selection)
              );
            }
          }
          class gk extends ge {
            constructor(t) {
              super(t),
                (this._indentSequence = t.config.get(
                  "codeBlock.indentSequence"
                ));
            }
            refresh() {
              this.isEnabled = this._checkEnabled();
            }
            execute() {
              const t = this.editor.model;
              t.change(() => {
                const e = lk(t);
                for (const n of e) {
                  const e = pk(t, n, this._indentSequence);
                  e && t.deleteContent(t.createSelection(e));
                }
              });
            }
            _checkEnabled() {
              if (!this._indentSequence) return !1;
              const t = this.editor.model;
              return (
                !!dk(t.document.selection) &&
                lk(t).some((e) => pk(t, e, this._indentSequence))
              );
            }
          }
          function pk(t, e, n) {
            const i = (function (t) {
              let e = t.parent.getChild(t.index);
              (e && !e.is("element", "softBreak")) || (e = t.nodeBefore);
              if (!e || e.is("element", "softBreak")) return null;
              return e;
            })(e);
            if (!i) return null;
            const o = ck(i),
              r = o.lastIndexOf(n);
            if (r + n.length !== o.length) return null;
            if (-1 === r) return null;
            const { parent: s, startOffset: a } = i;
            return t.createRange(
              t.createPositionAt(s, a + r),
              t.createPositionAt(s, a + r + n.length)
            );
          }
          function fk(t, e, n = !1) {
            const i = ak(e, "language", "class"),
              o = ak(e, "language", "label");
            return (e, r, s) => {
              const { writer: a, mapper: c, consumable: l } = s;
              if (!l.consume(r.item, "insert")) return;
              const d = r.item.getAttribute("language"),
                h = c.toViewPosition(t.createPositionBefore(r.item)),
                u = {};
              n && ((u["data-language"] = o[d]), (u.spellcheck = "false"));
              const m = a.createContainerElement("code", {
                  class: i[d] || null,
                }),
                g = a.createContainerElement("pre", u, m);
              a.insert(h, g), c.bindElements(r.item, m);
            };
          }
          const kk = "paragraph";
          class bk extends ue {
            static get pluginName() {
              return "CodeBlockEditing";
            }
            static get requires() {
              return [Bf];
            }
            constructor(t) {
              super(t),
                t.config.define("codeBlock", {
                  languages: [
                    { language: "plaintext", label: "Plain text" },
                    { language: "c", label: "C" },
                    { language: "cs", label: "C#" },
                    { language: "cpp", label: "C++" },
                    { language: "css", label: "CSS" },
                    { language: "diff", label: "Diff" },
                    { language: "html", label: "HTML" },
                    { language: "java", label: "Java" },
                    { language: "javascript", label: "JavaScript" },
                    { language: "php", label: "PHP" },
                    { language: "python", label: "Python" },
                    { language: "ruby", label: "Ruby" },
                    { language: "typescript", label: "TypeScript" },
                    { language: "xml", label: "XML" },
                  ],
                  indentSequence: "\t",
                });
            }
            init() {
              const t = this.editor,
                e = t.model.schema,
                n = t.model,
                i = t.editing.view,
                o = t.plugins.has("DocumentListEditing"),
                r = sk(t);
              t.commands.add("codeBlock", new uk(t)),
                t.commands.add("indentCodeBlock", new mk(t)),
                t.commands.add("outdentCodeBlock", new gk(t)),
                this.listenTo(
                  i.document,
                  "tab",
                  (e, n) => {
                    const i = n.shiftKey
                      ? "outdentCodeBlock"
                      : "indentCodeBlock";
                    t.commands.get(i).isEnabled &&
                      (t.execute(i),
                      n.stopPropagation(),
                      n.preventDefault(),
                      e.stop());
                  },
                  { context: "pre" }
                ),
                e.register("codeBlock", {
                  allowWhere: "$block",
                  allowChildren: "$text",
                  isBlock: !0,
                  allowAttributes: ["language"],
                }),
                e.addAttributeCheck((t, e) => {
                  const n =
                    t.endsWith("codeBlock") &&
                    e.startsWith("list") &&
                    "list" !== e;
                  return (
                    !(!o || !n) || (!t.endsWith("codeBlock $text") && void 0)
                  );
                }),
                t.model.schema.addChildCheck((t, e) => {
                  if (t.endsWith("codeBlock") && e.isObject) return !1;
                }),
                t.editing.downcastDispatcher.on(
                  "insert:codeBlock",
                  fk(n, r, !0)
                ),
                t.data.downcastDispatcher.on("insert:codeBlock", fk(n, r)),
                t.data.downcastDispatcher.on(
                  "insert:softBreak",
                  (function (t) {
                    return (e, n, i) => {
                      if ("codeBlock" !== n.item.parent.name) return;
                      const { writer: o, mapper: r, consumable: s } = i;
                      if (!s.consume(n.item, "insert")) return;
                      const a = r.toViewPosition(
                        t.createPositionBefore(n.item)
                      );
                      o.insert(a, o.createText("\n"));
                    };
                  })(n),
                  { priority: "high" }
                ),
                t.data.upcastDispatcher.on(
                  "element:code",
                  (function (t, e) {
                    const n = ak(e, "class", "language"),
                      i = e[0].language;
                    return (t, e, o) => {
                      const r = e.viewItem,
                        s = r.parent;
                      if (!s || !s.is("element", "pre")) return;
                      if (e.modelCursor.findAncestor("codeBlock")) return;
                      const { consumable: a, writer: c } = o;
                      if (!a.test(r, { name: !0 })) return;
                      const l = c.createElement("codeBlock"),
                        d = [...r.getClassNames()];
                      d.length || d.push("");
                      for (const t of d) {
                        const e = n[t];
                        if (e) {
                          c.setAttribute("language", e, l);
                          break;
                        }
                      }
                      l.hasAttribute("language") ||
                        c.setAttribute("language", i, l),
                        o.convertChildren(r, l),
                        o.safeInsert(l, e.modelCursor) &&
                          (a.consume(r, { name: !0 }),
                          o.updateConversionResult(l, e));
                    };
                  })(0, r)
                ),
                t.data.upcastDispatcher.on(
                  "text",
                  (t, e, { consumable: n, writer: i }) => {
                    let o = e.modelCursor;
                    if (!n.test(e.viewItem)) return;
                    if (!o.findAncestor("codeBlock")) return;
                    n.consume(e.viewItem);
                    const r = e.viewItem.data
                        .split("\n")
                        .map((t) => i.createText(t)),
                      s = r[r.length - 1];
                    for (const t of r)
                      if (
                        (i.insert(t, o),
                        (o = o.getShiftedBy(t.offsetSize)),
                        t !== s)
                      ) {
                        const t = i.createElement("softBreak");
                        i.insert(t, o), (o = i.createPositionAfter(t));
                      }
                    (e.modelRange = i.createRange(e.modelCursor, o)),
                      (e.modelCursor = o);
                  }
                ),
                t.data.upcastDispatcher.on(
                  "element:pre",
                  (t, e, { consumable: n }) => {
                    const i = e.viewItem;
                    if (i.findAncestor("pre")) return;
                    const o = Array.from(i.getChildren()),
                      r = o.find((t) => t.is("element", "code"));
                    if (r)
                      for (const t of o)
                        t !== r && t.is("$text") && n.consume(t, { name: !0 });
                  },
                  { priority: "high" }
                ),
                this.listenTo(
                  t.editing.view.document,
                  "clipboardInput",
                  (e, i) => {
                    let o = n.createRange(n.document.selection.anchor);
                    if (
                      (i.targetRanges &&
                        (o = t.editing.mapper.toModelRange(i.targetRanges[0])),
                      !o.start.parent.is("element", "codeBlock"))
                    )
                      return;
                    const r = i.dataTransfer.getData("text/plain"),
                      s = new bm(t.editing.view.document);
                    i.content = (function (t, e) {
                      const n = t.createDocumentFragment(),
                        i = e.split("\n"),
                        o = i.reduce(
                          (e, n, o) => (
                            e.push(n),
                            o < i.length - 1 && e.push(t.createElement("br")),
                            e
                          ),
                          []
                        );
                      return t.appendChild(o, n), n;
                    })(s, r);
                  }
                ),
                this.listenTo(n, "getSelectedContent", (t, [i]) => {
                  const o = i.anchor;
                  !i.isCollapsed &&
                    o.parent.is("element", "codeBlock") &&
                    o.hasSameParentAs(i.focus) &&
                    n.change((n) => {
                      const r = t.return;
                      if (
                        r.childCount > 1 ||
                        i.containsEntireContent(o.parent)
                      ) {
                        const e = n.createElement(
                          "codeBlock",
                          o.parent.getAttributes()
                        );
                        n.append(r, e);
                        const i = n.createDocumentFragment();
                        n.append(e, i), (t.return = i);
                      } else {
                        const t = r.getChild(0);
                        e.checkAttribute(t, "code") &&
                          n.setAttribute("code", !0, t);
                      }
                    });
                });
            }
            afterInit() {
              const t = this.editor,
                e = t.commands,
                n = e.get("indent"),
                i = e.get("outdent");
              n &&
                n.registerChildCommand(e.get("indentCodeBlock"), {
                  priority: "highest",
                }),
                i && i.registerChildCommand(e.get("outdentCodeBlock")),
                this.listenTo(
                  t.editing.view.document,
                  "enter",
                  (e, n) => {
                    t.model.document.selection
                      .getLastPosition()
                      .parent.is("element", "codeBlock") &&
                      ((function (t, e) {
                        const n = t.model.document,
                          i = t.editing.view,
                          o = n.selection.getLastPosition(),
                          r = o.nodeAfter;
                        if (e || !n.selection.isCollapsed || !o.isAtStart)
                          return !1;
                        if (!Ak(r)) return !1;
                        return (
                          t.model.change((e) => {
                            t.execute("enter");
                            const i = n.selection.anchor.parent.previousSibling;
                            e.rename(i, kk),
                              e.setSelection(i, "in"),
                              t.model.schema.removeDisallowedAttributes([i], e),
                              e.remove(r);
                          }),
                          i.scrollToTheSelection(),
                          !0
                        );
                      })(t, n.isSoft) ||
                        (function (t, e) {
                          const n = t.model,
                            i = n.document,
                            o = t.editing.view,
                            r = i.selection.getLastPosition(),
                            s = r.nodeBefore;
                          let a;
                          if (
                            e ||
                            !i.selection.isCollapsed ||
                            !r.isAtEnd ||
                            !s ||
                            !s.previousSibling
                          )
                            return !1;
                          if (Ak(s) && Ak(s.previousSibling))
                            a = n.createRange(
                              n.createPositionBefore(s.previousSibling),
                              n.createPositionAfter(s)
                            );
                          else if (
                            wk(s) &&
                            Ak(s.previousSibling) &&
                            Ak(s.previousSibling.previousSibling)
                          )
                            a = n.createRange(
                              n.createPositionBefore(
                                s.previousSibling.previousSibling
                              ),
                              n.createPositionAfter(s)
                            );
                          else {
                            if (
                              !(
                                wk(s) &&
                                Ak(s.previousSibling) &&
                                wk(s.previousSibling.previousSibling) &&
                                Ak(
                                  s.previousSibling.previousSibling
                                    .previousSibling
                                )
                              )
                            )
                              return !1;
                            a = n.createRange(
                              n.createPositionBefore(
                                s.previousSibling.previousSibling
                                  .previousSibling
                              ),
                              n.createPositionAfter(s)
                            );
                          }
                          return (
                            t.model.change((e) => {
                              e.remove(a), t.execute("enter");
                              const n = i.selection.anchor.parent;
                              e.rename(n, kk),
                                t.model.schema.removeDisallowedAttributes(
                                  [n],
                                  e
                                );
                            }),
                            o.scrollToTheSelection(),
                            !0
                          );
                        })(t, n.isSoft) ||
                        (function (t) {
                          const e = t.model.document,
                            n = e.selection.getLastPosition(),
                            i = n.nodeBefore || n.textNode;
                          let o;
                          i && i.is("$text") && (o = ck(i));
                          t.model.change((n) => {
                            t.execute("shiftEnter"),
                              o && n.insertText(o, e.selection.anchor);
                          });
                        })(t),
                      n.preventDefault(),
                      e.stop());
                  },
                  { context: "pre" }
                );
            }
          }
          function wk(t) {
            return t && t.is("$text") && !t.data.match(/\S/);
          }
          function Ak(t) {
            return t && t.is("element", "softBreak");
          }
          var _k = n(9085),
            Ck = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(_k.Z, Ck);
          _k.Z.locals;
          class vk extends ue {
            static get pluginName() {
              return "CodeBlockUI";
            }
            init() {
              const t = this.editor,
                e = t.t,
                n = t.ui.componentFactory,
                i = sk(t);
              n.add("codeBlock", (n) => {
                const o = t.commands.get("codeBlock"),
                  r = ou(n, Bh),
                  s = r.buttonView;
                return (
                  s.set({
                    label: e("Insert code block"),
                    tooltip: !0,
                    icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.87 12.61a.75.75 0 0 1-.089.976l-.085.07-3.154 2.254 3.412 2.414a.75.75 0 0 1 .237.95l-.057.095a.75.75 0 0 1-.95.237l-.096-.058-4.272-3.022-.003-1.223 4.01-2.867a.75.75 0 0 1 1.047.174zm2.795-.231.095.057 4.011 2.867-.003 1.223-4.272 3.022-.095.058a.75.75 0 0 1-.88-.151l-.07-.086-.058-.095a.75.75 0 0 1 .15-.88l.087-.07 3.412-2.414-3.154-2.253-.085-.071a.75.75 0 0 1 .862-1.207zM16 0a2 2 0 0 1 2 2v9.354l-.663-.492-.837-.001V2a.5.5 0 0 0-.5-.5H2a.5.5 0 0 0-.5.5v15a.5.5 0 0 0 .5.5h3.118L7.156 19H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h14zM5.009 15l.003 1H3v-1h2.009zm2.188-2-1.471 1H5v-1h2.197zM10 11v.095L8.668 12H7v-1h3zm4-2v1H7V9h7zm0-2v1H7V7h7zm-4-2v1H5V5h5zM6 3v1H3V3h3z"/></svg>',
                    isToggleable: !0,
                  }),
                  s.bind("isOn").to(o, "value", (t) => !!t),
                  s.on("execute", () => {
                    t.execute("codeBlock", { usePreviousLanguageChoice: !0 }),
                      t.editing.view.focus();
                  }),
                  r.on("execute", (e) => {
                    t.execute("codeBlock", {
                      language: e.source._codeBlockLanguage,
                      forceValue: !0,
                    }),
                      t.editing.view.focus();
                  }),
                  (r.class = "ck-code-block-dropdown"),
                  r.bind("isEnabled").to(o),
                  su(r, this._getLanguageListItemDefinitions(i)),
                  r
                );
              });
            }
            _getLanguageListItemDefinitions(t) {
              const e = this.editor.commands.get("codeBlock"),
                n = new Di();
              for (const i of t) {
                const t = {
                  type: "button",
                  model: new Su({
                    _codeBlockLanguage: i.language,
                    label: i.label,
                    withText: !0,
                  }),
                };
                t.model
                  .bind("isOn")
                  .to(e, "value", (e) => e === t.model._codeBlockLanguage),
                  n.add(t);
              }
              return n;
            }
          }
          class yk extends ge {
            constructor(t) {
              super(t), (this.affectsData = !1);
            }
            execute() {
              const t = this.editor.model,
                e = t.document.selection;
              let n = t.schema.getLimitElement(e);
              if (e.containsEntireContent(n) || !xk(t.schema, n))
                do {
                  if (((n = n.parent), !n)) return;
                } while (!xk(t.schema, n));
              t.change((t) => {
                t.setSelection(n, "in");
              });
            }
          }
          function xk(t, e) {
            return (
              t.isLimit(e) &&
              (t.checkChild(e, "$text") || t.checkChild(e, "paragraph"))
            );
          }
          const Ek = mr("Ctrl+A");
          class Dk extends ue {
            static get pluginName() {
              return "SelectAllEditing";
            }
            init() {
              const t = this.editor,
                e = t.editing.view.document;
              t.commands.add("selectAll", new yk(t)),
                this.listenTo(e, "keydown", (e, n) => {
                  ur(n) === Ek && (t.execute("selectAll"), n.preventDefault());
                });
            }
          }
          class Sk extends ue {
            static get pluginName() {
              return "SelectAllUI";
            }
            init() {
              const t = this.editor;
              t.ui.componentFactory.add("selectAll", (e) => {
                const n = t.commands.get("selectAll"),
                  i = new kh(e),
                  o = e.t;
                return (
                  i.set({
                    label: o("Select all"),
                    icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>',
                    keystroke: "Ctrl+A",
                    tooltip: !0,
                  }),
                  i.bind("isOn", "isEnabled").to(n, "value", "isEnabled"),
                  this.listenTo(i, "execute", () => {
                    t.execute("selectAll"), t.editing.view.focus();
                  }),
                  i
                );
              });
            }
          }
          class Ik extends ue {
            static get requires() {
              return [Dk, Sk];
            }
            static get pluginName() {
              return "SelectAll";
            }
          }
          var Tk = n(1590),
            Mk = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Tk.Z, Mk);
          Tk.Z.locals;
          var Bk = n(9289),
            Nk = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Bk.Z, Nk);
          Bk.Z.locals;
          class zk extends Vd {
            constructor(t) {
              super(t);
              const e = t.t;
              this.set("matchCount", 0),
                this.set("highlightOffset", 0),
                this.set("isDirty", !1),
                this.set("_areCommandsEnabled", {}),
                this.set("_resultsCounterText", ""),
                this.set("_matchCase", !1),
                this.set("_wholeWordsOnly", !1),
                this.bind("_searchResultsFound").to(
                  this,
                  "matchCount",
                  this,
                  "isDirty",
                  (t, e) => t > 0 && !e
                ),
                (this._findInputView = this._createInputField(
                  e("Find in text…")
                )),
                (this._replaceInputView = this._createInputField(
                  e("Replace with…")
                )),
                (this._findButtonView = this._createButton({
                  label: e("Find"),
                  class: "ck-button-find ck-button-action",
                  withText: !0,
                })),
                (this._findPrevButtonView = this._createButton({
                  label: e("Previous result"),
                  class: "ck-button-prev",
                  icon: Lu,
                  keystroke: "Shift+F3",
                  tooltip: !0,
                })),
                (this._findNextButtonView = this._createButton({
                  label: e("Next result"),
                  class: "ck-button-next",
                  icon: Lu,
                  keystroke: "F3",
                  tooltip: !0,
                })),
                (this._optionsDropdown = this._createOptionsDropdown()),
                (this._replaceButtonView = this._createButton({
                  label: e("Replace"),
                  class: "ck-button-replace",
                  withText: !0,
                })),
                (this._replaceAllButtonView = this._createButton({
                  label: e("Replace all"),
                  class: "ck-button-replaceall",
                  withText: !0,
                })),
                (this._findFieldsetView = this._createFindFieldset()),
                (this._replaceFieldsetView = this._createReplaceFieldset()),
                (this._focusTracker = new za()),
                (this._keystrokes = new Pa()),
                (this._focusables = new Od()),
                (this._focusCycler = new vh({
                  focusables: this._focusables,
                  focusTracker: this._focusTracker,
                  keystrokeHandler: this._keystrokes,
                  actions: { focusPrevious: "shift + tab", focusNext: "tab" },
                })),
                this.setTemplate({
                  tag: "form",
                  attributes: {
                    class: ["ck", "ck-find-and-replace-form"],
                    tabindex: "-1",
                  },
                  children: [
                    new bu(t, { label: e("Find and replace") }),
                    this._findFieldsetView,
                    this._replaceFieldsetView,
                  ],
                }),
                Ld(this);
            }
            render() {
              super.render(),
                Rd({ view: this }),
                this._initFocusCycling(),
                this._initKeystrokeHandling();
            }
            destroy() {
              super.destroy(),
                this._focusTracker.destroy(),
                this._keystrokes.destroy();
            }
            focus() {
              this._focusCycler.focusFirst();
            }
            reset() {
              (this._findInputView.errorText = null), (this.isDirty = !0);
            }
            get _textToFind() {
              return this._findInputView.fieldView.element.value;
            }
            get _textToReplace() {
              return this._replaceInputView.fieldView.element.value;
            }
            _createFindFieldset() {
              const t = this.locale,
                e = new Vd(t);
              return (
                this._findInputView.fieldView.on("input", () => {
                  this.isDirty = !0;
                }),
                this._findButtonView.on(
                  "execute",
                  this._onFindButtonExecute.bind(this)
                ),
                this._findPrevButtonView
                  .delegate("execute")
                  .to(this, "findPrevious"),
                this._findNextButtonView
                  .delegate("execute")
                  .to(this, "findNext"),
                this._findPrevButtonView
                  .bind("isEnabled")
                  .to(this, "_areCommandsEnabled", ({ findPrevious: t }) => t),
                this._findNextButtonView
                  .bind("isEnabled")
                  .to(this, "_areCommandsEnabled", ({ findNext: t }) => t),
                this._injectFindResultsCounter(),
                e.setTemplate({
                  tag: "fieldset",
                  attributes: {
                    class: ["ck", "ck-find-and-replace-form__find"],
                  },
                  children: [
                    this._findInputView,
                    this._findButtonView,
                    this._findPrevButtonView,
                    this._findNextButtonView,
                  ],
                }),
                e
              );
            }
            _onFindButtonExecute() {
              if (this._textToFind)
                (this.isDirty = !1),
                  this.fire("findNext", {
                    searchText: this._textToFind,
                    matchCase: this._matchCase,
                    wholeWords: this._wholeWordsOnly,
                  });
              else {
                const t = this.t;
                this._findInputView.errorText = t(
                  "Text to find must not be empty."
                );
              }
            }
            _injectFindResultsCounter() {
              const t = this.locale,
                e = t.t,
                n = this.bindTemplate,
                i = new Vd(t);
              this.bind("_resultsCounterText").to(
                this,
                "highlightOffset",
                this,
                "matchCount",
                (t, n) => e("%0 of %1", [t, n])
              ),
                i.setTemplate({
                  tag: "span",
                  attributes: {
                    class: [
                      "ck",
                      "ck-results-counter",
                      n.if("isDirty", "ck-hidden"),
                    ],
                  },
                  children: [{ text: n.to("_resultsCounterText") }],
                });
              const o = () => {
                const e = this._findInputView.fieldView.element;
                if (!e || !Ca(e)) return;
                const n = new ka(i.element).width,
                  o =
                    "ltr" === t.uiLanguageDirection
                      ? "paddingRight"
                      : "paddingLeft";
                e.style[o] = n
                  ? `calc( 2 * var(--ck-spacing-standard) + ${n}px )`
                  : null;
              };
              this.on("change:_resultsCounterText", o, { priority: "low" }),
                this.on("change:isDirty", o, { priority: "low" }),
                this._findInputView.template.children[0].children.push(i);
            }
            _createReplaceFieldset() {
              const t = this.locale,
                e = t.t,
                n = new Vd(t);
              return (
                this._replaceButtonView
                  .bind("isEnabled")
                  .to(
                    this,
                    "_areCommandsEnabled",
                    this,
                    "_searchResultsFound",
                    ({ replace: t }, e) => t && e
                  ),
                this._replaceAllButtonView
                  .bind("isEnabled")
                  .to(
                    this,
                    "_areCommandsEnabled",
                    this,
                    "_searchResultsFound",
                    ({ replaceAll: t }, e) => t && e
                  ),
                this._replaceInputView
                  .bind("isEnabled")
                  .to(
                    this,
                    "_areCommandsEnabled",
                    this,
                    "_searchResultsFound",
                    ({ replace: t }, e) => t && e
                  ),
                this._replaceInputView
                  .bind("infoText")
                  .to(
                    this._replaceInputView,
                    "isEnabled",
                    this._replaceInputView,
                    "isFocused",
                    (t, n) =>
                      t || !n
                        ? ""
                        : e("Tip: Find some text first in order to replace it.")
                  ),
                this._replaceButtonView.on("execute", () => {
                  this.fire("replace", {
                    searchText: this._textToFind,
                    replaceText: this._textToReplace,
                  });
                }),
                this._replaceAllButtonView.on("execute", () => {
                  this.fire("replaceAll", {
                    searchText: this._textToFind,
                    replaceText: this._textToReplace,
                  }),
                    this.focus();
                }),
                n.setTemplate({
                  tag: "fieldset",
                  attributes: {
                    class: ["ck", "ck-find-and-replace-form__replace"],
                  },
                  children: [
                    this._replaceInputView,
                    this._optionsDropdown,
                    this._replaceButtonView,
                    this._replaceAllButtonView,
                  ],
                }),
                n
              );
            }
            _createOptionsDropdown() {
              const t = this.locale,
                e = t.t,
                n = ou(t);
              (n.class = "ck-options-dropdown"),
                n.buttonView.set({
                  withText: !1,
                  label: e("Show options"),
                  icon: zd.cog,
                  tooltip: !0,
                });
              const i = new Su({
                  withText: !0,
                  label: e("Match case"),
                  _isMatchCaseSwitch: !0,
                }),
                o = new Su({ withText: !0, label: e("Whole words only") });
              return (
                i.bind("isOn").to(this, "_matchCase"),
                o.bind("isOn").to(this, "_wholeWordsOnly"),
                n.on("execute", (t) => {
                  t.source._isMatchCaseSwitch
                    ? (this._matchCase = !this._matchCase)
                    : (this._wholeWordsOnly = !this._wholeWordsOnly),
                    (this.isDirty = !0);
                }),
                su(
                  n,
                  new Di([
                    { type: "switchbutton", model: i },
                    { type: "switchbutton", model: o },
                  ])
                ),
                n
              );
            }
            _initFocusCycling() {
              [
                this._findInputView,
                this._findButtonView,
                this._findPrevButtonView,
                this._findNextButtonView,
                this._replaceInputView,
                this._optionsDropdown,
                this._replaceButtonView,
                this._replaceAllButtonView,
              ].forEach((t) => {
                this._focusables.add(t), this._focusTracker.add(t.element);
              });
            }
            _initKeystrokeHandling() {
              const t = (t) => t.stopPropagation(),
                e = (t) => {
                  t.stopPropagation(), t.preventDefault();
                };
              this._keystrokes.listenTo(this.element),
                this._keystrokes.set("f3", (t) => {
                  e(t), this._findNextButtonView.fire("execute");
                }),
                this._keystrokes.set("shift+f3", (t) => {
                  e(t), this._findPrevButtonView.fire("execute");
                }),
                this._keystrokes.set("enter", (t) => {
                  const n = t.target;
                  n === this._findInputView.fieldView.element
                    ? (this._areCommandsEnabled.findNext
                        ? this._findNextButtonView.fire("execute")
                        : this._findButtonView.fire("execute"),
                      e(t))
                    : n !== this._replaceInputView.fieldView.element ||
                      this.isDirty ||
                      (this._replaceButtonView.fire("execute"), e(t));
                }),
                this._keystrokes.set("shift+enter", (t) => {
                  t.target === this._findInputView.fieldView.element &&
                    (this._areCommandsEnabled.findPrevious
                      ? this._findPrevButtonView.fire("execute")
                      : this._findButtonView.fire("execute"),
                    e(t));
                }),
                this._keystrokes.set("arrowright", t),
                this._keystrokes.set("arrowleft", t),
                this._keystrokes.set("arrowup", t),
                this._keystrokes.set("arrowdown", t),
                this.listenTo(
                  this._findInputView.element,
                  "selectstart",
                  (t, e) => {
                    e.stopPropagation();
                  },
                  { priority: "high" }
                ),
                this.listenTo(
                  this._replaceInputView.element,
                  "selectstart",
                  (t, e) => {
                    e.stopPropagation();
                  },
                  { priority: "high" }
                );
            }
            _createButton(t) {
              const e = new kh(this.locale);
              return e.set(t), e;
            }
            _createInputField(t) {
              const e = new xu(this.locale, Eu);
              return (e.label = t), e;
            }
          }
          class Pk extends ue {
            static get pluginName() {
              return "FindAndReplaceUI";
            }
            constructor(t) {
              super(t), (this.formView = null);
            }
            init() {
              const t = this.editor;
              t.ui.componentFactory.add("findAndReplace", (e) => {
                const n = ou(e),
                  i = (this.formView = new zk(t.locale));
                return (
                  n.bind("isEnabled").to(t.commands.get("find")),
                  n.panelView.children.add(i),
                  n.on(
                    "change:isOpen",
                    (t, e, n) => {
                      n
                        ? (i.disableCssTransitions(),
                          i.reset(),
                          i._findInputView.fieldView.select(),
                          i.focus(),
                          i.enableCssTransitions())
                        : (i.focus(), this.fire("searchReseted"));
                    },
                    { priority: "low" }
                  ),
                  this._setupDropdownButton(n),
                  this._setupFormView(i),
                  n
                );
              });
            }
            _setupDropdownButton(t) {
              const e = this.editor,
                n = e.locale.t;
              t.buttonView.set({
                icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.87 13.786 1.532-1.286 3.857 4.596a1 1 0 1 1-1.532 1.286l-3.857-4.596z"/><path d="M16.004 8.5a6.5 6.5 0 0 1-9.216 5.905c-1.154-.53-.863-1.415-.663-1.615.194-.194.564-.592 1.635-.141a4.5 4.5 0 0 0 5.89-5.904l-.104-.227 1.332-1.331c.045-.046.196-.041.224.007a6.47 6.47 0 0 1 .902 3.306zm-3.4-5.715c.562.305.742 1.106.354 1.494-.388.388-.995.414-1.476.178a4.5 4.5 0 0 0-6.086 5.882l.114.236-1.348 1.349c-.038.037-.17.022-.198-.023a6.5 6.5 0 0 1 5.54-9.9 6.469 6.469 0 0 1 3.1.784z"/><path d="M4.001 11.93.948 8.877a.2.2 0 0 1 .141-.341h6.106a.2.2 0 0 1 .141.341L4.283 11.93a.2.2 0 0 1-.282 0zm11.083-6.789 3.053 3.053a.2.2 0 0 1-.14.342H11.89a.2.2 0 0 1-.14-.342l3.052-3.053a.2.2 0 0 1 .282 0z"/></svg>',
                label: n("Find and replace"),
                keystroke: "CTRL+F",
                tooltip: !0,
              }),
                e.keystrokes.set("Ctrl+F", (e, n) => {
                  (t.isOpen = !0), n();
                });
            }
            _setupFormView(t) {
              const e = this.editor.commands,
                n = this.editor.plugins.get("FindAndReplaceEditing").state,
                i = { before: -1, same: 0, after: 1 };
              t.bind("highlightOffset").to(n, "highlightedResult", (t) =>
                t
                  ? Array.from(n.results)
                      .sort(
                        (t, e) =>
                          i[
                            t.marker.getStart().compareWith(e.marker.getStart())
                          ]
                      )
                      .indexOf(t) + 1
                  : 0
              ),
                t.listenTo(n.results, "change", () => {
                  t.matchCount = n.results.length;
                }),
                t
                  .bind("_areCommandsEnabled")
                  .to(
                    e.get("findNext"),
                    "isEnabled",
                    e.get("findPrevious"),
                    "isEnabled",
                    e.get("replace"),
                    "isEnabled",
                    e.get("replaceAll"),
                    "isEnabled",
                    (t, e, n, i) => ({
                      findNext: t,
                      findPrevious: e,
                      replace: n,
                      replaceAll: i,
                    })
                  ),
                t
                  .delegate("findNext", "findPrevious", "replace", "replaceAll")
                  .to(this),
                t.on("change:isDirty", (t, e, n) => {
                  n && this.fire("searchReseted");
                });
            }
          }
          function Lk(t, e, n, i) {
            const o = i || new Di();
            return (
              e.change((i) => {
                [...t].forEach(({ type: t, item: s }) => {
                  if ("elementStart" === t && e.schema.checkChild(s, "$text")) {
                    const t = n({ item: s, text: Rk(e.createRangeIn(s)) });
                    if (!t) return;
                    t.forEach((t) => {
                      const e = `findResult:${r()}`,
                        n = i.addMarker(e, {
                          usingOperation: !1,
                          affectsData: !1,
                          range: i.createRange(
                            i.createPositionAt(s, t.start),
                            i.createPositionAt(s, t.end)
                          ),
                        }),
                        a = (function (t, e) {
                          const n = t.find(({ marker: t }) =>
                            e.getStart().isBefore(t.getStart())
                          );
                          return n ? t.getIndex(n) : t.length;
                        })(o, n);
                      o.add({ id: e, label: t.label, marker: n }, a);
                    });
                  }
                });
              }),
              o
            );
          }
          function Rk(t) {
            return Array.from(t.getItems()).reduce(
              (t, e) =>
                e.is("text") || e.is("textProxy") ? t + e.data : `${t}\n`,
              ""
            );
          }
          function Ok(t) {
            const e = t.length - 1;
            let n = t.index;
            return (
              3 === t.length && (n += t[1].length),
              { label: t[e], start: n, end: n + t[e].length }
            );
          }
          function jk(t, e) {
            let n = "gu";
            e.matchCase || (n += "i");
            let i = `(${gg(t)})`;
            if (e.wholeWords) {
              const e = "[^a-zA-ZÀ-ɏḀ-ỿ]";
              new RegExp("^" + e).test(t) || (i = `(^|${e}|_)${i}`),
                new RegExp(e + "$").test(t) || (i = `${i}(?=_|${e}|$)`);
            }
            const o = new RegExp(i, n);
            return function ({ text: t }) {
              return [...t.matchAll(o)].map(Ok);
            };
          }
          class Fk extends ge {
            constructor(t, e) {
              super(t),
                (this.isEnabled = !0),
                (this.affectsData = !1),
                (this._state = e);
            }
            execute(t, { matchCase: e, wholeWords: n } = {}) {
              const { editor: i } = this,
                { model: o } = i;
              let r;
              "string" == typeof t
                ? ((r = jk(t, { matchCase: e, wholeWords: n })),
                  (this._state.searchText = t))
                : (r = t);
              const s = o.document
                .getRootNames()
                .reduce(
                  (t, e) => Lk(o.createRangeIn(o.document.getRoot(e)), o, r, t),
                  null
                );
              return (
                this._state.clear(o),
                this._state.results.addMany(Array.from(s)),
                (this._state.highlightedResult = s.get(0)),
                "string" == typeof t && (this._state.searchText = t),
                (this._state.matchCase = !!e),
                (this._state.matchWholeWords = !!n),
                { results: s, findCallback: r }
              );
            }
          }
          class Vk extends ge {
            constructor(t, e) {
              super(t), (this.isEnabled = !0), (this._state = e);
            }
            execute(t, e) {
              const { model: n } = this.editor;
              n.change((i) => {
                const o = e.marker.getRange();
                if ("$graveyard" === o.root.rootName)
                  return void this._state.results.remove(e);
                let r = {};
                for (const t of o.getItems())
                  if (t.is("$text") || t.is("$textProxy")) {
                    r = t.getAttributes();
                    break;
                  }
                n.insertContent(i.createText(t, r), o),
                  this._state.results.has(e) && this._state.results.remove(e);
              });
            }
          }
          class Hk extends Vk {
            execute(t, e) {
              const { editor: n } = this,
                { model: i } = n,
                o =
                  e instanceof Di
                    ? e
                    : i.document
                        .getRootNames()
                        .reduce(
                          (t, n) =>
                            Lk(
                              i.createRangeIn(i.document.getRoot(n)),
                              i,
                              jk(e, this._state),
                              t
                            ),
                          null
                        );
              o.length &&
                i.change(() => {
                  [...o].forEach((e) => {
                    super.execute(t, e);
                  });
                });
            }
          }
          class Uk extends ge {
            constructor(t, e) {
              super(t),
                (this.affectsData = !1),
                (this._state = e),
                (this.isEnabled = !1),
                this.listenTo(this._state.results, "change", () => {
                  this.isEnabled = this._state.results.length > 1;
                });
            }
            refresh() {
              this.isEnabled = this._state.results.length > 1;
            }
            execute() {
              const t = this._state.results,
                e = t.getIndex(this._state.highlightedResult),
                n = e + 1 >= t.length ? 0 : e + 1;
              this._state.highlightedResult = this._state.results.get(n);
            }
          }
          class $k extends Uk {
            execute() {
              const t = this._state.results.getIndex(
                  this._state.highlightedResult
                ),
                e = t - 1 < 0 ? this._state.results.length - 1 : t - 1;
              this._state.highlightedResult = this._state.results.get(e);
            }
          }
          class qk {
            constructor(t) {
              this.set("results", new Di()),
                this.set("highlightedResult", null),
                this.set("searchText", ""),
                this.set("replaceText", ""),
                this.set("matchCase", !1),
                this.set("matchWholeWords", !1),
                this.results.on("change", (e, { removed: n, index: i }) => {
                  if ((n = Array.from(n)).length) {
                    let e = !1;
                    if (
                      (t.change((i) => {
                        for (const o of n)
                          this.highlightedResult === o && (e = !0),
                            t.markers.has(o.marker.name) &&
                              i.removeMarker(o.marker);
                      }),
                      e)
                    ) {
                      const t = i >= this.results.length ? 0 : i;
                      this.highlightedResult = this.results.get(t);
                    }
                  }
                });
            }
            clear(t) {
              (this.searchText = ""),
                t.change((e) => {
                  if (this.highlightedResult) {
                    const n = this.highlightedResult.marker.name.split(":")[1],
                      i = t.markers.get(`findResultHighlighted:${n}`);
                    i && e.removeMarker(i);
                  }
                  [...this.results].forEach(({ marker: t }) => {
                    e.removeMarker(t);
                  });
                }),
                this.results.clear();
            }
          }
          he(qk, re);
          var Gk = n(5436),
            Wk = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Gk.Z, Wk);
          Gk.Z.locals;
          class Yk extends ue {
            static get pluginName() {
              return "FindAndReplaceEditing";
            }
            init() {
              (this._activeResults = null),
                (this.state = new qk(this.editor.model)),
                this._defineConverters(),
                this._defineCommands(),
                this.listenTo(
                  this.state,
                  "change:highlightedResult",
                  (t, e, n, i) => {
                    const { model: o } = this.editor;
                    o.change((t) => {
                      if (i) {
                        const e = i.marker.name.split(":")[1],
                          n = o.markers.get(`findResultHighlighted:${e}`);
                        n && t.removeMarker(n);
                      }
                      if (n) {
                        const e = n.marker.name.split(":")[1];
                        t.addMarker(`findResultHighlighted:${e}`, {
                          usingOperation: !1,
                          affectsData: !1,
                          range: n.marker.getRange(),
                        });
                      }
                    });
                  }
                );
              const t = ra(
                function (t, e, n) {
                  if (n) {
                    const t = this.editor.editing.view.domConverter,
                      e = this.editor.editing.mapper.toViewRange(
                        n.marker.getRange()
                      );
                    va({ target: t.viewRangeToDom(e), viewportOffset: 40 });
                  }
                }.bind(this),
                32
              );
              this.listenTo(this.state, "change:highlightedResult", t, {
                priority: "low",
              }),
                this.listenTo(this.editor, "destroy", t.cancel);
            }
            find(t) {
              const { editor: e } = this,
                { model: n } = e,
                { findCallback: i, results: o } = e.execute("find", t);
              return (
                (this._activeResults = o),
                this.listenTo(n.document, "change:data", () =>
                  (function (t, e, n) {
                    const i = new Set(),
                      o = new Set();
                    e.document.differ.getChanges().forEach((t) => {
                      "$text" === t.name ||
                      e.schema.isInline(t.position.nodeAfter)
                        ? (i.add(t.position.parent),
                          [
                            ...e.markers.getMarkersAtPosition(t.position),
                          ].forEach((t) => {
                            o.add(t.name);
                          }))
                        : "insert" === t.type && i.add(t.position.nodeAfter);
                    }),
                      e.document.differ
                        .getChangedMarkers()
                        .forEach(({ name: t, data: { newRange: e } }) => {
                          e &&
                            "$graveyard" === e.start.root.rootName &&
                            o.add(t);
                        }),
                      i.forEach((t) => {
                        [
                          ...e.markers.getMarkersIntersectingRange(
                            e.createRangeIn(t)
                          ),
                        ].forEach((t) => o.add(t.name));
                      }),
                      e.change((e) => {
                        o.forEach((n) => {
                          t.has(n) && t.remove(n), e.removeMarker(n);
                        });
                      }),
                      i.forEach((i) => {
                        Lk(e.createRangeOn(i), e, n, t);
                      });
                  })(this._activeResults, n, i)
                ),
                this._activeResults
              );
            }
            stop() {
              this._activeResults &&
                (this.stopListening(this.editor.model.document),
                this.state.clear(this.editor.model),
                (this._activeResults = null));
            }
            _defineCommands() {
              this.editor.commands.add("find", new Fk(this.editor, this.state)),
                this.editor.commands.add(
                  "findNext",
                  new Uk(this.editor, this.state)
                ),
                this.editor.commands.add(
                  "findPrevious",
                  new $k(this.editor, this.state)
                ),
                this.editor.commands.add(
                  "replace",
                  new Vk(this.editor, this.state)
                ),
                this.editor.commands.add(
                  "replaceAll",
                  new Hk(this.editor, this.state)
                );
            }
            _defineConverters() {
              const { editor: t } = this;
              t.conversion.for("editingDowncast").markerToHighlight({
                model: "findResult",
                view: ({ markerName: t }) => {
                  const [, e] = t.split(":");
                  return {
                    name: "span",
                    classes: ["ck-find-result"],
                    attributes: { "data-find-result": e },
                  };
                },
              }),
                t.conversion.for("editingDowncast").markerToHighlight({
                  model: "findResultHighlighted",
                  view: ({ markerName: t }) => {
                    const [, e] = t.split(":");
                    return {
                      name: "span",
                      classes: ["ck-find-result_selected"],
                      attributes: { "data-find-result": e },
                    };
                  },
                });
            }
          }
          class Kk extends ge {
            constructor(t, e) {
              super(t), (this.attributeKey = e);
            }
            refresh() {
              const t = this.editor.model,
                e = t.document;
              (this.value = e.selection.getAttribute(this.attributeKey)),
                (this.isEnabled = t.schema.checkAttributeInSelection(
                  e.selection,
                  this.attributeKey
                ));
            }
            execute(t = {}) {
              const e = this.editor.model,
                n = e.document.selection,
                i = t.value;
              e.change((t) => {
                if (n.isCollapsed)
                  i
                    ? t.setSelectionAttribute(this.attributeKey, i)
                    : t.removeSelectionAttribute(this.attributeKey);
                else {
                  const o = e.schema.getValidRanges(
                    n.getRanges(),
                    this.attributeKey
                  );
                  for (const e of o)
                    i
                      ? t.setAttribute(this.attributeKey, i, e)
                      : t.removeAttribute(this.attributeKey, e);
                }
              });
            }
          }
          class Qk extends Di {
            constructor(t) {
              super(t),
                this.set("isEmpty", !0),
                this.on("change", () => {
                  this.set("isEmpty", 0 === this.length);
                });
            }
            add(t, e) {
              this.find((e) => e.color === t.color) || super.add(t, e);
            }
            hasColor(t) {
              return !!this.find((e) => e.color === t);
            }
          }
          he(Qk, re);
          var Zk = n(2585),
            Jk = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Zk.Z, Jk);
          Zk.Z.locals;
          class Xk extends Vd {
            constructor(
              t,
              {
                colors: e,
                columns: n,
                removeButtonLabel: i,
                documentColorsLabel: o,
                documentColorsCount: r,
              }
            ) {
              super(t),
                (this.items = this.createCollection()),
                (this.colorDefinitions = e),
                (this.focusTracker = new za()),
                (this.keystrokes = new Pa()),
                this.set("selectedColor"),
                (this.removeButtonLabel = i),
                (this.columns = n),
                (this.documentColors = new Qk()),
                (this.documentColorsCount = r),
                (this._focusCycler = new vh({
                  focusables: this.items,
                  focusTracker: this.focusTracker,
                  keystrokeHandler: this.keystrokes,
                  actions: { focusPrevious: "arrowup", focusNext: "arrowdown" },
                })),
                (this._documentColorsLabel = o),
                this.setTemplate({
                  tag: "div",
                  attributes: { class: ["ck", "ck-color-table"] },
                  children: this.items,
                }),
                this.items.add(this._removeColorButton());
            }
            updateDocumentColors(t, e) {
              const n = t.document,
                i = this.documentColorsCount;
              this.documentColors.clear();
              for (const o of n.getRootNames()) {
                const r = n.getRoot(o),
                  s = t.createRangeIn(r);
                for (const t of s.getItems())
                  if (
                    t.is("$textProxy") &&
                    t.hasAttribute(e) &&
                    (this._addColorToDocumentColors(t.getAttribute(e)),
                    this.documentColors.length >= i)
                  )
                    return;
              }
            }
            updateSelectedColors() {
              const t = this.documentColorsGrid,
                e = this.staticColorsGrid,
                n = this.selectedColor;
              (e.selectedColor = n), t && (t.selectedColor = n);
            }
            render() {
              super.render();
              for (const t of this.items) this.focusTracker.add(t.element);
              this.keystrokes.listenTo(this.element);
            }
            destroy() {
              super.destroy(),
                this.focusTracker.destroy(),
                this.keystrokes.destroy();
            }
            appendGrids() {
              if (
                !this.staticColorsGrid &&
                ((this.staticColorsGrid = this._createStaticColorsGrid()),
                this.items.add(this.staticColorsGrid),
                this.documentColorsCount)
              ) {
                const t = Hd.bind(this.documentColors, this.documentColors),
                  e = new uu(this.locale);
                (e.text = this._documentColorsLabel),
                  e.extendTemplate({
                    attributes: {
                      class: [
                        "ck",
                        "ck-color-grid__label",
                        t.if("isEmpty", "ck-hidden"),
                      ],
                    },
                  }),
                  this.items.add(e),
                  (this.documentColorsGrid = this._createDocumentColorsGrid()),
                  this.items.add(this.documentColorsGrid);
              }
            }
            focus() {
              this._focusCycler.focusFirst();
            }
            focusLast() {
              this._focusCycler.focusLast();
            }
            _removeColorButton() {
              const t = new kh();
              return (
                t.set({
                  withText: !0,
                  icon: zd.eraser,
                  tooltip: !0,
                  label: this.removeButtonLabel,
                }),
                (t.class = "ck-color-table__remove-color"),
                t.on("execute", () => {
                  this.fire("execute", { value: null });
                }),
                t
              );
            }
            _createStaticColorsGrid() {
              const t = new Dh(this.locale, {
                colorDefinitions: this.colorDefinitions,
                columns: this.columns,
              });
              return t.delegate("execute").to(this), t;
            }
            _createDocumentColorsGrid() {
              const t = Hd.bind(this.documentColors, this.documentColors),
                e = new Dh(this.locale, { columns: this.columns });
              return (
                e.delegate("execute").to(this),
                e.extendTemplate({
                  attributes: { class: t.if("isEmpty", "ck-hidden") },
                }),
                e.items.bindTo(this.documentColors).using((t) => {
                  const e = new Ch();
                  return (
                    e.set({
                      color: t.color,
                      hasBorder: t.options && t.options.hasBorder,
                    }),
                    t.label && e.set({ label: t.label, tooltip: !0 }),
                    e.on("execute", () => {
                      this.fire("execute", { value: t.color });
                    }),
                    e
                  );
                }),
                this.documentColors.on("change:isEmpty", (t, n, i) => {
                  i && (e.selectedColor = null);
                }),
                e
              );
            }
            _addColorToDocumentColors(t) {
              const e = this.colorDefinitions.find((e) => e.color === t);
              e
                ? this.documentColors.add(Object.assign({}, e))
                : this.documentColors.add({
                    color: t,
                    label: t,
                    options: { hasBorder: !1 },
                  });
            }
          }
          const tb = "fontColor",
            eb = "fontBackgroundColor";
          function nb(t) {
            return (e) => e.getStyle(t).replace(/\s/g, "");
          }
          function ib(t) {
            return (e, { writer: n }) =>
              n.createAttributeElement(
                "span",
                { style: `${t}:${e}` },
                { priority: 7 }
              );
          }
          class ob extends Kk {
            constructor(t) {
              super(t, eb);
            }
          }
          class rb extends ue {
            static get pluginName() {
              return "FontBackgroundColorEditing";
            }
            constructor(t) {
              super(t),
                t.config.define(eb, {
                  colors: [
                    { color: "hsl(0, 0%, 0%)", label: "Black" },
                    { color: "hsl(0, 0%, 30%)", label: "Dim grey" },
                    { color: "hsl(0, 0%, 60%)", label: "Grey" },
                    { color: "hsl(0, 0%, 90%)", label: "Light grey" },
                    {
                      color: "hsl(0, 0%, 100%)",
                      label: "White",
                      hasBorder: !0,
                    },
                    { color: "hsl(0, 75%, 60%)", label: "Red" },
                    { color: "hsl(30, 75%, 60%)", label: "Orange" },
                    { color: "hsl(60, 75%, 60%)", label: "Yellow" },
                    { color: "hsl(90, 75%, 60%)", label: "Light green" },
                    { color: "hsl(120, 75%, 60%)", label: "Green" },
                    { color: "hsl(150, 75%, 60%)", label: "Aquamarine" },
                    { color: "hsl(180, 75%, 60%)", label: "Turquoise" },
                    { color: "hsl(210, 75%, 60%)", label: "Light blue" },
                    { color: "hsl(240, 75%, 60%)", label: "Blue" },
                    { color: "hsl(270, 75%, 60%)", label: "Purple" },
                  ],
                  columns: 5,
                }),
                t.data.addStyleProcessorRules(Lm),
                t.conversion
                  .for("upcast")
                  .elementToAttribute({
                    view: {
                      name: "span",
                      styles: { "background-color": /[\s\S]+/ },
                    },
                    model: { key: eb, value: nb("background-color") },
                  }),
                t.conversion
                  .for("downcast")
                  .attributeToElement({
                    model: eb,
                    view: ib("background-color"),
                  }),
                t.commands.add(eb, new ob(t)),
                t.model.schema.extend("$text", { allowAttributes: eb }),
                t.model.schema.setAttributeProperties(eb, {
                  isFormatting: !0,
                  copyOnEnter: !0,
                });
            }
          }
          class sb extends ue {
            constructor(
              t,
              { commandName: e, icon: n, componentName: i, dropdownLabel: o }
            ) {
              super(t),
                (this.commandName = e),
                (this.componentName = i),
                (this.icon = n),
                (this.dropdownLabel = o),
                (this.columns = t.config.get(`${this.componentName}.columns`)),
                (this.colorTableView = void 0);
            }
            init() {
              const t = this.editor,
                e = t.locale,
                n = e.t,
                i = t.commands.get(this.commandName),
                o = (function (t) {
                  return t.map(_h).filter((t) => !!t);
                })(t.config.get(this.componentName).colors),
                r = (function (t, e) {
                  const n = t.t,
                    i = {
                      Black: n("Black"),
                      "Dim grey": n("Dim grey"),
                      Grey: n("Grey"),
                      "Light grey": n("Light grey"),
                      White: n("White"),
                      Red: n("Red"),
                      Orange: n("Orange"),
                      Yellow: n("Yellow"),
                      "Light green": n("Light green"),
                      Green: n("Green"),
                      Aquamarine: n("Aquamarine"),
                      Turquoise: n("Turquoise"),
                      "Light blue": n("Light blue"),
                      Blue: n("Blue"),
                      Purple: n("Purple"),
                    };
                  return e.map((t) => {
                    const e = i[t.label];
                    return e && e != t.label && (t.label = e), t;
                  });
                })(e, o),
                s = t.config.get(`${this.componentName}.documentColors`);
              t.ui.componentFactory.add(this.componentName, (e) => {
                const o = ou(e);
                return (
                  (this.colorTableView = (function ({
                    dropdownView: t,
                    colors: e,
                    columns: n,
                    removeButtonLabel: i,
                    documentColorsLabel: o,
                    documentColorsCount: r,
                  }) {
                    const s = t.locale,
                      a = new Xk(s, {
                        colors: e,
                        columns: n,
                        removeButtonLabel: i,
                        documentColorsLabel: o,
                        documentColorsCount: r,
                      });
                    return (
                      (t.colorTableView = a),
                      t.panelView.children.add(a),
                      a.delegate("execute").to(t, "execute"),
                      a
                    );
                  })({
                    dropdownView: o,
                    colors: r.map((t) => ({
                      label: t.label,
                      color: t.model,
                      options: { hasBorder: t.hasBorder },
                    })),
                    columns: this.columns,
                    removeButtonLabel: n("Remove color"),
                    documentColorsLabel:
                      0 !== s ? n("Document colors") : void 0,
                    documentColorsCount: void 0 === s ? this.columns : s,
                  })),
                  this.colorTableView.bind("selectedColor").to(i, "value"),
                  o.buttonView.set({
                    label: this.dropdownLabel,
                    icon: this.icon,
                    tooltip: !0,
                  }),
                  o.extendTemplate({
                    attributes: { class: "ck-color-ui-dropdown" },
                  }),
                  o.bind("isEnabled").to(i),
                  o.on("execute", (e, n) => {
                    t.execute(this.commandName, n), t.editing.view.focus();
                  }),
                  o.on("change:isOpen", (e, n, i) => {
                    o.colorTableView.appendGrids(),
                      i &&
                        (0 !== s &&
                          this.colorTableView.updateDocumentColors(
                            t.model,
                            this.componentName
                          ),
                        this.colorTableView.updateSelectedColors());
                  }),
                  o
                );
              });
            }
          }
          class ab extends sb {
            constructor(t) {
              const e = t.locale.t;
              super(t, {
                commandName: eb,
                componentName: eb,
                icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm8.38 9.262H7.62L10 5.506l2.38 5.756zm.532 1.285L14.34 16h1.426L10.804 4H9.196L4.234 16H5.66l1.428-3.453h5.824z"/></svg>',
                dropdownLabel: e("Font Background Color"),
              });
            }
            static get pluginName() {
              return "FontBackgroundColorUI";
            }
          }
          class cb extends Kk {
            constructor(t) {
              super(t, tb);
            }
          }
          class lb extends ue {
            static get pluginName() {
              return "FontColorEditing";
            }
            constructor(t) {
              super(t),
                t.config.define(tb, {
                  colors: [
                    { color: "hsl(0, 0%, 0%)", label: "Black" },
                    { color: "hsl(0, 0%, 30%)", label: "Dim grey" },
                    { color: "hsl(0, 0%, 60%)", label: "Grey" },
                    { color: "hsl(0, 0%, 90%)", label: "Light grey" },
                    {
                      color: "hsl(0, 0%, 100%)",
                      label: "White",
                      hasBorder: !0,
                    },
                    { color: "hsl(0, 75%, 60%)", label: "Red" },
                    { color: "hsl(30, 75%, 60%)", label: "Orange" },
                    { color: "hsl(60, 75%, 60%)", label: "Yellow" },
                    { color: "hsl(90, 75%, 60%)", label: "Light green" },
                    { color: "hsl(120, 75%, 60%)", label: "Green" },
                    { color: "hsl(150, 75%, 60%)", label: "Aquamarine" },
                    { color: "hsl(180, 75%, 60%)", label: "Turquoise" },
                    { color: "hsl(210, 75%, 60%)", label: "Light blue" },
                    { color: "hsl(240, 75%, 60%)", label: "Blue" },
                    { color: "hsl(270, 75%, 60%)", label: "Purple" },
                  ],
                  columns: 5,
                }),
                t.conversion
                  .for("upcast")
                  .elementToAttribute({
                    view: { name: "span", styles: { color: /[\s\S]+/ } },
                    model: { key: tb, value: nb("color") },
                  }),
                t.conversion
                  .for("upcast")
                  .elementToAttribute({
                    view: { name: "font", attributes: { color: /^#?\w+$/ } },
                    model: { key: tb, value: (t) => t.getAttribute("color") },
                  }),
                t.conversion
                  .for("downcast")
                  .attributeToElement({ model: tb, view: ib("color") }),
                t.commands.add(tb, new cb(t)),
                t.model.schema.extend("$text", { allowAttributes: tb }),
                t.model.schema.setAttributeProperties(tb, {
                  isFormatting: !0,
                  copyOnEnter: !0,
                });
            }
          }
          class db extends sb {
            constructor(t) {
              const e = t.locale.t;
              super(t, {
                commandName: tb,
                componentName: tb,
                icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.4 10.3 10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z"/></svg>',
                dropdownLabel: e("Font Color"),
              });
            }
            static get pluginName() {
              return "FontColorUI";
            }
          }
          const hb = [
              { model: "codeBlock", view: "pre" },
              { model: "paragraph", view: "p" },
              { model: "blockQuote", view: "blockquote" },
              { model: "listItem", view: "li" },
              { model: "pageBreak", view: "div" },
              { model: "rawHtml", view: "div" },
              { model: "table", view: "table" },
              { model: "tableRow", view: "tr" },
              { model: "tableCell", view: "td" },
              { model: "tableCell", view: "th" },
              { model: "caption", view: "caption" },
              { model: "caption", view: "figcaption" },
              { model: "imageBlock", view: "img" },
              { model: "imageInline", view: "img" },
              {
                model: "htmlP",
                view: "p",
                modelSchema: { inheritAllFrom: "$block" },
              },
              {
                model: "htmlBlockquote",
                view: "blockquote",
                modelSchema: { inheritAllFrom: "$container" },
              },
              {
                model: "htmlTable",
                view: "table",
                modelSchema: { allowWhere: "$block", isBlock: !0 },
              },
              {
                model: "htmlTbody",
                view: "tbody",
                modelSchema: { allowIn: "htmlTable", isBlock: !0 },
              },
              {
                model: "htmlThead",
                view: "thead",
                modelSchema: { allowIn: "htmlTable", isBlock: !0 },
              },
              {
                model: "htmlTfoot",
                view: "tfoot",
                modelSchema: { allowIn: "htmlTable", isBlock: !0 },
              },
              {
                model: "htmlCaption",
                view: "caption",
                modelSchema: {
                  allowIn: "htmlTable",
                  allowChildren: "$text",
                  isBlock: !0,
                },
              },
              {
                model: "htmlTr",
                view: "tr",
                modelSchema: {
                  allowIn: ["htmlTable", "htmlThead", "htmlTbody"],
                },
              },
              {
                model: "htmlTd",
                view: "td",
                modelSchema: {
                  allowIn: "htmlTr",
                  allowContentOf: "$container",
                },
              },
              {
                model: "htmlTh",
                view: "th",
                modelSchema: {
                  allowIn: "htmlTr",
                  allowContentOf: "$container",
                },
              },
              {
                model: "htmlFigure",
                view: "figure",
                modelSchema: { inheritAllFrom: "$container", isBlock: !0 },
              },
              {
                model: "htmlFigcaption",
                view: "figcaption",
                modelSchema: {
                  allowIn: "htmlFigure",
                  allowChildren: "$text",
                  isBlock: !0,
                },
              },
              {
                model: "htmlAddress",
                view: "address",
                modelSchema: { inheritAllFrom: "$container", isBlock: !0 },
              },
              {
                model: "htmlAside",
                view: "aside",
                modelSchema: { inheritAllFrom: "$container", isBlock: !0 },
              },
              {
                model: "htmlMain",
                view: "main",
                modelSchema: { inheritAllFrom: "$container", isBlock: !0 },
              },
              {
                model: "htmlDetails",
                view: "details",
                modelSchema: { inheritAllFrom: "$container", isBlock: !0 },
              },
              {
                model: "htmlSummary",
                view: "summary",
                modelSchema: {
                  allowChildren: "$text",
                  allowIn: "htmlDetails",
                  isBlock: !0,
                },
              },
              {
                model: "htmlDiv",
                view: "div",
                paragraphLikeModel: "htmlDivParagraph",
                modelSchema: { inheritAllFrom: "$container" },
              },
              {
                model: "htmlFieldset",
                view: "fieldset",
                modelSchema: { inheritAllFrom: "$container", isBlock: !0 },
              },
              {
                model: "htmlLegend",
                view: "legend",
                modelSchema: {
                  allowIn: "htmlFieldset",
                  allowChildren: "$text",
                },
              },
              {
                model: "htmlHeader",
                view: "header",
                modelSchema: { inheritAllFrom: "$container", isBlock: !0 },
              },
              {
                model: "htmlFooter",
                view: "footer",
                modelSchema: { inheritAllFrom: "$container", isBlock: !0 },
              },
              {
                model: "htmlForm",
                view: "form",
                modelSchema: { inheritAllFrom: "$container", isBlock: !0 },
              },
              {
                model: "htmlHgroup",
                view: "hgroup",
                modelSchema: {
                  allowChildren: [
                    "htmlH1",
                    "htmlH2",
                    "htmlH3",
                    "htmlH4",
                    "htmlH5",
                    "htmlH6",
                  ],
                  isBlock: !0,
                },
              },
              {
                model: "htmlH1",
                view: "h1",
                modelSchema: { inheritAllFrom: "$block" },
              },
              {
                model: "htmlH2",
                view: "h2",
                modelSchema: { inheritAllFrom: "$block" },
              },
              {
                model: "htmlH3",
                view: "h3",
                modelSchema: { inheritAllFrom: "$block" },
              },
              {
                model: "htmlH4",
                view: "h4",
                modelSchema: { inheritAllFrom: "$block" },
              },
              {
                model: "htmlH5",
                view: "h5",
                modelSchema: { inheritAllFrom: "$block" },
              },
              {
                model: "htmlH6",
                view: "h6",
                modelSchema: { inheritAllFrom: "$block" },
              },
              {
                model: "$htmlList",
                modelSchema: {
                  allowWhere: "$container",
                  allowChildren: ["$htmlList", "htmlLi"],
                  isBlock: !0,
                },
              },
              {
                model: "htmlDir",
                view: "dir",
                modelSchema: { inheritAllFrom: "$htmlList" },
              },
              {
                model: "htmlMenu",
                view: "menu",
                modelSchema: { inheritAllFrom: "$htmlList" },
              },
              {
                model: "htmlUl",
                view: "ul",
                modelSchema: { inheritAllFrom: "$htmlList" },
              },
              {
                model: "htmlOl",
                view: "ol",
                modelSchema: { inheritAllFrom: "$htmlList" },
              },
              {
                model: "htmlLi",
                view: "li",
                modelSchema: {
                  allowIn: "$htmlList",
                  allowChildren: "$text",
                  isBlock: !0,
                },
              },
              {
                model: "htmlPre",
                view: "pre",
                modelSchema: { inheritAllFrom: "$block" },
              },
              {
                model: "htmlArticle",
                view: "article",
                modelSchema: { inheritAllFrom: "$container", isBlock: !0 },
              },
              {
                model: "htmlSection",
                view: "section",
                modelSchema: { inheritAllFrom: "$container", isBlock: !0 },
              },
              {
                model: "htmlNav",
                view: "nav",
                modelSchema: { inheritAllFrom: "$container", isBlock: !0 },
              },
              {
                model: "htmlDl",
                view: "dl",
                modelSchema: {
                  allowWhere: "$container",
                  allowChildren: ["htmlDt", "htmlDd"],
                  isBlock: !0,
                },
              },
              {
                model: "htmlDt",
                view: "dt",
                modelSchema: { allowChildren: "$block", isBlock: !0 },
              },
              {
                model: "htmlDd",
                view: "dd",
                modelSchema: { allowChildren: "$block", isBlock: !0 },
              },
              {
                model: "htmlCenter",
                view: "center",
                modelSchema: { inheritAllFrom: "$container", isBlock: !0 },
              },
            ],
            ub = [
              {
                model: "htmlAcronym",
                view: "acronym",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlTt",
                view: "tt",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlFont",
                view: "font",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlTime",
                view: "time",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlVar",
                view: "var",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlBig",
                view: "big",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlSmall",
                view: "small",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlSamp",
                view: "samp",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlQ",
                view: "q",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlOutput",
                view: "output",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlKbd",
                view: "kbd",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlBdi",
                view: "bdi",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlBdo",
                view: "bdo",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlAbbr",
                view: "abbr",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlA",
                view: "a",
                priority: 5,
                coupledAttribute: "linkHref",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlStrong",
                view: "strong",
                coupledAttribute: "bold",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlB",
                view: "b",
                coupledAttribute: "bold",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlI",
                view: "i",
                coupledAttribute: "italic",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlEm",
                view: "em",
                coupledAttribute: "italic",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlS",
                view: "s",
                coupledAttribute: "strikethrough",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlDel",
                view: "del",
                coupledAttribute: "strikethrough",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlIns",
                view: "ins",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlU",
                view: "u",
                coupledAttribute: "underline",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlSub",
                view: "sub",
                coupledAttribute: "subscript",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlSup",
                view: "sup",
                coupledAttribute: "superscript",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlCode",
                view: "code",
                coupledAttribute: "code",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlMark",
                view: "mark",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlSpan",
                view: "span",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlCite",
                view: "cite",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlLabel",
                view: "label",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlDfn",
                view: "dfn",
                attributeProperties: { copyOnEnter: !0 },
              },
              {
                model: "htmlObject",
                view: "object",
                isObject: !0,
                modelSchema: { inheritAllFrom: "$inlineObject" },
              },
              {
                model: "htmlIframe",
                view: "iframe",
                isObject: !0,
                modelSchema: { inheritAllFrom: "$inlineObject" },
              },
              {
                model: "htmlInput",
                view: "input",
                isObject: !0,
                modelSchema: { inheritAllFrom: "$inlineObject" },
              },
              {
                model: "htmlButton",
                view: "button",
                isObject: !0,
                modelSchema: { inheritAllFrom: "$inlineObject" },
              },
              {
                model: "htmlTextarea",
                view: "textarea",
                isObject: !0,
                modelSchema: { inheritAllFrom: "$inlineObject" },
              },
              {
                model: "htmlSelect",
                view: "select",
                isObject: !0,
                modelSchema: { inheritAllFrom: "$inlineObject" },
              },
              {
                model: "htmlVideo",
                view: "video",
                isObject: !0,
                modelSchema: { inheritAllFrom: "$inlineObject" },
              },
              {
                model: "htmlEmbed",
                view: "embed",
                isObject: !0,
                modelSchema: { inheritAllFrom: "$inlineObject" },
              },
              {
                model: "htmlOembed",
                view: "oembed",
                isObject: !0,
                modelSchema: { inheritAllFrom: "$inlineObject" },
              },
              {
                model: "htmlAudio",
                view: "audio",
                isObject: !0,
                modelSchema: { inheritAllFrom: "$inlineObject" },
              },
              {
                model: "htmlImg",
                view: "img",
                isObject: !0,
                modelSchema: { inheritAllFrom: "$inlineObject" },
              },
              {
                model: "htmlCanvas",
                view: "canvas",
                isObject: !0,
                modelSchema: { inheritAllFrom: "$inlineObject" },
              },
              {
                model: "htmlMeter",
                view: "meter",
                isObject: !0,
                modelSchema: { inheritAllFrom: "$inlineObject" },
              },
              {
                model: "htmlProgress",
                view: "progress",
                isObject: !0,
                modelSchema: { inheritAllFrom: "$inlineObject" },
              },
              {
                model: "htmlScript",
                view: "script",
                modelSchema: { allowWhere: ["$text", "$block"], isInline: !0 },
              },
              {
                model: "htmlStyle",
                view: "style",
                modelSchema: { allowWhere: ["$text", "$block"], isInline: !0 },
              },
              {
                model: "htmlCustomElement",
                view: "$customElement",
                modelSchema: { allowWhere: ["$text", "$block"], isInline: !0 },
              },
            ];
          const mb = _t(function (t, e, n, i) {
            Co(t, e, n, i);
          });
          class gb extends ue {
            constructor(t) {
              super(t), (this._definitions = new Map());
            }
            static get pluginName() {
              return "DataSchema";
            }
            init() {
              for (const t of hb) this.registerBlockElement(t);
              for (const t of ub) this.registerInlineElement(t);
            }
            registerBlockElement(t) {
              this._definitions.set(t.model, { ...t, isBlock: !0 });
            }
            registerInlineElement(t) {
              this._definitions.set(t.model, { ...t, isInline: !0 });
            }
            extendBlockElement(t) {
              this._extendDefinition({ ...t, isBlock: !0 });
            }
            extendInlineElement(t) {
              this._extendDefinition({ ...t, isInline: !0 });
            }
            getDefinitionsForView(t, e) {
              const n = new Set();
              for (const i of this._getMatchingViewDefinitions(t)) {
                if (e) for (const t of this._getReferences(i.model)) n.add(t);
                n.add(i);
              }
              return n;
            }
            _getMatchingViewDefinitions(t) {
              return Array.from(this._definitions.values()).filter(
                (e) =>
                  e.view &&
                  (function (t, e) {
                    if ("string" == typeof t) return t === e;
                    if (t instanceof RegExp) return t.test(e);
                    return !1;
                  })(t, e.view)
              );
            }
            *_getReferences(t) {
              const { modelSchema: e } = this._definitions.get(t);
              if (!e) return;
              const n = [
                "inheritAllFrom",
                "inheritTypesFrom",
                "allowWhere",
                "allowContentOf",
                "allowAttributesOf",
              ];
              for (const i of n)
                for (const n of Ii(e[i] || [])) {
                  const e = this._definitions.get(n);
                  n !== t &&
                    e &&
                    (yield* this._getReferences(e.model), yield e);
                }
            }
            _extendDefinition(t) {
              const e = this._definitions.get(t.model),
                n = mb({}, e, t, (t, e) =>
                  Array.isArray(t) ? t.concat(e) : void 0
                );
              this._definitions.set(t.model, n);
            }
          }
          function pb(t, e, n, i) {
            e &&
              (function (t, e, n) {
                if (e.attributes)
                  for (const [i] of Object.entries(e.attributes))
                    t.removeAttribute(i, n);
                if (e.styles)
                  for (const i of Object.keys(e.styles)) t.removeStyle(i, n);
                e.classes && t.removeClass(e.classes, n);
              })(t, e, i),
              n && fb(t, n, i);
          }
          function fb(t, e, n) {
            if (e.attributes)
              for (const [i, o] of Object.entries(e.attributes))
                t.setAttribute(i, o, n);
            e.styles && t.setStyle(e.styles, n),
              e.classes && t.addClass(e.classes, n);
          }
          function kb(t, e) {
            const n = fc(t);
            for (const i in e)
              Array.isArray(e[i])
                ? (n[i] = Array.from(new Set([...(t[i] || []), ...e[i]])))
                : (n[i] = { ...t[i], ...e[i] });
            return n;
          }
          function bb({ model: t }) {
            return (e, n) =>
              n.writer.createElement(t, {
                htmlContent: e.getCustomProperty("$rawContent"),
              });
          }
          function wb(t, { view: e, isInline: n }) {
            const i = t.t;
            return (t, { writer: o }) => {
              const r = i("HTML object"),
                s = Ab(e, t, o),
                a = t.getAttribute("htmlAttributes");
              o.addClass("html-object-embed__content", s), a && fb(o, a, s);
              return Gg(
                o.createContainerElement(
                  n ? "span" : "div",
                  {
                    class: "html-object-embed",
                    "data-html-object-embed-label": r,
                  },
                  s
                ),
                o,
                { widgetLabel: r }
              );
            };
          }
          function Ab(t, e, n) {
            return n.createRawElement(t, null, (t, n) => {
              n.setContentOf(t, e.getAttribute("htmlContent"));
            });
          }
          function _b({ priority: t, view: e }) {
            return (n, i) => {
              if (!n) return;
              const { writer: o } = i,
                r = o.createAttributeElement(e, null, { priority: t });
              return fb(o, n, r), r;
            };
          }
          function Cb({ view: t }, e) {
            return (n) => {
              n.on(
                `element:${t}`,
                (t, n, i) => {
                  if (!n.modelRange || n.modelRange.isCollapsed) return;
                  const o = e.processViewAttributes(n.viewItem, i);
                  o && i.writer.setAttribute("htmlAttributes", o, n.modelRange);
                },
                { priority: "low" }
              );
            };
          }
          function vb({ model: t }) {
            return (e) => {
              e.on(`attribute:htmlAttributes:${t}`, (t, e, n) => {
                if (!n.consumable.consume(e.item, t.name)) return;
                const { attributeOldValue: i, attributeNewValue: o } = e;
                pb(n.writer, i, o, n.mapper.toViewElement(e.item));
              });
            };
          }
          const yb = function (t, e, n, i) {
            for (var o = t.length, r = n + (i ? 1 : -1); i ? r-- : ++r < o; )
              if (e(t[r], r, t)) return r;
            return -1;
          };
          const xb = function (t) {
            return t != t;
          };
          const Eb = function (t, e, n) {
            for (var i = n - 1, o = t.length; ++i < o; )
              if (t[i] === e) return i;
            return -1;
          };
          const Db = function (t, e, n) {
            return e == e ? Eb(t, e, n) : yb(t, xb, n);
          };
          const Sb = function (t, e, n, i) {
            for (var o = n - 1, r = t.length; ++o < r; )
              if (i(t[o], e)) return o;
            return -1;
          };
          var Ib = Array.prototype.splice;
          const Tb = function (t, e, n, i) {
            var o = i ? Sb : Db,
              r = -1,
              s = e.length,
              a = t;
            for (t === e && (e = An(e)), n && (a = eo(t, Rt(n))); ++r < s; )
              for (
                var c = 0, l = e[r], d = n ? n(l) : l;
                (c = o(a, d, c, i)) > -1;

              )
                a !== t && Ib.call(a, c, 1), Ib.call(t, c, 1);
            return t;
          };
          const Mb = pt(function (t, e) {
            return t && t.length && e && e.length ? Tb(t, e) : t;
          });
          var Bb = n(8468),
            Nb = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Bb.Z, Nb);
          Bb.Z.locals;
          class zb extends ue {
            constructor(t) {
              super(t),
                (this._dataSchema = t.plugins.get("DataSchema")),
                (this._allowedAttributes = new Hi()),
                (this._disallowedAttributes = new Hi()),
                (this._allowedElements = new Set()),
                (this._dataInitialized = !1),
                (this._coupledAttributes = null),
                this._registerElementsAfterInit(),
                this._registerElementHandlers(),
                this._registerModelPostFixer();
            }
            static get pluginName() {
              return "DataFilter";
            }
            static get requires() {
              return [gb, gp];
            }
            loadAllowedConfig(t) {
              this._loadConfig(t, (t) => this.allowAttributes(t));
            }
            loadDisallowedConfig(t) {
              this._loadConfig(t, (t) => this.disallowAttributes(t));
            }
            allowElement(t) {
              for (const e of this._dataSchema.getDefinitionsForView(t, !0))
                this._allowedElements.has(e) ||
                  (this._allowedElements.add(e),
                  this._dataInitialized && this._fireRegisterEvent(e),
                  (this._coupledAttributes = null));
            }
            allowAttributes(t) {
              this._allowedAttributes.add(t);
            }
            disallowAttributes(t) {
              this._disallowedAttributes.add(t);
            }
            _loadConfig(t, e) {
              for (const n of t) {
                const t = n.name || /[\s\S]+/;
                this.allowElement(t), jb(n).forEach(e);
              }
            }
            processViewAttributes(t, e) {
              return (
                Pb(t, e, this._disallowedAttributes),
                Pb(t, e, this._allowedAttributes)
              );
            }
            _registerElementsAfterInit() {
              this.editor.data.on(
                "init",
                () => {
                  this._dataInitialized = !0;
                  for (const t of this._allowedElements)
                    this._fireRegisterEvent(t);
                },
                { priority: s.get("highest") + 1 }
              );
            }
            _registerElementHandlers() {
              this.on(
                "register",
                (t, e) => {
                  const n = this.editor.model.schema;
                  if (e.isObject && !n.isRegistered(e.model))
                    this._registerObjectElement(e);
                  else if (e.isBlock) this._registerBlockElement(e);
                  else {
                    if (!e.isInline)
                      throw new c("data-filter-invalid-definition", null, e);
                    this._registerInlineElement(e);
                  }
                  t.stop();
                },
                { priority: "lowest" }
              );
            }
            _registerModelPostFixer() {
              const t = this.editor.model;
              t.document.registerPostFixer((e) => {
                const n = t.document.differ.getChanges();
                let i = !1;
                const o = this._getCoupledAttributesMap();
                for (const t of n) {
                  if ("attribute" != t.type || null !== t.attributeNewValue)
                    continue;
                  const n = o.get(t.attributeKey);
                  if (n)
                    for (const { item: o } of t.range.getWalker({
                      shallow: !0,
                    }))
                      for (const t of n)
                        o.hasAttribute(t) &&
                          (e.removeAttribute(t, o), (i = !0));
                }
                return i;
              });
            }
            _getCoupledAttributesMap() {
              if (this._coupledAttributes) return this._coupledAttributes;
              this._coupledAttributes = new Map();
              for (const t of this._allowedElements)
                if (t.coupledAttribute && t.model) {
                  const e = this._coupledAttributes.get(t.coupledAttribute);
                  e
                    ? e.push(t.model)
                    : this._coupledAttributes.set(t.coupledAttribute, [
                        t.model,
                      ]);
                }
            }
            _fireRegisterEvent(t) {
              this.fire(t.view ? `register:${t.view}` : "register", t);
            }
            _registerObjectElement(t) {
              const e = this.editor,
                n = e.model.schema,
                i = e.conversion,
                { view: o, model: r } = t;
              n.register(r, t.modelSchema),
                o &&
                  (n.extend(t.model, {
                    allowAttributes: ["htmlAttributes", "htmlContent"],
                  }),
                  e.data.registerRawContentMatcher({ name: o }),
                  i
                    .for("upcast")
                    .elementToElement({
                      view: o,
                      model: bb(t),
                      converterPriority: s.get("low") + 1,
                    }),
                  i.for("upcast").add(Cb(t, this)),
                  i
                    .for("editingDowncast")
                    .elementToStructure({
                      model: { name: r, attributes: ["htmlAttributes"] },
                      view: wb(e, t),
                    }),
                  i
                    .for("dataDowncast")
                    .elementToElement({
                      model: r,
                      view: (t, { writer: e }) => Ab(o, t, e),
                    }),
                  i.for("dataDowncast").add(vb(t)));
            }
            _registerBlockElement(t) {
              const e = this.editor,
                n = e.model.schema,
                i = e.conversion,
                { view: o, model: r } = t;
              if (!n.isRegistered(t.model)) {
                if ((n.register(t.model, t.modelSchema), !o)) return;
                i
                  .for("upcast")
                  .elementToElement({
                    model: r,
                    view: o,
                    converterPriority: s.get("low") + 1,
                  }),
                  i.for("downcast").elementToElement({ model: r, view: o });
              }
              o &&
                (n.extend(t.model, { allowAttributes: "htmlAttributes" }),
                i.for("upcast").add(Cb(t, this)),
                i.for("downcast").add(vb(t)));
            }
            _registerInlineElement(t) {
              const e = this.editor,
                n = e.model.schema,
                i = e.conversion,
                o = t.model;
              n.extend("$text", { allowAttributes: o }),
                t.attributeProperties &&
                  n.setAttributeProperties(o, t.attributeProperties),
                i.for("upcast").add(
                  (function ({ view: t, model: e }, n) {
                    return (i) => {
                      i.on(
                        `element:${t}`,
                        (t, i, o) => {
                          let r = n.processViewAttributes(i.viewItem, o);
                          if (
                            r ||
                            o.consumable.test(i.viewItem, { name: !0 })
                          ) {
                            (r = r || {}),
                              o.consumable.consume(i.viewItem, { name: !0 }),
                              i.modelRange ||
                                (i = Object.assign(
                                  i,
                                  o.convertChildren(i.viewItem, i.modelCursor)
                                ));
                            for (const t of i.modelRange.getItems())
                              if (o.schema.checkAttribute(t, e)) {
                                const n = kb(r, t.getAttribute(e) || {});
                                o.writer.setAttribute(e, n, t);
                              }
                          }
                        },
                        { priority: "low" }
                      );
                    };
                  })(t, this)
                ),
                i.for("downcast").attributeToElement({ model: o, view: _b(t) });
            }
          }
          function Pb(t, e, n) {
            const i = (function (t, { consumable: e }, n) {
                const i = n.matchAll(t) || [],
                  o = [];
                for (const n of i)
                  Lb(e, t, n),
                    delete n.match.name,
                    e.consume(t, n.match),
                    o.push(n);
                return o;
              })(t, e, n),
              {
                attributes: o,
                styles: r,
                classes: s,
              } = (function (t) {
                const e = {
                  attributes: new Set(),
                  classes: new Set(),
                  styles: new Set(),
                };
                for (const n of t)
                  for (const t in e) {
                    (n.match[t] || []).forEach((n) => e[t].add(n));
                  }
                return e;
              })(i),
              a = {};
            return (
              o.size && (a.attributes = Rb(o, (e) => t.getAttribute(e))),
              r.size && (a.styles = Rb(r, (e) => t.getStyle(e))),
              s.size && (a.classes = Array.from(s)),
              Object.keys(a).length ? a : null
            );
          }
          function Lb(t, e, n) {
            for (const i of ["attributes", "classes", "styles"]) {
              const o = n.match[i];
              if (o)
                for (const n of Array.from(o))
                  t.test(e, { [i]: [n] }) || Mb(o, n);
            }
          }
          function Rb(t, e) {
            const n = {};
            for (const i of t) {
              void 0 !== e(i) && (n[i] = e(i));
            }
            return n;
          }
          function Ob(t, e) {
            const { name: n } = t;
            return ye(t[e])
              ? Object.entries(t[e]).map(([t, i]) => ({
                  name: n,
                  [e]: { [t]: i },
                }))
              : Array.isArray(t[e])
              ? t[e].map((t) => ({ name: n, [e]: [t] }))
              : [t];
          }
          function jb(t) {
            const { name: e, attributes: n, classes: i, styles: o } = t,
              r = [];
            return (
              n && r.push(...Ob({ name: e, attributes: n }, "attributes")),
              i && r.push(...Ob({ name: e, classes: i }, "classes")),
              o && r.push(...Ob({ name: e, styles: o }, "styles")),
              r
            );
          }
          class Fb extends ue {
            static get requires() {
              return [zb];
            }
            static get pluginName() {
              return "CodeBlockElementSupport";
            }
            init() {
              if (!this.editor.plugins.has("CodeBlockEditing")) return;
              const t = this.editor.plugins.get(zb);
              t.on("register:pre", (e, n) => {
                if ("codeBlock" !== n.model) return;
                const i = this.editor,
                  o = i.model.schema,
                  r = i.conversion;
                o.extend("codeBlock", {
                  allowAttributes: ["htmlAttributes", "htmlContentAttributes"],
                }),
                  r.for("upcast").add(
                    (function (t) {
                      return (e) => {
                        e.on(
                          "element:code",
                          (e, n, i) => {
                            const o = n.viewItem,
                              r = o.parent;
                            function s(e, o) {
                              const r = t.processViewAttributes(e, i);
                              r && i.writer.setAttribute(o, r, n.modelRange);
                            }
                            r &&
                              r.is("element", "pre") &&
                              (s(r, "htmlAttributes"),
                              s(o, "htmlContentAttributes"));
                          },
                          { priority: "low" }
                        );
                      };
                    })(t)
                  ),
                  r.for("downcast").add((t) => {
                    t.on("attribute:htmlAttributes:codeBlock", (t, e, n) => {
                      if (!n.consumable.consume(e.item, t.name)) return;
                      const { attributeOldValue: i, attributeNewValue: o } = e,
                        r = n.mapper.toViewElement(e.item).parent;
                      pb(n.writer, i, o, r);
                    }),
                      t.on(
                        "attribute:htmlContentAttributes:codeBlock",
                        (t, e, n) => {
                          if (!n.consumable.consume(e.item, t.name)) return;
                          const { attributeOldValue: i, attributeNewValue: o } =
                              e,
                            r = n.mapper.toViewElement(e.item);
                          pb(n.writer, i, o, r);
                        }
                      );
                  }),
                  e.stop();
              });
            }
          }
          class Vb extends ue {
            static get requires() {
              return [zb];
            }
            static get pluginName() {
              return "DualContentModelElementSupport";
            }
            init() {
              this.editor.plugins.get(zb).on("register", (t, e) => {
                const n = this.editor,
                  i = n.model.schema,
                  o = n.conversion;
                if (!e.paragraphLikeModel) return;
                if (
                  i.isRegistered(e.model) ||
                  i.isRegistered(e.paragraphLikeModel)
                )
                  return;
                const r = { model: e.paragraphLikeModel, view: e.view };
                i.register(e.model, e.modelSchema),
                  i.register(r.model, { inheritAllFrom: "$block" }),
                  o
                    .for("upcast")
                    .elementToElement({
                      view: e.view,
                      model: (t, { writer: n }) =>
                        this._hasBlockContent(t)
                          ? n.createElement(e.model)
                          : n.createElement(r.model),
                      converterPriority: s.get("low") + 1,
                    }),
                  o
                    .for("downcast")
                    .elementToElement({ view: e.view, model: e.model }),
                  this._addAttributeConversion(e),
                  o
                    .for("downcast")
                    .elementToElement({ view: r.view, model: r.model }),
                  this._addAttributeConversion(r),
                  t.stop();
              });
            }
            _hasBlockContent(t) {
              const e = this.editor.editing.view,
                n = e.domConverter.blockElements;
              for (const i of e.createRangeIn(t).getItems())
                if (i.is("element") && n.includes(i.name)) return !0;
              return !1;
            }
            _addAttributeConversion(t) {
              const e = this.editor,
                n = e.conversion,
                i = e.plugins.get(zb);
              e.model.schema.extend(t.model, {
                allowAttributes: "htmlAttributes",
              }),
                n.for("upcast").add(Cb(t, i)),
                n.for("downcast").add(vb(t));
            }
          }
          class Hb extends ue {
            static get requires() {
              return [gb];
            }
            static get pluginName() {
              return "HeadingElementSupport";
            }
            init() {
              const t = this.editor;
              if (!t.plugins.has("HeadingEditing")) return;
              const e = t.plugins.get(gb),
                n = t.config.get("heading.options"),
                i = [];
              for (const t of n)
                "model" in t &&
                  "view" in t &&
                  (e.registerBlockElement({ view: t.view, model: t.model }),
                  i.push(t.model));
              e.extendBlockElement({
                model: "htmlHgroup",
                modelSchema: { allowChildren: i },
              });
            }
          }
          class Ub extends ue {
            static get requires() {
              return [zb];
            }
            static get pluginName() {
              return "ImageElementSupport";
            }
            init() {
              const t = this.editor;
              if (
                !t.plugins.has("ImageInlineEditing") &&
                !t.plugins.has("ImageBlockEditing")
              )
                return;
              const e = t.model.schema,
                n = t.conversion,
                i = t.plugins.get(zb);
              i.on("register:figure", () => {
                n.for("upcast").add(
                  (function (t) {
                    return (e) => {
                      e.on(
                        "element:figure",
                        (e, n, i) => {
                          const o = n.viewItem;
                          if (!n.modelRange || !o.hasClass("image")) return;
                          const r = t.processViewAttributes(o, i);
                          r &&
                            i.writer.setAttribute(
                              "htmlFigureAttributes",
                              r,
                              n.modelRange
                            );
                        },
                        { priority: "low" }
                      );
                    };
                  })(i)
                );
              }),
                i.on("register:img", (t, o) => {
                  ("imageBlock" !== o.model && "imageInline" !== o.model) ||
                    (e.isRegistered("imageBlock") &&
                      e.extend("imageBlock", {
                        allowAttributes: [
                          "htmlAttributes",
                          "htmlFigureAttributes",
                          "htmlLinkAttributes",
                        ],
                      }),
                    e.isRegistered("imageInline") &&
                      e.extend("imageInline", {
                        allowAttributes: ["htmlA", "htmlAttributes"],
                      }),
                    n.for("upcast").add(
                      (function (t) {
                        return (e) => {
                          e.on(
                            "element:img",
                            (e, n, i) => {
                              if (!n.modelRange) return;
                              const o = n.viewItem,
                                r = o.parent;
                              function s(e, o) {
                                const r = t.processViewAttributes(e, i);
                                r && i.writer.setAttribute(o, r, n.modelRange);
                              }
                              function a(t) {
                                n.modelRange &&
                                  n.modelRange
                                    .getContainedElement()
                                    .is("element", "imageBlock") &&
                                  s(t, "htmlLinkAttributes");
                              }
                              s(o, "htmlAttributes"),
                                r.is("element", "a") && a(r);
                            },
                            { priority: "low" }
                          );
                        };
                      })(i)
                    ),
                    n.for("downcast").add((t) => {
                      function e(e) {
                        t.on(
                          `attribute:${e}:imageInline`,
                          (t, e, n) => {
                            if (!n.consumable.consume(e.item, t.name)) return;
                            const {
                                attributeOldValue: i,
                                attributeNewValue: o,
                              } = e,
                              r = n.mapper.toViewElement(e.item);
                            pb(n.writer, i, o, r);
                          },
                          { priority: "low" }
                        );
                      }
                      function n(e, n) {
                        t.on(
                          `attribute:${n}:imageBlock`,
                          (t, n, i) => {
                            if (!i.consumable.test(n.item, t.name)) return;
                            const {
                                attributeOldValue: o,
                                attributeNewValue: r,
                              } = n,
                              s = i.mapper.toViewElement(n.item),
                              a = $b(i.writer, s, e);
                            a &&
                              (pb(i.writer, o, r, a),
                              i.consumable.consume(n.item, t.name));
                          },
                          { priority: "low" }
                        ),
                          "a" === e &&
                            t.on(
                              "attribute:linkHref:imageBlock",
                              (t, e, n) => {
                                if (
                                  !n.consumable.consume(
                                    e.item,
                                    "attribute:htmlLinkAttributes:imageBlock"
                                  )
                                )
                                  return;
                                const i = n.mapper.toViewElement(e.item),
                                  o = $b(n.writer, i, "a");
                                fb(
                                  n.writer,
                                  e.item.getAttribute("htmlLinkAttributes"),
                                  o
                                );
                              },
                              { priority: "low" }
                            );
                      }
                      e("htmlAttributes"),
                        n("img", "htmlAttributes"),
                        n("figure", "htmlFigureAttributes"),
                        n("a", "htmlLinkAttributes");
                    }),
                    t.stop());
                });
            }
          }
          function $b(t, e, n) {
            const i = t.createRangeOn(e);
            for (const { item: t } of i.getWalker())
              if (t.is("element", n)) return t;
          }
          class qb extends ue {
            static get requires() {
              return [zb];
            }
            static get pluginName() {
              return "MediaEmbedElementSupport";
            }
            init() {
              const t = this.editor;
              if (
                !t.plugins.has("MediaEmbed") ||
                t.config.get("mediaEmbed.previewsInData")
              )
                return;
              const e = t.model.schema,
                n = t.conversion,
                i = this.editor.plugins.get(zb),
                o = this.editor.plugins.get(gb),
                r = t.config.get("mediaEmbed.elementName");
              o.registerBlockElement({ model: "media", view: r }),
                i.on("register:figure", () => {
                  n.for("upcast").add(
                    (function (t) {
                      return (e) => {
                        e.on(
                          "element:figure",
                          (e, n, i) => {
                            const o = n.viewItem;
                            if (!n.modelRange || !o.hasClass("media")) return;
                            const r = t.processViewAttributes(o, i);
                            r &&
                              i.writer.setAttribute(
                                "htmlFigureAttributes",
                                r,
                                n.modelRange
                              );
                          },
                          { priority: "low" }
                        );
                      };
                    })(i)
                  );
                }),
                i.on(`register:${r}`, (t, o) => {
                  "media" === o.model &&
                    (e.extend("media", {
                      allowAttributes: [
                        "htmlAttributes",
                        "htmlFigureAttributes",
                      ],
                    }),
                    n.for("upcast").add(
                      (function (t, e) {
                        return (t) => {
                          t.on(`element:${e}`, n);
                        };
                        function n(e, n, i) {
                          function o(e, o) {
                            const r = t.processViewAttributes(e, i);
                            r && i.writer.setAttribute(o, r, n.modelRange);
                          }
                          o(n.viewItem, "htmlAttributes");
                        }
                      })(i, r)
                    ),
                    n.for("dataDowncast").add(
                      (function (t) {
                        return (e) => {
                          function n(t, n) {
                            e.on(`attribute:${n}:media`, (e, n, i) => {
                              if (!i.consumable.consume(n.item, e.name)) return;
                              const {
                                  attributeOldValue: o,
                                  attributeNewValue: r,
                                } = n,
                                s = i.mapper.toViewElement(n.item),
                                a = (function (t, e, n) {
                                  const i = t.createRangeOn(e);
                                  for (const { item: t } of i.getWalker())
                                    if (t.is("element", n)) return t;
                                })(i.writer, s, t);
                              pb(i.writer, o, r, a);
                            });
                          }
                          n(t, "htmlAttributes"),
                            n("figure", "htmlFigureAttributes");
                        };
                      })(r)
                    ),
                    t.stop());
                });
            }
          }
          class Gb extends ue {
            static get requires() {
              return [zb];
            }
            static get pluginName() {
              return "ScriptElementSupport";
            }
            init() {
              const t = this.editor.plugins.get(zb);
              t.on("register:script", (e, n) => {
                const i = this.editor,
                  o = i.model.schema,
                  r = i.conversion;
                o.register("htmlScript", n.modelSchema),
                  o.extend("htmlScript", {
                    allowAttributes: ["htmlAttributes", "htmlContent"],
                    isContent: !0,
                  }),
                  i.data.registerRawContentMatcher({ name: "script" }),
                  r
                    .for("upcast")
                    .elementToElement({ view: "script", model: bb(n) }),
                  r.for("upcast").add(Cb(n, t)),
                  r
                    .for("downcast")
                    .elementToElement({
                      model: "htmlScript",
                      view: (t, { writer: e }) => Ab("script", t, e),
                    }),
                  r.for("downcast").add(vb(n)),
                  e.stop();
              });
            }
          }
          class Wb extends ue {
            static get requires() {
              return [zb];
            }
            static get pluginName() {
              return "TableElementSupport";
            }
            init() {
              const t = this.editor;
              if (!t.plugins.has("TableEditing")) return;
              const e = t.model.schema,
                n = t.conversion,
                i = t.plugins.get(zb);
              i.on("register:figure", () => {
                n.for("upcast").add(
                  (function (t) {
                    return (e) => {
                      e.on(
                        "element:figure",
                        (e, n, i) => {
                          const o = n.viewItem;
                          if (!n.modelRange || !o.hasClass("table")) return;
                          const r = t.processViewAttributes(o, i);
                          r &&
                            i.writer.setAttribute(
                              "htmlFigureAttributes",
                              r,
                              n.modelRange
                            );
                        },
                        { priority: "low" }
                      );
                    };
                  })(i)
                );
              }),
                i.on("register:table", (t, o) => {
                  "table" === o.model &&
                    (e.extend("table", {
                      allowAttributes: [
                        "htmlAttributes",
                        "htmlFigureAttributes",
                        "htmlTheadAttributes",
                        "htmlTbodyAttributes",
                      ],
                    }),
                    n.for("upcast").add(
                      (function (t) {
                        return (e) => {
                          e.on("element:table", (e, n, i) => {
                            const o = n.viewItem;
                            r(o, "htmlAttributes");
                            for (const t of o.getChildren())
                              t.is("element", "thead") &&
                                r(t, "htmlTheadAttributes"),
                                t.is("element", "tbody") &&
                                  r(t, "htmlTbodyAttributes");
                            function r(e, o) {
                              const r = t.processViewAttributes(e, i);
                              r && i.writer.setAttribute(o, r, n.modelRange);
                            }
                          });
                        };
                      })(i)
                    ),
                    n.for("downcast").add((t) => {
                      function e(e, n) {
                        t.on(`attribute:${n}:table`, (t, n, i) => {
                          if (!i.consumable.consume(n.item, t.name)) return;
                          const o = i.mapper.toViewElement(n.item),
                            r = (function (t, e, n) {
                              const i = t.createRangeOn(e);
                              for (const { item: t } of i.getWalker())
                                if (t.is("element", n)) return t;
                            })(i.writer, o, e);
                          fb(i.writer, n.attributeNewValue, r);
                        });
                      }
                      e("table", "htmlAttributes"),
                        e("figure", "htmlFigureAttributes"),
                        e("thead", "htmlTheadAttributes"),
                        e("tbody", "htmlTbodyAttributes");
                    }),
                    t.stop());
                });
            }
          }
          class Yb extends ue {
            static get requires() {
              return [zb];
            }
            static get pluginName() {
              return "StyleElementSupport";
            }
            init() {
              const t = this.editor.plugins.get(zb);
              t.on("register:style", (e, n) => {
                const i = this.editor,
                  o = i.model.schema,
                  r = i.conversion;
                o.register("htmlStyle", n.modelSchema),
                  o.extend("htmlStyle", {
                    allowAttributes: ["htmlAttributes", "htmlContent"],
                    isContent: !0,
                  }),
                  i.data.registerRawContentMatcher({ name: "style" }),
                  r
                    .for("upcast")
                    .elementToElement({ view: "style", model: bb(n) }),
                  r.for("upcast").add(Cb(n, t)),
                  r
                    .for("downcast")
                    .elementToElement({
                      model: "htmlStyle",
                      view: (t, { writer: e }) => Ab("style", t, e),
                    }),
                  r.for("downcast").add(vb(n)),
                  e.stop();
              });
            }
          }
          class Kb extends ue {
            static get requires() {
              return [zb];
            }
            static get pluginName() {
              return "DocumentListElementSupport";
            }
            init() {
              const t = this.editor;
              if (!t.plugins.has("DocumentListEditing")) return;
              const e = t.model.schema,
                n = t.conversion,
                i = t.plugins.get(zb),
                o = t.plugins.get("DocumentListEditing");
              o.registerDowncastStrategy({
                scope: "item",
                attributeName: "htmlLiAttributes",
                setAttributeOnDowncast(t, e, n) {
                  fb(t, e, n);
                },
              }),
                o.registerDowncastStrategy({
                  scope: "list",
                  attributeName: "htmlListAttributes",
                  setAttributeOnDowncast(t, e, n) {
                    fb(t, e, n);
                  },
                }),
                i.on("register", (t, o) => {
                  ["ul", "ol", "li"].includes(o.view) &&
                    (t.stop(),
                    e.checkAttribute("$block", "htmlListAttributes") ||
                      (e.extend("$block", {
                        allowAttributes: [
                          "htmlListAttributes",
                          "htmlLiAttributes",
                        ],
                      }),
                      e.extend("$blockObject", {
                        allowAttributes: [
                          "htmlListAttributes",
                          "htmlLiAttributes",
                        ],
                      }),
                      e.extend("$container", {
                        allowAttributes: [
                          "htmlListAttributes",
                          "htmlLiAttributes",
                        ],
                      }),
                      n.for("upcast").add((t) => {
                        t.on("element:ul", Qb("htmlListAttributes", i), {
                          priority: "low",
                        }),
                          t.on("element:ol", Qb("htmlListAttributes", i), {
                            priority: "low",
                          }),
                          t.on("element:li", Qb("htmlLiAttributes", i), {
                            priority: "low",
                          });
                      })));
                }),
                o.on("postFixer", (t, { listNodes: e, writer: n }) => {
                  const i = [];
                  for (const { node: o, previous: r } of e) {
                    if (!r) continue;
                    const e = o.getAttribute("listIndent"),
                      s = r.getAttribute("listIndent");
                    let a = null;
                    if (
                      (e > s
                        ? (i[s] = r)
                        : e < s
                        ? ((a = i[e]), (i.length = e))
                        : (a = r),
                      a)
                    ) {
                      if (
                        a.getAttribute("listType") == o.getAttribute("listType")
                      ) {
                        const e = a.getAttribute("htmlListAttributes");
                        Cl(o.getAttribute("htmlListAttributes"), e) ||
                          (n.setAttribute("htmlListAttributes", e, o),
                          (t.return = !0));
                      }
                      if (
                        a.getAttribute("listItemId") ==
                        o.getAttribute("listItemId")
                      ) {
                        const e = a.getAttribute("htmlLiAttributes");
                        Cl(o.getAttribute("htmlLiAttributes"), e) ||
                          (n.setAttribute("htmlLiAttributes", e, o),
                          (t.return = !0));
                      }
                    }
                  }
                });
            }
            afterInit() {
              const t = this.editor;
              t.commands.get("indentList") &&
                this.listenTo(
                  t.commands.get("indentList"),
                  "afterExecute",
                  (e, n) => {
                    t.model.change((t) => {
                      for (const e of n)
                        t.setAttribute("htmlListAttributes", {}, e);
                    });
                  }
                );
            }
          }
          function Qb(t, e) {
            return (n, i, o) => {
              const r = i.viewItem;
              i.modelRange ||
                Object.assign(i, o.convertChildren(i.viewItem, i.modelCursor));
              const s = e.processViewAttributes(r, o);
              for (const e of i.modelRange.getItems({ shallow: !0 }))
                e.hasAttribute("listItemId") &&
                  (e.hasAttribute(t) || o.writer.setAttribute(t, s || {}, e));
            };
          }
          class Zb extends ue {
            static get requires() {
              return [zb, gb];
            }
            static get pluginName() {
              return "CustomElementSupport";
            }
            init() {
              const t = this.editor.plugins.get(zb),
                e = this.editor.plugins.get(gb);
              t.on("register:$customElement", (n, i) => {
                n.stop();
                const o = this.editor,
                  r = o.model.schema,
                  s = o.conversion,
                  a = o.editing.view.domConverter.unsafeElements,
                  c = o.data.htmlProcessor.domConverter.preElements;
                r.register(i.model, i.modelSchema),
                  r.extend(i.model, {
                    allowAttributes: [
                      "htmlElementName",
                      "htmlAttributes",
                      "htmlContent",
                    ],
                    isContent: !0,
                  }),
                  s.for("upcast").elementToElement({
                    view: /.*/,
                    model: (n, r) => {
                      if ("$comment" == n.name) return;
                      if (e.getDefinitionsForView(n.name).size) return;
                      a.includes(n.name) || a.push(n.name),
                        c.includes(n.name) || c.push(n.name);
                      const s = r.writer.createElement(i.model, {
                          htmlElementName: n.name,
                        }),
                        l = t.processViewAttributes(n, r);
                      l && r.writer.setAttribute("htmlAttributes", l, s);
                      const d = new bm(n.document).createDocumentFragment(n),
                        h = o.data.processor.toData(d);
                      r.writer.setAttribute("htmlContent", h, s);
                      for (const { item: t } of o.editing.view.createRangeIn(n))
                        r.consumable.consume(t, { name: !0 });
                      return s;
                    },
                    converterPriority: "low",
                  }),
                  s.for("editingDowncast").elementToElement({
                    model: {
                      name: i.model,
                      attributes: [
                        "htmlElementName",
                        "htmlAttributes",
                        "htmlContent",
                      ],
                    },
                    view: (t, { writer: e }) => {
                      const n = t.getAttribute("htmlElementName"),
                        i = e.createRawElement(n);
                      return (
                        t.hasAttribute("htmlAttributes") &&
                          fb(e, t.getAttribute("htmlAttributes"), i),
                        i
                      );
                    },
                  }),
                  s.for("dataDowncast").elementToElement({
                    model: {
                      name: i.model,
                      attributes: [
                        "htmlElementName",
                        "htmlAttributes",
                        "htmlContent",
                      ],
                    },
                    view: (t, { writer: e }) => {
                      const n = t.getAttribute("htmlElementName"),
                        i = t.getAttribute("htmlContent"),
                        o = e.createRawElement(n, null, (t, e) => {
                          e.setContentOf(t, i);
                          const n = t.firstChild;
                          for (n.remove(); n.firstChild; )
                            t.appendChild(n.firstChild);
                        });
                      return (
                        t.hasAttribute("htmlAttributes") &&
                          fb(e, t.getAttribute("htmlAttributes"), o),
                        o
                      );
                    },
                  });
              });
            }
          }
          function* Jb(t, e, n) {
            if (e.is("documentSelection") && e.isCollapsed)
              t.schema.checkAttributeInSelection(e, n) && (yield e);
            else
              for (const i of (function (t, e, n) {
                return e.is("node") || e.is("$text") || e.is("$textProxy")
                  ? t.schema.checkAttribute(e, n)
                    ? [t.createRangeOn(e)]
                    : []
                  : t.schema.getValidRanges(
                      t.createSelection(e).getRanges(),
                      n
                    );
              })(t, e, n))
                yield* i.getItems({ shallow: !0 });
          }
          function Xb(t, e, n, i, o) {
            const r = e.getAttribute(n),
              s = {};
            for (const t of ["attributes", "styles", "classes"])
              if (t != i) r && r[t] && (s[t] = r[t]);
              else {
                const e =
                  "classes" == t
                    ? new Set((r && r[t]) || [])
                    : new Map(Object.entries((r && r[t]) || {}));
                o(e),
                  e.size &&
                    (s[t] =
                      "classes" == t ? Array.from(e) : Object.fromEntries(e));
              }
            Object.keys(s).length
              ? e.is("documentSelection")
                ? t.setSelectionAttribute(n, s)
                : t.setAttribute(n, s, e)
              : r &&
                (e.is("documentSelection")
                  ? t.removeSelectionAttribute(n)
                  : t.removeAttribute(n, e));
          }
          class tw extends ge {
            refresh() {
              const t = this.editor.model,
                e = Na(t.document.selection.getSelectedBlocks());
              (this.value = !!e && e.is("element", "paragraph")),
                (this.isEnabled = !!e && ew(e, t.schema));
            }
            execute(t = {}) {
              const e = this.editor.model,
                n = e.document;
              e.change((i) => {
                const o = (t.selection || n.selection).getSelectedBlocks();
                for (const t of o)
                  !t.is("element", "paragraph") &&
                    ew(t, e.schema) &&
                    i.rename(t, "paragraph");
              });
            }
          }
          function ew(t, e) {
            return e.checkChild(t.parent, "paragraph") && !e.isObject(t);
          }
          class nw extends ge {
            execute(t) {
              const e = this.editor.model,
                n = t.attributes;
              let i = t.position;
              e.change((t) => {
                const o = t.createElement("paragraph");
                if (
                  (n && e.schema.setAllowedAttributes(o, n, t),
                  !e.schema.checkChild(i.parent, o))
                ) {
                  const n = e.schema.findAllowedParent(i, o);
                  if (!n) return;
                  i = t.split(i, n).position;
                }
                e.insertContent(o, i), t.setSelection(o, "in");
              });
            }
          }
          class iw extends ue {
            static get pluginName() {
              return "Paragraph";
            }
            init() {
              const t = this.editor,
                e = t.model;
              t.commands.add("paragraph", new tw(t)),
                t.commands.add("insertParagraph", new nw(t)),
                e.schema.register("paragraph", { inheritAllFrom: "$block" }),
                t.conversion.elementToElement({
                  model: "paragraph",
                  view: "p",
                }),
                t.conversion
                  .for("upcast")
                  .elementToElement({
                    model: (t, { writer: e }) =>
                      iw.paragraphLikeElements.has(t.name)
                        ? t.isEmpty
                          ? null
                          : e.createElement("paragraph")
                        : null,
                    view: /.+/,
                    converterPriority: "low",
                  });
            }
          }
          iw.paragraphLikeElements = new Set([
            "blockquote",
            "dd",
            "div",
            "dt",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "li",
            "p",
            "td",
            "th",
          ]);
          class ow extends ge {
            constructor(t, e) {
              super(t), (this.modelElements = e);
            }
            refresh() {
              const t = Na(
                this.editor.model.document.selection.getSelectedBlocks()
              );
              (this.value =
                !!t && this.modelElements.includes(t.name) && t.name),
                (this.isEnabled =
                  !!t &&
                  this.modelElements.some((e) =>
                    rw(t, e, this.editor.model.schema)
                  ));
            }
            execute(t) {
              const e = this.editor.model,
                n = e.document,
                i = t.value;
              e.change((t) => {
                const o = Array.from(n.selection.getSelectedBlocks()).filter(
                  (t) => rw(t, i, e.schema)
                );
                for (const e of o) e.is("element", i) || t.rename(e, i);
              });
            }
          }
          function rw(t, e, n) {
            return n.checkChild(t.parent, e) && !n.isObject(t);
          }
          const sw = "paragraph";
          class aw extends ue {
            static get pluginName() {
              return "HeadingEditing";
            }
            constructor(t) {
              super(t),
                t.config.define("heading", {
                  options: [
                    {
                      model: "paragraph",
                      title: "Paragraph",
                      class: "ck-heading_paragraph",
                    },
                    {
                      model: "heading1",
                      view: "h2",
                      title: "Heading 1",
                      class: "ck-heading_heading1",
                    },
                    {
                      model: "heading2",
                      view: "h3",
                      title: "Heading 2",
                      class: "ck-heading_heading2",
                    },
                    {
                      model: "heading3",
                      view: "h4",
                      title: "Heading 3",
                      class: "ck-heading_heading3",
                    },
                  ],
                });
            }
            static get requires() {
              return [iw];
            }
            init() {
              const t = this.editor,
                e = t.config.get("heading.options"),
                n = [];
              for (const i of e)
                i.model !== sw &&
                  (t.model.schema.register(i.model, {
                    inheritAllFrom: "$block",
                  }),
                  t.conversion.elementToElement(i),
                  n.push(i.model));
              this._addDefaultH1Conversion(t),
                t.commands.add("heading", new ow(t, n));
            }
            afterInit() {
              const t = this.editor,
                e = t.commands.get("enter"),
                n = t.config.get("heading.options");
              e &&
                this.listenTo(e, "afterExecute", (e, i) => {
                  const o =
                    t.model.document.selection.getFirstPosition().parent;
                  n.some((t) => o.is("element", t.model)) &&
                    !o.is("element", sw) &&
                    0 === o.childCount &&
                    i.writer.rename(o, sw);
                });
            }
            _addDefaultH1Conversion(t) {
              t.conversion
                .for("upcast")
                .elementToElement({
                  model: "heading1",
                  view: "h1",
                  converterPriority: s.get("low") + 1,
                });
            }
          }
          var cw = n(3230),
            lw = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(cw.Z, lw);
          cw.Z.locals;
          class dw extends ue {
            static get pluginName() {
              return "HeadingUI";
            }
            init() {
              const t = this.editor,
                e = t.t,
                n = (function (t) {
                  const e = t.t,
                    n = {
                      Paragraph: e("Paragraph"),
                      "Heading 1": e("Heading 1"),
                      "Heading 2": e("Heading 2"),
                      "Heading 3": e("Heading 3"),
                      "Heading 4": e("Heading 4"),
                      "Heading 5": e("Heading 5"),
                      "Heading 6": e("Heading 6"),
                    };
                  return t.config.get("heading.options").map((t) => {
                    const e = n[t.title];
                    return e && e != t.title && (t.title = e), t;
                  });
                })(t),
                i = e("Choose heading"),
                o = e("Heading");
              t.ui.componentFactory.add("heading", (e) => {
                const r = {},
                  s = new Di(),
                  a = t.commands.get("heading"),
                  c = t.commands.get("paragraph"),
                  l = [a];
                for (const t of n) {
                  const e = {
                    type: "button",
                    model: new Su({
                      label: t.title,
                      class: t.class,
                      withText: !0,
                    }),
                  };
                  "paragraph" === t.model
                    ? (e.model.bind("isOn").to(c, "value"),
                      e.model.set("commandName", "paragraph"),
                      l.push(c))
                    : (e.model
                        .bind("isOn")
                        .to(a, "value", (e) => e === t.model),
                      e.model.set({
                        commandName: "heading",
                        commandValue: t.model,
                      })),
                    s.add(e),
                    (r[t.model] = t.title);
                }
                const d = ou(e);
                return (
                  su(d, s),
                  d.buttonView.set({ isOn: !1, withText: !0, tooltip: o }),
                  d.extendTemplate({
                    attributes: { class: ["ck-heading-dropdown"] },
                  }),
                  d
                    .bind("isEnabled")
                    .toMany(l, "isEnabled", (...t) => t.some((t) => t)),
                  d.buttonView
                    .bind("label")
                    .to(a, "value", c, "value", (t, e) => {
                      const n = t || (e && "paragraph");
                      return r[n] ? r[n] : i;
                    }),
                  this.listenTo(d, "execute", (e) => {
                    t.execute(
                      e.source.commandName,
                      e.source.commandValue
                        ? { value: e.source.commandValue }
                        : void 0
                    ),
                      t.editing.view.focus();
                  }),
                  d
                );
              });
            }
          }
          class hw extends ge {
            refresh() {
              const t = this.editor.model,
                e = t.schema,
                n = t.document.selection;
              this.isEnabled = (function (t, e, n) {
                const i = (function (t, e) {
                  const n = Jg(t, e).start.parent;
                  if (n.isEmpty && !n.is("element", "$root")) return n.parent;
                  return n;
                })(t, n);
                return e.checkChild(i, "horizontalLine");
              })(n, e, t);
            }
            execute() {
              const t = this.editor.model;
              t.change((e) => {
                const n = e.createElement("horizontalLine");
                t.insertObject(n, null, null, { setSelection: "after" });
              });
            }
          }
          var uw = n(2536),
            mw = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(uw.Z, mw);
          uw.Z.locals;
          class gw extends ue {
            static get pluginName() {
              return "HorizontalLineEditing";
            }
            init() {
              const t = this.editor,
                e = t.model.schema,
                n = t.t,
                i = t.conversion;
              e.register("horizontalLine", { inheritAllFrom: "$blockObject" }),
                i
                  .for("dataDowncast")
                  .elementToElement({
                    model: "horizontalLine",
                    view: (t, { writer: e }) => e.createEmptyElement("hr"),
                  }),
                i.for("editingDowncast").elementToStructure({
                  model: "horizontalLine",
                  view: (t, { writer: e }) => {
                    const i = n("Horizontal line"),
                      o = e.createContainerElement(
                        "div",
                        null,
                        e.createEmptyElement("hr")
                      );
                    return (
                      e.addClass("ck-horizontal-line", o),
                      e.setCustomProperty("hr", !0, o),
                      (function (t, e, n) {
                        return (
                          e.setCustomProperty("horizontalLine", !0, t),
                          Gg(t, e, { label: n })
                        );
                      })(o, e, i)
                    );
                  },
                }),
                i
                  .for("upcast")
                  .elementToElement({ view: "hr", model: "horizontalLine" }),
                t.commands.add("horizontalLine", new hw(t));
            }
          }
          class pw extends ue {
            static get pluginName() {
              return "HorizontalLineUI";
            }
            init() {
              const t = this.editor,
                e = t.t;
              t.ui.componentFactory.add("horizontalLine", (n) => {
                const i = t.commands.get("horizontalLine"),
                  o = new kh(n);
                return (
                  o.set({
                    label: e("Horizontal line"),
                    icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 9h16v2H2z"/></svg>',
                    tooltip: !0,
                  }),
                  o.bind("isEnabled").to(i, "isEnabled"),
                  this.listenTo(o, "execute", () => {
                    t.execute("horizontalLine"), t.editing.view.focus();
                  }),
                  o
                );
              });
            }
          }
          class fw extends ge {
            refresh() {
              const t = this.editor.plugins
                .get("ImageUtils")
                .getClosestSelectedImageElement(
                  this.editor.model.document.selection
                );
              (this.isEnabled = !!t),
                this.isEnabled && t.hasAttribute("alt")
                  ? (this.value = t.getAttribute("alt"))
                  : (this.value = !1);
            }
            execute(t) {
              const e = this.editor,
                n = e.plugins.get("ImageUtils"),
                i = e.model,
                o = n.getClosestSelectedImageElement(i.document.selection);
              i.change((e) => {
                e.setAttribute("alt", t.newValue, o);
              });
            }
          }
          class kw extends ue {
            static get requires() {
              return [Yp];
            }
            static get pluginName() {
              return "ImageTextAlternativeEditing";
            }
            init() {
              this.editor.commands.add(
                "imageTextAlternative",
                new fw(this.editor)
              );
            }
          }
          var bw = n(6831),
            ww = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(bw.Z, ww);
          bw.Z.locals;
          class Aw extends Vd {
            constructor(t) {
              super(t);
              const e = this.locale.t;
              (this.focusTracker = new za()),
                (this.keystrokes = new Pa()),
                (this.labeledInput = this._createLabeledInputView()),
                (this.saveButtonView = this._createButton(
                  e("Save"),
                  zd.check,
                  "ck-button-save"
                )),
                (this.saveButtonView.type = "submit"),
                (this.cancelButtonView = this._createButton(
                  e("Cancel"),
                  zd.cancel,
                  "ck-button-cancel",
                  "cancel"
                )),
                (this._focusables = new Od()),
                (this._focusCycler = new vh({
                  focusables: this._focusables,
                  focusTracker: this.focusTracker,
                  keystrokeHandler: this.keystrokes,
                  actions: { focusPrevious: "shift + tab", focusNext: "tab" },
                })),
                this.setTemplate({
                  tag: "form",
                  attributes: {
                    class: [
                      "ck",
                      "ck-text-alternative-form",
                      "ck-responsive-form",
                    ],
                    tabindex: "-1",
                  },
                  children: [
                    this.labeledInput,
                    this.saveButtonView,
                    this.cancelButtonView,
                  ],
                }),
                Ld(this);
            }
            render() {
              super.render(),
                this.keystrokes.listenTo(this.element),
                Rd({ view: this }),
                [
                  this.labeledInput,
                  this.saveButtonView,
                  this.cancelButtonView,
                ].forEach((t) => {
                  this._focusables.add(t), this.focusTracker.add(t.element);
                });
            }
            destroy() {
              super.destroy(),
                this.focusTracker.destroy(),
                this.keystrokes.destroy();
            }
            _createButton(t, e, n, i) {
              const o = new kh(this.locale);
              return (
                o.set({ label: t, icon: e, tooltip: !0 }),
                o.extendTemplate({ attributes: { class: n } }),
                i && o.delegate("execute").to(this, i),
                o
              );
            }
            _createLabeledInputView() {
              const t = this.locale.t,
                e = new xu(this.locale, Eu);
              return (e.label = t("Text alternative")), e;
            }
          }
          function _w(t) {
            const e = t.editing.view,
              n = zu.defaultPositions,
              i = t.plugins.get("ImageUtils");
            return {
              target: e.domConverter.viewToDom(
                i.getClosestSelectedImageWidget(e.document.selection)
              ),
              positions: [
                n.northArrowSouth,
                n.northArrowSouthWest,
                n.northArrowSouthEast,
                n.southArrowNorth,
                n.southArrowNorthWest,
                n.southArrowNorthEast,
                n.viewportStickyNorth,
              ],
            };
          }
          class Cw extends ue {
            static get requires() {
              return [Hu];
            }
            static get pluginName() {
              return "ImageTextAlternativeUI";
            }
            init() {
              this._createButton(), this._createForm();
            }
            destroy() {
              super.destroy(), this._form.destroy();
            }
            _createButton() {
              const t = this.editor,
                e = t.t;
              t.ui.componentFactory.add("imageTextAlternative", (n) => {
                const i = t.commands.get("imageTextAlternative"),
                  o = new kh(n);
                return (
                  o.set({
                    label: e("Change image text alternative"),
                    icon: zd.lowVision,
                    tooltip: !0,
                  }),
                  o.bind("isEnabled").to(i, "isEnabled"),
                  this.listenTo(o, "execute", () => {
                    this._showForm();
                  }),
                  o
                );
              });
            }
            _createForm() {
              const t = this.editor,
                e = t.editing.view.document,
                n = t.plugins.get("ImageUtils");
              (this._balloon = this.editor.plugins.get("ContextualBalloon")),
                (this._form = new Aw(t.locale)),
                this._form.render(),
                this.listenTo(this._form, "submit", () => {
                  t.execute("imageTextAlternative", {
                    newValue: this._form.labeledInput.fieldView.element.value,
                  }),
                    this._hideForm(!0);
                }),
                this.listenTo(this._form, "cancel", () => {
                  this._hideForm(!0);
                }),
                this._form.keystrokes.set("Esc", (t, e) => {
                  this._hideForm(!0), e();
                }),
                this.listenTo(t.ui, "update", () => {
                  n.getClosestSelectedImageWidget(e.selection)
                    ? this._isVisible &&
                      (function (t) {
                        const e = t.plugins.get("ContextualBalloon");
                        if (
                          t.plugins
                            .get("ImageUtils")
                            .getClosestSelectedImageWidget(
                              t.editing.view.document.selection
                            )
                        ) {
                          const n = _w(t);
                          e.updatePosition(n);
                        }
                      })(t)
                    : this._hideForm(!0);
                }),
                Pd({
                  emitter: this._form,
                  activator: () => this._isVisible,
                  contextElements: [this._balloon.view.element],
                  callback: () => this._hideForm(),
                });
            }
            _showForm() {
              if (this._isVisible) return;
              const t = this.editor,
                e = t.commands.get("imageTextAlternative"),
                n = this._form.labeledInput;
              this._form.disableCssTransitions(),
                this._isInBalloon ||
                  this._balloon.add({ view: this._form, position: _w(t) }),
                (n.fieldView.value = n.fieldView.element.value = e.value || ""),
                this._form.labeledInput.fieldView.select(),
                this._form.enableCssTransitions();
            }
            _hideForm(t) {
              this._isInBalloon &&
                (this._form.focusTracker.isFocused &&
                  this._form.saveButtonView.focus(),
                this._balloon.remove(this._form),
                t && this.editor.editing.view.focus());
            }
            get _isVisible() {
              return this._balloon.visibleView === this._form;
            }
            get _isInBalloon() {
              return this._balloon.hasView(this._form);
            }
          }
          class vw extends ue {
            static get requires() {
              return [kw, Cw];
            }
            static get pluginName() {
              return "ImageTextAlternative";
            }
          }
          function yw(t, e) {
            return (t) => {
              t.on(`attribute:srcset:${e}`, n);
            };
            function n(e, n, i) {
              if (!i.consumable.consume(n.item, e.name)) return;
              const o = i.writer,
                r = i.mapper.toViewElement(n.item),
                s = t.findViewImgElement(r);
              if (null === n.attributeNewValue) {
                const t = n.attributeOldValue;
                t.data &&
                  (o.removeAttribute("srcset", s),
                  o.removeAttribute("sizes", s),
                  t.width && o.removeAttribute("width", s));
              } else {
                const t = n.attributeNewValue;
                t.data &&
                  (o.setAttribute("srcset", t.data, s),
                  o.setAttribute("sizes", "100vw", s),
                  t.width && o.setAttribute("width", t.width, s));
              }
            }
          }
          function xw(t, e, n) {
            return (t) => {
              t.on(`attribute:${n}:${e}`, i);
            };
            function i(e, n, i) {
              if (!i.consumable.consume(n.item, e.name)) return;
              const o = i.writer,
                r = i.mapper.toViewElement(n.item),
                s = t.findViewImgElement(r);
              o.setAttribute(n.attributeKey, n.attributeNewValue || "", s);
            }
          }
          class Ew extends _s {
            observe(t) {
              this.listenTo(
                t,
                "load",
                (t, e) => {
                  const n = e.target;
                  this.checkShouldIgnoreEventFromTarget(n) ||
                    ("IMG" == n.tagName && this._fireEvents(e));
                },
                { useCapture: !0 }
              );
            }
            _fireEvents(t) {
              this.isEnabled &&
                (this.document.fire("layoutChanged"),
                this.document.fire("imageLoaded", t));
            }
          }
          class Dw extends ge {
            constructor(t) {
              super(t);
              const e = t.config.get("image.insert.type");
              t.plugins.has("ImageBlockEditing") ||
                ("block" === e && l("image-block-plugin-required")),
                t.plugins.has("ImageInlineEditing") ||
                  ("inline" === e && l("image-inline-plugin-required"));
            }
            refresh() {
              this.isEnabled = this.editor.plugins
                .get("ImageUtils")
                .isImageAllowed();
            }
            execute(t) {
              const e = Ii(t.source),
                n = this.editor.model.document.selection,
                i = this.editor.plugins.get("ImageUtils"),
                o = Object.fromEntries(n.getAttributes());
              e.forEach((t, e) => {
                const r = n.getSelectedElement();
                if (
                  ("string" == typeof t && (t = { src: t }),
                  e && r && i.isImage(r))
                ) {
                  const e = this.editor.model.createPositionAfter(r);
                  i.insertImage({ ...t, ...o }, e);
                } else i.insertImage({ ...t, ...o });
              });
            }
          }
          class Sw extends ue {
            static get requires() {
              return [Yp];
            }
            static get pluginName() {
              return "ImageEditing";
            }
            init() {
              const t = this.editor,
                e = t.conversion;
              t.editing.view.addObserver(Ew),
                e
                  .for("upcast")
                  .attributeToAttribute({
                    view: { name: "img", key: "alt" },
                    model: "alt",
                  })
                  .attributeToAttribute({
                    view: { name: "img", key: "srcset" },
                    model: {
                      key: "srcset",
                      value: (t) => {
                        const e = { data: t.getAttribute("srcset") };
                        return (
                          t.hasAttribute("width") &&
                            (e.width = t.getAttribute("width")),
                          e
                        );
                      },
                    },
                  });
              const n = new Dw(t);
              t.commands.add("insertImage", n),
                t.commands.add("imageInsert", n);
            }
          }
          class Iw extends ge {
            constructor(t, e) {
              super(t), (this._modelElementName = e);
            }
            refresh() {
              const t = this.editor.plugins.get("ImageUtils"),
                e = t.getClosestSelectedImageElement(
                  this.editor.model.document.selection
                );
              "imageBlock" === this._modelElementName
                ? (this.isEnabled = t.isInlineImage(e))
                : (this.isEnabled = t.isBlockImage(e));
            }
            execute() {
              const t = this.editor,
                e = this.editor.model,
                n = t.plugins.get("ImageUtils"),
                i = n.getClosestSelectedImageElement(e.document.selection),
                o = Object.fromEntries(i.getAttributes());
              return o.src || o.uploadId
                ? e.change((t) => {
                    const r = Array.from(e.markers).filter((t) =>
                        t.getRange().containsItem(i)
                      ),
                      s = n.insertImage(
                        o,
                        e.createSelection(i, "on"),
                        this._modelElementName
                      );
                    if (!s) return null;
                    const a = t.createRangeOn(s);
                    for (const e of r) {
                      const n = e.getRange(),
                        i =
                          "$graveyard" != n.root.rootName
                            ? n.getJoined(a, !0)
                            : a;
                      t.updateMarker(e, { range: i });
                    }
                    return { oldElement: i, newElement: s };
                  })
                : null;
            }
          }
          class Tw extends ue {
            static get requires() {
              return [Sw, Yp, Ng];
            }
            static get pluginName() {
              return "ImageBlockEditing";
            }
            init() {
              const t = this.editor;
              t.model.schema.register("imageBlock", {
                inheritAllFrom: "$blockObject",
                allowAttributes: ["alt", "src", "srcset"],
              }),
                this._setupConversion(),
                t.plugins.has("ImageInlineEditing") &&
                  (t.commands.add(
                    "imageTypeBlock",
                    new Iw(this.editor, "imageBlock")
                  ),
                  this._setupClipboardIntegration());
            }
            _setupConversion() {
              const t = this.editor,
                e = t.t,
                n = t.conversion,
                i = t.plugins.get("ImageUtils");
              n
                .for("dataDowncast")
                .elementToStructure({
                  model: "imageBlock",
                  view: (t, { writer: e }) => qp(e),
                }),
                n
                  .for("editingDowncast")
                  .elementToStructure({
                    model: "imageBlock",
                    view: (t, { writer: n }) =>
                      i.toImageWidget(qp(n), n, e("image widget")),
                  }),
                n
                  .for("downcast")
                  .add(xw(i, "imageBlock", "src"))
                  .add(xw(i, "imageBlock", "alt"))
                  .add(yw(i, "imageBlock")),
                n
                  .for("upcast")
                  .elementToElement({
                    view: Gp(t, "imageBlock"),
                    model: (t, { writer: e }) =>
                      e.createElement(
                        "imageBlock",
                        t.hasAttribute("src")
                          ? { src: t.getAttribute("src") }
                          : null
                      ),
                  })
                  .add(
                    (function (t) {
                      return (t) => {
                        t.on("element:figure", e);
                      };
                      function e(e, n, i) {
                        if (
                          !i.consumable.test(n.viewItem, {
                            name: !0,
                            classes: "image",
                          })
                        )
                          return;
                        const o = t.findViewImgElement(n.viewItem);
                        if (!o || !i.consumable.test(o, { name: !0 })) return;
                        i.consumable.consume(n.viewItem, {
                          name: !0,
                          classes: "image",
                        });
                        const r = Na(
                          i.convertItem(o, n.modelCursor).modelRange.getItems()
                        );
                        r
                          ? (i.convertChildren(n.viewItem, r),
                            i.updateConversionResult(r, n))
                          : i.consumable.revert(n.viewItem, {
                              name: !0,
                              classes: "image",
                            });
                      }
                    })(i)
                  );
            }
            _setupClipboardIntegration() {
              const t = this.editor,
                e = t.model,
                n = t.editing.view,
                i = t.plugins.get("ImageUtils");
              this.listenTo(
                t.plugins.get("ClipboardPipeline"),
                "inputTransformation",
                (o, r) => {
                  const s = Array.from(r.content.getChildren());
                  let a;
                  if (!s.every(i.isInlineImageView)) return;
                  a = r.targetRanges
                    ? t.editing.mapper.toModelRange(r.targetRanges[0])
                    : e.document.selection.getFirstRange();
                  const c = e.createSelection(a);
                  if ("imageBlock" === Wp(e.schema, c)) {
                    const t = new bm(n.document),
                      e = s.map((e) =>
                        t.createElement("figure", { class: "image" }, e)
                      );
                    r.content = t.createDocumentFragment(e);
                  }
                }
              );
            }
          }
          var Mw = n(9048),
            Bw = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Mw.Z, Bw);
          Mw.Z.locals;
          class Nw extends ue {
            static get requires() {
              return [Tw, gp, vw];
            }
            static get pluginName() {
              return "ImageBlock";
            }
          }
          class zw extends ue {
            static get requires() {
              return [Sw, Yp, Ng];
            }
            static get pluginName() {
              return "ImageInlineEditing";
            }
            init() {
              const t = this.editor,
                e = t.model.schema;
              e.register("imageInline", {
                inheritAllFrom: "$inlineObject",
                allowAttributes: ["alt", "src", "srcset"],
              }),
                e.addChildCheck((t, e) => {
                  if (t.endsWith("caption") && "imageInline" === e.name)
                    return !1;
                }),
                this._setupConversion(),
                t.plugins.has("ImageBlockEditing") &&
                  (t.commands.add(
                    "imageTypeInline",
                    new Iw(this.editor, "imageInline")
                  ),
                  this._setupClipboardIntegration());
            }
            _setupConversion() {
              const t = this.editor,
                e = t.t,
                n = t.conversion,
                i = t.plugins.get("ImageUtils");
              n
                .for("dataDowncast")
                .elementToElement({
                  model: "imageInline",
                  view: (t, { writer: e }) => e.createEmptyElement("img"),
                }),
                n.for("editingDowncast").elementToStructure({
                  model: "imageInline",
                  view: (t, { writer: n }) =>
                    i.toImageWidget(
                      (function (t) {
                        return t.createContainerElement(
                          "span",
                          { class: "image-inline" },
                          t.createEmptyElement("img")
                        );
                      })(n),
                      n,
                      e("image widget")
                    ),
                }),
                n
                  .for("downcast")
                  .add(xw(i, "imageInline", "src"))
                  .add(xw(i, "imageInline", "alt"))
                  .add(yw(i, "imageInline")),
                n
                  .for("upcast")
                  .elementToElement({
                    view: Gp(t, "imageInline"),
                    model: (t, { writer: e }) =>
                      e.createElement(
                        "imageInline",
                        t.hasAttribute("src")
                          ? { src: t.getAttribute("src") }
                          : null
                      ),
                  });
            }
            _setupClipboardIntegration() {
              const t = this.editor,
                e = t.model,
                n = t.editing.view,
                i = t.plugins.get("ImageUtils");
              this.listenTo(
                t.plugins.get("ClipboardPipeline"),
                "inputTransformation",
                (o, r) => {
                  const s = Array.from(r.content.getChildren());
                  let a;
                  if (!s.every(i.isBlockImageView)) return;
                  a = r.targetRanges
                    ? t.editing.mapper.toModelRange(r.targetRanges[0])
                    : e.document.selection.getFirstRange();
                  const c = e.createSelection(a);
                  if ("imageInline" === Wp(e.schema, c)) {
                    const t = new bm(n.document),
                      e = s.map((e) =>
                        1 === e.childCount
                          ? (Array.from(e.getAttributes()).forEach((n) =>
                              t.setAttribute(...n, i.findViewImgElement(e))
                            ),
                            e.getChild(0))
                          : e
                      );
                    r.content = t.createDocumentFragment(e);
                  }
                }
              );
            }
          }
          class Pw extends ue {
            static get requires() {
              return [zw, gp, vw];
            }
            static get pluginName() {
              return "ImageInline";
            }
          }
          class Lw extends ge {
            refresh() {
              const t = this.editor,
                e = t.plugins.get("ImageCaptionUtils");
              if (!t.plugins.has(Tw))
                return (this.isEnabled = !1), void (this.value = !1);
              const n = t.model.document.selection,
                i = n.getSelectedElement();
              if (!i) {
                const t = e.getCaptionFromModelSelection(n);
                return (this.isEnabled = !!t), void (this.value = !!t);
              }
              (this.isEnabled = this.editor.plugins
                .get("ImageUtils")
                .isImage(i)),
                this.isEnabled
                  ? (this.value = !!e.getCaptionFromImageModelElement(i))
                  : (this.value = !1);
            }
            execute(t = {}) {
              const { focusCaptionOnShow: e } = t;
              this.editor.model.change((t) => {
                this.value
                  ? this._hideImageCaption(t)
                  : this._showImageCaption(t, e);
              });
            }
            _showImageCaption(t, e) {
              const n = this.editor.model.document.selection,
                i = this.editor.plugins.get("ImageCaptionEditing");
              let o = n.getSelectedElement();
              const r = i._getSavedCaption(o);
              this.editor.plugins.get("ImageUtils").isInlineImage(o) &&
                (this.editor.execute("imageTypeBlock"),
                (o = n.getSelectedElement()));
              const s = r || t.createElement("caption");
              t.append(s, o), e && t.setSelection(s, "in");
            }
            _hideImageCaption(t) {
              const e = this.editor,
                n = e.model.document.selection,
                i = e.plugins.get("ImageCaptionEditing"),
                o = e.plugins.get("ImageCaptionUtils");
              let r,
                s = n.getSelectedElement();
              s
                ? (r = o.getCaptionFromImageModelElement(s))
                : ((r = o.getCaptionFromModelSelection(n)), (s = r.parent)),
                i._saveCaption(s, r),
                t.setSelection(s, "on"),
                t.remove(r);
            }
          }
          class Rw extends ue {
            static get pluginName() {
              return "ImageCaptionUtils";
            }
            static get requires() {
              return [Yp];
            }
            getCaptionFromImageModelElement(t) {
              for (const e of t.getChildren())
                if (e && e.is("element", "caption")) return e;
              return null;
            }
            getCaptionFromModelSelection(t) {
              const e = this.editor.plugins.get("ImageUtils"),
                n = t.getFirstPosition().findAncestor("caption");
              return n && e.isBlockImage(n.parent) ? n : null;
            }
            matchImageCaptionViewElement(t) {
              const e = this.editor.plugins.get("ImageUtils");
              return "figcaption" == t.name && e.isBlockImageView(t.parent)
                ? { name: !0 }
                : null;
            }
          }
          class Ow extends ue {
            static get requires() {
              return [Yp, Rw];
            }
            static get pluginName() {
              return "ImageCaptionEditing";
            }
            constructor(t) {
              super(t), (this._savedCaptionsMap = new WeakMap());
            }
            init() {
              const t = this.editor,
                e = t.model.schema;
              e.isRegistered("caption")
                ? e.extend("caption", { allowIn: "imageBlock" })
                : e.register("caption", {
                    allowIn: "imageBlock",
                    allowContentOf: "$block",
                    isLimit: !0,
                  }),
                t.commands.add("toggleImageCaption", new Lw(this.editor)),
                this._setupConversion(),
                this._setupImageTypeCommandsIntegration();
            }
            _setupConversion() {
              const t = this.editor,
                e = t.editing.view,
                n = t.plugins.get("ImageUtils"),
                i = t.plugins.get("ImageCaptionUtils"),
                o = t.t;
              t.conversion
                .for("upcast")
                .elementToElement({
                  view: (t) => i.matchImageCaptionViewElement(t),
                  model: "caption",
                }),
                t.conversion
                  .for("dataDowncast")
                  .elementToElement({
                    model: "caption",
                    view: (t, { writer: e }) =>
                      n.isBlockImage(t.parent)
                        ? e.createContainerElement("figcaption")
                        : null,
                  }),
                t.conversion.for("editingDowncast").elementToElement({
                  model: "caption",
                  view: (t, { writer: i }) => {
                    if (!n.isBlockImage(t.parent)) return null;
                    const r = i.createEditableElement("figcaption");
                    return (
                      i.setCustomProperty("imageCaption", !0, r),
                      tm({
                        view: e,
                        element: r,
                        text: o("Enter image caption"),
                        keepOnFocus: !0,
                      }),
                      Zg(r, i)
                    );
                  },
                });
            }
            _setupImageTypeCommandsIntegration() {
              const t = this.editor,
                e = t.plugins.get("ImageUtils"),
                n = t.plugins.get("ImageCaptionUtils"),
                i = t.commands.get("imageTypeInline"),
                o = t.commands.get("imageTypeBlock"),
                r = (t) => {
                  if (!t.return) return;
                  const { oldElement: i, newElement: o } = t.return;
                  if (!i) return;
                  if (e.isBlockImage(i)) {
                    const t = n.getCaptionFromImageModelElement(i);
                    if (t) return void this._saveCaption(o, t);
                  }
                  const r = this._getSavedCaption(i);
                  r && this._saveCaption(o, r);
                };
              i && this.listenTo(i, "execute", r, { priority: "low" }),
                o && this.listenTo(o, "execute", r, { priority: "low" });
            }
            _getSavedCaption(t) {
              const e = this._savedCaptionsMap.get(t);
              return e ? Ua.fromJSON(e) : null;
            }
            _saveCaption(t, e) {
              this._savedCaptionsMap.set(t, e.toJSON());
            }
          }
          class jw extends ue {
            static get requires() {
              return [Rw];
            }
            static get pluginName() {
              return "ImageCaptionUI";
            }
            init() {
              const t = this.editor,
                e = t.editing.view,
                n = t.plugins.get("ImageCaptionUtils"),
                i = t.t;
              t.ui.componentFactory.add("toggleImageCaption", (o) => {
                const r = t.commands.get("toggleImageCaption"),
                  s = new kh(o);
                return (
                  s.set({ icon: zd.caption, tooltip: !0, isToggleable: !0 }),
                  s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"),
                  s
                    .bind("label")
                    .to(r, "value", (t) =>
                      i(t ? "Toggle caption off" : "Toggle caption on")
                    ),
                  this.listenTo(s, "execute", () => {
                    t.execute("toggleImageCaption", { focusCaptionOnShow: !0 });
                    const i = n.getCaptionFromModelSelection(
                      t.model.document.selection
                    );
                    if (i) {
                      const n = t.editing.mapper.toViewElement(i);
                      e.scrollToTheSelection(),
                        e.change((t) => {
                          t.addClass("image__caption_highlighted", n);
                        });
                    }
                  }),
                  s
                );
              });
            }
          }
          var Fw = n(8662),
            Vw = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Fw.Z, Vw);
          Fw.Z.locals;
          class Hw {
            constructor() {
              const t = new window.FileReader();
              (this._reader = t),
                (this._data = void 0),
                this.set("loaded", 0),
                (t.onprogress = (t) => {
                  this.loaded = t.loaded;
                });
            }
            get error() {
              return this._reader.error;
            }
            get data() {
              return this._data;
            }
            read(t) {
              const e = this._reader;
              return (
                (this.total = t.size),
                new Promise((n, i) => {
                  (e.onload = () => {
                    const t = e.result;
                    (this._data = t), n(t);
                  }),
                    (e.onerror = () => {
                      i("error");
                    }),
                    (e.onabort = () => {
                      i("aborted");
                    }),
                    this._reader.readAsDataURL(t);
                })
              );
            }
            abort() {
              this._reader.abort();
            }
          }
          he(Hw, re);
          class Uw extends ue {
            static get pluginName() {
              return "FileRepository";
            }
            static get requires() {
              return [Bd];
            }
            init() {
              (this.loaders = new Di()),
                this.loaders.on("add", () => this._updatePendingAction()),
                this.loaders.on("remove", () => this._updatePendingAction()),
                (this._loadersMap = new Map()),
                (this._pendingAction = null),
                this.set("uploaded", 0),
                this.set("uploadTotal", null),
                this.bind("uploadedPercent").to(
                  this,
                  "uploaded",
                  this,
                  "uploadTotal",
                  (t, e) => (e ? (t / e) * 100 : 0)
                );
            }
            getLoader(t) {
              return this._loadersMap.get(t) || null;
            }
            createLoader(t) {
              if (!this.createUploadAdapter)
                return l("filerepository-no-upload-adapter"), null;
              const e = new $w(Promise.resolve(t), this.createUploadAdapter);
              return (
                this.loaders.add(e),
                this._loadersMap.set(t, e),
                t instanceof Promise &&
                  e.file
                    .then((t) => {
                      this._loadersMap.set(t, e);
                    })
                    .catch(() => {}),
                e.on("change:uploaded", () => {
                  let t = 0;
                  for (const e of this.loaders) t += e.uploaded;
                  this.uploaded = t;
                }),
                e.on("change:uploadTotal", () => {
                  let t = 0;
                  for (const e of this.loaders)
                    e.uploadTotal && (t += e.uploadTotal);
                  this.uploadTotal = t;
                }),
                e
              );
            }
            destroyLoader(t) {
              const e = t instanceof $w ? t : this.getLoader(t);
              e._destroy(),
                this.loaders.remove(e),
                this._loadersMap.forEach((t, n) => {
                  t === e && this._loadersMap.delete(n);
                });
            }
            _updatePendingAction() {
              const t = this.editor.plugins.get(Bd);
              if (this.loaders.length) {
                if (!this._pendingAction) {
                  const e = this.editor.t,
                    n = (t) => `${e("Upload in progress")} ${parseInt(t)}%.`;
                  (this._pendingAction = t.add(n(this.uploadedPercent))),
                    this._pendingAction
                      .bind("message")
                      .to(this, "uploadedPercent", n);
                }
              } else
                t.remove(this._pendingAction), (this._pendingAction = null);
            }
          }
          he(Uw, re);
          class $w {
            constructor(t, e) {
              (this.id = r()),
                (this._filePromiseWrapper = this._createFilePromiseWrapper(t)),
                (this._adapter = e(this)),
                (this._reader = new Hw()),
                this.set("status", "idle"),
                this.set("uploaded", 0),
                this.set("uploadTotal", null),
                this.bind("uploadedPercent").to(
                  this,
                  "uploaded",
                  this,
                  "uploadTotal",
                  (t, e) => (e ? (t / e) * 100 : 0)
                ),
                this.set("uploadResponse", null);
            }
            get file() {
              return this._filePromiseWrapper
                ? this._filePromiseWrapper.promise.then((t) =>
                    this._filePromiseWrapper ? t : null
                  )
                : Promise.resolve(null);
            }
            get data() {
              return this._reader.data;
            }
            read() {
              if ("idle" != this.status)
                throw new c("filerepository-read-wrong-status", this);
              return (
                (this.status = "reading"),
                this.file
                  .then((t) => this._reader.read(t))
                  .then((t) => {
                    if ("reading" !== this.status) throw this.status;
                    return (this.status = "idle"), t;
                  })
                  .catch((t) => {
                    if ("aborted" === t)
                      throw ((this.status = "aborted"), "aborted");
                    throw (
                      ((this.status = "error"),
                      this._reader.error ? this._reader.error : t)
                    );
                  })
              );
            }
            upload() {
              if ("idle" != this.status)
                throw new c("filerepository-upload-wrong-status", this);
              return (
                (this.status = "uploading"),
                this.file
                  .then(() => this._adapter.upload())
                  .then(
                    (t) => (
                      (this.uploadResponse = t), (this.status = "idle"), t
                    )
                  )
                  .catch((t) => {
                    if ("aborted" === this.status) throw "aborted";
                    throw ((this.status = "error"), t);
                  })
              );
            }
            abort() {
              const t = this.status;
              (this.status = "aborted"),
                this._filePromiseWrapper.isFulfilled
                  ? "reading" == t
                    ? this._reader.abort()
                    : "uploading" == t &&
                      this._adapter.abort &&
                      this._adapter.abort()
                  : (this._filePromiseWrapper.promise.catch(() => {}),
                    this._filePromiseWrapper.rejecter("aborted")),
                this._destroy();
            }
            _destroy() {
              (this._filePromiseWrapper = void 0),
                (this._reader = void 0),
                (this._adapter = void 0),
                (this.uploadResponse = void 0);
            }
            _createFilePromiseWrapper(t) {
              const e = {};
              return (
                (e.promise = new Promise((n, i) => {
                  (e.rejecter = i),
                    (e.isFulfilled = !1),
                    t
                      .then((t) => {
                        (e.isFulfilled = !0), n(t);
                      })
                      .catch((t) => {
                        (e.isFulfilled = !0), i(t);
                      });
                })),
                e
              );
            }
          }
          he($w, re);
          class qw extends Vd {
            constructor(t) {
              super(t),
                (this.buttonView = new kh(t)),
                (this._fileInputView = new Gw(t)),
                this._fileInputView.bind("acceptedType").to(this),
                this._fileInputView.bind("allowMultipleFiles").to(this),
                this._fileInputView.delegate("done").to(this),
                this.setTemplate({
                  tag: "span",
                  attributes: { class: "ck-file-dialog-button" },
                  children: [this.buttonView, this._fileInputView],
                }),
                this.buttonView.on("execute", () => {
                  this._fileInputView.open();
                });
            }
            focus() {
              this.buttonView.focus();
            }
          }
          class Gw extends Vd {
            constructor(t) {
              super(t),
                this.set("acceptedType"),
                this.set("allowMultipleFiles", !1);
              const e = this.bindTemplate;
              this.setTemplate({
                tag: "input",
                attributes: {
                  class: ["ck-hidden"],
                  type: "file",
                  tabindex: "-1",
                  accept: e.to("acceptedType"),
                  multiple: e.to("allowMultipleFiles"),
                },
                on: {
                  change: e.to(() => {
                    this.element &&
                      this.element.files &&
                      this.element.files.length &&
                      this.fire("done", this.element.files),
                      (this.element.value = "");
                  }),
                },
              });
            }
            open() {
              this.element.click();
            }
          }
          function Ww(t) {
            const e = t.map((t) => t.replace("+", "\\+"));
            return new RegExp(`^image\\/(${e.join("|")})$`);
          }
          function Yw(t) {
            return new Promise((e, n) => {
              const i = t.getAttribute("src");
              fetch(i)
                .then((t) => t.blob())
                .then((t) => {
                  const n = Kw(t, i),
                    o = n.replace("image/", ""),
                    r = new File([t], `image.${o}`, { type: n });
                  e(r);
                })
                .catch((t) =>
                  t && "TypeError" === t.name
                    ? (function (t) {
                        return (function (t) {
                          return new Promise((e, n) => {
                            const i = os.document.createElement("img");
                            i.addEventListener("load", () => {
                              const t = os.document.createElement("canvas");
                              (t.width = i.width), (t.height = i.height);
                              t.getContext("2d").drawImage(i, 0, 0),
                                t.toBlob((t) => (t ? e(t) : n()));
                            }),
                              i.addEventListener("error", () => n()),
                              (i.src = t);
                          });
                        })(t).then((e) => {
                          const n = Kw(e, t),
                            i = n.replace("image/", "");
                          return new File([e], `image.${i}`, { type: n });
                        });
                      })(i)
                        .then(e)
                        .catch(n)
                    : n(t)
                );
            });
          }
          function Kw(t, e) {
            return t.type
              ? t.type
              : e.match(/data:(image\/\w+);base64/)
              ? e.match(/data:(image\/\w+);base64/)[1].toLowerCase()
              : "image/jpeg";
          }
          class Qw extends ue {
            static get pluginName() {
              return "ImageUploadUI";
            }
            init() {
              const t = this.editor,
                e = t.t,
                n = (n) => {
                  const i = new qw(n),
                    o = t.commands.get("uploadImage"),
                    r = t.config.get("image.upload.types"),
                    s = Ww(r);
                  return (
                    i.set({
                      acceptedType: r.map((t) => `image/${t}`).join(","),
                      allowMultipleFiles: !0,
                    }),
                    i.buttonView.set({
                      label: e("Insert image"),
                      icon: zd.image,
                      tooltip: !0,
                    }),
                    i.buttonView.bind("isEnabled").to(o),
                    i.on("done", (e, n) => {
                      const i = Array.from(n).filter((t) => s.test(t.type));
                      i.length && t.execute("uploadImage", { file: i });
                    }),
                    i
                  );
                };
              t.ui.componentFactory.add("uploadImage", n),
                t.ui.componentFactory.add("imageUpload", n);
            }
          }
          var Zw = n(5870),
            Jw = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Zw.Z, Jw);
          Zw.Z.locals;
          var Xw = n(9899),
            tA = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Xw.Z, tA);
          Xw.Z.locals;
          var eA = n(9825),
            nA = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(eA.Z, nA);
          eA.Z.locals;
          class iA extends ue {
            static get pluginName() {
              return "ImageUploadProgress";
            }
            constructor(t) {
              super(t),
                (this.placeholder =
                  "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==");
            }
            init() {
              const t = this.editor;
              t.plugins.has("ImageBlockEditing") &&
                t.editing.downcastDispatcher.on(
                  "attribute:uploadStatus:imageBlock",
                  (...t) => this.uploadStatusChange(...t)
                ),
                t.plugins.has("ImageInlineEditing") &&
                  t.editing.downcastDispatcher.on(
                    "attribute:uploadStatus:imageInline",
                    (...t) => this.uploadStatusChange(...t)
                  );
            }
            uploadStatusChange(t, e, n) {
              const i = this.editor,
                o = e.item,
                r = o.getAttribute("uploadId");
              if (!n.consumable.consume(e.item, t.name)) return;
              const s = i.plugins.get("ImageUtils"),
                a = i.plugins.get(Uw),
                c = r ? e.attributeNewValue : null,
                l = this.placeholder,
                d = i.editing.mapper.toViewElement(o),
                h = n.writer;
              if ("reading" == c) return oA(d, h), void rA(s, l, d, h);
              if ("uploading" == c) {
                const t = a.loaders.get(r);
                return (
                  oA(d, h),
                  void (t
                    ? (sA(d, h),
                      (function (t, e, n, i) {
                        const o = (function (t) {
                          const e = t.createUIElement("div", {
                            class: "ck-progress-bar",
                          });
                          return t.setCustomProperty("progressBar", !0, e), e;
                        })(e);
                        e.insert(e.createPositionAt(t, "end"), o),
                          n.on("change:uploadedPercent", (t, e, n) => {
                            i.change((t) => {
                              t.setStyle("width", n + "%", o);
                            });
                          });
                      })(d, h, t, i.editing.view),
                      (function (t, e, n, i) {
                        if (i.data) {
                          const o = t.findViewImgElement(e);
                          n.setAttribute("src", i.data, o);
                        }
                      })(s, d, h, t))
                    : rA(s, l, d, h))
                );
              }
              "complete" == c &&
                a.loaders.get(r) &&
                (function (t, e, n) {
                  const i = e.createUIElement("div", {
                    class: "ck-image-upload-complete-icon",
                  });
                  e.insert(e.createPositionAt(t, "end"), i),
                    setTimeout(() => {
                      n.change((t) => t.remove(t.createRangeOn(i)));
                    }, 3e3);
                })(d, h, i.editing.view),
                (function (t, e) {
                  cA(t, e, "progressBar");
                })(d, h),
                sA(d, h),
                (function (t, e) {
                  e.removeClass("ck-appear", t);
                })(d, h);
            }
          }
          function oA(t, e) {
            t.hasClass("ck-appear") || e.addClass("ck-appear", t);
          }
          function rA(t, e, n, i) {
            n.hasClass("ck-image-upload-placeholder") ||
              i.addClass("ck-image-upload-placeholder", n);
            const o = t.findViewImgElement(n);
            o.getAttribute("src") !== e && i.setAttribute("src", e, o),
              aA(n, "placeholder") ||
                i.insert(
                  i.createPositionAfter(o),
                  (function (t) {
                    const e = t.createUIElement("div", {
                      class: "ck-upload-placeholder-loader",
                    });
                    return t.setCustomProperty("placeholder", !0, e), e;
                  })(i)
                );
          }
          function sA(t, e) {
            t.hasClass("ck-image-upload-placeholder") &&
              e.removeClass("ck-image-upload-placeholder", t),
              cA(t, e, "placeholder");
          }
          function aA(t, e) {
            for (const n of t.getChildren())
              if (n.getCustomProperty(e)) return n;
          }
          function cA(t, e, n) {
            const i = aA(t, n);
            i && e.remove(e.createRangeOn(i));
          }
          class lA extends ge {
            refresh() {
              const t = this.editor,
                e = t.plugins.get("ImageUtils"),
                n = t.model.document.selection.getSelectedElement();
              this.isEnabled = e.isImageAllowed() || e.isImage(n);
            }
            execute(t) {
              const e = Ii(t.file),
                n = this.editor.model.document.selection,
                i = this.editor.plugins.get("ImageUtils"),
                o = Object.fromEntries(n.getAttributes());
              e.forEach((t, e) => {
                const r = n.getSelectedElement();
                if (e && r && i.isImage(r)) {
                  const e = this.editor.model.createPositionAfter(r);
                  this._uploadImage(t, o, e);
                } else this._uploadImage(t, o);
              });
            }
            _uploadImage(t, e, n) {
              const i = this.editor,
                o = i.plugins.get(Uw).createLoader(t),
                r = i.plugins.get("ImageUtils");
              o && r.insertImage({ ...e, uploadId: o.id }, n);
            }
          }
          class dA extends ue {
            static get requires() {
              return [Uw, Du, Ng, Yp];
            }
            static get pluginName() {
              return "ImageUploadEditing";
            }
            constructor(t) {
              super(t),
                t.config.define("image", {
                  upload: {
                    types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"],
                  },
                }),
                (this._uploadImageElements = new Map());
            }
            init() {
              const t = this.editor,
                e = t.model.document,
                n = t.conversion,
                i = t.plugins.get(Uw),
                o = t.plugins.get("ImageUtils"),
                r = Ww(t.config.get("image.upload.types")),
                s = new lA(t);
              t.commands.add("uploadImage", s),
                t.commands.add("imageUpload", s),
                n
                  .for("upcast")
                  .attributeToAttribute({
                    view: { name: "img", key: "uploadId" },
                    model: "uploadId",
                  }),
                this.listenTo(
                  t.editing.view.document,
                  "clipboardInput",
                  (e, n) => {
                    if (
                      ((i = n.dataTransfer),
                      Array.from(i.types).includes("text/html") &&
                        "" !== i.getData("text/html"))
                    )
                      return;
                    var i;
                    const o = Array.from(n.dataTransfer.files).filter(
                      (t) => !!t && r.test(t.type)
                    );
                    o.length &&
                      (e.stop(),
                      t.model.change((e) => {
                        n.targetRanges &&
                          e.setSelection(
                            n.targetRanges.map((e) =>
                              t.editing.mapper.toModelRange(e)
                            )
                          ),
                          t.model.enqueueChange(() => {
                            t.execute("uploadImage", { file: o });
                          });
                      }));
                  }
                ),
                this.listenTo(
                  t.plugins.get("ClipboardPipeline"),
                  "inputTransformation",
                  (e, n) => {
                    const r = Array.from(
                      t.editing.view.createRangeIn(n.content)
                    )
                      .filter(
                        (t) =>
                          (function (t, e) {
                            return (
                              !(
                                !t.isInlineImageView(e) ||
                                !e.getAttribute("src")
                              ) &&
                              (e
                                .getAttribute("src")
                                .match(/^data:image\/\w+;base64,/g) ||
                                e.getAttribute("src").match(/^blob:/g))
                            );
                          })(o, t.item) &&
                          !t.item.getAttribute("uploadProcessed")
                      )
                      .map((t) => ({
                        promise: Yw(t.item),
                        imageElement: t.item,
                      }));
                    if (!r.length) return;
                    const s = new bm(t.editing.view.document);
                    for (const t of r) {
                      s.setAttribute("uploadProcessed", !0, t.imageElement);
                      const e = i.createLoader(t.promise);
                      e &&
                        (s.setAttribute("src", "", t.imageElement),
                        s.setAttribute("uploadId", e.id, t.imageElement));
                    }
                  }
                ),
                t.editing.view.document.on("dragover", (t, e) => {
                  e.preventDefault();
                }),
                e.on("change", () => {
                  const n = e.differ
                      .getChanges({ includeChangesInGraveyard: !0 })
                      .reverse(),
                    o = new Set();
                  for (const e of n)
                    if ("insert" == e.type && "$text" != e.name) {
                      const n = e.position.nodeAfter,
                        r = "$graveyard" == e.position.root.rootName;
                      for (const e of hA(t, n)) {
                        const t = e.getAttribute("uploadId");
                        if (!t) continue;
                        const n = i.loaders.get(t);
                        n &&
                          (r
                            ? o.has(t) || n.abort()
                            : (o.add(t),
                              this._uploadImageElements.set(t, e),
                              "idle" == n.status && this._readAndUpload(n)));
                      }
                    }
                }),
                this.on(
                  "uploadComplete",
                  (t, { imageElement: e, data: n }) => {
                    const i = n.urls ? n.urls : n;
                    this.editor.model.change((t) => {
                      t.setAttribute("src", i.default, e),
                        this._parseAndSetSrcsetAttributeOnImage(i, e, t);
                    });
                  },
                  { priority: "low" }
                );
            }
            afterInit() {
              const t = this.editor.model.schema;
              this.editor.plugins.has("ImageBlockEditing") &&
                t.extend("imageBlock", {
                  allowAttributes: ["uploadId", "uploadStatus"],
                }),
                this.editor.plugins.has("ImageInlineEditing") &&
                  t.extend("imageInline", {
                    allowAttributes: ["uploadId", "uploadStatus"],
                  });
            }
            _readAndUpload(t) {
              const e = this.editor,
                n = e.model,
                i = e.locale.t,
                o = e.plugins.get(Uw),
                r = e.plugins.get(Du),
                s = e.plugins.get("ImageUtils"),
                a = this._uploadImageElements;
              return (
                n.enqueueChange({ isUndoable: !1 }, (e) => {
                  e.setAttribute("uploadStatus", "reading", a.get(t.id));
                }),
                t
                  .read()
                  .then(() => {
                    const i = t.upload(),
                      o = a.get(t.id);
                    if (sr.isSafari) {
                      const t = e.editing.mapper.toViewElement(o),
                        n = s.findViewImgElement(t);
                      e.editing.view.once("render", () => {
                        if (!n.parent) return;
                        const t = e.editing.view.domConverter.mapViewToDom(
                          n.parent
                        );
                        if (!t) return;
                        const i = t.style.display;
                        (t.style.display = "none"),
                          (t._ckHack = t.offsetHeight),
                          (t.style.display = i);
                      });
                    }
                    return (
                      n.enqueueChange({ isUndoable: !1 }, (t) => {
                        t.setAttribute("uploadStatus", "uploading", o);
                      }),
                      i
                    );
                  })
                  .then((e) => {
                    n.enqueueChange({ isUndoable: !1 }, (n) => {
                      const i = a.get(t.id);
                      n.setAttribute("uploadStatus", "complete", i),
                        this.fire("uploadComplete", {
                          data: e,
                          imageElement: i,
                        });
                    }),
                      c();
                  })
                  .catch((e) => {
                    if ("error" !== t.status && "aborted" !== t.status) throw e;
                    "error" == t.status &&
                      e &&
                      r.showWarning(e, {
                        title: i("Upload failed"),
                        namespace: "upload",
                      }),
                      n.enqueueChange({ isUndoable: !1 }, (e) => {
                        e.remove(a.get(t.id));
                      }),
                      c();
                  })
              );
              function c() {
                n.enqueueChange({ isUndoable: !1 }, (e) => {
                  const n = a.get(t.id);
                  e.removeAttribute("uploadId", n),
                    e.removeAttribute("uploadStatus", n),
                    a.delete(t.id);
                }),
                  o.destroyLoader(t);
              }
            }
            _parseAndSetSrcsetAttributeOnImage(t, e, n) {
              let i = 0;
              const o = Object.keys(t)
                .filter((t) => {
                  const e = parseInt(t, 10);
                  if (!isNaN(e)) return (i = Math.max(i, e)), !0;
                })
                .map((e) => `${t[e]} ${e}w`)
                .join(", ");
              "" != o && n.setAttribute("srcset", { data: o, width: i }, e);
            }
          }
          function hA(t, e) {
            const n = t.plugins.get("ImageUtils");
            return Array.from(t.model.createRangeOn(e))
              .filter((t) => n.isImage(t.item))
              .map((t) => t.item);
          }
          var uA = n(5150),
            mA = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(uA.Z, mA);
          uA.Z.locals;
          var gA = n(9292),
            pA = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(gA.Z, pA);
          gA.Z.locals;
          class fA extends ge {
            constructor(t, e) {
              super(t),
                (this._defaultStyles = { imageBlock: !1, imageInline: !1 }),
                (this._styles = new Map(
                  e.map((t) => {
                    if (t.isDefault)
                      for (const e of t.modelElements)
                        this._defaultStyles[e] = t.name;
                    return [t.name, t];
                  })
                ));
            }
            refresh() {
              const t = this.editor.plugins
                .get("ImageUtils")
                .getClosestSelectedImageElement(
                  this.editor.model.document.selection
                );
              (this.isEnabled = !!t),
                this.isEnabled
                  ? t.hasAttribute("imageStyle")
                    ? (this.value = t.getAttribute("imageStyle"))
                    : (this.value = this._defaultStyles[t.name])
                  : (this.value = !1);
            }
            execute(t = {}) {
              const e = this.editor,
                n = e.model,
                i = e.plugins.get("ImageUtils");
              n.change((e) => {
                const o = t.value;
                let r = i.getClosestSelectedImageElement(n.document.selection);
                o &&
                  this.shouldConvertImageType(o, r) &&
                  (this.editor.execute(
                    i.isBlockImage(r) ? "imageTypeInline" : "imageTypeBlock"
                  ),
                  (r = i.getClosestSelectedImageElement(n.document.selection))),
                  !o || this._styles.get(o).isDefault
                    ? e.removeAttribute("imageStyle", r)
                    : e.setAttribute("imageStyle", o, r);
              });
            }
            shouldConvertImageType(t, e) {
              return !this._styles.get(t).modelElements.includes(e.name);
            }
          }
          const {
              objectFullWidth: kA,
              objectInline: bA,
              objectLeft: wA,
              objectRight: AA,
              objectCenter: _A,
              objectBlockLeft: CA,
              objectBlockRight: vA,
            } = zd,
            yA = {
              get inline() {
                return {
                  name: "inline",
                  title: "In line",
                  icon: bA,
                  modelElements: ["imageInline"],
                  isDefault: !0,
                };
              },
              get alignLeft() {
                return {
                  name: "alignLeft",
                  title: "Left aligned image",
                  icon: wA,
                  modelElements: ["imageBlock", "imageInline"],
                  className: "image-style-align-left",
                };
              },
              get alignBlockLeft() {
                return {
                  name: "alignBlockLeft",
                  title: "Left aligned image",
                  icon: CA,
                  modelElements: ["imageBlock"],
                  className: "image-style-block-align-left",
                };
              },
              get alignCenter() {
                return {
                  name: "alignCenter",
                  title: "Centered image",
                  icon: _A,
                  modelElements: ["imageBlock"],
                  className: "image-style-align-center",
                };
              },
              get alignRight() {
                return {
                  name: "alignRight",
                  title: "Right aligned image",
                  icon: AA,
                  modelElements: ["imageBlock", "imageInline"],
                  className: "image-style-align-right",
                };
              },
              get alignBlockRight() {
                return {
                  name: "alignBlockRight",
                  title: "Right aligned image",
                  icon: vA,
                  modelElements: ["imageBlock"],
                  className: "image-style-block-align-right",
                };
              },
              get block() {
                return {
                  name: "block",
                  title: "Centered image",
                  icon: _A,
                  modelElements: ["imageBlock"],
                  isDefault: !0,
                };
              },
              get side() {
                return {
                  name: "side",
                  title: "Side image",
                  icon: AA,
                  modelElements: ["imageBlock"],
                  className: "image-style-side",
                };
              },
            },
            xA = {
              full: kA,
              left: CA,
              right: vA,
              center: _A,
              inlineLeft: wA,
              inlineRight: AA,
              inline: bA,
            },
            EA = [
              {
                name: "imageStyle:wrapText",
                title: "Wrap text",
                defaultItem: "imageStyle:alignLeft",
                items: ["imageStyle:alignLeft", "imageStyle:alignRight"],
              },
              {
                name: "imageStyle:breakText",
                title: "Break text",
                defaultItem: "imageStyle:block",
                items: [
                  "imageStyle:alignBlockLeft",
                  "imageStyle:block",
                  "imageStyle:alignBlockRight",
                ],
              },
            ];
          function DA(t) {
            l("image-style-configuration-definition-invalid", t);
          }
          const SA = {
            normalizeStyles: function (t) {
              return (t.configuredStyles.options || [])
                .map((t) =>
                  (function (t) {
                    t =
                      "string" == typeof t
                        ? yA[t]
                          ? { ...yA[t] }
                          : { name: t }
                        : (function (t, e) {
                            const n = { ...e };
                            for (const i in t)
                              Object.prototype.hasOwnProperty.call(e, i) ||
                                (n[i] = t[i]);
                            return n;
                          })(yA[t.name], t);
                    "string" == typeof t.icon &&
                      (t.icon = xA[t.icon] || t.icon);
                    return t;
                  })(t)
                )
                .filter((e) =>
                  (function (
                    t,
                    { isBlockPluginLoaded: e, isInlinePluginLoaded: n }
                  ) {
                    const { modelElements: i, name: o } = t;
                    if (!(i && i.length && o)) return DA({ style: t }), !1;
                    {
                      const o = [
                        e ? "imageBlock" : null,
                        n ? "imageInline" : null,
                      ];
                      if (!i.some((t) => o.includes(t)))
                        return (
                          l("image-style-missing-dependency", {
                            style: t,
                            missingPlugins: i.map((t) =>
                              "imageBlock" === t
                                ? "ImageBlockEditing"
                                : "ImageInlineEditing"
                            ),
                          }),
                          !1
                        );
                    }
                    return !0;
                  })(e, t)
                );
            },
            getDefaultStylesConfiguration: function (t, e) {
              return t && e
                ? {
                    options: [
                      "inline",
                      "alignLeft",
                      "alignRight",
                      "alignCenter",
                      "alignBlockLeft",
                      "alignBlockRight",
                      "block",
                      "side",
                    ],
                  }
                : t
                ? { options: ["block", "side"] }
                : e
                ? { options: ["inline", "alignLeft", "alignRight"] }
                : {};
            },
            getDefaultDropdownDefinitions: function (t) {
              return t.has("ImageBlockEditing") && t.has("ImageInlineEditing")
                ? [...EA]
                : [];
            },
            warnInvalidStyle: DA,
            DEFAULT_OPTIONS: yA,
            DEFAULT_ICONS: xA,
            DEFAULT_DROPDOWN_DEFINITIONS: EA,
          };
          function IA(t, e) {
            for (const n of e) if (n.name === t) return n;
          }
          class TA extends ue {
            static get pluginName() {
              return "ImageStyleEditing";
            }
            static get requires() {
              return [Yp];
            }
            init() {
              const { normalizeStyles: t, getDefaultStylesConfiguration: e } =
                  SA,
                n = this.editor,
                i = n.plugins.has("ImageBlockEditing"),
                o = n.plugins.has("ImageInlineEditing");
              n.config.define("image.styles", e(i, o)),
                (this.normalizedStyles = t({
                  configuredStyles: n.config.get("image.styles"),
                  isBlockPluginLoaded: i,
                  isInlinePluginLoaded: o,
                })),
                this._setupConversion(i, o),
                this._setupPostFixer(),
                n.commands.add("imageStyle", new fA(n, this.normalizedStyles));
            }
            _setupConversion(t, e) {
              const n = this.editor,
                i = n.model.schema,
                o =
                  ((r = this.normalizedStyles),
                  (t, e, n) => {
                    if (!n.consumable.consume(e.item, t.name)) return;
                    const i = IA(e.attributeNewValue, r),
                      o = IA(e.attributeOldValue, r),
                      s = n.mapper.toViewElement(e.item),
                      a = n.writer;
                    o && a.removeClass(o.className, s),
                      i && a.addClass(i.className, s);
                  });
              var r;
              const s = (function (t) {
                const e = {
                  imageInline: t.filter(
                    (t) =>
                      !t.isDefault && t.modelElements.includes("imageInline")
                  ),
                  imageBlock: t.filter(
                    (t) =>
                      !t.isDefault && t.modelElements.includes("imageBlock")
                  ),
                };
                return (t, n, i) => {
                  if (!n.modelRange) return;
                  const o = n.viewItem,
                    r = Na(n.modelRange.getItems());
                  if (r && i.schema.checkAttribute(r, "imageStyle"))
                    for (const t of e[r.name])
                      i.consumable.consume(o, { classes: t.className }) &&
                        i.writer.setAttribute("imageStyle", t.name, r);
                };
              })(this.normalizedStyles);
              n.editing.downcastDispatcher.on("attribute:imageStyle", o),
                n.data.downcastDispatcher.on("attribute:imageStyle", o),
                t &&
                  (i.extend("imageBlock", { allowAttributes: "imageStyle" }),
                  n.data.upcastDispatcher.on("element:figure", s, {
                    priority: "low",
                  })),
                e &&
                  (i.extend("imageInline", { allowAttributes: "imageStyle" }),
                  n.data.upcastDispatcher.on("element:img", s, {
                    priority: "low",
                  }));
            }
            _setupPostFixer() {
              const t = this.editor,
                e = t.model.document,
                n = t.plugins.get(Yp),
                i = new Map(this.normalizedStyles.map((t) => [t.name, t]));
              e.registerPostFixer((t) => {
                let o = !1;
                for (const r of e.differ.getChanges())
                  if (
                    "insert" == r.type ||
                    ("attribute" == r.type && "imageStyle" == r.attributeKey)
                  ) {
                    let e =
                      "insert" == r.type
                        ? r.position.nodeAfter
                        : r.range.start.nodeAfter;
                    if (
                      (e &&
                        e.is("element", "paragraph") &&
                        e.childCount > 0 &&
                        (e = e.getChild(0)),
                      !n.isImage(e))
                    )
                      continue;
                    const s = e.getAttribute("imageStyle");
                    if (!s) continue;
                    const a = i.get(s);
                    (a && a.modelElements.includes(e.name)) ||
                      (t.removeAttribute("imageStyle", e), (o = !0));
                  }
                return o;
              });
            }
          }
          var MA = n(4622),
            BA = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(MA.Z, BA);
          MA.Z.locals;
          class NA extends ue {
            static get requires() {
              return [TA];
            }
            static get pluginName() {
              return "ImageStyleUI";
            }
            get localizedDefaultStylesTitles() {
              const t = this.editor.t;
              return {
                "Wrap text": t("Wrap text"),
                "Break text": t("Break text"),
                "In line": t("In line"),
                "Full size image": t("Full size image"),
                "Side image": t("Side image"),
                "Left aligned image": t("Left aligned image"),
                "Centered image": t("Centered image"),
                "Right aligned image": t("Right aligned image"),
              };
            }
            init() {
              const t = this.editor.plugins,
                e = this.editor.config.get("image.toolbar") || [],
                n = zA(
                  t.get("ImageStyleEditing").normalizedStyles,
                  this.localizedDefaultStylesTitles
                );
              for (const t of n) this._createButton(t);
              const i = zA(
                [...e.filter(x), ...SA.getDefaultDropdownDefinitions(t)],
                this.localizedDefaultStylesTitles
              );
              for (const t of i) this._createDropdown(t, n);
            }
            _createDropdown(t, e) {
              const n = this.editor.ui.componentFactory;
              n.add(t.name, (i) => {
                let o;
                const { defaultItem: r, items: s, title: a } = t,
                  c = s
                    .filter((t) => e.find(({ name: e }) => PA(e) === t))
                    .map((t) => {
                      const e = n.create(t);
                      return t === r && (o = e), e;
                    });
                s.length !== c.length && SA.warnInvalidStyle({ dropdown: t });
                const l = ou(i, Bh),
                  d = l.buttonView,
                  h = d.arrowView;
                return (
                  ru(l, c),
                  d.set({ label: LA(a, o.label), class: null, tooltip: !0 }),
                  h.unbind("label"),
                  h.set({ label: a }),
                  d.bind("icon").toMany(c, "isOn", (...t) => {
                    const e = t.findIndex(st);
                    return e < 0 ? o.icon : c[e].icon;
                  }),
                  d.bind("label").toMany(c, "isOn", (...t) => {
                    const e = t.findIndex(st);
                    return LA(a, e < 0 ? o.label : c[e].label);
                  }),
                  d.bind("isOn").toMany(c, "isOn", (...t) => t.some(st)),
                  d
                    .bind("class")
                    .toMany(c, "isOn", (...t) =>
                      t.some(st) ? "ck-splitbutton_flatten" : null
                    ),
                  d.on("execute", () => {
                    c.some(({ isOn: t }) => t)
                      ? (l.isOpen = !l.isOpen)
                      : o.fire("execute");
                  }),
                  l
                    .bind("isEnabled")
                    .toMany(c, "isEnabled", (...t) => t.some(st)),
                  l
                );
              });
            }
            _createButton(t) {
              const e = t.name;
              this.editor.ui.componentFactory.add(PA(e), (n) => {
                const i = this.editor.commands.get("imageStyle"),
                  o = new kh(n);
                return (
                  o.set({
                    label: t.title,
                    icon: t.icon,
                    tooltip: !0,
                    isToggleable: !0,
                  }),
                  o.bind("isEnabled").to(i, "isEnabled"),
                  o.bind("isOn").to(i, "value", (t) => t === e),
                  o.on("execute", this._executeCommand.bind(this, e)),
                  o
                );
              });
            }
            _executeCommand(t) {
              this.editor.execute("imageStyle", { value: t }),
                this.editor.editing.view.focus();
            }
          }
          function zA(t, e) {
            for (const n of t) e[n.title] && (n.title = e[n.title]);
            return t;
          }
          function PA(t) {
            return `imageStyle:${t}`;
          }
          function LA(t, e) {
            return (t ? t + ": " : "") + e;
          }
          class RA extends ue {
            static get pluginName() {
              return "IndentEditing";
            }
            init() {
              const t = this.editor;
              t.commands.add("indent", new fe(t)),
                t.commands.add("outdent", new fe(t));
            }
          }
          const OA =
              '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>',
            jA =
              '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
          class FA extends ue {
            static get pluginName() {
              return "IndentUI";
            }
            init() {
              const t = this.editor,
                e = t.locale,
                n = t.t,
                i = "ltr" == e.uiLanguageDirection ? OA : jA,
                o = "ltr" == e.uiLanguageDirection ? jA : OA;
              this._defineButton("indent", n("Increase indent"), i),
                this._defineButton("outdent", n("Decrease indent"), o);
            }
            _defineButton(t, e, n) {
              const i = this.editor;
              i.ui.componentFactory.add(t, (o) => {
                const r = i.commands.get(t),
                  s = new kh(o);
                return (
                  s.set({ label: e, icon: n, tooltip: !0 }),
                  s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"),
                  this.listenTo(s, "execute", () => {
                    i.execute(t), i.editing.view.focus();
                  }),
                  s
                );
              });
            }
          }
          class VA extends ge {
            constructor(t, e) {
              super(t), (this._indentBehavior = e);
            }
            refresh() {
              const t = this.editor.model,
                e = Na(t.document.selection.getSelectedBlocks());
              e && t.schema.checkAttribute(e, "blockIndent")
                ? (this.isEnabled = this._indentBehavior.checkEnabled(
                    e.getAttribute("blockIndent")
                  ))
                : (this.isEnabled = !1);
            }
            execute() {
              const t = this.editor.model,
                e = (function (t) {
                  const e = t.document.selection,
                    n = t.schema;
                  return Array.from(e.getSelectedBlocks()).filter((t) =>
                    n.checkAttribute(t, "blockIndent")
                  );
                })(t);
              t.change((t) => {
                for (const n of e) {
                  const e = n.getAttribute("blockIndent"),
                    i = this._indentBehavior.getNextIndent(e);
                  i
                    ? t.setAttribute("blockIndent", i, n)
                    : t.removeAttribute("blockIndent", n);
                }
              });
            }
          }
          class HA {
            constructor(t) {
              (this.isForward = "forward" === t.direction),
                (this.offset = t.offset),
                (this.unit = t.unit);
            }
            checkEnabled(t) {
              const e = parseFloat(t || 0);
              return this.isForward || e > 0;
            }
            getNextIndent(t) {
              const e = parseFloat(t || 0);
              if (!(!t || t.endsWith(this.unit)))
                return this.isForward ? this.offset + this.unit : void 0;
              const n = e + (this.isForward ? this.offset : -this.offset);
              return n > 0 ? n + this.unit : void 0;
            }
          }
          class UA {
            constructor(t) {
              (this.isForward = "forward" === t.direction),
                (this.classes = t.classes);
            }
            checkEnabled(t) {
              const e = this.classes.indexOf(t);
              return this.isForward ? e < this.classes.length - 1 : e >= 0;
            }
            getNextIndent(t) {
              const e = this.classes.indexOf(t),
                n = this.isForward ? 1 : -1;
              return this.classes[e + n];
            }
          }
          const $A = [
            "paragraph",
            "heading1",
            "heading2",
            "heading3",
            "heading4",
            "heading5",
            "heading6",
          ];
          const qA = "italic";
          class GA extends ue {
            static get pluginName() {
              return "ItalicEditing";
            }
            init() {
              const t = this.editor;
              t.model.schema.extend("$text", { allowAttributes: qA }),
                t.model.schema.setAttributeProperties(qA, {
                  isFormatting: !0,
                  copyOnEnter: !0,
                }),
                t.conversion.attributeToElement({
                  model: qA,
                  view: "i",
                  upcastAlso: ["em", { styles: { "font-style": "italic" } }],
                }),
                t.commands.add(qA, new Vf(t, qA)),
                t.keystrokes.set("CTRL+I", qA);
            }
          }
          const WA = "italic";
          class YA extends ue {
            static get pluginName() {
              return "ItalicUI";
            }
            init() {
              const t = this.editor,
                e = t.t;
              t.ui.componentFactory.add(WA, (n) => {
                const i = t.commands.get(WA),
                  o = new kh(n);
                return (
                  o.set({
                    label: e("Italic"),
                    icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>',
                    keystroke: "CTRL+I",
                    tooltip: !0,
                    isToggleable: !0,
                  }),
                  o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"),
                  this.listenTo(o, "execute", () => {
                    t.execute(WA), t.editing.view.focus();
                  }),
                  o
                );
              });
            }
          }
          class KA {
            constructor() {
              this._definitions = new Set();
            }
            get length() {
              return this._definitions.size;
            }
            add(t) {
              Array.isArray(t)
                ? t.forEach((t) => this._definitions.add(t))
                : this._definitions.add(t);
            }
            getDispatcher() {
              return (t) => {
                t.on(
                  "attribute:linkHref",
                  (t, e, n) => {
                    if (!n.consumable.test(e.item, "attribute:linkHref"))
                      return;
                    if (!e.item.is("selection") && !n.schema.isInline(e.item))
                      return;
                    const i = n.writer,
                      o = i.document.selection;
                    for (const t of this._definitions) {
                      const r = i.createAttributeElement("a", t.attributes, {
                        priority: 5,
                      });
                      t.classes && i.addClass(t.classes, r);
                      for (const e in t.styles) i.setStyle(e, t.styles[e], r);
                      i.setCustomProperty("link", !0, r),
                        t.callback(e.attributeNewValue)
                          ? e.item.is("selection")
                            ? i.wrap(o.getFirstRange(), r)
                            : i.wrap(n.mapper.toViewRange(e.range), r)
                          : i.unwrap(n.mapper.toViewRange(e.range), r);
                    }
                  },
                  { priority: "high" }
                );
              };
            }
            getDispatcherForLinkedImage() {
              return (t) => {
                t.on(
                  "attribute:linkHref:imageBlock",
                  (t, e, { writer: n, mapper: i }) => {
                    const o = i.toViewElement(e.item),
                      r = Array.from(o.getChildren()).find(
                        (t) => "a" === t.name
                      );
                    for (const t of this._definitions) {
                      const i = Vi(t.attributes);
                      if (t.callback(e.attributeNewValue)) {
                        for (const [t, e] of i)
                          "class" === t
                            ? n.addClass(e, r)
                            : n.setAttribute(t, e, r);
                        t.classes && n.addClass(t.classes, r);
                        for (const e in t.styles) n.setStyle(e, t.styles[e], r);
                      } else {
                        for (const [t, e] of i)
                          "class" === t
                            ? n.removeClass(e, r)
                            : n.removeAttribute(t, r);
                        t.classes && n.removeClass(t.classes, r);
                        for (const e in t.styles) n.removeStyle(e, r);
                      }
                    }
                  }
                );
              };
            }
          }
          class QA extends ge {
            constructor(t) {
              super(t),
                (this.manualDecorators = new Di()),
                (this.automaticDecorators = new KA());
            }
            restoreManualDecoratorStates() {
              for (const t of this.manualDecorators)
                t.value = this._getDecoratorStateFromModel(t.id);
            }
            refresh() {
              const t = this.editor.model,
                e = t.document.selection,
                n = e.getSelectedElement() || Na(e.getSelectedBlocks());
              vf(n, t.schema)
                ? ((this.value = n.getAttribute("linkHref")),
                  (this.isEnabled = t.schema.checkAttribute(n, "linkHref")))
                : ((this.value = e.getAttribute("linkHref")),
                  (this.isEnabled = t.schema.checkAttributeInSelection(
                    e,
                    "linkHref"
                  )));
              for (const t of this.manualDecorators)
                t.value = this._getDecoratorStateFromModel(t.id);
            }
            execute(t, e = {}) {
              const n = this.editor.model,
                i = n.document.selection,
                o = [],
                r = [];
              for (const t in e) e[t] ? o.push(t) : r.push(t);
              n.change((e) => {
                if (i.isCollapsed) {
                  const s = i.getFirstPosition();
                  if (i.hasAttribute("linkHref")) {
                    const a = Cg(s, "linkHref", i.getAttribute("linkHref"), n);
                    e.setAttribute("linkHref", t, a),
                      o.forEach((t) => {
                        e.setAttribute(t, !0, a);
                      }),
                      r.forEach((t) => {
                        e.removeAttribute(t, a);
                      }),
                      e.setSelection(e.createPositionAfter(a.end.nodeBefore));
                  } else if ("" !== t) {
                    const r = Vi(i.getAttributes());
                    r.set("linkHref", t),
                      o.forEach((t) => {
                        r.set(t, !0);
                      });
                    const { end: a } = n.insertContent(e.createText(t, r), s);
                    e.setSelection(a);
                  }
                  ["linkHref", ...o, ...r].forEach((t) => {
                    e.removeSelectionAttribute(t);
                  });
                } else {
                  const s = n.schema.getValidRanges(i.getRanges(), "linkHref"),
                    a = [];
                  for (const t of i.getSelectedBlocks())
                    n.schema.checkAttribute(t, "linkHref") &&
                      a.push(e.createRangeOn(t));
                  const c = a.slice();
                  for (const t of s) this._isRangeToUpdate(t, a) && c.push(t);
                  for (const n of c)
                    e.setAttribute("linkHref", t, n),
                      o.forEach((t) => {
                        e.setAttribute(t, !0, n);
                      }),
                      r.forEach((t) => {
                        e.removeAttribute(t, n);
                      });
                }
              });
            }
            _getDecoratorStateFromModel(t) {
              const e = this.editor.model,
                n = e.document.selection,
                i = n.getSelectedElement();
              return vf(i, e.schema) ? i.getAttribute(t) : n.getAttribute(t);
            }
            _isRangeToUpdate(t, e) {
              for (const n of e) if (n.containsRange(t)) return !1;
              return !0;
            }
          }
          class ZA extends ge {
            refresh() {
              const t = this.editor.model,
                e = t.document.selection,
                n = e.getSelectedElement();
              vf(n, t.schema)
                ? (this.isEnabled = t.schema.checkAttribute(n, "linkHref"))
                : (this.isEnabled = t.schema.checkAttributeInSelection(
                    e,
                    "linkHref"
                  ));
            }
            execute() {
              const t = this.editor,
                e = this.editor.model,
                n = e.document.selection,
                i = t.commands.get("link");
              e.change((t) => {
                const o = n.isCollapsed
                  ? [
                      Cg(
                        n.getFirstPosition(),
                        "linkHref",
                        n.getAttribute("linkHref"),
                        e
                      ),
                    ]
                  : e.schema.getValidRanges(n.getRanges(), "linkHref");
                for (const e of o)
                  if ((t.removeAttribute("linkHref", e), i))
                    for (const n of i.manualDecorators)
                      t.removeAttribute(n.id, e);
              });
            }
          }
          class JA {
            constructor({
              id: t,
              label: e,
              attributes: n,
              classes: i,
              styles: o,
              defaultValue: r,
            }) {
              (this.id = t),
                this.set("value"),
                (this.defaultValue = r),
                (this.label = e),
                (this.attributes = n),
                (this.classes = i),
                (this.styles = o);
            }
            _createPattern() {
              return {
                attributes: this.attributes,
                classes: this.classes,
                styles: this.styles,
              };
            }
          }
          he(JA, re);
          var XA = n(399),
            t_ = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(XA.Z, t_);
          XA.Z.locals;
          const e_ = "automatic",
            n_ = /^(https?:)?\/\//;
          class i_ extends ue {
            static get pluginName() {
              return "LinkEditing";
            }
            static get requires() {
              return [ag, tg, Ng];
            }
            constructor(t) {
              super(t),
                t.config.define("link", { addTargetToExternalLinks: !1 });
            }
            init() {
              const t = this.editor;
              t.model.schema.extend("$text", { allowAttributes: "linkHref" }),
                t.conversion
                  .for("dataDowncast")
                  .attributeToElement({ model: "linkHref", view: _f }),
                t.conversion
                  .for("editingDowncast")
                  .attributeToElement({
                    model: "linkHref",
                    view: (t, e) => _f(Cf(t), e),
                  }),
                t.conversion
                  .for("upcast")
                  .elementToAttribute({
                    view: { name: "a", attributes: { href: !0 } },
                    model: {
                      key: "linkHref",
                      value: (t) => t.getAttribute("href"),
                    },
                  }),
                t.commands.add("link", new QA(t)),
                t.commands.add("unlink", new ZA(t));
              const e = (function (t, e) {
                const n = {
                  "Open in a new tab": t("Open in a new tab"),
                  Downloadable: t("Downloadable"),
                };
                return (
                  e.forEach(
                    (t) => (t.label && n[t.label] && (t.label = n[t.label]), t)
                  ),
                  e
                );
              })(
                t.t,
                (function (t) {
                  const e = [];
                  if (t)
                    for (const [n, i] of Object.entries(t)) {
                      const t = Object.assign({}, i, { id: `link${pf(n)}` });
                      e.push(t);
                    }
                  return e;
                })(t.config.get("link.decorators"))
              );
              this._enableAutomaticDecorators(e.filter((t) => t.mode === e_)),
                this._enableManualDecorators(
                  e.filter((t) => "manual" === t.mode)
                );
              t.plugins.get(ag).registerAttribute("linkHref"),
                yg(t, "linkHref", "a", "ck-link_selected"),
                this._enableLinkOpen(),
                this._enableInsertContentSelectionAttributesFixer(),
                this._enableClickingAfterLink(),
                this._enableTypingOverLink(),
                this._handleDeleteContentAfterLink();
            }
            _enableAutomaticDecorators(t) {
              const e = this.editor,
                n = e.commands.get("link").automaticDecorators;
              e.config.get("link.addTargetToExternalLinks") &&
                n.add({
                  id: "linkIsExternal",
                  mode: e_,
                  callback: (t) => n_.test(t),
                  attributes: { target: "_blank", rel: "noopener noreferrer" },
                }),
                n.add(t),
                n.length && e.conversion.for("downcast").add(n.getDispatcher());
            }
            _enableManualDecorators(t) {
              if (!t.length) return;
              const e = this.editor,
                n = e.commands.get("link").manualDecorators;
              t.forEach((t) => {
                e.model.schema.extend("$text", { allowAttributes: t.id }),
                  (t = new JA(t)),
                  n.add(t),
                  e.conversion.for("downcast").attributeToElement({
                    model: t.id,
                    view: (e, { writer: n, schema: i }, { item: o }) => {
                      if (i.isInline(o) && e) {
                        const e = n.createAttributeElement("a", t.attributes, {
                          priority: 5,
                        });
                        t.classes && n.addClass(t.classes, e);
                        for (const i in t.styles) n.setStyle(i, t.styles[i], e);
                        return n.setCustomProperty("link", !0, e), e;
                      }
                    },
                  }),
                  e.conversion
                    .for("upcast")
                    .elementToAttribute({
                      view: { name: "a", ...t._createPattern() },
                      model: { key: t.id },
                    });
              });
            }
            _enableLinkOpen() {
              const t = this.editor,
                e = t.editing.view.document,
                n = t.model.document;
              this.listenTo(
                e,
                "click",
                (t, e) => {
                  if (!(sr.isMac ? e.domEvent.metaKey : e.domEvent.ctrlKey))
                    return;
                  let n = e.domTarget;
                  if (
                    ("a" != n.tagName.toLowerCase() && (n = n.closest("a")), !n)
                  )
                    return;
                  const i = n.getAttribute("href");
                  i && (t.stop(), e.preventDefault(), xf(i));
                },
                { context: "$capture" }
              ),
                this.listenTo(
                  e,
                  "enter",
                  (t, e) => {
                    const i = n.selection,
                      o = i.getSelectedElement(),
                      r = o
                        ? o.getAttribute("linkHref")
                        : i.getAttribute("linkHref");
                    r && e.domEvent.altKey && (t.stop(), xf(r));
                  },
                  { context: "a" }
                );
            }
            _enableInsertContentSelectionAttributesFixer() {
              const t = this.editor.model,
                e = t.document.selection;
              this.listenTo(
                t,
                "insertContent",
                () => {
                  const n = e.anchor.nodeBefore,
                    i = e.anchor.nodeAfter;
                  e.hasAttribute("linkHref") &&
                    n &&
                    n.hasAttribute("linkHref") &&
                    ((i && i.hasAttribute("linkHref")) ||
                      t.change((e) => {
                        o_(e, s_(t.schema));
                      }));
                },
                { priority: "low" }
              );
            }
            _enableClickingAfterLink() {
              const t = this.editor,
                e = t.model;
              t.editing.view.addObserver(km);
              let n = !1;
              this.listenTo(t.editing.view.document, "mousedown", () => {
                n = !0;
              }),
                this.listenTo(
                  t.editing.view.document,
                  "selectionChange",
                  () => {
                    if (!n) return;
                    n = !1;
                    const t = e.document.selection;
                    if (!t.isCollapsed) return;
                    if (!t.hasAttribute("linkHref")) return;
                    const i = t.getFirstPosition(),
                      o = Cg(i, "linkHref", t.getAttribute("linkHref"), e);
                    (i.isTouching(o.start) || i.isTouching(o.end)) &&
                      e.change((t) => {
                        o_(t, s_(e.schema));
                      });
                  }
                );
            }
            _enableTypingOverLink() {
              const t = this.editor,
                e = t.editing.view;
              let n, i;
              this.listenTo(
                e.document,
                "delete",
                () => {
                  i = !0;
                },
                { priority: "high" }
              ),
                this.listenTo(
                  t.model,
                  "deleteContent",
                  () => {
                    const e = t.model.document.selection;
                    e.isCollapsed ||
                      (i
                        ? (i = !1)
                        : r_(t) &&
                          (function (t) {
                            const e = t.document.selection,
                              n = e.getFirstPosition(),
                              i = e.getLastPosition(),
                              o = n.nodeAfter;
                            if (!o) return !1;
                            if (!o.is("$text")) return !1;
                            if (!o.hasAttribute("linkHref")) return !1;
                            const r = i.textNode || i.nodeBefore;
                            if (o === r) return !0;
                            return Cg(
                              n,
                              "linkHref",
                              o.getAttribute("linkHref"),
                              t
                            ).containsRange(t.createRange(n, i), !0);
                          })(t.model) &&
                          (n = e.getAttributes()));
                  },
                  { priority: "high" }
                ),
                this.listenTo(
                  t.model,
                  "insertContent",
                  (e, [o]) => {
                    (i = !1),
                      r_(t) &&
                        n &&
                        (t.model.change((t) => {
                          for (const [e, i] of n) t.setAttribute(e, i, o);
                        }),
                        (n = null));
                  },
                  { priority: "high" }
                );
            }
            _handleDeleteContentAfterLink() {
              const t = this.editor,
                e = t.model,
                n = e.document.selection,
                i = t.editing.view;
              let o = !1,
                r = !1;
              this.listenTo(
                i.document,
                "delete",
                (t, e) => {
                  r = e.domEvent.keyCode === dr.backspace;
                },
                { priority: "high" }
              ),
                this.listenTo(
                  e,
                  "deleteContent",
                  () => {
                    o = !1;
                    const t = n.getFirstPosition(),
                      i = n.getAttribute("linkHref");
                    if (!i) return;
                    const r = Cg(t, "linkHref", i, e);
                    o = r.containsPosition(t) || r.end.isEqual(t);
                  },
                  { priority: "high" }
                ),
                this.listenTo(
                  e,
                  "deleteContent",
                  () => {
                    r &&
                      ((r = !1),
                      o ||
                        t.model.enqueueChange((t) => {
                          o_(t, s_(e.schema));
                        }));
                  },
                  { priority: "low" }
                );
            }
          }
          function o_(t, e) {
            t.removeSelectionAttribute("linkHref");
            for (const n of e) t.removeSelectionAttribute(n);
          }
          function r_(t) {
            return t.model.change((t) => t.batch).isTyping;
          }
          function s_(t) {
            return t
              .getDefinition("$text")
              .allowAttributes.filter((t) => t.startsWith("link"));
          }
          var a_ = n(4827),
            c_ = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(a_.Z, c_);
          a_.Z.locals;
          class l_ extends Vd {
            constructor(t, e) {
              super(t);
              const n = t.t;
              (this.focusTracker = new za()),
                (this.keystrokes = new Pa()),
                (this.urlInputView = this._createUrlInput()),
                (this.saveButtonView = this._createButton(
                  n("Save"),
                  zd.check,
                  "ck-button-save"
                )),
                (this.saveButtonView.type = "submit"),
                (this.cancelButtonView = this._createButton(
                  n("Cancel"),
                  zd.cancel,
                  "ck-button-cancel",
                  "cancel"
                )),
                (this._manualDecoratorSwitches =
                  this._createManualDecoratorSwitches(e)),
                (this.children = this._createFormChildren(e.manualDecorators)),
                (this._focusables = new Od()),
                (this._focusCycler = new vh({
                  focusables: this._focusables,
                  focusTracker: this.focusTracker,
                  keystrokeHandler: this.keystrokes,
                  actions: { focusPrevious: "shift + tab", focusNext: "tab" },
                }));
              const i = ["ck", "ck-link-form", "ck-responsive-form"];
              e.manualDecorators.length &&
                i.push("ck-link-form_layout-vertical", "ck-vertical-form"),
                this.setTemplate({
                  tag: "form",
                  attributes: { class: i, tabindex: "-1" },
                  children: this.children,
                }),
                Ld(this);
            }
            getDecoratorSwitchesState() {
              return Array.from(this._manualDecoratorSwitches).reduce(
                (t, e) => ((t[e.name] = e.isOn), t),
                {}
              );
            }
            render() {
              super.render(), Rd({ view: this });
              [
                this.urlInputView,
                ...this._manualDecoratorSwitches,
                this.saveButtonView,
                this.cancelButtonView,
              ].forEach((t) => {
                this._focusables.add(t), this.focusTracker.add(t.element);
              }),
                this.keystrokes.listenTo(this.element);
            }
            destroy() {
              super.destroy(),
                this.focusTracker.destroy(),
                this.keystrokes.destroy();
            }
            focus() {
              this._focusCycler.focusFirst();
            }
            _createUrlInput() {
              const t = this.locale.t,
                e = new xu(this.locale, Eu);
              return (e.label = t("Link URL")), e;
            }
            _createButton(t, e, n, i) {
              const o = new kh(this.locale);
              return (
                o.set({ label: t, icon: e, tooltip: !0 }),
                o.extendTemplate({ attributes: { class: n } }),
                i && o.delegate("execute").to(this, i),
                o
              );
            }
            _createManualDecoratorSwitches(t) {
              const e = this.createCollection();
              for (const n of t.manualDecorators) {
                const i = new Ah(this.locale);
                i.set({ name: n.id, label: n.label, withText: !0 }),
                  i
                    .bind("isOn")
                    .toMany([n, t], "value", (t, e) =>
                      void 0 === e && void 0 === t ? n.defaultValue : t
                    ),
                  i.on("execute", () => {
                    n.set("value", !i.isOn);
                  }),
                  e.add(i);
              }
              return e;
            }
            _createFormChildren(t) {
              const e = this.createCollection();
              if ((e.add(this.urlInputView), t.length)) {
                const t = new Vd();
                t.setTemplate({
                  tag: "ul",
                  children: this._manualDecoratorSwitches.map((t) => ({
                    tag: "li",
                    children: [t],
                    attributes: { class: ["ck", "ck-list__item"] },
                  })),
                  attributes: { class: ["ck", "ck-reset", "ck-list"] },
                }),
                  e.add(t);
              }
              return (
                e.add(this.saveButtonView), e.add(this.cancelButtonView), e
              );
            }
          }
          var d_ = n(9465),
            h_ = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(d_.Z, h_);
          d_.Z.locals;
          class u_ extends Vd {
            constructor(t) {
              super(t);
              const e = t.t;
              (this.focusTracker = new za()),
                (this.keystrokes = new Pa()),
                (this.previewButtonView = this._createPreviewButton()),
                (this.unlinkButtonView = this._createButton(
                  e("Unlink"),
                  '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>',
                  "unlink"
                )),
                (this.editButtonView = this._createButton(
                  e("Edit link"),
                  zd.pencil,
                  "edit"
                )),
                this.set("href"),
                (this._focusables = new Od()),
                (this._focusCycler = new vh({
                  focusables: this._focusables,
                  focusTracker: this.focusTracker,
                  keystrokeHandler: this.keystrokes,
                  actions: { focusPrevious: "shift + tab", focusNext: "tab" },
                })),
                this.setTemplate({
                  tag: "div",
                  attributes: {
                    class: ["ck", "ck-link-actions", "ck-responsive-form"],
                    tabindex: "-1",
                  },
                  children: [
                    this.previewButtonView,
                    this.editButtonView,
                    this.unlinkButtonView,
                  ],
                });
            }
            render() {
              super.render();
              [
                this.previewButtonView,
                this.editButtonView,
                this.unlinkButtonView,
              ].forEach((t) => {
                this._focusables.add(t), this.focusTracker.add(t.element);
              }),
                this.keystrokes.listenTo(this.element);
            }
            destroy() {
              super.destroy(),
                this.focusTracker.destroy(),
                this.keystrokes.destroy();
            }
            focus() {
              this._focusCycler.focusFirst();
            }
            _createButton(t, e, n) {
              const i = new kh(this.locale);
              return (
                i.set({ label: t, icon: e, tooltip: !0 }),
                i.delegate("execute").to(this, n),
                i
              );
            }
            _createPreviewButton() {
              const t = new kh(this.locale),
                e = this.bindTemplate,
                n = this.t;
              return (
                t.set({ withText: !0, tooltip: n("Open link in new tab") }),
                t.extendTemplate({
                  attributes: {
                    class: ["ck", "ck-link-actions__preview"],
                    href: e.to("href", (t) => t && Cf(t)),
                    target: "_blank",
                    rel: "noopener noreferrer",
                  },
                }),
                t
                  .bind("label")
                  .to(this, "href", (t) => t || n("This link has no URL")),
                t.bind("isEnabled").to(this, "href", (t) => !!t),
                (t.template.tag = "a"),
                (t.template.eventListeners = {}),
                t
              );
            }
          }
          const m_ = "link-ui";
          class g_ extends ue {
            static get requires() {
              return [Hu];
            }
            static get pluginName() {
              return "LinkUI";
            }
            init() {
              const t = this.editor;
              t.editing.view.addObserver(fm),
                (this.actionsView = this._createActionsView()),
                (this.formView = this._createFormView()),
                (this._balloon = t.plugins.get(Hu)),
                this._createToolbarLinkButton(),
                this._enableUserBalloonInteractions(),
                t.conversion
                  .for("editingDowncast")
                  .markerToHighlight({
                    model: m_,
                    view: { classes: ["ck-fake-link-selection"] },
                  }),
                t.conversion
                  .for("editingDowncast")
                  .markerToElement({
                    model: m_,
                    view: {
                      name: "span",
                      classes: [
                        "ck-fake-link-selection",
                        "ck-fake-link-selection_collapsed",
                      ],
                    },
                  });
            }
            destroy() {
              super.destroy(), this.formView.destroy();
            }
            _createActionsView() {
              const t = this.editor,
                e = new u_(t.locale),
                n = t.commands.get("link"),
                i = t.commands.get("unlink");
              return (
                e.bind("href").to(n, "value"),
                e.editButtonView.bind("isEnabled").to(n),
                e.unlinkButtonView.bind("isEnabled").to(i),
                this.listenTo(e, "edit", () => {
                  this._addFormView();
                }),
                this.listenTo(e, "unlink", () => {
                  t.execute("unlink"), this._hideUI();
                }),
                e.keystrokes.set("Esc", (t, e) => {
                  this._hideUI(), e();
                }),
                e.keystrokes.set(Af, (t, e) => {
                  this._addFormView(), e();
                }),
                e
              );
            }
            _createFormView() {
              const t = this.editor,
                e = t.commands.get("link"),
                n = t.config.get("link.defaultProtocol"),
                i = new l_(t.locale, e);
              return (
                i.urlInputView.fieldView.bind("value").to(e, "value"),
                i.urlInputView.bind("isReadOnly").to(e, "isEnabled", (t) => !t),
                i.saveButtonView.bind("isEnabled").to(e),
                this.listenTo(i, "submit", () => {
                  const { value: e } = i.urlInputView.fieldView.element,
                    o = yf(e, n);
                  t.execute("link", o, i.getDecoratorSwitchesState()),
                    this._closeFormView();
                }),
                this.listenTo(i, "cancel", () => {
                  this._closeFormView();
                }),
                i.keystrokes.set("Esc", (t, e) => {
                  this._closeFormView(), e();
                }),
                i
              );
            }
            _createToolbarLinkButton() {
              const t = this.editor,
                e = t.commands.get("link"),
                n = t.t;
              t.keystrokes.set(Af, (t, n) => {
                n(), e.isEnabled && this._showUI(!0);
              }),
                t.ui.componentFactory.add("link", (t) => {
                  const i = new kh(t);
                  return (
                    (i.isEnabled = !0),
                    (i.label = n("Link")),
                    (i.icon =
                      '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>'),
                    (i.keystroke = Af),
                    (i.tooltip = !0),
                    (i.isToggleable = !0),
                    i.bind("isEnabled").to(e, "isEnabled"),
                    i.bind("isOn").to(e, "value", (t) => !!t),
                    this.listenTo(i, "execute", () => this._showUI(!0)),
                    i
                  );
                });
            }
            _enableUserBalloonInteractions() {
              const t = this.editor.editing.view.document;
              this.listenTo(t, "click", () => {
                this._getSelectedLinkElement() && this._showUI();
              }),
                this.editor.keystrokes.set(
                  "Tab",
                  (t, e) => {
                    this._areActionsVisible &&
                      !this.actionsView.focusTracker.isFocused &&
                      (this.actionsView.focus(), e());
                  },
                  { priority: "high" }
                ),
                this.editor.keystrokes.set("Esc", (t, e) => {
                  this._isUIVisible && (this._hideUI(), e());
                }),
                Pd({
                  emitter: this.formView,
                  activator: () => this._isUIInPanel,
                  contextElements: [this._balloon.view.element],
                  callback: () => this._hideUI(),
                });
            }
            _addActionsView() {
              this._areActionsInPanel ||
                this._balloon.add({
                  view: this.actionsView,
                  position: this._getBalloonPositionData(),
                });
            }
            _addFormView() {
              if (this._isFormInPanel) return;
              const t = this.editor.commands.get("link");
              this.formView.disableCssTransitions(),
                this._balloon.add({
                  view: this.formView,
                  position: this._getBalloonPositionData(),
                }),
                this._balloon.visibleView === this.formView &&
                  this.formView.urlInputView.fieldView.select(),
                this.formView.enableCssTransitions(),
                (this.formView.urlInputView.fieldView.element.value =
                  t.value || "");
            }
            _closeFormView() {
              const t = this.editor.commands.get("link");
              t.restoreManualDecoratorStates(),
                void 0 !== t.value ? this._removeFormView() : this._hideUI();
            }
            _removeFormView() {
              this._isFormInPanel &&
                (this.formView.saveButtonView.focus(),
                this._balloon.remove(this.formView),
                this.editor.editing.view.focus(),
                this._hideFakeVisualSelection());
            }
            _showUI(t = !1) {
              this._getSelectedLinkElement()
                ? (this._areActionsVisible
                    ? this._addFormView()
                    : this._addActionsView(),
                  t && this._balloon.showStack("main"))
                : (this._showFakeVisualSelection(),
                  this._addActionsView(),
                  t && this._balloon.showStack("main"),
                  this._addFormView()),
                this._startUpdatingUI();
            }
            _hideUI() {
              if (!this._isUIInPanel) return;
              const t = this.editor;
              this.stopListening(t.ui, "update"),
                this.stopListening(this._balloon, "change:visibleView"),
                t.editing.view.focus(),
                this._removeFormView(),
                this._balloon.remove(this.actionsView),
                this._hideFakeVisualSelection();
            }
            _startUpdatingUI() {
              const t = this.editor,
                e = t.editing.view.document;
              let n = this._getSelectedLinkElement(),
                i = r();
              const o = () => {
                const t = this._getSelectedLinkElement(),
                  e = r();
                (n && !t) || (!n && e !== i)
                  ? this._hideUI()
                  : this._isUIVisible &&
                    this._balloon.updatePosition(
                      this._getBalloonPositionData()
                    ),
                  (n = t),
                  (i = e);
              };
              function r() {
                return e.selection.focus
                  .getAncestors()
                  .reverse()
                  .find((t) => t.is("element"));
              }
              this.listenTo(t.ui, "update", o),
                this.listenTo(this._balloon, "change:visibleView", o);
            }
            get _isFormInPanel() {
              return this._balloon.hasView(this.formView);
            }
            get _areActionsInPanel() {
              return this._balloon.hasView(this.actionsView);
            }
            get _areActionsVisible() {
              return this._balloon.visibleView === this.actionsView;
            }
            get _isUIInPanel() {
              return this._isFormInPanel || this._areActionsInPanel;
            }
            get _isUIVisible() {
              return (
                this._balloon.visibleView == this.formView ||
                this._areActionsVisible
              );
            }
            _getBalloonPositionData() {
              const t = this.editor.editing.view,
                e = this.editor.model,
                n = t.document;
              let i = null;
              if (e.markers.has(m_)) {
                const e = Array.from(
                    this.editor.editing.mapper.markerNameToElements(m_)
                  ),
                  n = t.createRange(
                    t.createPositionBefore(e[0]),
                    t.createPositionAfter(e[e.length - 1])
                  );
                i = t.domConverter.viewRangeToDom(n);
              } else
                i = () => {
                  const e = this._getSelectedLinkElement();
                  return e
                    ? t.domConverter.mapViewToDom(e)
                    : t.domConverter.viewRangeToDom(
                        n.selection.getFirstRange()
                      );
                };
              return { target: i };
            }
            _getSelectedLinkElement() {
              const t = this.editor.editing.view,
                e = t.document.selection,
                n = e.getSelectedElement();
              if (e.isCollapsed || (n && qg(n)))
                return p_(e.getFirstPosition());
              {
                const n = e.getFirstRange().getTrimmed(),
                  i = p_(n.start),
                  o = p_(n.end);
                return i && i == o && t.createRangeIn(i).getTrimmed().isEqual(n)
                  ? i
                  : null;
              }
            }
            _showFakeVisualSelection() {
              const t = this.editor.model;
              t.change((e) => {
                const n = t.document.selection.getFirstRange();
                if (t.markers.has(m_)) e.updateMarker(m_, { range: n });
                else if (n.start.isAtEnd) {
                  const i = n.start.getLastMatchingPosition(
                    ({ item: e }) => !t.schema.isContent(e),
                    { boundaries: n }
                  );
                  e.addMarker(m_, {
                    usingOperation: !1,
                    affectsData: !1,
                    range: e.createRange(i, n.end),
                  });
                } else
                  e.addMarker(m_, {
                    usingOperation: !1,
                    affectsData: !1,
                    range: n,
                  });
              });
            }
            _hideFakeVisualSelection() {
              const t = this.editor.model;
              t.markers.has(m_) &&
                t.change((t) => {
                  t.removeMarker(m_);
                });
            }
          }
          function p_(t) {
            return t.getAncestors().find((t) => {
              return (
                (e = t).is("attributeElement") && !!e.getCustomProperty("link")
              );
              var e;
            });
          }
          class f_ extends ge {
            constructor(t, e) {
              super(t), (this.type = e);
            }
            refresh() {
              (this.value = this._getValue()),
                (this.isEnabled = this._checkEnabled());
            }
            execute(t = {}) {
              const e = this.editor.model,
                n = e.document,
                i = Array.from(n.selection.getSelectedBlocks()).filter((t) =>
                  b_(t, e.schema)
                ),
                o = void 0 !== t.forceValue ? !t.forceValue : this.value;
              e.change((t) => {
                if (o) {
                  let e = i[i.length - 1].nextSibling,
                    n = Number.POSITIVE_INFINITY,
                    o = [];
                  for (
                    ;
                    e &&
                    "listItem" == e.name &&
                    0 !== e.getAttribute("listIndent");

                  ) {
                    const t = e.getAttribute("listIndent");
                    t < n && (n = t);
                    const i = t - n;
                    o.push({ element: e, listIndent: i }), (e = e.nextSibling);
                  }
                  o = o.reverse();
                  for (const e of o)
                    t.setAttribute("listIndent", e.listIndent, e.element);
                }
                if (!o) {
                  let t = Number.POSITIVE_INFINITY;
                  for (const e of i)
                    e.is("element", "listItem") &&
                      e.getAttribute("listIndent") < t &&
                      (t = e.getAttribute("listIndent"));
                  (t = 0 === t ? 1 : t), k_(i, !0, t), k_(i, !1, t);
                }
                for (const e of i.reverse())
                  o && "listItem" == e.name
                    ? t.rename(e, "paragraph")
                    : o || "listItem" == e.name
                    ? o ||
                      "listItem" != e.name ||
                      e.getAttribute("listType") == this.type ||
                      t.setAttribute("listType", this.type, e)
                    : (t.setAttributes(
                        { listType: this.type, listIndent: 0 },
                        e
                      ),
                      t.rename(e, "listItem"));
                this.fire("_executeCleanup", i);
              });
            }
            _getValue() {
              const t = Na(
                this.editor.model.document.selection.getSelectedBlocks()
              );
              return (
                !!t &&
                t.is("element", "listItem") &&
                t.getAttribute("listType") == this.type
              );
            }
            _checkEnabled() {
              if (this.value) return !0;
              const t = this.editor.model.document.selection,
                e = this.editor.model.schema,
                n = Na(t.getSelectedBlocks());
              return !!n && b_(n, e);
            }
          }
          function k_(t, e, n) {
            const i = e ? t[0] : t[t.length - 1];
            if (i.is("element", "listItem")) {
              let o = i[e ? "previousSibling" : "nextSibling"],
                r = i.getAttribute("listIndent");
              for (
                ;
                o &&
                o.is("element", "listItem") &&
                o.getAttribute("listIndent") >= n;

              )
                r > o.getAttribute("listIndent") &&
                  (r = o.getAttribute("listIndent")),
                  o.getAttribute("listIndent") == r &&
                    t[e ? "unshift" : "push"](o),
                  (o = o[e ? "previousSibling" : "nextSibling"]);
            }
          }
          function b_(t, e) {
            return e.checkChild(t.parent, "listItem") && !e.isObject(t);
          }
          class w_ extends ge {
            constructor(t, e) {
              super(t), (this._indentBy = "forward" == e ? 1 : -1);
            }
            refresh() {
              this.isEnabled = this._checkEnabled();
            }
            execute() {
              const t = this.editor.model,
                e = t.document;
              let n = Array.from(e.selection.getSelectedBlocks());
              t.change((t) => {
                const e = n[n.length - 1];
                let i = e.nextSibling;
                for (
                  ;
                  i &&
                  "listItem" == i.name &&
                  i.getAttribute("listIndent") > e.getAttribute("listIndent");

                )
                  n.push(i), (i = i.nextSibling);
                this._indentBy < 0 && (n = n.reverse());
                for (const e of n) {
                  const n = e.getAttribute("listIndent") + this._indentBy;
                  n < 0
                    ? t.rename(e, "paragraph")
                    : t.setAttribute("listIndent", n, e);
                }
                this.fire("_executeCleanup", n);
              });
            }
            _checkEnabled() {
              const t = Na(
                this.editor.model.document.selection.getSelectedBlocks()
              );
              if (!t || !t.is("element", "listItem")) return !1;
              if (this._indentBy > 0) {
                const e = t.getAttribute("listIndent"),
                  n = t.getAttribute("listType");
                let i = t.previousSibling;
                for (
                  ;
                  i &&
                  i.is("element", "listItem") &&
                  i.getAttribute("listIndent") >= e;

                ) {
                  if (i.getAttribute("listIndent") == e)
                    return i.getAttribute("listType") == n;
                  i = i.previousSibling;
                }
                return !1;
              }
              return !0;
            }
          }
          function A_(t, e) {
            const n = e.mapper,
              i = e.writer,
              o = "numbered" == t.getAttribute("listType") ? "ol" : "ul",
              r = (function (t) {
                const e = t.createContainerElement("li");
                return (e.getFillerOffset = E_), e;
              })(i),
              s = i.createContainerElement(o, null);
            return (
              i.insert(i.createPositionAt(s, 0), r), n.bindElements(t, r), r
            );
          }
          function __(t, e, n, i) {
            const o = e.parent,
              r = n.mapper,
              s = n.writer;
            let a = r.toViewPosition(i.createPositionBefore(t));
            const c = y_(t.previousSibling, {
                sameIndent: !0,
                smallerIndent: !0,
                listIndent: t.getAttribute("listIndent"),
              }),
              l = t.previousSibling;
            if (
              c &&
              c.getAttribute("listIndent") == t.getAttribute("listIndent")
            ) {
              const t = r.toViewElement(c);
              a = s.breakContainer(s.createPositionAfter(t));
            } else if (l && "listItem" == l.name) {
              a = r.toViewPosition(i.createPositionAt(l, "end"));
              const t = r.findMappedViewAncestor(a),
                e = (function (t) {
                  for (const e of t.getChildren())
                    if ("ul" == e.name || "ol" == e.name) return e;
                  return null;
                })(t);
              a = e ? s.createPositionBefore(e) : s.createPositionAt(t, "end");
            } else a = r.toViewPosition(i.createPositionBefore(t));
            if (((a = v_(a)), s.insert(a, o), l && "listItem" == l.name)) {
              const t = r.toViewElement(l),
                n = s
                  .createRange(s.createPositionAt(t, 0), a)
                  .getWalker({ ignoreElementEnd: !0 });
              for (const t of n)
                if (t.item.is("element", "li")) {
                  const i = s.breakContainer(s.createPositionBefore(t.item)),
                    o = t.item.parent,
                    r = s.createPositionAt(e, "end");
                  C_(s, r.nodeBefore, r.nodeAfter),
                    s.move(s.createRangeOn(o), r),
                    (n.position = i);
                }
            } else {
              const n = o.nextSibling;
              if (n && (n.is("element", "ul") || n.is("element", "ol"))) {
                let i = null;
                for (const e of n.getChildren()) {
                  const n = r.toModelElement(e);
                  if (
                    !(
                      n &&
                      n.getAttribute("listIndent") >
                        t.getAttribute("listIndent")
                    )
                  )
                    break;
                  i = e;
                }
                i &&
                  (s.breakContainer(s.createPositionAfter(i)),
                  s.move(
                    s.createRangeOn(i.parent),
                    s.createPositionAt(e, "end")
                  ));
              }
            }
            C_(s, o, o.nextSibling), C_(s, o.previousSibling, o);
          }
          function C_(t, e, n) {
            return !e ||
              !n ||
              ("ul" != e.name && "ol" != e.name) ||
              e.name != n.name ||
              e.getAttribute("class") !== n.getAttribute("class")
              ? null
              : t.mergeContainers(t.createPositionAfter(e));
          }
          function v_(t) {
            return t.getLastMatchingPosition((t) => t.item.is("uiElement"));
          }
          function y_(t, e) {
            const n = !!e.sameIndent,
              i = !!e.smallerIndent,
              o = e.listIndent;
            let r = t;
            for (; r && "listItem" == r.name; ) {
              const t = r.getAttribute("listIndent");
              if ((n && o == t) || (i && o > t)) return r;
              r = "forward" === e.direction ? r.nextSibling : r.previousSibling;
            }
            return null;
          }
          function x_(t, e, n, i) {
            t.ui.componentFactory.add(e, (o) => {
              const r = t.commands.get(e),
                s = new kh(o);
              return (
                s.set({ label: n, icon: i, tooltip: !0, isToggleable: !0 }),
                s.bind("isOn", "isEnabled").to(r, "value", "isEnabled"),
                s.on("execute", () => {
                  t.execute(e), t.editing.view.focus();
                }),
                s
              );
            });
          }
          function E_() {
            const t =
              !this.isEmpty &&
              ("ul" == this.getChild(0).name || "ol" == this.getChild(0).name);
            return this.isEmpty || t ? 0 : No.call(this);
          }
          function D_(t) {
            return (e, n, i) => {
              const o = i.consumable;
              if (
                !o.test(n.item, "insert") ||
                !o.test(n.item, "attribute:listType") ||
                !o.test(n.item, "attribute:listIndent")
              )
                return;
              o.consume(n.item, "insert"),
                o.consume(n.item, "attribute:listType"),
                o.consume(n.item, "attribute:listIndent");
              const r = n.item;
              __(r, A_(r, i), i, t);
            };
          }
          function S_(t, e, n) {
            if (!n.consumable.test(e.item, t.name)) return;
            const i = n.mapper.toViewElement(e.item),
              o = n.writer;
            o.breakContainer(o.createPositionBefore(i)),
              o.breakContainer(o.createPositionAfter(i));
            const r = i.parent,
              s = "numbered" == e.attributeNewValue ? "ol" : "ul";
            o.rename(s, r);
          }
          function I_(t, e, n) {
            n.consumable.consume(e.item, t.name);
            const i = n.mapper.toViewElement(e.item).parent,
              o = n.writer;
            C_(o, i, i.nextSibling), C_(o, i.previousSibling, i);
          }
          function T_(t, e, n) {
            if (
              n.consumable.test(e.item, t.name) &&
              "listItem" != e.item.name
            ) {
              let t = n.mapper.toViewPosition(e.range.start);
              const i = n.writer,
                o = [];
              for (
                ;
                ("ul" == t.parent.name || "ol" == t.parent.name) &&
                ((t = i.breakContainer(t)), "li" == t.parent.name);

              ) {
                const e = t,
                  n = i.createPositionAt(t.parent, "end");
                if (!e.isEqual(n)) {
                  const t = i.remove(i.createRange(e, n));
                  o.push(t);
                }
                t = i.createPositionAfter(t.parent);
              }
              if (o.length > 0) {
                for (let e = 0; e < o.length; e++) {
                  const n = t.nodeBefore;
                  if (((t = i.insert(t, o[e]).end), e > 0)) {
                    const e = C_(i, n, n.nextSibling);
                    e && e.parent == n && t.offset--;
                  }
                }
                C_(i, t.nodeBefore, t.nodeAfter);
              }
            }
          }
          function M_(t, e, n) {
            const i = n.mapper.toViewPosition(e.position),
              o = i.nodeBefore,
              r = i.nodeAfter;
            C_(n.writer, o, r);
          }
          function B_(t, e, n) {
            if (n.consumable.consume(e.viewItem, { name: !0 })) {
              const t = n.writer,
                i = t.createElement("listItem"),
                o = (function (t) {
                  let e = 0,
                    n = t.parent;
                  for (; n; ) {
                    if (n.is("element", "li")) e++;
                    else {
                      const t = n.previousSibling;
                      t && t.is("element", "li") && e++;
                    }
                    n = n.parent;
                  }
                  return e;
                })(e.viewItem);
              t.setAttribute("listIndent", o, i);
              const r =
                e.viewItem.parent && "ol" == e.viewItem.parent.name
                  ? "numbered"
                  : "bulleted";
              if (
                (t.setAttribute("listType", r, i),
                !n.safeInsert(i, e.modelCursor))
              )
                return;
              const s = (function (t, e, n) {
                const { writer: i, schema: o } = n;
                let r = i.createPositionAfter(t);
                for (const s of e)
                  if ("ul" == s.name || "ol" == s.name)
                    r = n.convertItem(s, r).modelCursor;
                  else {
                    const e = n.convertItem(s, i.createPositionAt(t, "end")),
                      a = e.modelRange.start.nodeAfter;
                    a &&
                      a.is("element") &&
                      !o.checkChild(t, a.name) &&
                      ((t = e.modelCursor.parent.is("element", "listItem")
                        ? e.modelCursor.parent
                        : R_(e.modelCursor)),
                      (r = i.createPositionAfter(t)));
                  }
                return r;
              })(i, e.viewItem.getChildren(), n);
              (e.modelRange = t.createRange(e.modelCursor, s)),
                n.updateConversionResult(i, e);
            }
          }
          function N_(t, e, n) {
            if (n.consumable.test(e.viewItem, { name: !0 })) {
              const t = Array.from(e.viewItem.getChildren());
              for (const e of t) {
                !(e.is("element", "li") || j_(e)) && e._remove();
              }
            }
          }
          function z_(t, e, n) {
            if (n.consumable.test(e.viewItem, { name: !0 })) {
              if (0 === e.viewItem.childCount) return;
              const t = [...e.viewItem.getChildren()];
              let n = !1;
              for (const e of t) n && !j_(e) && e._remove(), j_(e) && (n = !0);
            }
          }
          function P_(t) {
            return (e, n) => {
              if (n.isPhantom) return;
              const i = n.modelPosition.nodeBefore;
              if (i && i.is("element", "listItem")) {
                const e = n.mapper.toViewElement(i),
                  o = e.getAncestors().find(j_),
                  r = t.createPositionAt(e, 0).getWalker();
                for (const t of r) {
                  if ("elementStart" == t.type && t.item.is("element", "li")) {
                    n.viewPosition = t.previousPosition;
                    break;
                  }
                  if ("elementEnd" == t.type && t.item == o) {
                    n.viewPosition = t.nextPosition;
                    break;
                  }
                }
              }
            };
          }
          function L_(t, [e, n]) {
            let i,
              o = e.is("documentFragment") ? e.getChild(0) : e;
            if (
              ((i = n ? this.createSelection(n) : this.document.selection),
              o && o.is("element", "listItem"))
            ) {
              const t = i.getFirstPosition();
              let e = null;
              if (
                (t.parent.is("element", "listItem")
                  ? (e = t.parent)
                  : t.nodeBefore &&
                    t.nodeBefore.is("element", "listItem") &&
                    (e = t.nodeBefore),
                e)
              ) {
                const t = e.getAttribute("listIndent");
                if (t > 0)
                  for (; o && o.is("element", "listItem"); )
                    o._setAttribute(
                      "listIndent",
                      o.getAttribute("listIndent") + t
                    ),
                      (o = o.nextSibling);
              }
            }
          }
          function R_(t) {
            const e = new $a({ startPosition: t });
            let n;
            do {
              n = e.next();
            } while (!n.value.item.is("element", "listItem"));
            return n.value.item;
          }
          function O_(t, e, n, i, o, r) {
            const s = y_(e.nodeBefore, {
                sameIndent: !0,
                smallerIndent: !0,
                listIndent: t,
                foo: "b",
              }),
              a = o.mapper,
              c = o.writer,
              l = s ? s.getAttribute("listIndent") : null;
            let d;
            if (s)
              if (l == t) {
                const t = a.toViewElement(s).parent;
                d = c.createPositionAfter(t);
              } else {
                const t = r.createPositionAt(s, "end");
                d = a.toViewPosition(t);
              }
            else d = n;
            d = v_(d);
            for (const t of [...i.getChildren()])
              j_(t) &&
                ((d = c.move(c.createRangeOn(t), d).end),
                C_(c, t, t.nextSibling),
                C_(c, t.previousSibling, t));
          }
          function j_(t) {
            return t.is("element", "ol") || t.is("element", "ul");
          }
          class F_ extends ue {
            static get pluginName() {
              return "ListEditing";
            }
            static get requires() {
              return [Og, ig];
            }
            init() {
              const t = this.editor;
              t.model.schema.register("listItem", {
                inheritAllFrom: "$block",
                allowAttributes: ["listType", "listIndent"],
              });
              const e = t.data,
                n = t.editing;
              var i;
              t.model.document.registerPostFixer((e) =>
                (function (t, e) {
                  const n = t.document.differ.getChanges(),
                    i = new Map();
                  let o = !1;
                  for (const i of n)
                    if ("insert" == i.type && "listItem" == i.name)
                      r(i.position);
                    else if ("insert" == i.type && "listItem" != i.name) {
                      if ("$text" != i.name) {
                        const n = i.position.nodeAfter;
                        n.hasAttribute("listIndent") &&
                          (e.removeAttribute("listIndent", n), (o = !0)),
                          n.hasAttribute("listType") &&
                            (e.removeAttribute("listType", n), (o = !0)),
                          n.hasAttribute("listStyle") &&
                            (e.removeAttribute("listStyle", n), (o = !0)),
                          n.hasAttribute("listReversed") &&
                            (e.removeAttribute("listReversed", n), (o = !0)),
                          n.hasAttribute("listStart") &&
                            (e.removeAttribute("listStart", n), (o = !0));
                        for (const e of Array.from(t.createRangeIn(n)).filter(
                          (t) => t.item.is("element", "listItem")
                        ))
                          r(e.previousPosition);
                      }
                      r(i.position.getShiftedBy(i.length));
                    } else
                      "remove" == i.type && "listItem" == i.name
                        ? r(i.position)
                        : (("attribute" == i.type &&
                            "listIndent" == i.attributeKey) ||
                            ("attribute" == i.type &&
                              "listType" == i.attributeKey)) &&
                          r(i.range.start);
                  for (const t of i.values()) s(t), a(t);
                  return o;
                  function r(t) {
                    const e = t.nodeBefore;
                    if (e && e.is("element", "listItem")) {
                      let t = e;
                      if (i.has(t)) return;
                      for (
                        let e = t.previousSibling;
                        e && e.is("element", "listItem");
                        e = t.previousSibling
                      )
                        if (((t = e), i.has(t))) return;
                      i.set(e, t);
                    } else {
                      const e = t.nodeAfter;
                      e && e.is("element", "listItem") && i.set(e, e);
                    }
                  }
                  function s(t) {
                    let n = 0,
                      i = null;
                    for (; t && t.is("element", "listItem"); ) {
                      const r = t.getAttribute("listIndent");
                      if (r > n) {
                        let s;
                        null === i
                          ? ((i = r - n), (s = n))
                          : (i > r && (i = r), (s = r - i)),
                          e.setAttribute("listIndent", s, t),
                          (o = !0);
                      } else (i = null), (n = t.getAttribute("listIndent") + 1);
                      t = t.nextSibling;
                    }
                  }
                  function a(t) {
                    let n = [],
                      i = null;
                    for (; t && t.is("element", "listItem"); ) {
                      const r = t.getAttribute("listIndent");
                      if (
                        (i &&
                          i.getAttribute("listIndent") > r &&
                          (n = n.slice(0, r + 1)),
                        0 != r)
                      )
                        if (n[r]) {
                          const i = n[r];
                          t.getAttribute("listType") != i &&
                            (e.setAttribute("listType", i, t), (o = !0));
                        } else n[r] = t.getAttribute("listType");
                      (i = t), (t = t.nextSibling);
                    }
                  }
                })(t.model, e)
              ),
                n.mapper.registerViewToModelLength("li", V_),
                e.mapper.registerViewToModelLength("li", V_),
                n.mapper.on("modelToViewPosition", P_(n.view)),
                n.mapper.on(
                  "viewToModelPosition",
                  ((i = t.model),
                  (t, e) => {
                    const n = e.viewPosition,
                      o = n.parent,
                      r = e.mapper;
                    if ("ul" == o.name || "ol" == o.name) {
                      if (n.isAtEnd) {
                        const t = r.toModelElement(n.nodeBefore),
                          o = r.getModelLength(n.nodeBefore);
                        e.modelPosition = i
                          .createPositionBefore(t)
                          .getShiftedBy(o);
                      } else {
                        const t = r.toModelElement(n.nodeAfter);
                        e.modelPosition = i.createPositionBefore(t);
                      }
                      t.stop();
                    } else if (
                      "li" == o.name &&
                      n.nodeBefore &&
                      ("ul" == n.nodeBefore.name || "ol" == n.nodeBefore.name)
                    ) {
                      const s = r.toModelElement(o);
                      let a = 1,
                        c = n.nodeBefore;
                      for (; c && j_(c); )
                        (a += r.getModelLength(c)), (c = c.previousSibling);
                      (e.modelPosition = i
                        .createPositionBefore(s)
                        .getShiftedBy(a)),
                        t.stop();
                    }
                  })
                ),
                e.mapper.on("modelToViewPosition", P_(n.view)),
                t.conversion.for("editingDowncast").add((e) => {
                  e.on("insert", T_, { priority: "high" }),
                    e.on("insert:listItem", D_(t.model)),
                    e.on("attribute:listType:listItem", S_, {
                      priority: "high",
                    }),
                    e.on("attribute:listType:listItem", I_, {
                      priority: "low",
                    }),
                    e.on(
                      "attribute:listIndent:listItem",
                      (function (t) {
                        return (e, n, i) => {
                          if (
                            !i.consumable.consume(
                              n.item,
                              "attribute:listIndent"
                            )
                          )
                            return;
                          const o = i.mapper.toViewElement(n.item),
                            r = i.writer;
                          r.breakContainer(r.createPositionBefore(o)),
                            r.breakContainer(r.createPositionAfter(o));
                          const s = o.parent,
                            a = s.previousSibling,
                            c = r.createRangeOn(s);
                          r.remove(c),
                            a && a.nextSibling && C_(r, a, a.nextSibling),
                            O_(
                              n.attributeOldValue + 1,
                              n.range.start,
                              c.start,
                              o,
                              i,
                              t
                            ),
                            __(n.item, o, i, t);
                          for (const t of n.item.getChildren())
                            i.consumable.consume(t, "insert");
                        };
                      })(t.model)
                    ),
                    e.on(
                      "remove:listItem",
                      (function (t) {
                        return (e, n, i) => {
                          const o = i.mapper
                              .toViewPosition(n.position)
                              .getLastMatchingPosition(
                                (t) => !t.item.is("element", "li")
                              ).nodeAfter,
                            r = i.writer;
                          r.breakContainer(r.createPositionBefore(o)),
                            r.breakContainer(r.createPositionAfter(o));
                          const s = o.parent,
                            a = s.previousSibling,
                            c = r.createRangeOn(s),
                            l = r.remove(c);
                          a && a.nextSibling && C_(r, a, a.nextSibling),
                            O_(
                              i.mapper
                                .toModelElement(o)
                                .getAttribute("listIndent") + 1,
                              n.position,
                              c.start,
                              o,
                              i,
                              t
                            );
                          for (const t of r.createRangeIn(l).getItems())
                            i.mapper.unbindViewElement(t);
                          e.stop();
                        };
                      })(t.model)
                    ),
                    e.on("remove", M_, { priority: "low" });
                }),
                t.conversion.for("dataDowncast").add((e) => {
                  e.on("insert", T_, { priority: "high" }),
                    e.on("insert:listItem", D_(t.model));
                }),
                t.conversion.for("upcast").add((t) => {
                  t.on("element:ul", N_, { priority: "high" }),
                    t.on("element:ol", N_, { priority: "high" }),
                    t.on("element:li", z_, { priority: "high" }),
                    t.on("element:li", B_);
                }),
                t.model.on("insertContent", L_, { priority: "high" }),
                t.commands.add("numberedList", new f_(t, "numbered")),
                t.commands.add("bulletedList", new f_(t, "bulleted")),
                t.commands.add("indentList", new w_(t, "forward")),
                t.commands.add("outdentList", new w_(t, "backward"));
              const o = n.view.document;
              this.listenTo(
                o,
                "enter",
                (t, e) => {
                  const n = this.editor.model.document,
                    i = n.selection.getLastPosition().parent;
                  n.selection.isCollapsed &&
                    "listItem" == i.name &&
                    i.isEmpty &&
                    (this.editor.execute("outdentList"),
                    e.preventDefault(),
                    t.stop());
                },
                { context: "li" }
              ),
                this.listenTo(
                  o,
                  "delete",
                  (t, e) => {
                    if ("backward" !== e.direction) return;
                    const n = this.editor.model.document.selection;
                    if (!n.isCollapsed) return;
                    const i = n.getFirstPosition();
                    if (!i.isAtStart) return;
                    const o = i.parent;
                    if ("listItem" !== o.name) return;
                    (o.previousSibling &&
                      "listItem" === o.previousSibling.name) ||
                      (this.editor.execute("outdentList"),
                      e.preventDefault(),
                      t.stop());
                  },
                  { context: "li" }
                ),
                this.listenTo(
                  t.editing.view.document,
                  "tab",
                  (e, n) => {
                    const i = n.shiftKey ? "outdentList" : "indentList";
                    this.editor.commands.get(i).isEnabled &&
                      (t.execute(i),
                      n.stopPropagation(),
                      n.preventDefault(),
                      e.stop());
                  },
                  { context: "li" }
                );
            }
            afterInit() {
              const t = this.editor.commands,
                e = t.get("indent"),
                n = t.get("outdent");
              e && e.registerChildCommand(t.get("indentList")),
                n && n.registerChildCommand(t.get("outdentList"));
            }
          }
          function V_(t) {
            let e = 1;
            for (const n of t.getChildren())
              if ("ul" == n.name || "ol" == n.name)
                for (const t of n.getChildren()) e += V_(t);
            return e;
          }
          class H_ extends ue {
            static get pluginName() {
              return "ListUI";
            }
            init() {
              const t = this.editor.t;
              x_(
                this.editor,
                "numberedList",
                t("Numbered List"),
                '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>'
              ),
                x_(
                  this.editor,
                  "bulletedList",
                  t("Bulleted List"),
                  '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>'
                );
            }
          }
          function U_() {
            return {
              baseUrl: null,
              breaks: !1,
              extensions: null,
              gfm: !0,
              headerIds: !0,
              headerPrefix: "",
              highlight: null,
              langPrefix: "language-",
              mangle: !0,
              pedantic: !1,
              renderer: null,
              sanitize: !1,
              sanitizer: null,
              silent: !1,
              smartLists: !1,
              smartypants: !1,
              tokenizer: null,
              walkTokens: null,
              xhtml: !1,
            };
          }
          let $_ = {
            baseUrl: null,
            breaks: !1,
            extensions: null,
            gfm: !0,
            headerIds: !0,
            headerPrefix: "",
            highlight: null,
            langPrefix: "language-",
            mangle: !0,
            pedantic: !1,
            renderer: null,
            sanitize: !1,
            sanitizer: null,
            silent: !1,
            smartLists: !1,
            smartypants: !1,
            tokenizer: null,
            walkTokens: null,
            xhtml: !1,
          };
          const q_ = /[&<>"']/,
            G_ = /[&<>"']/g,
            W_ = /[<>"']|&(?!#?\w+;)/,
            Y_ = /[<>"']|&(?!#?\w+;)/g,
            K_ = {
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;",
            },
            Q_ = (t) => K_[t];
          function Z_(t, e) {
            if (e) {
              if (q_.test(t)) return t.replace(G_, Q_);
            } else if (W_.test(t)) return t.replace(Y_, Q_);
            return t;
          }
          const J_ = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi;
          function X_(t) {
            return t.replace(J_, (t, e) =>
              "colon" === (e = e.toLowerCase())
                ? ":"
                : "#" === e.charAt(0)
                ? "x" === e.charAt(1)
                  ? String.fromCharCode(parseInt(e.substring(2), 16))
                  : String.fromCharCode(+e.substring(1))
                : ""
            );
          }
          const tC = /(^|[^\[])\^/g;
          function eC(t, e) {
            (t = t.source || t), (e = e || "");
            const n = {
              replace: (e, i) => (
                (i = (i = i.source || i).replace(tC, "$1")),
                (t = t.replace(e, i)),
                n
              ),
              getRegex: () => new RegExp(t, e),
            };
            return n;
          }
          const nC = /[^\w:]/g,
            iC = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;
          function oC(t, e, n) {
            if (t) {
              let t;
              try {
                t = decodeURIComponent(X_(n)).replace(nC, "").toLowerCase();
              } catch (t) {
                return null;
              }
              if (
                0 === t.indexOf("javascript:") ||
                0 === t.indexOf("vbscript:") ||
                0 === t.indexOf("data:")
              )
                return null;
            }
            e &&
              !iC.test(n) &&
              (n = (function (t, e) {
                rC[" " + t] ||
                  (sC.test(t)
                    ? (rC[" " + t] = t + "/")
                    : (rC[" " + t] = uC(t, "/", !0)));
                const n = -1 === (t = rC[" " + t]).indexOf(":");
                return "//" === e.substring(0, 2)
                  ? n
                    ? e
                    : t.replace(aC, "$1") + e
                  : "/" === e.charAt(0)
                  ? n
                    ? e
                    : t.replace(cC, "$1") + e
                  : t + e;
              })(e, n));
            try {
              n = encodeURI(n).replace(/%25/g, "%");
            } catch (t) {
              return null;
            }
            return n;
          }
          const rC = {},
            sC = /^[^:]+:\/*[^/]*$/,
            aC = /^([^:]+:)[\s\S]*$/,
            cC = /^([^:]+:\/*[^/]*)[\s\S]*$/;
          const lC = { exec: function () {} };
          function dC(t) {
            let e,
              n,
              i = 1;
            for (; i < arguments.length; i++)
              for (n in ((e = arguments[i]), e))
                Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
            return t;
          }
          function hC(t, e) {
            const n = t
              .replace(/\|/g, (t, e, n) => {
                let i = !1,
                  o = e;
                for (; --o >= 0 && "\\" === n[o]; ) i = !i;
                return i ? "|" : " |";
              })
              .split(/ \|/);
            let i = 0;
            if (
              (n[0].trim() || n.shift(),
              n.length > 0 && !n[n.length - 1].trim() && n.pop(),
              n.length > e)
            )
              n.splice(e);
            else for (; n.length < e; ) n.push("");
            for (; i < n.length; i++) n[i] = n[i].trim().replace(/\\\|/g, "|");
            return n;
          }
          function uC(t, e, n) {
            const i = t.length;
            if (0 === i) return "";
            let o = 0;
            for (; o < i; ) {
              const r = t.charAt(i - o - 1);
              if (r !== e || n) {
                if (r === e || !n) break;
                o++;
              } else o++;
            }
            return t.substr(0, i - o);
          }
          function mC(t) {
            t &&
              t.sanitize &&
              !t.silent &&
              console.warn(
                "marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options"
              );
          }
          function gC(t, e) {
            if (e < 1) return "";
            let n = "";
            for (; e > 1; ) 1 & e && (n += t), (e >>= 1), (t += t);
            return n + t;
          }
          function pC(t, e, n, i) {
            const o = e.href,
              r = e.title ? Z_(e.title) : null,
              s = t[1].replace(/\\([\[\]])/g, "$1");
            if ("!" !== t[0].charAt(0)) {
              i.state.inLink = !0;
              const t = {
                type: "link",
                raw: n,
                href: o,
                title: r,
                text: s,
                tokens: i.inlineTokens(s, []),
              };
              return (i.state.inLink = !1), t;
            }
            return { type: "image", raw: n, href: o, title: r, text: Z_(s) };
          }
          class fC {
            constructor(t) {
              this.options = t || $_;
            }
            space(t) {
              const e = this.rules.block.newline.exec(t);
              if (e && e[0].length > 0) return { type: "space", raw: e[0] };
            }
            code(t) {
              const e = this.rules.block.code.exec(t);
              if (e) {
                const t = e[0].replace(/^ {1,4}/gm, "");
                return {
                  type: "code",
                  raw: e[0],
                  codeBlockStyle: "indented",
                  text: this.options.pedantic ? t : uC(t, "\n"),
                };
              }
            }
            fences(t) {
              const e = this.rules.block.fences.exec(t);
              if (e) {
                const t = e[0],
                  n = (function (t, e) {
                    const n = t.match(/^(\s+)(?:```)/);
                    if (null === n) return e;
                    const i = n[1];
                    return e
                      .split("\n")
                      .map((t) => {
                        const e = t.match(/^\s+/);
                        if (null === e) return t;
                        const [n] = e;
                        return n.length >= i.length ? t.slice(i.length) : t;
                      })
                      .join("\n");
                  })(t, e[3] || "");
                return {
                  type: "code",
                  raw: t,
                  lang: e[2] ? e[2].trim() : e[2],
                  text: n,
                };
              }
            }
            heading(t) {
              const e = this.rules.block.heading.exec(t);
              if (e) {
                let t = e[2].trim();
                if (/#$/.test(t)) {
                  const e = uC(t, "#");
                  this.options.pedantic
                    ? (t = e.trim())
                    : (e && !/ $/.test(e)) || (t = e.trim());
                }
                const n = {
                  type: "heading",
                  raw: e[0],
                  depth: e[1].length,
                  text: t,
                  tokens: [],
                };
                return this.lexer.inline(n.text, n.tokens), n;
              }
            }
            hr(t) {
              const e = this.rules.block.hr.exec(t);
              if (e) return { type: "hr", raw: e[0] };
            }
            blockquote(t) {
              const e = this.rules.block.blockquote.exec(t);
              if (e) {
                const t = e[0].replace(/^ *> ?/gm, "");
                return {
                  type: "blockquote",
                  raw: e[0],
                  tokens: this.lexer.blockTokens(t, []),
                  text: t,
                };
              }
            }
            list(t) {
              let e = this.rules.block.list.exec(t);
              if (e) {
                let n,
                  i,
                  o,
                  r,
                  s,
                  a,
                  c,
                  l,
                  d,
                  h,
                  u,
                  m,
                  g = e[1].trim();
                const p = g.length > 1,
                  f = {
                    type: "list",
                    raw: "",
                    ordered: p,
                    start: p ? +g.slice(0, -1) : "",
                    loose: !1,
                    items: [],
                  };
                (g = p ? `\\d{1,9}\\${g.slice(-1)}` : `\\${g}`),
                  this.options.pedantic && (g = p ? g : "[*+-]");
                const k = new RegExp(`^( {0,3}${g})((?: [^\\n]*)?(?:\\n|$))`);
                for (
                  ;
                  t &&
                  ((m = !1), (e = k.exec(t))) &&
                  !this.rules.block.hr.test(t);

                ) {
                  if (
                    ((n = e[0]),
                    (t = t.substring(n.length)),
                    (l = e[2].split("\n", 1)[0]),
                    (d = t.split("\n", 1)[0]),
                    this.options.pedantic
                      ? ((r = 2), (u = l.trimLeft()))
                      : ((r = e[2].search(/[^ ]/)),
                        (r = r > 4 ? 1 : r),
                        (u = l.slice(r)),
                        (r += e[1].length)),
                    (a = !1),
                    !l &&
                      /^ *$/.test(d) &&
                      ((n += d + "\n"),
                      (t = t.substring(d.length + 1)),
                      (m = !0)),
                    !m)
                  ) {
                    const e = new RegExp(
                      `^ {0,${Math.min(3, r - 1)}}(?:[*+-]|\\d{1,9}[.)])`
                    );
                    for (
                      ;
                      t &&
                      ((h = t.split("\n", 1)[0]),
                      (l = h),
                      this.options.pedantic &&
                        (l = l.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")),
                      !e.test(l));

                    ) {
                      if (l.search(/[^ ]/) >= r || !l.trim())
                        u += "\n" + l.slice(r);
                      else {
                        if (a) break;
                        u += "\n" + l;
                      }
                      a || l.trim() || (a = !0),
                        (n += h + "\n"),
                        (t = t.substring(h.length + 1));
                    }
                  }
                  f.loose ||
                    (c ? (f.loose = !0) : /\n *\n *$/.test(n) && (c = !0)),
                    this.options.gfm &&
                      ((i = /^\[[ xX]\] /.exec(u)),
                      i &&
                        ((o = "[ ] " !== i[0]),
                        (u = u.replace(/^\[[ xX]\] +/, "")))),
                    f.items.push({
                      type: "list_item",
                      raw: n,
                      task: !!i,
                      checked: o,
                      loose: !1,
                      text: u,
                    }),
                    (f.raw += n);
                }
                (f.items[f.items.length - 1].raw = n.trimRight()),
                  (f.items[f.items.length - 1].text = u.trimRight()),
                  (f.raw = f.raw.trimRight());
                const b = f.items.length;
                for (s = 0; s < b; s++) {
                  (this.lexer.state.top = !1),
                    (f.items[s].tokens = this.lexer.blockTokens(
                      f.items[s].text,
                      []
                    ));
                  const t = f.items[s].tokens.filter((t) => "space" === t.type),
                    e = t.every((t) => {
                      const e = t.raw.split("");
                      let n = 0;
                      for (const t of e)
                        if (("\n" === t && (n += 1), n > 1)) return !0;
                      return !1;
                    });
                  !f.loose &&
                    t.length &&
                    e &&
                    ((f.loose = !0), (f.items[s].loose = !0));
                }
                return f;
              }
            }
            html(t) {
              const e = this.rules.block.html.exec(t);
              if (e) {
                const t = {
                  type: "html",
                  raw: e[0],
                  pre:
                    !this.options.sanitizer &&
                    ("pre" === e[1] || "script" === e[1] || "style" === e[1]),
                  text: e[0],
                };
                return (
                  this.options.sanitize &&
                    ((t.type = "paragraph"),
                    (t.text = this.options.sanitizer
                      ? this.options.sanitizer(e[0])
                      : Z_(e[0])),
                    (t.tokens = []),
                    this.lexer.inline(t.text, t.tokens)),
                  t
                );
              }
            }
            def(t) {
              const e = this.rules.block.def.exec(t);
              if (e) {
                e[3] && (e[3] = e[3].substring(1, e[3].length - 1));
                return {
                  type: "def",
                  tag: e[1].toLowerCase().replace(/\s+/g, " "),
                  raw: e[0],
                  href: e[2],
                  title: e[3],
                };
              }
            }
            table(t) {
              const e = this.rules.block.table.exec(t);
              if (e) {
                const t = {
                  type: "table",
                  header: hC(e[1]).map((t) => ({ text: t })),
                  align: e[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
                  rows:
                    e[3] && e[3].trim()
                      ? e[3].replace(/\n[ \t]*$/, "").split("\n")
                      : [],
                };
                if (t.header.length === t.align.length) {
                  t.raw = e[0];
                  let n,
                    i,
                    o,
                    r,
                    s = t.align.length;
                  for (n = 0; n < s; n++)
                    /^ *-+: *$/.test(t.align[n])
                      ? (t.align[n] = "right")
                      : /^ *:-+: *$/.test(t.align[n])
                      ? (t.align[n] = "center")
                      : /^ *:-+ *$/.test(t.align[n])
                      ? (t.align[n] = "left")
                      : (t.align[n] = null);
                  for (s = t.rows.length, n = 0; n < s; n++)
                    t.rows[n] = hC(t.rows[n], t.header.length).map((t) => ({
                      text: t,
                    }));
                  for (s = t.header.length, i = 0; i < s; i++)
                    (t.header[i].tokens = []),
                      this.lexer.inlineTokens(
                        t.header[i].text,
                        t.header[i].tokens
                      );
                  for (s = t.rows.length, i = 0; i < s; i++)
                    for (r = t.rows[i], o = 0; o < r.length; o++)
                      (r[o].tokens = []),
                        this.lexer.inlineTokens(r[o].text, r[o].tokens);
                  return t;
                }
              }
            }
            lheading(t) {
              const e = this.rules.block.lheading.exec(t);
              if (e) {
                const t = {
                  type: "heading",
                  raw: e[0],
                  depth: "=" === e[2].charAt(0) ? 1 : 2,
                  text: e[1],
                  tokens: [],
                };
                return this.lexer.inline(t.text, t.tokens), t;
              }
            }
            paragraph(t) {
              const e = this.rules.block.paragraph.exec(t);
              if (e) {
                const t = {
                  type: "paragraph",
                  raw: e[0],
                  text:
                    "\n" === e[1].charAt(e[1].length - 1)
                      ? e[1].slice(0, -1)
                      : e[1],
                  tokens: [],
                };
                return this.lexer.inline(t.text, t.tokens), t;
              }
            }
            text(t) {
              const e = this.rules.block.text.exec(t);
              if (e) {
                const t = { type: "text", raw: e[0], text: e[0], tokens: [] };
                return this.lexer.inline(t.text, t.tokens), t;
              }
            }
            escape(t) {
              const e = this.rules.inline.escape.exec(t);
              if (e) return { type: "escape", raw: e[0], text: Z_(e[1]) };
            }
            tag(t) {
              const e = this.rules.inline.tag.exec(t);
              if (e)
                return (
                  !this.lexer.state.inLink && /^<a /i.test(e[0])
                    ? (this.lexer.state.inLink = !0)
                    : this.lexer.state.inLink &&
                      /^<\/a>/i.test(e[0]) &&
                      (this.lexer.state.inLink = !1),
                  !this.lexer.state.inRawBlock &&
                  /^<(pre|code|kbd|script)(\s|>)/i.test(e[0])
                    ? (this.lexer.state.inRawBlock = !0)
                    : this.lexer.state.inRawBlock &&
                      /^<\/(pre|code|kbd|script)(\s|>)/i.test(e[0]) &&
                      (this.lexer.state.inRawBlock = !1),
                  {
                    type: this.options.sanitize ? "text" : "html",
                    raw: e[0],
                    inLink: this.lexer.state.inLink,
                    inRawBlock: this.lexer.state.inRawBlock,
                    text: this.options.sanitize
                      ? this.options.sanitizer
                        ? this.options.sanitizer(e[0])
                        : Z_(e[0])
                      : e[0],
                  }
                );
            }
            link(t) {
              const e = this.rules.inline.link.exec(t);
              if (e) {
                const t = e[2].trim();
                if (!this.options.pedantic && /^</.test(t)) {
                  if (!/>$/.test(t)) return;
                  const e = uC(t.slice(0, -1), "\\");
                  if ((t.length - e.length) % 2 == 0) return;
                } else {
                  const t = (function (t, e) {
                    if (-1 === t.indexOf(e[1])) return -1;
                    const n = t.length;
                    let i = 0,
                      o = 0;
                    for (; o < n; o++)
                      if ("\\" === t[o]) o++;
                      else if (t[o] === e[0]) i++;
                      else if (t[o] === e[1] && (i--, i < 0)) return o;
                    return -1;
                  })(e[2], "()");
                  if (t > -1) {
                    const n =
                      (0 === e[0].indexOf("!") ? 5 : 4) + e[1].length + t;
                    (e[2] = e[2].substring(0, t)),
                      (e[0] = e[0].substring(0, n).trim()),
                      (e[3] = "");
                  }
                }
                let n = e[2],
                  i = "";
                if (this.options.pedantic) {
                  const t = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(n);
                  t && ((n = t[1]), (i = t[3]));
                } else i = e[3] ? e[3].slice(1, -1) : "";
                return (
                  (n = n.trim()),
                  /^</.test(n) &&
                    (n =
                      this.options.pedantic && !/>$/.test(t)
                        ? n.slice(1)
                        : n.slice(1, -1)),
                  pC(
                    e,
                    {
                      href: n ? n.replace(this.rules.inline._escapes, "$1") : n,
                      title: i
                        ? i.replace(this.rules.inline._escapes, "$1")
                        : i,
                    },
                    e[0],
                    this.lexer
                  )
                );
              }
            }
            reflink(t, e) {
              let n;
              if (
                (n = this.rules.inline.reflink.exec(t)) ||
                (n = this.rules.inline.nolink.exec(t))
              ) {
                let t = (n[2] || n[1]).replace(/\s+/g, " ");
                if (((t = e[t.toLowerCase()]), !t || !t.href)) {
                  const t = n[0].charAt(0);
                  return { type: "text", raw: t, text: t };
                }
                return pC(n, t, n[0], this.lexer);
              }
            }
            emStrong(t, e, n = "") {
              let i = this.rules.inline.emStrong.lDelim.exec(t);
              if (!i) return;
              if (i[3] && n.match(/[\p{L}\p{N}]/u)) return;
              const o = i[1] || i[2] || "";
              if (
                !o ||
                (o && ("" === n || this.rules.inline.punctuation.exec(n)))
              ) {
                const n = i[0].length - 1;
                let o,
                  r,
                  s = n,
                  a = 0;
                const c =
                  "*" === i[0][0]
                    ? this.rules.inline.emStrong.rDelimAst
                    : this.rules.inline.emStrong.rDelimUnd;
                for (
                  c.lastIndex = 0, e = e.slice(-1 * t.length + n);
                  null != (i = c.exec(e));

                ) {
                  if (((o = i[1] || i[2] || i[3] || i[4] || i[5] || i[6]), !o))
                    continue;
                  if (((r = o.length), i[3] || i[4])) {
                    s += r;
                    continue;
                  }
                  if ((i[5] || i[6]) && n % 3 && !((n + r) % 3)) {
                    a += r;
                    continue;
                  }
                  if (((s -= r), s > 0)) continue;
                  if (((r = Math.min(r, r + s + a)), Math.min(n, r) % 2)) {
                    const e = t.slice(1, n + i.index + r);
                    return {
                      type: "em",
                      raw: t.slice(0, n + i.index + r + 1),
                      text: e,
                      tokens: this.lexer.inlineTokens(e, []),
                    };
                  }
                  const e = t.slice(2, n + i.index + r - 1);
                  return {
                    type: "strong",
                    raw: t.slice(0, n + i.index + r + 1),
                    text: e,
                    tokens: this.lexer.inlineTokens(e, []),
                  };
                }
              }
            }
            codespan(t) {
              const e = this.rules.inline.code.exec(t);
              if (e) {
                let t = e[2].replace(/\n/g, " ");
                const n = /[^ ]/.test(t),
                  i = /^ /.test(t) && / $/.test(t);
                return (
                  n && i && (t = t.substring(1, t.length - 1)),
                  (t = Z_(t, !0)),
                  { type: "codespan", raw: e[0], text: t }
                );
              }
            }
            br(t) {
              const e = this.rules.inline.br.exec(t);
              if (e) return { type: "br", raw: e[0] };
            }
            del(t) {
              const e = this.rules.inline.del.exec(t);
              if (e)
                return {
                  type: "del",
                  raw: e[0],
                  text: e[2],
                  tokens: this.lexer.inlineTokens(e[2], []),
                };
            }
            autolink(t, e) {
              const n = this.rules.inline.autolink.exec(t);
              if (n) {
                let t, i;
                return (
                  "@" === n[2]
                    ? ((t = Z_(this.options.mangle ? e(n[1]) : n[1])),
                      (i = "mailto:" + t))
                    : ((t = Z_(n[1])), (i = t)),
                  {
                    type: "link",
                    raw: n[0],
                    text: t,
                    href: i,
                    tokens: [{ type: "text", raw: t, text: t }],
                  }
                );
              }
            }
            url(t, e) {
              let n;
              if ((n = this.rules.inline.url.exec(t))) {
                let t, i;
                if ("@" === n[2])
                  (t = Z_(this.options.mangle ? e(n[0]) : n[0])),
                    (i = "mailto:" + t);
                else {
                  let e;
                  do {
                    (e = n[0]),
                      (n[0] = this.rules.inline._backpedal.exec(n[0])[0]);
                  } while (e !== n[0]);
                  (t = Z_(n[0])), (i = "www." === n[1] ? "http://" + t : t);
                }
                return {
                  type: "link",
                  raw: n[0],
                  text: t,
                  href: i,
                  tokens: [{ type: "text", raw: t, text: t }],
                };
              }
            }
            inlineText(t, e) {
              const n = this.rules.inline.text.exec(t);
              if (n) {
                let t;
                return (
                  (t = this.lexer.state.inRawBlock
                    ? this.options.sanitize
                      ? this.options.sanitizer
                        ? this.options.sanitizer(n[0])
                        : Z_(n[0])
                      : n[0]
                    : Z_(this.options.smartypants ? e(n[0]) : n[0])),
                  { type: "text", raw: n[0], text: t }
                );
              }
            }
          }
          const kC = {
            newline: /^(?: *(?:\n|$))+/,
            code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/,
            fences:
              /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/,
            hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
            heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,
            blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
            list: /^( {0,3}bull)( [^\n]+?)?(?:\n|$)/,
            html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))",
            def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/,
            table: lC,
            lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
            _paragraph:
              /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,
            text: /^[^\n]+/,
            _label: /(?!\s*\])(?:\\.|[^\[\]\\])+/,
            _title:
              /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/,
          };
          (kC.def = eC(kC.def)
            .replace("label", kC._label)
            .replace("title", kC._title)
            .getRegex()),
            (kC.bullet = /(?:[*+-]|\d{1,9}[.)])/),
            (kC.listItemStart = eC(/^( *)(bull) */)
              .replace("bull", kC.bullet)
              .getRegex()),
            (kC.list = eC(kC.list)
              .replace(/bull/g, kC.bullet)
              .replace(
                "hr",
                "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))"
              )
              .replace("def", "\\n+(?=" + kC.def.source + ")")
              .getRegex()),
            (kC._tag =
              "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul"),
            (kC._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/),
            (kC.html = eC(kC.html, "i")
              .replace("comment", kC._comment)
              .replace("tag", kC._tag)
              .replace(
                "attribute",
                / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/
              )
              .getRegex()),
            (kC.paragraph = eC(kC._paragraph)
              .replace("hr", kC.hr)
              .replace("heading", " {0,3}#{1,6} ")
              .replace("|lheading", "")
              .replace("|table", "")
              .replace("blockquote", " {0,3}>")
              .replace(
                "fences",
                " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n"
              )
              .replace("list", " {0,3}(?:[*+-]|1[.)]) ")
              .replace(
                "html",
                "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)"
              )
              .replace("tag", kC._tag)
              .getRegex()),
            (kC.blockquote = eC(kC.blockquote)
              .replace("paragraph", kC.paragraph)
              .getRegex()),
            (kC.normal = dC({}, kC)),
            (kC.gfm = dC({}, kC.normal, {
              table:
                "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)",
            })),
            (kC.gfm.table = eC(kC.gfm.table)
              .replace("hr", kC.hr)
              .replace("heading", " {0,3}#{1,6} ")
              .replace("blockquote", " {0,3}>")
              .replace("code", " {4}[^\\n]")
              .replace(
                "fences",
                " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n"
              )
              .replace("list", " {0,3}(?:[*+-]|1[.)]) ")
              .replace(
                "html",
                "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)"
              )
              .replace("tag", kC._tag)
              .getRegex()),
            (kC.gfm.paragraph = eC(kC._paragraph)
              .replace("hr", kC.hr)
              .replace("heading", " {0,3}#{1,6} ")
              .replace("|lheading", "")
              .replace("table", kC.gfm.table)
              .replace("blockquote", " {0,3}>")
              .replace(
                "fences",
                " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n"
              )
              .replace("list", " {0,3}(?:[*+-]|1[.)]) ")
              .replace(
                "html",
                "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)"
              )
              .replace("tag", kC._tag)
              .getRegex()),
            (kC.pedantic = dC({}, kC.normal, {
              html: eC(
                "^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))"
              )
                .replace("comment", kC._comment)
                .replace(
                  /tag/g,
                  "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b"
                )
                .getRegex(),
              def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
              heading: /^(#{1,6})(.*)(?:\n+|$)/,
              fences: lC,
              paragraph: eC(kC.normal._paragraph)
                .replace("hr", kC.hr)
                .replace("heading", " *#{1,6} *[^\n]")
                .replace("lheading", kC.lheading)
                .replace("blockquote", " {0,3}>")
                .replace("|fences", "")
                .replace("|list", "")
                .replace("|html", "")
                .getRegex(),
            }));
          const bC = {
            escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
            autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
            url: lC,
            tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
            link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
            reflink: /^!?\[(label)\]\[(ref)\]/,
            nolink: /^!?\[(ref)\](?:\[\])?/,
            reflinkSearch: "reflink|nolink(?!\\()",
            emStrong: {
              lDelim:
                /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/,
              rDelimAst:
                /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/,
              rDelimUnd:
                /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/,
            },
            code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
            br: /^( {2,}|\\)\n(?!\s*$)/,
            del: lC,
            text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,
            punctuation: /^([\spunctuation])/,
          };
          function wC(t) {
            return t
              .replace(/---/g, "—")
              .replace(/--/g, "–")
              .replace(/(^|[-\u2014/(\[{"\s])'/g, "$1‘")
              .replace(/'/g, "’")
              .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1“")
              .replace(/"/g, "”")
              .replace(/\.{3}/g, "…");
          }
          function AC(t) {
            let e,
              n,
              i = "";
            const o = t.length;
            for (e = 0; e < o; e++)
              (n = t.charCodeAt(e)),
                Math.random() > 0.5 && (n = "x" + n.toString(16)),
                (i += "&#" + n + ";");
            return i;
          }
          (bC._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~"),
            (bC.punctuation = eC(bC.punctuation)
              .replace(/punctuation/g, bC._punctuation)
              .getRegex()),
            (bC.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g),
            (bC.escapedEmSt = /\\\*|\\_/g),
            (bC._comment = eC(kC._comment)
              .replace("(?:--\x3e|$)", "--\x3e")
              .getRegex()),
            (bC.emStrong.lDelim = eC(bC.emStrong.lDelim)
              .replace(/punct/g, bC._punctuation)
              .getRegex()),
            (bC.emStrong.rDelimAst = eC(bC.emStrong.rDelimAst, "g")
              .replace(/punct/g, bC._punctuation)
              .getRegex()),
            (bC.emStrong.rDelimUnd = eC(bC.emStrong.rDelimUnd, "g")
              .replace(/punct/g, bC._punctuation)
              .getRegex()),
            (bC._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g),
            (bC._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/),
            (bC._email =
              /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/),
            (bC.autolink = eC(bC.autolink)
              .replace("scheme", bC._scheme)
              .replace("email", bC._email)
              .getRegex()),
            (bC._attribute =
              /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/),
            (bC.tag = eC(bC.tag)
              .replace("comment", bC._comment)
              .replace("attribute", bC._attribute)
              .getRegex()),
            (bC._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/),
            (bC._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/),
            (bC._title =
              /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/),
            (bC.link = eC(bC.link)
              .replace("label", bC._label)
              .replace("href", bC._href)
              .replace("title", bC._title)
              .getRegex()),
            (bC.reflink = eC(bC.reflink)
              .replace("label", bC._label)
              .replace("ref", kC._label)
              .getRegex()),
            (bC.nolink = eC(bC.nolink).replace("ref", kC._label).getRegex()),
            (bC.reflinkSearch = eC(bC.reflinkSearch, "g")
              .replace("reflink", bC.reflink)
              .replace("nolink", bC.nolink)
              .getRegex()),
            (bC.normal = dC({}, bC)),
            (bC.pedantic = dC({}, bC.normal, {
              strong: {
                start: /^__|\*\*/,
                middle:
                  /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
                endAst: /\*\*(?!\*)/g,
                endUnd: /__(?!_)/g,
              },
              em: {
                start: /^_|\*/,
                middle:
                  /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/,
                endAst: /\*(?!\*)/g,
                endUnd: /_(?!_)/g,
              },
              link: eC(/^!?\[(label)\]\((.*?)\)/)
                .replace("label", bC._label)
                .getRegex(),
              reflink: eC(/^!?\[(label)\]\s*\[([^\]]*)\]/)
                .replace("label", bC._label)
                .getRegex(),
            })),
            (bC.gfm = dC({}, bC.normal, {
              escape: eC(bC.escape).replace("])", "~|])").getRegex(),
              _extended_email:
                /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
              url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
              _backpedal:
                /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
              del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
              text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/,
            })),
            (bC.gfm.url = eC(bC.gfm.url, "i")
              .replace("email", bC.gfm._extended_email)
              .getRegex()),
            (bC.breaks = dC({}, bC.gfm, {
              br: eC(bC.br).replace("{2,}", "*").getRegex(),
              text: eC(bC.gfm.text)
                .replace("\\b_", "\\b_| {2,}\\n")
                .replace(/\{2,\}/g, "*")
                .getRegex(),
            }));
          class _C {
            constructor(t) {
              (this.tokens = []),
                (this.tokens.links = Object.create(null)),
                (this.options = t || $_),
                (this.options.tokenizer = this.options.tokenizer || new fC()),
                (this.tokenizer = this.options.tokenizer),
                (this.tokenizer.options = this.options),
                (this.tokenizer.lexer = this),
                (this.inlineQueue = []),
                (this.state = { inLink: !1, inRawBlock: !1, top: !0 });
              const e = { block: kC.normal, inline: bC.normal };
              this.options.pedantic
                ? ((e.block = kC.pedantic), (e.inline = bC.pedantic))
                : this.options.gfm &&
                  ((e.block = kC.gfm),
                  this.options.breaks
                    ? (e.inline = bC.breaks)
                    : (e.inline = bC.gfm)),
                (this.tokenizer.rules = e);
            }
            static get rules() {
              return { block: kC, inline: bC };
            }
            static lex(t, e) {
              return new _C(e).lex(t);
            }
            static lexInline(t, e) {
              return new _C(e).inlineTokens(t);
            }
            lex(t) {
              let e;
              for (
                t = t.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    "),
                  this.blockTokens(t, this.tokens);
                (e = this.inlineQueue.shift());

              )
                this.inlineTokens(e.src, e.tokens);
              return this.tokens;
            }
            blockTokens(t, e = []) {
              let n, i, o, r;
              for (this.options.pedantic && (t = t.replace(/^ +$/gm, "")); t; )
                if (
                  !(
                    this.options.extensions &&
                    this.options.extensions.block &&
                    this.options.extensions.block.some(
                      (i) =>
                        !!(n = i.call({ lexer: this }, t, e)) &&
                        ((t = t.substring(n.raw.length)), e.push(n), !0)
                    )
                  )
                )
                  if ((n = this.tokenizer.space(t)))
                    (t = t.substring(n.raw.length)),
                      1 === n.raw.length && e.length > 0
                        ? (e[e.length - 1].raw += "\n")
                        : e.push(n);
                  else if ((n = this.tokenizer.code(t)))
                    (t = t.substring(n.raw.length)),
                      (i = e[e.length - 1]),
                      !i || ("paragraph" !== i.type && "text" !== i.type)
                        ? e.push(n)
                        : ((i.raw += "\n" + n.raw),
                          (i.text += "\n" + n.text),
                          (this.inlineQueue[this.inlineQueue.length - 1].src =
                            i.text));
                  else if ((n = this.tokenizer.fences(t)))
                    (t = t.substring(n.raw.length)), e.push(n);
                  else if ((n = this.tokenizer.heading(t)))
                    (t = t.substring(n.raw.length)), e.push(n);
                  else if ((n = this.tokenizer.hr(t)))
                    (t = t.substring(n.raw.length)), e.push(n);
                  else if ((n = this.tokenizer.blockquote(t)))
                    (t = t.substring(n.raw.length)), e.push(n);
                  else if ((n = this.tokenizer.list(t)))
                    (t = t.substring(n.raw.length)), e.push(n);
                  else if ((n = this.tokenizer.html(t)))
                    (t = t.substring(n.raw.length)), e.push(n);
                  else if ((n = this.tokenizer.def(t)))
                    (t = t.substring(n.raw.length)),
                      (i = e[e.length - 1]),
                      !i || ("paragraph" !== i.type && "text" !== i.type)
                        ? this.tokens.links[n.tag] ||
                          (this.tokens.links[n.tag] = {
                            href: n.href,
                            title: n.title,
                          })
                        : ((i.raw += "\n" + n.raw),
                          (i.text += "\n" + n.raw),
                          (this.inlineQueue[this.inlineQueue.length - 1].src =
                            i.text));
                  else if ((n = this.tokenizer.table(t)))
                    (t = t.substring(n.raw.length)), e.push(n);
                  else if ((n = this.tokenizer.lheading(t)))
                    (t = t.substring(n.raw.length)), e.push(n);
                  else {
                    if (
                      ((o = t),
                      this.options.extensions &&
                        this.options.extensions.startBlock)
                    ) {
                      let e = 1 / 0;
                      const n = t.slice(1);
                      let i;
                      this.options.extensions.startBlock.forEach(function (t) {
                        (i = t.call({ lexer: this }, n)),
                          "number" == typeof i &&
                            i >= 0 &&
                            (e = Math.min(e, i));
                      }),
                        e < 1 / 0 && e >= 0 && (o = t.substring(0, e + 1));
                    }
                    if (this.state.top && (n = this.tokenizer.paragraph(o)))
                      (i = e[e.length - 1]),
                        r && "paragraph" === i.type
                          ? ((i.raw += "\n" + n.raw),
                            (i.text += "\n" + n.text),
                            this.inlineQueue.pop(),
                            (this.inlineQueue[this.inlineQueue.length - 1].src =
                              i.text))
                          : e.push(n),
                        (r = o.length !== t.length),
                        (t = t.substring(n.raw.length));
                    else if ((n = this.tokenizer.text(t)))
                      (t = t.substring(n.raw.length)),
                        (i = e[e.length - 1]),
                        i && "text" === i.type
                          ? ((i.raw += "\n" + n.raw),
                            (i.text += "\n" + n.text),
                            this.inlineQueue.pop(),
                            (this.inlineQueue[this.inlineQueue.length - 1].src =
                              i.text))
                          : e.push(n);
                    else if (t) {
                      const e = "Infinite loop on byte: " + t.charCodeAt(0);
                      if (this.options.silent) {
                        console.error(e);
                        break;
                      }
                      throw new Error(e);
                    }
                  }
              return (this.state.top = !0), e;
            }
            inline(t, e) {
              this.inlineQueue.push({ src: t, tokens: e });
            }
            inlineTokens(t, e = []) {
              let n,
                i,
                o,
                r,
                s,
                a,
                c = t;
              if (this.tokens.links) {
                const t = Object.keys(this.tokens.links);
                if (t.length > 0)
                  for (
                    ;
                    null !=
                    (r = this.tokenizer.rules.inline.reflinkSearch.exec(c));

                  )
                    t.includes(r[0].slice(r[0].lastIndexOf("[") + 1, -1)) &&
                      (c =
                        c.slice(0, r.index) +
                        "[" +
                        gC("a", r[0].length - 2) +
                        "]" +
                        c.slice(
                          this.tokenizer.rules.inline.reflinkSearch.lastIndex
                        ));
              }
              for (
                ;
                null != (r = this.tokenizer.rules.inline.blockSkip.exec(c));

              )
                c =
                  c.slice(0, r.index) +
                  "[" +
                  gC("a", r[0].length - 2) +
                  "]" +
                  c.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
              for (
                ;
                null != (r = this.tokenizer.rules.inline.escapedEmSt.exec(c));

              )
                c =
                  c.slice(0, r.index) +
                  "++" +
                  c.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
              for (; t; )
                if (
                  (s || (a = ""),
                  (s = !1),
                  !(
                    this.options.extensions &&
                    this.options.extensions.inline &&
                    this.options.extensions.inline.some(
                      (i) =>
                        !!(n = i.call({ lexer: this }, t, e)) &&
                        ((t = t.substring(n.raw.length)), e.push(n), !0)
                    )
                  ))
                )
                  if ((n = this.tokenizer.escape(t)))
                    (t = t.substring(n.raw.length)), e.push(n);
                  else if ((n = this.tokenizer.tag(t)))
                    (t = t.substring(n.raw.length)),
                      (i = e[e.length - 1]),
                      i && "text" === n.type && "text" === i.type
                        ? ((i.raw += n.raw), (i.text += n.text))
                        : e.push(n);
                  else if ((n = this.tokenizer.link(t)))
                    (t = t.substring(n.raw.length)), e.push(n);
                  else if ((n = this.tokenizer.reflink(t, this.tokens.links)))
                    (t = t.substring(n.raw.length)),
                      (i = e[e.length - 1]),
                      i && "text" === n.type && "text" === i.type
                        ? ((i.raw += n.raw), (i.text += n.text))
                        : e.push(n);
                  else if ((n = this.tokenizer.emStrong(t, c, a)))
                    (t = t.substring(n.raw.length)), e.push(n);
                  else if ((n = this.tokenizer.codespan(t)))
                    (t = t.substring(n.raw.length)), e.push(n);
                  else if ((n = this.tokenizer.br(t)))
                    (t = t.substring(n.raw.length)), e.push(n);
                  else if ((n = this.tokenizer.del(t)))
                    (t = t.substring(n.raw.length)), e.push(n);
                  else if ((n = this.tokenizer.autolink(t, AC)))
                    (t = t.substring(n.raw.length)), e.push(n);
                  else if (
                    this.state.inLink ||
                    !(n = this.tokenizer.url(t, AC))
                  ) {
                    if (
                      ((o = t),
                      this.options.extensions &&
                        this.options.extensions.startInline)
                    ) {
                      let e = 1 / 0;
                      const n = t.slice(1);
                      let i;
                      this.options.extensions.startInline.forEach(function (t) {
                        (i = t.call({ lexer: this }, n)),
                          "number" == typeof i &&
                            i >= 0 &&
                            (e = Math.min(e, i));
                      }),
                        e < 1 / 0 && e >= 0 && (o = t.substring(0, e + 1));
                    }
                    if ((n = this.tokenizer.inlineText(o, wC)))
                      (t = t.substring(n.raw.length)),
                        "_" !== n.raw.slice(-1) && (a = n.raw.slice(-1)),
                        (s = !0),
                        (i = e[e.length - 1]),
                        i && "text" === i.type
                          ? ((i.raw += n.raw), (i.text += n.text))
                          : e.push(n);
                    else if (t) {
                      const e = "Infinite loop on byte: " + t.charCodeAt(0);
                      if (this.options.silent) {
                        console.error(e);
                        break;
                      }
                      throw new Error(e);
                    }
                  } else (t = t.substring(n.raw.length)), e.push(n);
              return e;
            }
          }
          class CC {
            constructor(t) {
              this.options = t || $_;
            }
            code(t, e, n) {
              const i = (e || "").match(/\S*/)[0];
              if (this.options.highlight) {
                const e = this.options.highlight(t, i);
                null != e && e !== t && ((n = !0), (t = e));
              }
              return (
                (t = t.replace(/\n$/, "") + "\n"),
                i
                  ? '<pre><code class="' +
                    this.options.langPrefix +
                    Z_(i, !0) +
                    '">' +
                    (n ? t : Z_(t, !0)) +
                    "</code></pre>\n"
                  : "<pre><code>" + (n ? t : Z_(t, !0)) + "</code></pre>\n"
              );
            }
            blockquote(t) {
              return "<blockquote>\n" + t + "</blockquote>\n";
            }
            html(t) {
              return t;
            }
            heading(t, e, n, i) {
              return this.options.headerIds
                ? "<h" +
                    e +
                    ' id="' +
                    this.options.headerPrefix +
                    i.slug(n) +
                    '">' +
                    t +
                    "</h" +
                    e +
                    ">\n"
                : "<h" + e + ">" + t + "</h" + e + ">\n";
            }
            hr() {
              return this.options.xhtml ? "<hr/>\n" : "<hr>\n";
            }
            list(t, e, n) {
              const i = e ? "ol" : "ul";
              return (
                "<" +
                i +
                (e && 1 !== n ? ' start="' + n + '"' : "") +
                ">\n" +
                t +
                "</" +
                i +
                ">\n"
              );
            }
            listitem(t) {
              return "<li>" + t + "</li>\n";
            }
            checkbox(t) {
              return (
                "<input " +
                (t ? 'checked="" ' : "") +
                'disabled="" type="checkbox"' +
                (this.options.xhtml ? " /" : "") +
                "> "
              );
            }
            paragraph(t) {
              return "<p>" + t + "</p>\n";
            }
            table(t, e) {
              return (
                e && (e = "<tbody>" + e + "</tbody>"),
                "<table>\n<thead>\n" + t + "</thead>\n" + e + "</table>\n"
              );
            }
            tablerow(t) {
              return "<tr>\n" + t + "</tr>\n";
            }
            tablecell(t, e) {
              const n = e.header ? "th" : "td";
              return (
                (e.align
                  ? "<" + n + ' align="' + e.align + '">'
                  : "<" + n + ">") +
                t +
                "</" +
                n +
                ">\n"
              );
            }
            strong(t) {
              return "<strong>" + t + "</strong>";
            }
            em(t) {
              return "<em>" + t + "</em>";
            }
            codespan(t) {
              return "<code>" + t + "</code>";
            }
            br() {
              return this.options.xhtml ? "<br/>" : "<br>";
            }
            del(t) {
              return "<del>" + t + "</del>";
            }
            link(t, e, n) {
              if (
                null ===
                (t = oC(this.options.sanitize, this.options.baseUrl, t))
              )
                return n;
              let i = '<a href="' + Z_(t) + '"';
              return (
                e && (i += ' title="' + e + '"'), (i += ">" + n + "</a>"), i
              );
            }
            image(t, e, n) {
              if (
                null ===
                (t = oC(this.options.sanitize, this.options.baseUrl, t))
              )
                return n;
              let i = '<img src="' + t + '" alt="' + n + '"';
              return (
                e && (i += ' title="' + e + '"'),
                (i += this.options.xhtml ? "/>" : ">"),
                i
              );
            }
            text(t) {
              return t;
            }
          }
          class vC {
            strong(t) {
              return t;
            }
            em(t) {
              return t;
            }
            codespan(t) {
              return t;
            }
            del(t) {
              return t;
            }
            html(t) {
              return t;
            }
            text(t) {
              return t;
            }
            link(t, e, n) {
              return "" + n;
            }
            image(t, e, n) {
              return "" + n;
            }
            br() {
              return "";
            }
          }
          class yC {
            constructor() {
              this.seen = {};
            }
            serialize(t) {
              return t
                .toLowerCase()
                .trim()
                .replace(/<[!\/a-z].*?>/gi, "")
                .replace(
                  /[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g,
                  ""
                )
                .replace(/\s/g, "-");
            }
            getNextSafeSlug(t, e) {
              let n = t,
                i = 0;
              if (this.seen.hasOwnProperty(n)) {
                i = this.seen[t];
                do {
                  i++, (n = t + "-" + i);
                } while (this.seen.hasOwnProperty(n));
              }
              return e || ((this.seen[t] = i), (this.seen[n] = 0)), n;
            }
            slug(t, e = {}) {
              const n = this.serialize(t);
              return this.getNextSafeSlug(n, e.dryrun);
            }
          }
          class xC {
            constructor(t) {
              (this.options = t || $_),
                (this.options.renderer = this.options.renderer || new CC()),
                (this.renderer = this.options.renderer),
                (this.renderer.options = this.options),
                (this.textRenderer = new vC()),
                (this.slugger = new yC());
            }
            static parse(t, e) {
              return new xC(e).parse(t);
            }
            static parseInline(t, e) {
              return new xC(e).parseInline(t);
            }
            parse(t, e = !0) {
              let n,
                i,
                o,
                r,
                s,
                a,
                c,
                l,
                d,
                h,
                u,
                m,
                g,
                p,
                f,
                k,
                b,
                w,
                A,
                _ = "";
              const C = t.length;
              for (n = 0; n < C; n++)
                if (
                  ((h = t[n]),
                  this.options.extensions &&
                    this.options.extensions.renderers &&
                    this.options.extensions.renderers[h.type] &&
                    ((A = this.options.extensions.renderers[h.type].call(
                      { parser: this },
                      h
                    )),
                    !1 !== A ||
                      ![
                        "space",
                        "hr",
                        "heading",
                        "code",
                        "table",
                        "blockquote",
                        "list",
                        "html",
                        "paragraph",
                        "text",
                      ].includes(h.type)))
                )
                  _ += A || "";
                else
                  switch (h.type) {
                    case "space":
                      continue;
                    case "hr":
                      _ += this.renderer.hr();
                      continue;
                    case "heading":
                      _ += this.renderer.heading(
                        this.parseInline(h.tokens),
                        h.depth,
                        X_(this.parseInline(h.tokens, this.textRenderer)),
                        this.slugger
                      );
                      continue;
                    case "code":
                      _ += this.renderer.code(h.text, h.lang, h.escaped);
                      continue;
                    case "table":
                      for (
                        l = "", c = "", r = h.header.length, i = 0;
                        i < r;
                        i++
                      )
                        c += this.renderer.tablecell(
                          this.parseInline(h.header[i].tokens),
                          { header: !0, align: h.align[i] }
                        );
                      for (
                        l += this.renderer.tablerow(c),
                          d = "",
                          r = h.rows.length,
                          i = 0;
                        i < r;
                        i++
                      ) {
                        for (
                          a = h.rows[i], c = "", s = a.length, o = 0;
                          o < s;
                          o++
                        )
                          c += this.renderer.tablecell(
                            this.parseInline(a[o].tokens),
                            { header: !1, align: h.align[o] }
                          );
                        d += this.renderer.tablerow(c);
                      }
                      _ += this.renderer.table(l, d);
                      continue;
                    case "blockquote":
                      (d = this.parse(h.tokens)),
                        (_ += this.renderer.blockquote(d));
                      continue;
                    case "list":
                      for (
                        u = h.ordered,
                          m = h.start,
                          g = h.loose,
                          r = h.items.length,
                          d = "",
                          i = 0;
                        i < r;
                        i++
                      )
                        (f = h.items[i]),
                          (k = f.checked),
                          (b = f.task),
                          (p = ""),
                          f.task &&
                            ((w = this.renderer.checkbox(k)),
                            g
                              ? f.tokens.length > 0 &&
                                "paragraph" === f.tokens[0].type
                                ? ((f.tokens[0].text =
                                    w + " " + f.tokens[0].text),
                                  f.tokens[0].tokens &&
                                    f.tokens[0].tokens.length > 0 &&
                                    "text" === f.tokens[0].tokens[0].type &&
                                    (f.tokens[0].tokens[0].text =
                                      w + " " + f.tokens[0].tokens[0].text))
                                : f.tokens.unshift({ type: "text", text: w })
                              : (p += w)),
                          (p += this.parse(f.tokens, g)),
                          (d += this.renderer.listitem(p, b, k));
                      _ += this.renderer.list(d, u, m);
                      continue;
                    case "html":
                      _ += this.renderer.html(h.text);
                      continue;
                    case "paragraph":
                      _ += this.renderer.paragraph(this.parseInline(h.tokens));
                      continue;
                    case "text":
                      for (
                        d = h.tokens ? this.parseInline(h.tokens) : h.text;
                        n + 1 < C && "text" === t[n + 1].type;

                      )
                        (h = t[++n]),
                          (d +=
                            "\n" +
                            (h.tokens ? this.parseInline(h.tokens) : h.text));
                      _ += e ? this.renderer.paragraph(d) : d;
                      continue;
                    default: {
                      const t =
                        'Token with "' + h.type + '" type was not found.';
                      if (this.options.silent) return void console.error(t);
                      throw new Error(t);
                    }
                  }
              return _;
            }
            parseInline(t, e) {
              e = e || this.renderer;
              let n,
                i,
                o,
                r = "";
              const s = t.length;
              for (n = 0; n < s; n++)
                if (
                  ((i = t[n]),
                  this.options.extensions &&
                    this.options.extensions.renderers &&
                    this.options.extensions.renderers[i.type] &&
                    ((o = this.options.extensions.renderers[i.type].call(
                      { parser: this },
                      i
                    )),
                    !1 !== o ||
                      ![
                        "escape",
                        "html",
                        "link",
                        "image",
                        "strong",
                        "em",
                        "codespan",
                        "br",
                        "del",
                        "text",
                      ].includes(i.type)))
                )
                  r += o || "";
                else
                  switch (i.type) {
                    case "escape":
                    case "text":
                      r += e.text(i.text);
                      break;
                    case "html":
                      r += e.html(i.text);
                      break;
                    case "link":
                      r += e.link(
                        i.href,
                        i.title,
                        this.parseInline(i.tokens, e)
                      );
                      break;
                    case "image":
                      r += e.image(i.href, i.title, i.text);
                      break;
                    case "strong":
                      r += e.strong(this.parseInline(i.tokens, e));
                      break;
                    case "em":
                      r += e.em(this.parseInline(i.tokens, e));
                      break;
                    case "codespan":
                      r += e.codespan(i.text);
                      break;
                    case "br":
                      r += e.br();
                      break;
                    case "del":
                      r += e.del(this.parseInline(i.tokens, e));
                      break;
                    default: {
                      const t =
                        'Token with "' + i.type + '" type was not found.';
                      if (this.options.silent) return void console.error(t);
                      throw new Error(t);
                    }
                  }
              return r;
            }
          }
          function EC(t, e, n) {
            if (null == t)
              throw new Error("marked(): input parameter is undefined or null");
            if ("string" != typeof t)
              throw new Error(
                "marked(): input parameter is of type " +
                  Object.prototype.toString.call(t) +
                  ", string expected"
              );
            if (
              ("function" == typeof e && ((n = e), (e = null)),
              mC((e = dC({}, EC.defaults, e || {}))),
              n)
            ) {
              const i = e.highlight;
              let o;
              try {
                o = _C.lex(t, e);
              } catch (t) {
                return n(t);
              }
              const r = function (t) {
                let r;
                if (!t)
                  try {
                    e.walkTokens && EC.walkTokens(o, e.walkTokens),
                      (r = xC.parse(o, e));
                  } catch (e) {
                    t = e;
                  }
                return (e.highlight = i), t ? n(t) : n(null, r);
              };
              if (!i || i.length < 3) return r();
              if ((delete e.highlight, !o.length)) return r();
              let s = 0;
              return (
                EC.walkTokens(o, function (t) {
                  "code" === t.type &&
                    (s++,
                    setTimeout(() => {
                      i(t.text, t.lang, function (e, n) {
                        if (e) return r(e);
                        null != n &&
                          n !== t.text &&
                          ((t.text = n), (t.escaped = !0)),
                          s--,
                          0 === s && r();
                      });
                    }, 0));
                }),
                void (0 === s && r())
              );
            }
            try {
              const n = _C.lex(t, e);
              return (
                e.walkTokens && EC.walkTokens(n, e.walkTokens), xC.parse(n, e)
              );
            } catch (t) {
              if (
                ((t.message +=
                  "\nPlease report this to https://github.com/markedjs/marked."),
                e.silent)
              )
                return (
                  "<p>An error occurred:</p><pre>" +
                  Z_(t.message + "", !0) +
                  "</pre>"
                );
              throw t;
            }
          }
          (EC.options = EC.setOptions =
            function (t) {
              var e;
              return dC(EC.defaults, t), (e = EC.defaults), ($_ = e), EC;
            }),
            (EC.getDefaults = U_),
            (EC.defaults = $_),
            (EC.use = function (...t) {
              const e = dC({}, ...t),
                n = EC.defaults.extensions || {
                  renderers: {},
                  childTokens: {},
                };
              let i;
              t.forEach((t) => {
                if (
                  (t.extensions &&
                    ((i = !0),
                    t.extensions.forEach((t) => {
                      if (!t.name) throw new Error("extension name required");
                      if (t.renderer) {
                        const e = n.renderers ? n.renderers[t.name] : null;
                        n.renderers[t.name] = e
                          ? function (...n) {
                              let i = t.renderer.apply(this, n);
                              return !1 === i && (i = e.apply(this, n)), i;
                            }
                          : t.renderer;
                      }
                      if (t.tokenizer) {
                        if (
                          !t.level ||
                          ("block" !== t.level && "inline" !== t.level)
                        )
                          throw new Error(
                            "extension level must be 'block' or 'inline'"
                          );
                        n[t.level]
                          ? n[t.level].unshift(t.tokenizer)
                          : (n[t.level] = [t.tokenizer]),
                          t.start &&
                            ("block" === t.level
                              ? n.startBlock
                                ? n.startBlock.push(t.start)
                                : (n.startBlock = [t.start])
                              : "inline" === t.level &&
                                (n.startInline
                                  ? n.startInline.push(t.start)
                                  : (n.startInline = [t.start])));
                      }
                      t.childTokens && (n.childTokens[t.name] = t.childTokens);
                    })),
                  t.renderer)
                ) {
                  const n = EC.defaults.renderer || new CC();
                  for (const e in t.renderer) {
                    const i = n[e];
                    n[e] = (...o) => {
                      let r = t.renderer[e].apply(n, o);
                      return !1 === r && (r = i.apply(n, o)), r;
                    };
                  }
                  e.renderer = n;
                }
                if (t.tokenizer) {
                  const n = EC.defaults.tokenizer || new fC();
                  for (const e in t.tokenizer) {
                    const i = n[e];
                    n[e] = (...o) => {
                      let r = t.tokenizer[e].apply(n, o);
                      return !1 === r && (r = i.apply(n, o)), r;
                    };
                  }
                  e.tokenizer = n;
                }
                if (t.walkTokens) {
                  const n = EC.defaults.walkTokens;
                  e.walkTokens = function (e) {
                    t.walkTokens.call(this, e), n && n.call(this, e);
                  };
                }
                i && (e.extensions = n), EC.setOptions(e);
              });
            }),
            (EC.walkTokens = function (t, e) {
              for (const n of t)
                switch ((e.call(EC, n), n.type)) {
                  case "table":
                    for (const t of n.header) EC.walkTokens(t.tokens, e);
                    for (const t of n.rows)
                      for (const n of t) EC.walkTokens(n.tokens, e);
                    break;
                  case "list":
                    EC.walkTokens(n.items, e);
                    break;
                  default:
                    EC.defaults.extensions &&
                    EC.defaults.extensions.childTokens &&
                    EC.defaults.extensions.childTokens[n.type]
                      ? EC.defaults.extensions.childTokens[n.type].forEach(
                          function (t) {
                            EC.walkTokens(n[t], e);
                          }
                        )
                      : n.tokens && EC.walkTokens(n.tokens, e);
                }
            }),
            (EC.parseInline = function (t, e) {
              if (null == t)
                throw new Error(
                  "marked.parseInline(): input parameter is undefined or null"
                );
              if ("string" != typeof t)
                throw new Error(
                  "marked.parseInline(): input parameter is of type " +
                    Object.prototype.toString.call(t) +
                    ", string expected"
                );
              mC((e = dC({}, EC.defaults, e || {})));
              try {
                const n = _C.lexInline(t, e);
                return (
                  e.walkTokens && EC.walkTokens(n, e.walkTokens),
                  xC.parseInline(n, e)
                );
              } catch (t) {
                if (
                  ((t.message +=
                    "\nPlease report this to https://github.com/markedjs/marked."),
                  e.silent)
                )
                  return (
                    "<p>An error occurred:</p><pre>" +
                    Z_(t.message + "", !0) +
                    "</pre>"
                  );
                throw t;
              }
            }),
            (EC.Parser = xC),
            (EC.parser = xC.parse),
            (EC.Renderer = CC),
            (EC.TextRenderer = vC),
            (EC.Lexer = _C),
            (EC.lexer = _C.lex),
            (EC.Tokenizer = fC),
            (EC.Slugger = yC),
            (EC.parse = EC);
          EC.options,
            EC.setOptions,
            EC.use,
            EC.walkTokens,
            EC.parseInline,
            xC.parse,
            _C.lex;
          function DC(t, e) {
            return Array(e + 1).join(t);
          }
          EC.use({
            tokenizer: { autolink: () => null, url: () => null },
            renderer: {
              checkbox(...t) {
                return Object.getPrototypeOf(this)
                  .checkbox.call(this, ...t)
                  .trimRight();
              },
              code(...t) {
                return Object.getPrototypeOf(this)
                  .code.call(this, ...t)
                  .replace("\n</code>", "</code>");
              },
            },
          });
          var SC = [
            "address",
            "article",
            "aside",
            "audio",
            "blockquote",
            "body",
            "canvas",
            "center",
            "dd",
            "dir",
            "div",
            "dl",
            "dt",
            "fieldset",
            "figcaption",
            "figure",
            "footer",
            "form",
            "frameset",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "header",
            "hgroup",
            "hr",
            "html",
            "isindex",
            "li",
            "main",
            "menu",
            "nav",
            "noframes",
            "noscript",
            "ol",
            "output",
            "p",
            "pre",
            "section",
            "table",
            "tbody",
            "td",
            "tfoot",
            "th",
            "thead",
            "tr",
            "ul",
          ];
          function IC(t) {
            return -1 !== SC.indexOf(t.nodeName.toLowerCase());
          }
          var TC = [
            "area",
            "base",
            "br",
            "col",
            "command",
            "embed",
            "hr",
            "img",
            "input",
            "keygen",
            "link",
            "meta",
            "param",
            "source",
            "track",
            "wbr",
          ];
          function MC(t) {
            return -1 !== TC.indexOf(t.nodeName.toLowerCase());
          }
          var BC = TC.join();
          var NC = {};
          function zC(t) {
            for (var e in ((this.options = t),
            (this._keep = []),
            (this._remove = []),
            (this.blankRule = { replacement: t.blankReplacement }),
            (this.keepReplacement = t.keepReplacement),
            (this.defaultRule = { replacement: t.defaultReplacement }),
            (this.array = []),
            t.rules))
              this.array.push(t.rules[e]);
          }
          function PC(t, e, n) {
            for (var i = 0; i < t.length; i++) {
              var o = t[i];
              if (LC(o, e, n)) return o;
            }
          }
          function LC(t, e, n) {
            var i = t.filter;
            if ("string" == typeof i) {
              if (i === e.nodeName.toLowerCase()) return !0;
            } else if (Array.isArray(i)) {
              if (i.indexOf(e.nodeName.toLowerCase()) > -1) return !0;
            } else {
              if ("function" != typeof i)
                throw new TypeError(
                  "`filter` needs to be a string, array, or function"
                );
              if (i.call(t, e, n)) return !0;
            }
          }
          function RC(t) {
            var e = t.nextSibling || t.parentNode;
            return t.parentNode.removeChild(t), e;
          }
          function OC(t, e, n) {
            return (t && t.parentNode === e) || n(e)
              ? e.nextSibling || e.parentNode
              : e.firstChild || e.nextSibling || e.parentNode;
          }
          (NC.paragraph = {
            filter: "p",
            replacement: function (t) {
              return "\n\n" + t + "\n\n";
            },
          }),
            (NC.lineBreak = {
              filter: "br",
              replacement: function (t, e, n) {
                return n.br + "\n";
              },
            }),
            (NC.heading = {
              filter: ["h1", "h2", "h3", "h4", "h5", "h6"],
              replacement: function (t, e, n) {
                var i = Number(e.nodeName.charAt(1));
                return "setext" === n.headingStyle && i < 3
                  ? "\n\n" +
                      t +
                      "\n" +
                      DC(1 === i ? "=" : "-", t.length) +
                      "\n\n"
                  : "\n\n" + DC("#", i) + " " + t + "\n\n";
              },
            }),
            (NC.blockquote = {
              filter: "blockquote",
              replacement: function (t) {
                return (
                  "\n\n" +
                  (t = (t = t.replace(/^\n+|\n+$/g, "")).replace(/^/gm, "> ")) +
                  "\n\n"
                );
              },
            }),
            (NC.list = {
              filter: ["ul", "ol"],
              replacement: function (t, e) {
                var n = e.parentNode;
                return "LI" === n.nodeName && n.lastElementChild === e
                  ? "\n" + t
                  : "\n\n" + t + "\n\n";
              },
            }),
            (NC.listItem = {
              filter: "li",
              replacement: function (t, e, n) {
                t = t
                  .replace(/^\n+/, "")
                  .replace(/\n+$/, "\n")
                  .replace(/\n/gm, "\n    ");
                var i = n.bulletListMarker + "   ",
                  o = e.parentNode;
                if ("OL" === o.nodeName) {
                  var r = o.getAttribute("start"),
                    s = Array.prototype.indexOf.call(o.children, e);
                  i = (r ? Number(r) + s : s + 1) + ".  ";
                }
                return i + t + (e.nextSibling && !/\n$/.test(t) ? "\n" : "");
              },
            }),
            (NC.indentedCodeBlock = {
              filter: function (t, e) {
                return (
                  "indented" === e.codeBlockStyle &&
                  "PRE" === t.nodeName &&
                  t.firstChild &&
                  "CODE" === t.firstChild.nodeName
                );
              },
              replacement: function (t, e, n) {
                return (
                  "\n\n    " +
                  e.firstChild.textContent.replace(/\n/g, "\n    ") +
                  "\n\n"
                );
              },
            }),
            (NC.fencedCodeBlock = {
              filter: function (t, e) {
                return (
                  "fenced" === e.codeBlockStyle &&
                  "PRE" === t.nodeName &&
                  t.firstChild &&
                  "CODE" === t.firstChild.nodeName
                );
              },
              replacement: function (t, e, n) {
                for (
                  var i,
                    o = ((e.firstChild.className || "").match(
                      /language-(\S+)/
                    ) || [null, ""])[1],
                    r = e.firstChild.textContent,
                    s = n.fence.charAt(0),
                    a = 3,
                    c = new RegExp("^" + s + "{3,}", "gm");
                  (i = c.exec(r));

                )
                  i[0].length >= a && (a = i[0].length + 1);
                var l = DC(s, a);
                return (
                  "\n\n" +
                  l +
                  o +
                  "\n" +
                  r.replace(/\n$/, "") +
                  "\n" +
                  l +
                  "\n\n"
                );
              },
            }),
            (NC.horizontalRule = {
              filter: "hr",
              replacement: function (t, e, n) {
                return "\n\n" + n.hr + "\n\n";
              },
            }),
            (NC.inlineLink = {
              filter: function (t, e) {
                return (
                  "inlined" === e.linkStyle &&
                  "A" === t.nodeName &&
                  t.getAttribute("href")
                );
              },
              replacement: function (t, e) {
                return (
                  "[" +
                  t +
                  "](" +
                  e.getAttribute("href") +
                  (e.title ? ' "' + e.title + '"' : "") +
                  ")"
                );
              },
            }),
            (NC.referenceLink = {
              filter: function (t, e) {
                return (
                  "referenced" === e.linkStyle &&
                  "A" === t.nodeName &&
                  t.getAttribute("href")
                );
              },
              replacement: function (t, e, n) {
                var i,
                  o,
                  r = e.getAttribute("href"),
                  s = e.title ? ' "' + e.title + '"' : "";
                switch (n.linkReferenceStyle) {
                  case "collapsed":
                    (i = "[" + t + "][]"), (o = "[" + t + "]: " + r + s);
                    break;
                  case "shortcut":
                    (i = "[" + t + "]"), (o = "[" + t + "]: " + r + s);
                    break;
                  default:
                    var a = this.references.length + 1;
                    (i = "[" + t + "][" + a + "]"),
                      (o = "[" + a + "]: " + r + s);
                }
                return this.references.push(o), i;
              },
              references: [],
              append: function (t) {
                var e = "";
                return (
                  this.references.length &&
                    ((e = "\n\n" + this.references.join("\n") + "\n\n"),
                    (this.references = [])),
                  e
                );
              },
            }),
            (NC.emphasis = {
              filter: ["em", "i"],
              replacement: function (t, e, n) {
                return t.trim() ? n.emDelimiter + t + n.emDelimiter : "";
              },
            }),
            (NC.strong = {
              filter: ["strong", "b"],
              replacement: function (t, e, n) {
                return t.trim()
                  ? n.strongDelimiter + t + n.strongDelimiter
                  : "";
              },
            }),
            (NC.code = {
              filter: function (t) {
                var e = t.previousSibling || t.nextSibling,
                  n = "PRE" === t.parentNode.nodeName && !e;
                return "CODE" === t.nodeName && !n;
              },
              replacement: function (t) {
                if (!t.trim()) return "";
                var e = "`",
                  n = "",
                  i = "",
                  o = t.match(/`+/gm);
                if (o)
                  for (
                    /^`/.test(t) && (n = " "), /`$/.test(t) && (i = " ");
                    -1 !== o.indexOf(e);

                  )
                    e += "`";
                return e + n + t + i + e;
              },
            }),
            (NC.image = {
              filter: "img",
              replacement: function (t, e) {
                var n = e.alt || "",
                  i = e.getAttribute("src") || "",
                  o = e.title || "";
                return i
                  ? "![" + n + "](" + i + (o ? ' "' + o + '"' : "") + ")"
                  : "";
              },
            }),
            (zC.prototype = {
              add: function (t, e) {
                this.array.unshift(e);
              },
              keep: function (t) {
                this._keep.unshift({
                  filter: t,
                  replacement: this.keepReplacement,
                });
              },
              remove: function (t) {
                this._remove.unshift({
                  filter: t,
                  replacement: function () {
                    return "";
                  },
                });
              },
              forNode: function (t) {
                return t.isBlank
                  ? this.blankRule
                  : (e = PC(this.array, t, this.options)) ||
                    (e = PC(this._keep, t, this.options)) ||
                    (e = PC(this._remove, t, this.options))
                  ? e
                  : this.defaultRule;
                var e;
              },
              forEach: function (t) {
                for (var e = 0; e < this.array.length; e++) t(this.array[e], e);
              },
            });
          var jC = "undefined" != typeof window ? window : {};
          var FC,
            VC = (function () {
              var t = jC.DOMParser,
                e = !1;
              try {
                new t().parseFromString("", "text/html") && (e = !0);
              } catch (t) {}
              return e;
            })()
              ? jC.DOMParser
              : (function () {
                  var t = function () {},
                    e = n(1576).JSDOM;
                  return (
                    (t.prototype.parseFromString = function (t) {
                      return new e(t).window.document;
                    }),
                    t
                  );
                })();
          function HC(t) {
            var e;
            "string" == typeof t
              ? (e = (FC = FC || new VC())
                  .parseFromString(
                    '<x-turndown id="turndown-root">' + t + "</x-turndown>",
                    "text/html"
                  )
                  .getElementById("turndown-root"))
              : (e = t.cloneNode(!0));
            return (
              (function (t) {
                var e = t.element,
                  n = t.isBlock,
                  i = t.isVoid,
                  o =
                    t.isPre ||
                    function (t) {
                      return "PRE" === t.nodeName;
                    };
                if (e.firstChild && !o(e)) {
                  for (
                    var r = null, s = !1, a = null, c = OC(a, e, o);
                    c !== e;

                  ) {
                    if (3 === c.nodeType || 4 === c.nodeType) {
                      var l = c.data.replace(/[ \r\n\t]+/g, " ");
                      if (
                        ((r && !/ $/.test(r.data)) ||
                          s ||
                          " " !== l[0] ||
                          (l = l.substr(1)),
                        !l)
                      ) {
                        c = RC(c);
                        continue;
                      }
                      (c.data = l), (r = c);
                    } else {
                      if (1 !== c.nodeType) {
                        c = RC(c);
                        continue;
                      }
                      n(c) || "BR" === c.nodeName
                        ? (r && (r.data = r.data.replace(/ $/, "")),
                          (r = null),
                          (s = !1))
                        : i(c) && ((r = null), (s = !0));
                    }
                    var d = OC(a, c, o);
                    (a = c), (c = d);
                  }
                  r && ((r.data = r.data.replace(/ $/, "")), r.data || RC(r));
                }
              })({ element: e, isBlock: IC, isVoid: MC }),
              e
            );
          }
          function UC(t) {
            return (
              (t.isBlock = IC(t)),
              (t.isCode =
                "code" === t.nodeName.toLowerCase() || t.parentNode.isCode),
              (t.isBlank = (function (t) {
                return (
                  -1 ===
                    [
                      "A",
                      "TH",
                      "TD",
                      "IFRAME",
                      "SCRIPT",
                      "AUDIO",
                      "VIDEO",
                    ].indexOf(t.nodeName) &&
                  /^\s*$/i.test(t.textContent) &&
                  !MC(t) &&
                  !(function (t) {
                    return t.querySelector && t.querySelector(BC);
                  })(t)
                );
              })(t)),
              (t.flankingWhitespace = (function (t) {
                var e = "",
                  n = "";
                if (!t.isBlock) {
                  var i = /^\s/.test(t.textContent),
                    o = /\s$/.test(t.textContent),
                    r = t.isBlank && i && o;
                  i && !$C("left", t) && (e = " "),
                    r || !o || $C("right", t) || (n = " ");
                }
                return { leading: e, trailing: n };
              })(t)),
              t
            );
          }
          function $C(t, e) {
            var n, i, o;
            return (
              "left" === t
                ? ((n = e.previousSibling), (i = / $/))
                : ((n = e.nextSibling), (i = /^ /)),
              n &&
                (3 === n.nodeType
                  ? (o = i.test(n.nodeValue))
                  : 1 !== n.nodeType || IC(n) || (o = i.test(n.textContent))),
              o
            );
          }
          var qC = Array.prototype.reduce,
            GC = /^\n*/,
            WC = /\n*$/,
            YC = [
              [/\\/g, "\\\\"],
              [/\*/g, "\\*"],
              [/^-/g, "\\-"],
              [/^\+ /g, "\\+ "],
              [/^(=+)/g, "\\$1"],
              [/^(#{1,6}) /g, "\\$1 "],
              [/`/g, "\\`"],
              [/^~~~/g, "\\~~~"],
              [/\[/g, "\\["],
              [/\]/g, "\\]"],
              [/^>/g, "\\>"],
              [/_/g, "\\_"],
              [/^(\d+)\. /g, "$1\\. "],
            ];
          function KC(t) {
            if (!(this instanceof KC)) return new KC(t);
            var e = {
              rules: NC,
              headingStyle: "setext",
              hr: "* * *",
              bulletListMarker: "*",
              codeBlockStyle: "indented",
              fence: "```",
              emDelimiter: "_",
              strongDelimiter: "**",
              linkStyle: "inlined",
              linkReferenceStyle: "full",
              br: "  ",
              blankReplacement: function (t, e) {
                return e.isBlock ? "\n\n" : "";
              },
              keepReplacement: function (t, e) {
                return e.isBlock ? "\n\n" + e.outerHTML + "\n\n" : e.outerHTML;
              },
              defaultReplacement: function (t, e) {
                return e.isBlock ? "\n\n" + t + "\n\n" : t;
              },
            };
            (this.options = (function (t) {
              for (var e = 1; e < arguments.length; e++) {
                var n = arguments[e];
                for (var i in n) n.hasOwnProperty(i) && (t[i] = n[i]);
              }
              return t;
            })({}, e, t)),
              (this.rules = new zC(this.options));
          }
          function QC(t) {
            var e = this;
            return qC.call(
              t.childNodes,
              function (t, n) {
                var i = "";
                return (
                  3 === (n = new UC(n)).nodeType
                    ? (i = n.isCode ? n.nodeValue : e.escape(n.nodeValue))
                    : 1 === n.nodeType && (i = JC.call(e, n)),
                  XC(t, i)
                );
              },
              ""
            );
          }
          function ZC(t) {
            var e = this;
            return (
              this.rules.forEach(function (n) {
                "function" == typeof n.append &&
                  (t = XC(t, n.append(e.options)));
              }),
              t.replace(/^[\t\r\n]+/, "").replace(/[\t\r\n\s]+$/, "")
            );
          }
          function JC(t) {
            var e = this.rules.forNode(t),
              n = QC.call(this, t),
              i = t.flankingWhitespace;
            return (
              (i.leading || i.trailing) && (n = n.trim()),
              i.leading + e.replacement(n, t, this.options) + i.trailing
            );
          }
          function XC(t, e) {
            var n,
              i,
              o,
              r =
                ((n = e),
                (i = [t.match(WC)[0], n.match(GC)[0]].sort()),
                (o = i[i.length - 1]).length < 2 ? o : "\n\n");
            return (t = t.replace(WC, "")) + r + (e = e.replace(GC, ""));
          }
          KC.prototype = {
            turndown: function (t) {
              if (
                !(function (t) {
                  return (
                    null != t &&
                    ("string" == typeof t ||
                      (t.nodeType &&
                        (1 === t.nodeType ||
                          9 === t.nodeType ||
                          11 === t.nodeType)))
                  );
                })(t)
              )
                throw new TypeError(
                  t + " is not a string, or an element/document/fragment node."
                );
              if ("" === t) return "";
              var e = QC.call(this, new HC(t));
              return ZC.call(this, e);
            },
            use: function (t) {
              if (Array.isArray(t))
                for (var e = 0; e < t.length; e++) this.use(t[e]);
              else {
                if ("function" != typeof t)
                  throw new TypeError(
                    "plugin must be a Function or an Array of Functions"
                  );
                t(this);
              }
              return this;
            },
            addRule: function (t, e) {
              return this.rules.add(t, e), this;
            },
            keep: function (t) {
              return this.rules.keep(t), this;
            },
            remove: function (t) {
              return this.rules.remove(t), this;
            },
            escape: function (t) {
              return YC.reduce(function (t, e) {
                return t.replace(e[0], e[1]);
              }, t);
            },
          };
          const tv = KC;
          var ev = /highlight-(?:text|source)-([a-z0-9]+)/;
          function nv(t) {
            t.addRule("highlightedCodeBlock", {
              filter: function (t) {
                var e = t.firstChild;
                return (
                  "DIV" === t.nodeName &&
                  ev.test(t.className) &&
                  e &&
                  "PRE" === e.nodeName
                );
              },
              replacement: function (t, e, n) {
                var i = ((e.className || "").match(ev) || [null, ""])[1];
                return (
                  "\n\n" +
                  n.fence +
                  i +
                  "\n" +
                  e.firstChild.textContent +
                  "\n" +
                  n.fence +
                  "\n\n"
                );
              },
            });
          }
          function iv(t) {
            t.addRule("strikethrough", {
              filter: ["del", "s", "strike"],
              replacement: function (t) {
                return "~" + t + "~";
              },
            });
          }
          var ov = Array.prototype.indexOf,
            rv = Array.prototype.every,
            sv = {};
          function av(t) {
            var e,
              n,
              i = t.parentNode;
            return (
              "THEAD" === i.nodeName ||
              (i.firstChild === t &&
                ("TABLE" === i.nodeName ||
                  ((n = (e = i).previousSibling),
                  "TBODY" === e.nodeName &&
                    (!n ||
                      ("THEAD" === n.nodeName &&
                        /^\s*$/i.test(n.textContent))))) &&
                rv.call(t.childNodes, function (t) {
                  return "TH" === t.nodeName;
                }))
            );
          }
          function cv(t, e) {
            var n = " ";
            return (
              0 === ov.call(e.parentNode.childNodes, e) && (n = "| "),
              n + t + " |"
            );
          }
          function lv(t) {
            for (var e in (t.keep(function (t) {
              return "TABLE" === t.nodeName && !av(t.rows[0]);
            }),
            sv))
              t.addRule(e, sv[e]);
          }
          function dv(t) {
            t.addRule("taskListItems", {
              filter: function (t) {
                return "checkbox" === t.type && "LI" === t.parentNode.nodeName;
              },
              replacement: function (t, e) {
                return (e.checked ? "[x]" : "[ ]") + " ";
              },
            });
          }
          (sv.tableCell = {
            filter: ["th", "td"],
            replacement: function (t, e) {
              return cv(t, e);
            },
          }),
            (sv.tableRow = {
              filter: "tr",
              replacement: function (t, e) {
                var n = "",
                  i = { left: ":--", right: "--:", center: ":-:" };
                if (av(e))
                  for (var o = 0; o < e.childNodes.length; o++) {
                    var r = "---",
                      s = (
                        e.childNodes[o].getAttribute("align") || ""
                      ).toLowerCase();
                    s && (r = i[s] || r), (n += cv(r, e.childNodes[o]));
                  }
                return "\n" + t + (n ? "\n" + n : "");
              },
            }),
            (sv.table = {
              filter: function (t) {
                return "TABLE" === t.nodeName && av(t.rows[0]);
              },
              replacement: function (t) {
                return "\n\n" + (t = t.replace("\n\n", "\n")) + "\n\n";
              },
            }),
            (sv.tableSection = {
              filter: ["thead", "tbody", "tfoot"],
              replacement: function (t) {
                return t;
              },
            });
          const hv = tv.prototype.escape;
          function uv(t) {
            return (t = (t = hv(t)).replace(/</g, "\\<"));
          }
          tv.prototype.escape = function (t) {
            let e = "",
              n = 0;
            for (const i of (function* (t) {
              for (const e of t.matchAll(gv)) {
                const t = e[0],
                  n = pv(t);
                yield Object.assign([t.substring(0, n)], { index: e.index });
              }
            })(t)) {
              const o = i.index;
              o > n && (e += uv(t.substring(n, o)));
              const r = i[0];
              (e += r), (n = o + r.length);
            }
            return n < t.length && (e += uv(t.substring(n, t.length))), e;
          };
          const mv = new tv({
            codeBlockStyle: "fenced",
            hr: "---",
            headingStyle: "atx",
          });
          mv.use([
            function (t) {
              t.use([nv, iv, lv, dv]);
            },
            function (t) {
              t.addRule("taskListItems", {
                filter: (t) =>
                  "checkbox" === t.type &&
                  ("LI" === t.parentNode.nodeName ||
                    "LI" === t.parentNode.parentNode.nodeName),
                replacement: (t, e) => (e.checked ? "[x]" : "[ ]") + " ",
              });
            },
          ]);
          const gv = new RegExp(
            /\b(?:(?:https?|ftp):\/\/|www\.)/.source +
              /(?![-_])(?:[-_a-z0-9\u00a1-\uffff]{1,63}\.)+(?:[a-z\u00a1-\uffff]{2,63})/
                .source +
              /(?:[^\s<>]*)/.source,
            "gi"
          );
          function pv(t) {
            let e = t.length;
            for (; e > 0; ) {
              const n = t[e - 1];
              if ("?!.,:*_~'\"".includes(n)) e--;
              else {
                if (")" != n) break;
                {
                  let n = 0;
                  for (let i = 0; i < e; i++)
                    "(" == t[i] ? n++ : ")" == t[i] && n--;
                  if (!(n < 0)) break;
                  e--;
                }
              }
            }
            return e;
          }
          class fv {
            constructor(t) {
              this._htmlDP = new al(t);
            }
            keepHtml(t) {
              mv.keep([t]);
            }
            toView(t) {
              const e =
                ((n = t),
                EC.parse(n, {
                  gfm: !0,
                  breaks: !0,
                  tables: !0,
                  xhtml: !0,
                  headerIds: !1,
                }));
              var n;
              return this._htmlDP.toView(e);
            }
            toData(t) {
              return (function (t) {
                return mv.turndown(t);
              })(this._htmlDP.toData(t));
            }
            registerRawContentMatcher(t) {
              this._htmlDP.registerRawContentMatcher(t);
            }
            useFillerType() {}
          }
          function kv(t, e) {
            return (t) => {
              t.on("attribute:url:media", n);
            };
            function n(n, i, o) {
              if (!o.consumable.consume(i.item, n.name)) return;
              const r = i.attributeNewValue,
                s = o.writer,
                a = o.mapper.toViewElement(i.item),
                c = [...a.getChildren()].find((t) =>
                  t.getCustomProperty("media-content")
                );
              s.remove(c);
              const l = t.getMediaViewElement(s, r, e);
              s.insert(s.createPositionAt(a, 0), l);
            }
          }
          function bv(t, e, n, i) {
            return t.createContainerElement("figure", { class: "media" }, [
              e.getMediaViewElement(t, n, i),
              t.createSlot(),
            ]);
          }
          function wv(t) {
            const e = t.getSelectedElement();
            return e && e.is("element", "media") ? e : null;
          }
          function Av(t, e, n, i) {
            t.change((o) => {
              const r = o.createElement("media", { url: e });
              t.insertObject(r, n, null, {
                setSelection: "on",
                findOptimalPosition: i,
              });
            });
          }
          class _v extends ge {
            refresh() {
              const t = this.editor.model,
                e = t.document.selection,
                n = wv(e);
              (this.value = n ? n.getAttribute("url") : null),
                (this.isEnabled =
                  (function (t) {
                    const e = t.getSelectedElement();
                    return !!e && "media" === e.name;
                  })(e) ||
                  (function (t, e) {
                    let n = Jg(t, e).start.parent;
                    n.isEmpty && !e.schema.isLimit(n) && (n = n.parent);
                    return e.schema.checkChild(n, "media");
                  })(e, t));
            }
            execute(t) {
              const e = this.editor.model,
                n = e.document.selection,
                i = wv(n);
              i
                ? e.change((e) => {
                    e.setAttribute("url", t, i);
                  })
                : Av(e, t, n, !0);
            }
          }
          class Cv {
            constructor(t, e) {
              const n = e.providers,
                i = e.extraProviders || [],
                o = new Set(e.removeProviders),
                r = n.concat(i).filter((t) => {
                  const e = t.name;
                  return e
                    ? !o.has(e)
                    : (l("media-embed-no-provider-name", { provider: t }), !1);
                });
              (this.locale = t), (this.providerDefinitions = r);
            }
            hasMedia(t) {
              return !!this._getMedia(t);
            }
            getMediaViewElement(t, e, n) {
              return this._getMedia(e).getViewElement(t, n);
            }
            _getMedia(t) {
              if (!t) return new vv(this.locale);
              t = t.trim();
              for (const e of this.providerDefinitions) {
                const n = e.html,
                  i = Ii(e.url);
                for (const e of i) {
                  const i = this._getUrlMatches(t, e);
                  if (i) return new vv(this.locale, t, i, n);
                }
              }
              return null;
            }
            _getUrlMatches(t, e) {
              let n = t.match(e);
              if (n) return n;
              let i = t.replace(/^https?:\/\//, "");
              return (
                (n = i.match(e)),
                n ||
                  ((i = i.replace(/^www\./, "")), (n = i.match(e)), n || null)
              );
            }
          }
          class vv {
            constructor(t, e, n, i) {
              (this.url = this._getValidUrl(e)),
                (this._t = t.t),
                (this._match = n),
                (this._previewRenderer = i);
            }
            getViewElement(t, e) {
              const n = {};
              let i;
              if (
                e.renderForEditingView ||
                (e.renderMediaPreview && this.url && this._previewRenderer)
              ) {
                this.url && (n["data-oembed-url"] = this.url),
                  e.renderForEditingView && (n.class = "ck-media__wrapper");
                const o = this._getPreviewHtml(e);
                i = t.createRawElement("div", n, (t, e) => {
                  e.setContentOf(t, o);
                });
              } else
                this.url && (n.url = this.url),
                  (i = t.createEmptyElement(e.elementName, n));
              return t.setCustomProperty("media-content", !0, i), i;
            }
            _getPreviewHtml(t) {
              return this._previewRenderer
                ? this._previewRenderer(this._match)
                : this.url && t.renderForEditingView
                ? this._getPlaceholderHtml()
                : "";
            }
            _getPlaceholderHtml() {
              const t = new gh(),
                e = new hh();
              (t.text = this._t("Open media in new tab")),
                (e.content =
                  '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>'),
                (e.viewBox = "0 0 64 42");
              return new Hd({
                tag: "div",
                attributes: { class: "ck ck-reset_all ck-media__placeholder" },
                children: [
                  {
                    tag: "div",
                    attributes: { class: "ck-media__placeholder__icon" },
                    children: [e],
                  },
                  {
                    tag: "a",
                    attributes: {
                      class: "ck-media__placeholder__url",
                      target: "_blank",
                      rel: "noopener noreferrer",
                      href: this.url,
                    },
                    children: [
                      {
                        tag: "span",
                        attributes: {
                          class: "ck-media__placeholder__url__text",
                        },
                        children: [this.url],
                      },
                      t,
                    ],
                  },
                ],
              }).render().outerHTML;
            }
            _getValidUrl(t) {
              return t ? (t.match(/^https?/) ? t : "https://" + t) : null;
            }
          }
          var yv = n(952),
            xv = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(yv.Z, xv);
          yv.Z.locals;
          class Ev extends ue {
            static get pluginName() {
              return "MediaEmbedEditing";
            }
            constructor(t) {
              super(t),
                t.config.define("mediaEmbed", {
                  elementName: "oembed",
                  providers: [
                    {
                      name: "dailymotion",
                      url: /^dailymotion\.com\/video\/(\w+)/,
                      html: (t) =>
                        `<div style="position: relative; padding-bottom: 100%; height: 0; "><iframe src="https://www.dailymotion.com/embed/video/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" width="480" height="270" allowfullscreen allow="autoplay"></iframe></div>`,
                    },
                    {
                      name: "spotify",
                      url: [
                        /^open\.spotify\.com\/(artist\/\w+)/,
                        /^open\.spotify\.com\/(album\/\w+)/,
                        /^open\.spotify\.com\/(track\/\w+)/,
                      ],
                      html: (t) =>
                        `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;"><iframe src="https://open.spotify.com/embed/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe></div>`,
                    },
                    {
                      name: "youtube",
                      url: [
                        /^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)/,
                        /^(?:m\.)?youtube\.com\/v\/([\w-]+)/,
                        /^youtube\.com\/embed\/([\w-]+)/,
                        /^youtu\.be\/([\w-]+)/,
                      ],
                      html: (t) =>
                        `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://www.youtube.com/embed/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>`,
                    },
                    {
                      name: "vimeo",
                      url: [
                        /^vimeo\.com\/(\d+)/,
                        /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/,
                        /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/,
                        /^vimeo\.com\/channels\/[^/]+\/(\d+)/,
                        /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/,
                        /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/,
                        /^player\.vimeo\.com\/video\/(\d+)/,
                      ],
                      html: (t) =>
                        `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://player.vimeo.com/video/${t[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>`,
                    },
                    { name: "instagram", url: /^instagram\.com\/p\/(\w+)/ },
                    { name: "twitter", url: /^twitter\.com/ },
                    {
                      name: "googleMaps",
                      url: [
                        /^google\.com\/maps/,
                        /^goo\.gl\/maps/,
                        /^maps\.google\.com/,
                        /^maps\.app\.goo\.gl/,
                      ],
                    },
                    { name: "flickr", url: /^flickr\.com/ },
                    { name: "facebook", url: /^facebook\.com/ },
                  ],
                }),
                (this.registry = new Cv(t.locale, t.config.get("mediaEmbed")));
            }
            init() {
              const t = this.editor,
                e = t.model.schema,
                n = t.t,
                i = t.conversion,
                o = t.config.get("mediaEmbed.previewsInData"),
                r = t.config.get("mediaEmbed.elementName"),
                s = this.registry;
              t.commands.add("mediaEmbed", new _v(t)),
                e.register("media", {
                  inheritAllFrom: "$blockObject",
                  allowAttributes: ["url"],
                }),
                i.for("dataDowncast").elementToStructure({
                  model: "media",
                  view: (t, { writer: e }) => {
                    const n = t.getAttribute("url");
                    return bv(e, s, n, {
                      elementName: r,
                      renderMediaPreview: n && o,
                    });
                  },
                }),
                i
                  .for("dataDowncast")
                  .add(kv(s, { elementName: r, renderMediaPreview: o })),
                i.for("editingDowncast").elementToStructure({
                  model: "media",
                  view: (t, { writer: e }) => {
                    const i = t.getAttribute("url");
                    return (function (t, e, n) {
                      return (
                        e.setCustomProperty("media", !0, t),
                        Gg(t, e, { label: n })
                      );
                    })(
                      bv(e, s, i, { elementName: r, renderForEditingView: !0 }),
                      e,
                      n("media widget")
                    );
                  },
                }),
                i
                  .for("editingDowncast")
                  .add(kv(s, { elementName: r, renderForEditingView: !0 })),
                i
                  .for("upcast")
                  .elementToElement({
                    view: (t) =>
                      ["oembed", r].includes(t.name) && t.getAttribute("url")
                        ? { name: !0 }
                        : null,
                    model: (t, { writer: e }) => {
                      const n = t.getAttribute("url");
                      if (s.hasMedia(n))
                        return e.createElement("media", { url: n });
                    },
                  })
                  .elementToElement({
                    view: {
                      name: "div",
                      attributes: { "data-oembed-url": !0 },
                    },
                    model: (t, { writer: e }) => {
                      const n = t.getAttribute("data-oembed-url");
                      if (s.hasMedia(n))
                        return e.createElement("media", { url: n });
                    },
                  })
                  .add((t) => {
                    t.on("element:figure", function (t, e, n) {
                      if (
                        !n.consumable.consume(e.viewItem, {
                          name: !0,
                          classes: "media",
                        })
                      )
                        return;
                      const { modelRange: i, modelCursor: o } =
                        n.convertChildren(e.viewItem, e.modelCursor);
                      (e.modelRange = i), (e.modelCursor = o);
                      Na(i.getItems()) ||
                        n.consumable.revert(e.viewItem, {
                          name: !0,
                          classes: "media",
                        });
                    });
                  });
            }
          }
          const Dv = /^(?:http(s)?:\/\/)?[\w-]+\.[\w-.~:/?#[\]@!$&'()*+,;=%]+$/;
          class Sv extends ue {
            static get requires() {
              return [xp, ig, Pp];
            }
            static get pluginName() {
              return "AutoMediaEmbed";
            }
            constructor(t) {
              super(t),
                (this._timeoutId = null),
                (this._positionToInsert = null);
            }
            init() {
              const t = this.editor,
                e = t.model.document;
              this.listenTo(
                t.plugins.get("ClipboardPipeline"),
                "inputTransformation",
                () => {
                  const t = e.selection.getFirstRange(),
                    n = ed.fromPosition(t.start);
                  n.stickiness = "toPrevious";
                  const i = ed.fromPosition(t.end);
                  (i.stickiness = "toNext"),
                    e.once(
                      "change:data",
                      () => {
                        this._embedMediaBetweenPositions(n, i),
                          n.detach(),
                          i.detach();
                      },
                      { priority: "high" }
                    );
                }
              ),
                t.commands.get("undo").on(
                  "execute",
                  () => {
                    this._timeoutId &&
                      (os.window.clearTimeout(this._timeoutId),
                      this._positionToInsert.detach(),
                      (this._timeoutId = null),
                      (this._positionToInsert = null));
                  },
                  { priority: "high" }
                );
            }
            _embedMediaBetweenPositions(t, e) {
              const n = this.editor,
                i = n.plugins.get(Ev).registry,
                o = new cc(t, e),
                r = o.getWalker({ ignoreElementEnd: !0 });
              let s = "";
              for (const t of r) t.item.is("$textProxy") && (s += t.item.data);
              if (((s = s.trim()), !s.match(Dv))) return void o.detach();
              if (!i.hasMedia(s)) return void o.detach();
              n.commands.get("mediaEmbed").isEnabled
                ? ((this._positionToInsert = ed.fromPosition(t)),
                  (this._timeoutId = os.window.setTimeout(() => {
                    n.model.change((t) => {
                      let e;
                      (this._timeoutId = null),
                        t.remove(o),
                        o.detach(),
                        "$graveyard" !== this._positionToInsert.root.rootName &&
                          (e = this._positionToInsert),
                        Av(n.model, s, e, !1),
                        this._positionToInsert.detach(),
                        (this._positionToInsert = null);
                    }),
                      n.plugins.get("Delete").requestUndoOnBackspace();
                  }, 100)))
                : o.detach();
            }
          }
          var Iv = n(3525),
            Tv = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Iv.Z, Tv);
          Iv.Z.locals;
          class Mv extends Vd {
            constructor(t, e) {
              super(e);
              const n = e.t;
              (this.focusTracker = new za()),
                (this.keystrokes = new Pa()),
                this.set("mediaURLInputValue", ""),
                (this.urlInputView = this._createUrlInput()),
                (this.saveButtonView = this._createButton(
                  n("Save"),
                  zd.check,
                  "ck-button-save"
                )),
                (this.saveButtonView.type = "submit"),
                this.saveButtonView
                  .bind("isEnabled")
                  .to(this, "mediaURLInputValue", (t) => !!t),
                (this.cancelButtonView = this._createButton(
                  n("Cancel"),
                  zd.cancel,
                  "ck-button-cancel",
                  "cancel"
                )),
                (this._focusables = new Od()),
                (this._focusCycler = new vh({
                  focusables: this._focusables,
                  focusTracker: this.focusTracker,
                  keystrokeHandler: this.keystrokes,
                  actions: { focusPrevious: "shift + tab", focusNext: "tab" },
                })),
                (this._validators = t),
                this.setTemplate({
                  tag: "form",
                  attributes: {
                    class: ["ck", "ck-media-form", "ck-responsive-form"],
                    tabindex: "-1",
                  },
                  children: [
                    this.urlInputView,
                    this.saveButtonView,
                    this.cancelButtonView,
                  ],
                }),
                Ld(this);
            }
            render() {
              super.render(), Rd({ view: this });
              [
                this.urlInputView,
                this.saveButtonView,
                this.cancelButtonView,
              ].forEach((t) => {
                this._focusables.add(t), this.focusTracker.add(t.element);
              }),
                this.keystrokes.listenTo(this.element);
              const t = (t) => t.stopPropagation();
              this.keystrokes.set("arrowright", t),
                this.keystrokes.set("arrowleft", t),
                this.keystrokes.set("arrowup", t),
                this.keystrokes.set("arrowdown", t),
                this.listenTo(
                  this.urlInputView.element,
                  "selectstart",
                  (t, e) => {
                    e.stopPropagation();
                  },
                  { priority: "high" }
                );
            }
            destroy() {
              super.destroy(),
                this.focusTracker.destroy(),
                this.keystrokes.destroy();
            }
            focus() {
              this._focusCycler.focusFirst();
            }
            get url() {
              return this.urlInputView.fieldView.element.value.trim();
            }
            set url(t) {
              this.urlInputView.fieldView.element.value = t.trim();
            }
            isValid() {
              this.resetFormStatus();
              for (const t of this._validators) {
                const e = t(this);
                if (e) return (this.urlInputView.errorText = e), !1;
              }
              return !0;
            }
            resetFormStatus() {
              (this.urlInputView.errorText = null),
                (this.urlInputView.infoText = this._urlInputViewInfoDefault);
            }
            _createUrlInput() {
              const t = this.locale.t,
                e = new xu(this.locale, Eu),
                n = e.fieldView;
              return (
                (this._urlInputViewInfoDefault = t(
                  "Paste the media URL in the input."
                )),
                (this._urlInputViewInfoTip = t(
                  "Tip: Paste the URL into the content to embed faster."
                )),
                (e.label = t("Media URL")),
                (e.infoText = this._urlInputViewInfoDefault),
                n.on("input", () => {
                  (e.infoText = n.element.value
                    ? this._urlInputViewInfoTip
                    : this._urlInputViewInfoDefault),
                    (this.mediaURLInputValue = n.element.value.trim());
                }),
                e
              );
            }
            _createButton(t, e, n, i) {
              const o = new kh(this.locale);
              return (
                o.set({ label: t, icon: e, tooltip: !0 }),
                o.extendTemplate({ attributes: { class: n } }),
                i && o.delegate("execute").to(this, i),
                o
              );
            }
          }
          class Bv extends ue {
            static get requires() {
              return [Ev];
            }
            static get pluginName() {
              return "MediaEmbedUI";
            }
            init() {
              const t = this.editor,
                e = t.commands.get("mediaEmbed"),
                n = t.plugins.get(Ev).registry;
              t.ui.componentFactory.add("mediaEmbed", (i) => {
                const o = ou(i),
                  r = new Mv(
                    (function (t, e) {
                      return [
                        (e) => {
                          if (!e.url.length)
                            return t("The URL must not be empty.");
                        },
                        (n) => {
                          if (!e.hasMedia(n.url))
                            return t("This media URL is not supported.");
                        },
                      ];
                    })(t.t, n),
                    t.locale
                  );
                return (
                  this._setUpDropdown(o, r, e, t), this._setUpForm(o, r, e), o
                );
              });
            }
            _setUpDropdown(t, e, n) {
              const i = this.editor,
                o = i.t,
                r = t.buttonView;
              function s() {
                i.editing.view.focus(), (t.isOpen = !1);
              }
              t.bind("isEnabled").to(n),
                t.panelView.children.add(e),
                r.set({
                  label: o("Insert media"),
                  icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M18.68 3.03c.6 0 .59-.03.59.55v12.84c0 .59.01.56-.59.56H1.29c-.6 0-.59.03-.59-.56V3.58c0-.58-.01-.55.6-.55h17.38zM15.77 15V5H4.2v10h11.57zM2 4v1h1V4H2zm0 2v1h1V6H2zm0 2v1h1V8H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zM17 4v1h1V4h-1zm0 2v1h1V6h-1zm0 2v1h1V8h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zM7.5 7.177a.4.4 0 0 1 .593-.351l5.133 2.824a.4.4 0 0 1 0 .7l-5.133 2.824a.4.4 0 0 1-.593-.35V7.176v.001z"/></svg>',
                  tooltip: !0,
                }),
                r.on(
                  "open",
                  () => {
                    e.disableCssTransitions(),
                      (e.url = n.value || ""),
                      e.urlInputView.fieldView.select(),
                      e.focus(),
                      e.enableCssTransitions();
                  },
                  { priority: "low" }
                ),
                t.on("submit", () => {
                  e.isValid() && (i.execute("mediaEmbed", e.url), s());
                }),
                t.on("change:isOpen", () => e.resetFormStatus()),
                t.on("cancel", () => s());
            }
            _setUpForm(t, e, n) {
              e.delegate("submit", "cancel").to(t),
                e.urlInputView.bind("value").to(n, "value"),
                e.urlInputView.bind("isReadOnly").to(n, "isEnabled", (t) => !t);
            }
          }
          var Nv = n(5777),
            zv = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Nv.Z, zv);
          Nv.Z.locals;
          class Pv extends ge {
            constructor(t) {
              super(t),
                t.plugins.has("ImageUtils") || l("image-utils-plugin-required"),
                this.set("isImageSelected", !1);
            }
            refresh() {
              const t =
                  this.editor.model.document.selection.getSelectedElement(),
                e = this.editor.plugins.get("ImageUtils");
              (this.isEnabled =
                e.isImageAllowed(this.editor.model) || e.isImage(t)),
                (this.isImageSelected = e.isImage(t));
            }
            execute(t) {
              const e = this.editor.model,
                n = e.document.selection.getSelectedElement(),
                i = this.editor.plugins.get("ImageUtils");
              this.editor.editing.view.focus();
              const o = t.source;
              if (this.isEnabled)
                if (i.isImage(n)) this.updateImage(o, n);
                else {
                  const t = Object.fromEntries(
                    e.document.selection.getAttributes()
                  );
                  i.insertImage({ src: o, ...t }, e.document.selection);
                }
            }
            updateImage(t, e) {
              this.editor.model.change((n) => {
                n.setAttribute("src", t, e),
                  n.removeAttribute("srcset", e),
                  n.removeAttribute("sizes", e);
              });
            }
          }
          var Lv = n(4944),
            Rv = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Lv.Z, Rv);
          Lv.Z.locals;
          class Ov extends Vd {
            constructor(t) {
              super(t);
              const e = t.t;
              (this.keystrokes = new Pa()),
                (this._focusables = new Od()),
                (this._focusTracker = new za()),
                (this._children = this.createCollection()),
                (this.urlInputView = this._createUrlInput(
                  e("Insert image via URL")
                )),
                (this.saveButtonView = this._createButton(
                  e("Insert"),
                  zd.check,
                  "ck-button-save"
                )),
                (this.saveButtonView.type = "submit"),
                (this.cancelButtonView = this._createButton(
                  e("Cancel"),
                  zd.cancel,
                  "ck-button-cancel",
                  "cancel"
                )),
                this.setTemplate({
                  tag: "form",
                  attributes: {
                    class: ["ck", "ck-insert-image-form"],
                    tabindex: "-1",
                  },
                  children: this._children,
                });
            }
            _createUrlInput(t) {
              const e = new xu(this.locale, Eu);
              return (
                (e.fieldView.placeholder = "https://example.com"),
                (e.label = t),
                this._children.add(e),
                this._focusables.add(e),
                this._focusTracker.add(e.element),
                e
              );
            }
            _createButton(t, e, n, i) {
              const o = new kh(this.locale);
              return (
                o.set({ label: t, icon: e, tooltip: !0 }),
                o.extendTemplate({ attributes: { class: n } }),
                i && o.delegate("execute").to(this, i),
                this._children.add(o),
                this._focusables.add(o),
                this._focusTracker.add(o.element),
                o
              );
            }
            render() {
              super.render(),
                Rd({ view: this }),
                this.keystrokes.listenTo(this.element),
                new vh({
                  focusables: this._focusables,
                  focusTracker: this._focusTracker,
                  keystrokeHandler: this.keystrokes,
                  actions: { focusPrevious: "shift + tab", focusNext: "tab" },
                }).focusFirst();
            }
            resetFormForInsert() {
              const t = this.locale.t;
              (this.urlInputView.fieldView.element.value = ""),
                (this.saveButtonView.label = t("Insert"));
            }
            resetFormForUpdate(t) {
              const e = this.locale.t;
              (this.urlInputView.fieldView.element.value = t),
                (this.saveButtonView.label = e("Update")),
                (this.urlInputView.label = e("Update image URL"));
            }
          }
          const jv = "only-insert-image";
          class Fv extends ue {
            constructor(t) {
              super(t),
                this.set("isActiveView", !1),
                (this.formView = new Ov(t.locale));
            }
            static get requires() {
              return [Hu];
            }
            static get pluginName() {
              return "InsertImageForm";
            }
            get viewElement() {
              return this.formView.element;
            }
            init() {
              const t = this.editor;
              t.editing.view.addObserver(fm),
                this._initUserInteractionsFromFormView(t),
                (this._balloon = t.plugins.get(Hu));
            }
            _initUserInteractionsFromFormView(t) {
              this.listenTo(this.formView, "submit", () => {
                (0 != this.formView.urlInputView.fieldView.element.value) !=
                  null &&
                  this.formView.urlInputView.fieldView.element.value.trim()
                    .length &&
                  (t.execute("imageinsert", {
                    source: this.formView.urlInputView.fieldView.element.value,
                  }),
                  this.hideUI());
              }),
                this.listenTo(this.formView, "cancel", () => {
                  this.hideUI();
                }),
                this.formView.keystrokes.set("Esc", () => {
                  this.hideUI();
                });
            }
            destroy() {
              super.destroy(), this.formView.destroy();
            }
            _addFormView() {
              this._isFormInBalloon ||
                (this._balloon.add({
                  view: this.formView,
                  position: this._getBalloonPositionData(),
                }),
                this._balloon.visibleView === this.formView &&
                  this.formView.urlInputView.fieldView.select());
            }
            _removeFormView() {
              var t;
              this._isFormInBalloon &&
                (this.formView.saveButtonView.focus(),
                this._balloon.remove(this.formView),
                this.editor.editing.view.focus(),
                (t = this.editor.model).markers.has(jv) &&
                  t.change((t) => {
                    t.removeMarker(jv);
                  }));
            }
            _showUI() {
              if (
                this.editor.plugins
                  .get("ImageUtils")
                  .isImage(
                    this.editor.model.document.selection.getSelectedElement()
                  )
              ) {
                const t =
                  this.editor.model.document.selection.getSelectedElement();
                this.formView.resetFormForUpdate(t.getAttribute("src"));
              } else this.formView.resetFormForInsert();
              this._addFormView(), (this.isActiveView = !0);
            }
            hideUI() {
              this._isFormInBalloon &&
                (this.editor.editing.view.focus(),
                this._removeFormView(),
                (this.isActiveView = !1));
            }
            swapUI() {
              this.isActiveView ? this.hideUI() : this._showUI();
            }
            get _isFormInBalloon() {
              return this._balloon.hasView(this.formView);
            }
            get _isFormVisible() {
              return this._balloon.visibleView == this.formView;
            }
            _getBalloonPositionData() {
              const t = this.editor.editing.view,
                e = t.document;
              return {
                target: t.domConverter.viewRangeToDom(
                  e.selection.getFirstRange()
                ),
              };
            }
          }
          function Vv(t, e) {
            if (!t.childCount) return;
            const n = new bm(t.document),
              i = (function (t, e) {
                const n = e.createRangeIn(t),
                  i = new Hi({
                    name: /^p|h\d+$/,
                    styles: { "mso-list": /.*/ },
                  }),
                  o = [];
                for (const t of n)
                  if ("elementStart" === t.type && i.match(t.item)) {
                    const e = $v(t.item);
                    o.push({
                      element: t.item,
                      id: e.id,
                      order: e.order,
                      indent: e.indent,
                    });
                  }
                return o;
              })(t, n);
            if (!i.length) return;
            let o = null,
              r = 1;
            i.forEach((t, s) => {
              const a = (function (t, e) {
                  if (!t) return !0;
                  if (t.id !== e.id) return e.indent - t.indent != 1;
                  const n = e.element.previousSibling;
                  if (!n) return !0;
                  return (
                    (i = n), !(i.is("element", "ol") || i.is("element", "ul"))
                  );
                  var i;
                })(i[s - 1], t),
                c = a ? null : i[s - 1],
                l = ((h = t), (d = c) ? h.indent - d.indent : h.indent - 1);
              var d, h;
              if ((a && ((o = null), (r = 1)), !o || 0 !== l)) {
                const i = (function (t, e) {
                  const n = new RegExp(
                      `@list l${t.id}:level${t.indent}\\s*({[^}]*)`,
                      "gi"
                    ),
                    i = /mso-level-number-format:([^;]{0,100});/gi,
                    o = /mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi,
                    r = n.exec(e);
                  let s = "decimal",
                    a = "ol",
                    c = null;
                  if (r && r[1]) {
                    const e = i.exec(r[1]);
                    if (
                      (e &&
                        e[1] &&
                        ((s = e[1].trim()),
                        (a = "bullet" !== s && "image" !== s ? "ol" : "ul")),
                      "bullet" === s)
                    ) {
                      const e = (function (t) {
                        const e = (function (t) {
                          if (t.getChild(0).is("$text")) return null;
                          for (const e of t.getChildren()) {
                            if (!e.is("element", "span")) continue;
                            const t = e.getChild(0);
                            return t.is("$text") ? t : t.getChild(0);
                          }
                        })(t);
                        if (!e) return null;
                        const n = e._data;
                        if ("o" === n) return "circle";
                        if ("·" === n) return "disc";
                        if ("§" === n) return "square";
                        return null;
                      })(t.element);
                      e && (s = e);
                    } else {
                      const t = o.exec(r[1]);
                      t && t[1] && (c = parseInt(t[1]));
                    }
                  }
                  return { type: a, startIndex: c, style: Hv(s) };
                })(t, e);
                if (o) {
                  if (t.indent > r) {
                    const t = o.getChild(o.childCount - 1),
                      e = t.getChild(t.childCount - 1);
                    (o = Uv(i, e, n)), (r += 1);
                  } else if (t.indent < r) {
                    const e = r - t.indent;
                    (o = (function (t, e) {
                      const n = t.getAncestors({ parentFirst: !0 });
                      let i = null,
                        o = 0;
                      for (const t of n)
                        if (
                          (("ul" !== t.name && "ol" !== t.name) || o++, o === e)
                        ) {
                          i = t;
                          break;
                        }
                      return i;
                    })(o, e)),
                      (r = parseInt(t.indent));
                  }
                } else o = Uv(i, t.element, n);
                t.indent <= r &&
                  (o.is("element", i.type) || (o = n.rename(i.type, o)));
              }
              const u = (function (t, e) {
                return (
                  (function (t, e) {
                    const n = new Hi({
                        name: "span",
                        styles: { "mso-list": "Ignore" },
                      }),
                      i = e.createRangeIn(t);
                    for (const t of i)
                      "elementStart" === t.type &&
                        n.match(t.item) &&
                        e.remove(t.item);
                  })(t, e),
                  e.rename("li", t)
                );
              })(t.element, n);
              n.appendChild(u, o);
            });
          }
          function Hv(t) {
            if (t.startsWith("arabic-leading-zero"))
              return "decimal-leading-zero";
            switch (t) {
              case "alpha-upper":
                return "upper-alpha";
              case "alpha-lower":
                return "lower-alpha";
              case "roman-upper":
                return "upper-roman";
              case "roman-lower":
                return "lower-roman";
              case "circle":
              case "disc":
              case "square":
                return t;
              default:
                return null;
            }
          }
          function Uv(t, e, n) {
            const i = e.parent,
              o = n.createElement(t.type),
              r = i.getChildIndex(e) + 1;
            return (
              n.insertChild(r, o, i),
              t.style && n.setStyle("list-style-type", t.style, o),
              t.startIndex &&
                t.startIndex > 1 &&
                n.setAttribute("start", t.startIndex, o),
              o
            );
          }
          function $v(t) {
            const e = {},
              n = t.getStyle("mso-list");
            if (n) {
              const t = n.match(/(^|\s{1,100})l(\d+)/i),
                i = n.match(/\s{0,100}lfo(\d+)/i),
                o = n.match(/\s{0,100}level(\d+)/i);
              t &&
                i &&
                o &&
                ((e.id = t[2]), (e.order = i[1]), (e.indent = o[1]));
            }
            return e;
          }
          const qv = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
          class Gv {
            constructor(t) {
              this.document = t;
            }
            isActive(t) {
              return qv.test(t);
            }
            execute(t) {
              const e = new bm(this.document),
                { body: n } = t._parsedData;
              !(function (t, e) {
                for (const n of t.getChildren())
                  if (
                    n.is("element", "b") &&
                    "normal" === n.getStyle("font-weight")
                  ) {
                    const i = t.getChildIndex(n);
                    e.remove(n), e.insertChild(i, n.getChildren(), t);
                  }
              })(n, e),
                (function (t, e) {
                  for (const n of e.createRangeIn(t)) {
                    const t = n.item;
                    if (t.is("element", "li")) {
                      const n = t.getChild(0);
                      n && n.is("element", "p") && e.unwrapElement(n);
                    }
                  }
                })(n, e),
                (t.content = n);
            }
          }
          function Wv(t, e) {
            if (!t.childCount) return;
            const n = new bm(),
              i = (function (t, e) {
                const n = e.createRangeIn(t),
                  i = new Hi({ name: /v:(.+)/ }),
                  o = [];
                for (const t of n) {
                  if ("elementStart" != t.type) continue;
                  const e = t.item,
                    n = (e.previousSibling && e.previousSibling.name) || null;
                  i.match(e) &&
                    e.getAttribute("o:gfxdata") &&
                    "v:shapetype" !== n &&
                    o.push(t.item.getAttribute("id"));
                }
                return o;
              })(t, n);
            !(function (t, e, n) {
              const i = n.createRangeIn(e),
                o = new Hi({ name: "img" }),
                r = [];
              for (const e of i)
                if (o.match(e.item)) {
                  const n = e.item,
                    i = n.getAttribute("v:shapes")
                      ? n.getAttribute("v:shapes").split(" ")
                      : [];
                  i.length && i.every((e) => t.indexOf(e) > -1)
                    ? r.push(n)
                    : n.getAttribute("src") || r.push(n);
                }
              for (const t of r) n.remove(t);
            })(i, t, n),
              (function (t, e) {
                const n = e.createRangeIn(t),
                  i = new Hi({ name: /v:(.+)/ }),
                  o = [];
                for (const t of n)
                  "elementStart" == t.type && i.match(t.item) && o.push(t.item);
                for (const t of o) e.remove(t);
              })(t, n);
            const o = (function (t, e) {
              const n = e.createRangeIn(t),
                i = new Hi({ name: "img" }),
                o = [];
              for (const t of n)
                i.match(t.item) &&
                  t.item.getAttribute("src").startsWith("file://") &&
                  o.push(t.item);
              return o;
            })(t, n);
            o.length &&
              (function (t, e, n) {
                if (t.length === e.length)
                  for (let i = 0; i < t.length; i++) {
                    const o = `data:${e[i].type};base64,${Yv(e[i].hex)}`;
                    n.setAttribute("src", o, t[i]);
                  }
              })(
                o,
                (function (t) {
                  if (!t) return [];
                  const e =
                      /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/,
                    n = new RegExp(
                      "(?:(" + e.source + "))([\\da-fA-F\\s]+)\\}",
                      "g"
                    ),
                    i = t.match(n),
                    o = [];
                  if (i)
                    for (const t of i) {
                      let n = !1;
                      t.includes("\\pngblip")
                        ? (n = "image/png")
                        : t.includes("\\jpegblip") && (n = "image/jpeg"),
                        n &&
                          o.push({
                            hex: t.replace(e, "").replace(/[^\da-fA-F]/g, ""),
                            type: n,
                          });
                    }
                  return o;
                })(e),
                n
              );
          }
          function Yv(t) {
            return btoa(
              t
                .match(/\w{2}/g)
                .map((t) => String.fromCharCode(parseInt(t, 16)))
                .join("")
            );
          }
          const Kv =
              /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i,
            Qv = /xmlns:o="urn:schemas-microsoft-com/i;
          class Zv {
            constructor(t) {
              this.document = t;
            }
            isActive(t) {
              return Kv.test(t) || Qv.test(t);
            }
            execute(t) {
              const { body: e, stylesString: n } = t._parsedData;
              Vv(e, n),
                Wv(e, t.dataTransfer.getData("text/rtf")),
                (t.content = e);
            }
          }
          function Jv(t) {
            return t.replace(
              /<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g,
              (t, e) =>
                1 === e.length
                  ? " "
                  : Array(e.length + 1)
                      .join("  ")
                      .substr(0, e.length)
            );
          }
          function Xv(t, e) {
            const n = new DOMParser(),
              i = (function (t) {
                return Jv(Jv(t))
                  .replace(
                    /(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g,
                    "$1$2"
                  )
                  .replace(
                    /<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g,
                    ""
                  )
                  .replace(/ <\//g, " </")
                  .replace(/ <o:p><\/o:p>/g, " <o:p></o:p>")
                  .replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "")
                  .replace(/>([^\S\r\n]*[\r\n]\s*)</g, "><");
              })(
                (function (t) {
                  const e = "</body>",
                    n = "</html>",
                    i = t.indexOf(e);
                  if (i < 0) return t;
                  const o = t.indexOf(n, i + e.length);
                  return (
                    t.substring(0, i + e.length) +
                    (o >= 0 ? t.substring(o) : "")
                  );
                })((t = t.replace(/<!--\[if gte vml 1]>/g, "")))
              ),
              o = n.parseFromString(i, "text/html");
            !(function (t) {
              t.querySelectorAll("span[style*=spacerun]").forEach((t) => {
                const e = t.innerText.length || 0;
                t.innerHTML = Array(e + 1)
                  .join("  ")
                  .substr(0, e);
              });
            })(o);
            const r = o.body.innerHTML,
              s = (function (t, e) {
                const n = new Jo(e),
                  i = new us(n, { renderingMode: "data" }),
                  o = t.createDocumentFragment(),
                  r = t.body.childNodes;
                for (; r.length > 0; ) o.appendChild(r[0]);
                return i.domToView(o, { skipComments: !0 });
              })(o, e),
              a = (function (t) {
                const e = [],
                  n = [],
                  i = Array.from(t.getElementsByTagName("style"));
                for (const t of i)
                  t.sheet &&
                    t.sheet.cssRules &&
                    t.sheet.cssRules.length &&
                    (e.push(t.sheet), n.push(t.innerHTML));
                return { styles: e, stylesString: n.join(" ") };
              })(o);
            return {
              body: s,
              bodyString: r,
              styles: a.styles,
              stylesString: a.stylesString,
            };
          }
          const ty = "removeFormat";
          class ey extends ue {
            static get pluginName() {
              return "RemoveFormatUI";
            }
            init() {
              const t = this.editor,
                e = t.t;
              t.ui.componentFactory.add(ty, (n) => {
                const i = t.commands.get(ty),
                  o = new kh(n);
                return (
                  o.set({
                    label: e("Remove Format"),
                    icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.69 14.915c.053.052.173.083.36.093a.366.366 0 0 1 .345.485l-.003.01a.738.738 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.681.681 0 0 1 .644-.458c.197-.012.325-.043.386-.093a.28.28 0 0 0 .072-.11L9.592 4.5H6.269c-.359-.017-.609.013-.75.09-.142.078-.289.265-.442.563-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486c.001-.284-.054-.464-.167-.54-.112-.076-.367-.106-.766-.091h-3.28l-2.68 10.257c-.006.074.007.127.038.158zM3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1zm11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414-1.414 1.414z"/></svg>',
                    tooltip: !0,
                  }),
                  o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"),
                  this.listenTo(o, "execute", () => {
                    t.execute(ty), t.editing.view.focus();
                  }),
                  o
                );
              });
            }
          }
          class ny extends ge {
            refresh() {
              const t = this.editor.model;
              this.isEnabled = !!Na(
                this._getFormattingItems(t.document.selection, t.schema)
              );
            }
            execute() {
              const t = this.editor.model,
                e = t.schema;
              t.change((n) => {
                for (const i of this._getFormattingItems(
                  t.document.selection,
                  e
                ))
                  if (i.is("selection"))
                    for (const t of this._getFormattingAttributes(i, e))
                      n.removeSelectionAttribute(t);
                  else {
                    const t = n.createRangeOn(i);
                    for (const o of this._getFormattingAttributes(i, e))
                      n.removeAttribute(o, t);
                  }
              });
            }
            *_getFormattingItems(t, e) {
              const n = (t) => !!Na(this._getFormattingAttributes(t, e));
              for (const i of t.getRanges())
                for (const t of i.getItems())
                  !e.isBlock(t) && n(t) && (yield t);
              for (const e of t.getSelectedBlocks()) n(e) && (yield e);
              n(t) && (yield t);
            }
            *_getFormattingAttributes(t, e) {
              for (const [n] of t.getAttributes()) {
                const t = e.getAttributeProperties(n);
                t && t.isFormatting && (yield n);
              }
            }
          }
          class iy extends ue {
            static get pluginName() {
              return "RemoveFormatEditing";
            }
            init() {
              const t = this.editor;
              t.commands.add("removeFormat", new ny(t));
            }
          }
          function oy(t) {
            const e = [
                { name: "address", isVoid: !1 },
                { name: "article", isVoid: !1 },
                { name: "aside", isVoid: !1 },
                { name: "blockquote", isVoid: !1 },
                { name: "br", isVoid: !0 },
                { name: "details", isVoid: !1 },
                { name: "dialog", isVoid: !1 },
                { name: "dd", isVoid: !1 },
                { name: "div", isVoid: !1 },
                { name: "dl", isVoid: !1 },
                { name: "dt", isVoid: !1 },
                { name: "fieldset", isVoid: !1 },
                { name: "figcaption", isVoid: !1 },
                { name: "figure", isVoid: !1 },
                { name: "footer", isVoid: !1 },
                { name: "form", isVoid: !1 },
                { name: "h1", isVoid: !1 },
                { name: "h2", isVoid: !1 },
                { name: "h3", isVoid: !1 },
                { name: "h4", isVoid: !1 },
                { name: "h5", isVoid: !1 },
                { name: "h6", isVoid: !1 },
                { name: "header", isVoid: !1 },
                { name: "hgroup", isVoid: !1 },
                { name: "hr", isVoid: !0 },
                { name: "input", isVoid: !0 },
                { name: "li", isVoid: !1 },
                { name: "main", isVoid: !1 },
                { name: "nav", isVoid: !1 },
                { name: "ol", isVoid: !1 },
                { name: "p", isVoid: !1 },
                { name: "section", isVoid: !1 },
                { name: "table", isVoid: !1 },
                { name: "tbody", isVoid: !1 },
                { name: "td", isVoid: !1 },
                { name: "textarea", isVoid: !1 },
                { name: "th", isVoid: !1 },
                { name: "thead", isVoid: !1 },
                { name: "tr", isVoid: !1 },
                { name: "ul", isVoid: !1 },
              ],
              n = e.map((t) => t.name).join("|"),
              i = t
                .replace(new RegExp(`</?(${n})( .*?)?>`, "g"), "\n$&\n")
                .split("\n");
            let o = 0;
            return i
              .filter((t) => t.length)
              .map((t) =>
                (function (t, e) {
                  return e.some(
                    (e) =>
                      !e.isVoid && !!new RegExp(`<${e.name}( .*?)?>`).test(t)
                  );
                })(t, e)
                  ? ry(t, o++)
                  : (function (t, e) {
                      return e.some((e) => new RegExp(`</${e.name}>`).test(t));
                    })(t, e)
                  ? ry(t, --o)
                  : ry(t, o)
              )
              .join("\n");
          }
          function ry(t, e, n = "    ") {
            return `${n.repeat(Math.max(0, e))}${t}`;
          }
          var sy = n(671),
            ay = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(sy.Z, ay);
          sy.Z.locals;
          const cy = "SourceEditingMode";
          function ly(t) {
            return (function (t) {
              return t.startsWith("<");
            })(t)
              ? oy(t)
              : t;
          }
          const dy = "strikethrough";
          class hy extends ue {
            static get pluginName() {
              return "StrikethroughEditing";
            }
            init() {
              const t = this.editor;
              t.model.schema.extend("$text", { allowAttributes: dy }),
                t.model.schema.setAttributeProperties(dy, {
                  isFormatting: !0,
                  copyOnEnter: !0,
                }),
                t.conversion.attributeToElement({
                  model: dy,
                  view: "s",
                  upcastAlso: [
                    "del",
                    "strike",
                    { styles: { "text-decoration": "line-through" } },
                  ],
                }),
                t.commands.add(dy, new Vf(t, dy)),
                t.keystrokes.set("CTRL+SHIFT+X", "strikethrough");
            }
          }
          const uy = "strikethrough";
          class my extends ue {
            static get pluginName() {
              return "StrikethroughUI";
            }
            init() {
              const t = this.editor,
                e = t.t;
              t.ui.componentFactory.add(uy, (n) => {
                const i = t.commands.get(uy),
                  o = new kh(n);
                return (
                  o.set({
                    label: e("Strikethrough"),
                    icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9 6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>',
                    keystroke: "CTRL+SHIFT+X",
                    tooltip: !0,
                    isToggleable: !0,
                  }),
                  o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"),
                  this.listenTo(o, "execute", () => {
                    t.execute(uy), t.editing.view.focus();
                  }),
                  o
                );
              });
            }
          }
          const gy = "subscript";
          class py extends ue {
            static get pluginName() {
              return "SubscriptEditing";
            }
            init() {
              const t = this.editor;
              t.model.schema.extend("$text", { allowAttributes: gy }),
                t.model.schema.setAttributeProperties(gy, {
                  isFormatting: !0,
                  copyOnEnter: !0,
                }),
                t.conversion.attributeToElement({
                  model: gy,
                  view: "sub",
                  upcastAlso: [{ styles: { "vertical-align": "sub" } }],
                }),
                t.commands.add(gy, new Vf(t, gy));
            }
          }
          const fy = "subscript";
          class ky extends ue {
            static get pluginName() {
              return "SubscriptUI";
            }
            init() {
              const t = this.editor,
                e = t.t;
              t.ui.componentFactory.add(fy, (n) => {
                const i = t.commands.get(fy),
                  o = new kh(n);
                return (
                  o.set({
                    label: e("Subscript"),
                    icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.03 10.349 3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82zm8.147 7.829h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309z"/></svg>',
                    tooltip: !0,
                    isToggleable: !0,
                  }),
                  o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"),
                  this.listenTo(o, "execute", () => {
                    t.execute(fy), t.editing.view.focus();
                  }),
                  o
                );
              });
            }
          }
          const by = "superscript";
          class wy extends ue {
            static get pluginName() {
              return "SuperscriptEditing";
            }
            init() {
              const t = this.editor;
              t.model.schema.extend("$text", { allowAttributes: by }),
                t.model.schema.setAttributeProperties(by, {
                  isFormatting: !0,
                  copyOnEnter: !0,
                }),
                t.conversion.attributeToElement({
                  model: by,
                  view: "sup",
                  upcastAlso: [{ styles: { "vertical-align": "super" } }],
                }),
                t.commands.add(by, new Vf(t, by));
            }
          }
          const Ay = "superscript";
          class _y extends ue {
            static get pluginName() {
              return "SuperscriptUI";
            }
            init() {
              const t = this.editor,
                e = t.t;
              t.ui.componentFactory.add(Ay, (n) => {
                const i = t.commands.get(Ay),
                  o = new kh(n);
                return (
                  o.set({
                    label: e("Superscript"),
                    icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M15.677 8.678h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309zM7.03 10.349l3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82z"/></svg>',
                    tooltip: !0,
                    isToggleable: !0,
                  }),
                  o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"),
                  this.listenTo(o, "execute", () => {
                    t.execute(Ay), t.editing.view.focus();
                  }),
                  o
                );
              });
            }
          }
          function Cy(t, e, n, i, o = 1) {
            e > o ? i.setAttribute(t, e, n) : i.removeAttribute(t, n);
          }
          function vy(t, e, n = {}) {
            const i = t.createElement("tableCell", n);
            return t.insertElement("paragraph", i), t.insert(i, e), i;
          }
          function yy(t, e) {
            const n = e.parent.parent,
              i = parseInt(n.getAttribute("headingColumns") || 0),
              { column: o } = t.getCellLocation(e);
            return !!i && o < i;
          }
          function xy() {
            return (t) => {
              t.on("element:table", (t, e, n) => {
                const i = e.viewItem;
                if (!n.consumable.test(i, { name: !0 })) return;
                const {
                    rows: o,
                    headingRows: r,
                    headingColumns: s,
                  } = (function (t) {
                    const e = { headingRows: 0, headingColumns: 0 },
                      n = [],
                      i = [];
                    let o;
                    for (const r of Array.from(t.getChildren()))
                      if (
                        "tbody" === r.name ||
                        "thead" === r.name ||
                        "tfoot" === r.name
                      ) {
                        "thead" !== r.name || o || (o = r);
                        const t = Array.from(r.getChildren()).filter((t) =>
                          t.is("element", "tr")
                        );
                        for (const r of t)
                          if ("thead" === r.parent.name && r.parent === o)
                            e.headingRows++, n.push(r);
                          else {
                            i.push(r);
                            const t = Dy(r);
                            t > e.headingColumns && (e.headingColumns = t);
                          }
                      }
                    return (e.rows = [...n, ...i]), e;
                  })(i),
                  a = {};
                s && (a.headingColumns = s), r && (a.headingRows = r);
                const c = n.writer.createElement("table", a);
                if (n.safeInsert(c, e.modelCursor)) {
                  if (
                    (n.consumable.consume(i, { name: !0 }),
                    o.forEach((t) =>
                      n.convertItem(t, n.writer.createPositionAt(c, "end"))
                    ),
                    n.convertChildren(i, n.writer.createPositionAt(c, "end")),
                    c.isEmpty)
                  ) {
                    const t = n.writer.createElement("tableRow");
                    n.writer.insert(t, n.writer.createPositionAt(c, "end")),
                      vy(n.writer, n.writer.createPositionAt(t, "end"));
                  }
                  n.updateConversionResult(c, e);
                }
              });
            };
          }
          function Ey(t) {
            return (e) => {
              e.on(
                `element:${t}`,
                (t, e, n) => {
                  if (e.modelRange && e.viewItem.isEmpty) {
                    const t = e.modelRange.start.nodeAfter,
                      i = n.writer.createPositionAt(t, 0);
                    n.writer.insertElement("paragraph", i);
                  }
                },
                { priority: "low" }
              );
            };
          }
          function Dy(t) {
            let e = 0,
              n = 0;
            const i = Array.from(t.getChildren()).filter(
              (t) => "th" === t.name || "td" === t.name
            );
            for (; n < i.length && "th" === i[n].name; ) {
              const t = i[n];
              (e += parseInt(t.getAttribute("colspan") || 1)), n++;
            }
            return e;
          }
          class Sy {
            constructor(t, e = {}) {
              (this._table = t),
                (this._startRow = void 0 !== e.row ? e.row : e.startRow || 0),
                (this._endRow = void 0 !== e.row ? e.row : e.endRow),
                (this._startColumn =
                  void 0 !== e.column ? e.column : e.startColumn || 0),
                (this._endColumn =
                  void 0 !== e.column ? e.column : e.endColumn),
                (this._includeAllSlots = !!e.includeAllSlots),
                (this._skipRows = new Set()),
                (this._row = 0),
                (this._rowIndex = 0),
                (this._column = 0),
                (this._cellIndex = 0),
                (this._spannedCells = new Map()),
                (this._nextCellAtColumn = -1);
            }
            [Symbol.iterator]() {
              return this;
            }
            next() {
              const t = this._table.getChild(this._rowIndex);
              if (!t || this._isOverEndRow()) return { done: !0 };
              if (!t.is("element", "tableRow"))
                return this._rowIndex++, this.next();
              if (this._isOverEndColumn()) return this._advanceToNextRow();
              let e = null;
              const n = this._getSpanned();
              if (n)
                this._includeAllSlots &&
                  !this._shouldSkipSlot() &&
                  (e = this._formatOutValue(n.cell, n.row, n.column));
              else {
                const n = t.getChild(this._cellIndex);
                if (!n) return this._advanceToNextRow();
                const i = parseInt(n.getAttribute("colspan") || 1),
                  o = parseInt(n.getAttribute("rowspan") || 1);
                (i > 1 || o > 1) && this._recordSpans(n, o, i),
                  this._shouldSkipSlot() || (e = this._formatOutValue(n)),
                  (this._nextCellAtColumn = this._column + i);
              }
              return (
                this._column++,
                this._column == this._nextCellAtColumn && this._cellIndex++,
                e || this.next()
              );
            }
            skipRow(t) {
              this._skipRows.add(t);
            }
            _advanceToNextRow() {
              return (
                this._row++,
                this._rowIndex++,
                (this._column = 0),
                (this._cellIndex = 0),
                (this._nextCellAtColumn = -1),
                this.next()
              );
            }
            _isOverEndRow() {
              return void 0 !== this._endRow && this._row > this._endRow;
            }
            _isOverEndColumn() {
              return (
                void 0 !== this._endColumn && this._column > this._endColumn
              );
            }
            _formatOutValue(t, e = this._row, n = this._column) {
              return { done: !1, value: new Iy(this, t, e, n) };
            }
            _shouldSkipSlot() {
              const t = this._skipRows.has(this._row),
                e = this._row < this._startRow,
                n = this._column < this._startColumn,
                i =
                  void 0 !== this._endColumn && this._column > this._endColumn;
              return t || e || n || i;
            }
            _getSpanned() {
              const t = this._spannedCells.get(this._row);
              return (t && t.get(this._column)) || null;
            }
            _recordSpans(t, e, n) {
              const i = { cell: t, row: this._row, column: this._column };
              for (let t = this._row; t < this._row + e; t++)
                for (let e = this._column; e < this._column + n; e++)
                  (t == this._row && e == this._column) ||
                    this._markSpannedCell(t, e, i);
            }
            _markSpannedCell(t, e, n) {
              this._spannedCells.has(t) || this._spannedCells.set(t, new Map());
              this._spannedCells.get(t).set(e, n);
            }
          }
          class Iy {
            constructor(t, e, n, i) {
              (this.cell = e),
                (this.row = t._row),
                (this.column = t._column),
                (this.cellAnchorRow = n),
                (this.cellAnchorColumn = i),
                (this._cellIndex = t._cellIndex),
                (this._rowIndex = t._rowIndex),
                (this._table = t._table);
            }
            get isAnchor() {
              return (
                this.row === this.cellAnchorRow &&
                this.column === this.cellAnchorColumn
              );
            }
            get cellWidth() {
              return parseInt(this.cell.getAttribute("colspan") || 1);
            }
            get cellHeight() {
              return parseInt(this.cell.getAttribute("rowspan") || 1);
            }
            get rowIndex() {
              return this._rowIndex;
            }
            getPositionBefore() {
              return this._table.root.document.model.createPositionAt(
                this._table.getChild(this.row),
                this._cellIndex
              );
            }
          }
          function Ty(t, e = {}) {
            return (n, { writer: i }) => {
              const o = n.getAttribute("headingRows") || 0,
                r = [];
              o > 0 &&
                r.push(
                  i.createContainerElement(
                    "thead",
                    null,
                    i.createSlot(
                      (t) => t.is("element", "tableRow") && t.index < o
                    )
                  )
                ),
                o < t.getRows(n) &&
                  r.push(
                    i.createContainerElement(
                      "tbody",
                      null,
                      i.createSlot(
                        (t) => t.is("element", "tableRow") && t.index >= o
                      )
                    )
                  );
              const s = i.createContainerElement("figure", { class: "table" }, [
                i.createContainerElement("table", null, r),
                i.createSlot((t) => !t.is("element", "tableRow")),
              ]);
              return e.asWidget
                ? (function (t, e) {
                    return (
                      e.setCustomProperty("table", !0, t),
                      Gg(t, e, { hasSelectionHandle: !0 })
                    );
                  })(s, i)
                : s;
            };
          }
          function My(t = {}) {
            return (e, { writer: n }) => {
              const i = e.parent,
                o = i.parent,
                r = o.getChildIndex(i),
                s = new Sy(o, { row: r }),
                a = o.getAttribute("headingRows") || 0,
                c = o.getAttribute("headingColumns") || 0;
              for (const i of s)
                if (i.cell == e) {
                  const e = i.row < a || i.column < c ? "th" : "td";
                  return t.asWidget
                    ? Zg(n.createEditableElement(e), n)
                    : n.createContainerElement(e);
                }
            };
          }
          function By(t = {}) {
            return (e, { writer: n, consumable: i, mapper: o }) => {
              if (e.parent.is("element", "tableCell") && Ny(e))
                return t.asWidget
                  ? n.createContainerElement("span", {
                      class: "ck-table-bogus-paragraph",
                    })
                  : (i.consume(e, "insert"),
                    void o.bindElements(e, o.toViewElement(e.parent)));
            };
          }
          function Ny(t) {
            return (
              1 == t.parent.childCount && ![...t.getAttributeKeys()].length
            );
          }
          class zy extends ge {
            refresh() {
              const t = this.editor.model,
                e = t.document.selection,
                n = t.schema;
              this.isEnabled = (function (t, e) {
                const n = t.getFirstPosition().parent,
                  i = n === n.root ? n : n.parent;
                return e.checkChild(i, "table");
              })(e, n);
            }
            execute(t = {}) {
              const e = this.editor.model,
                n = this.editor.plugins.get("TableUtils"),
                i = this.editor.config.get("table"),
                o = i.defaultHeadings.rows,
                r = i.defaultHeadings.columns;
              void 0 === t.headingRows && o && (t.headingRows = o),
                void 0 === t.headingColumns && r && (t.headingColumns = r),
                e.change((i) => {
                  const o = n.createTable(i, t);
                  e.insertObject(o, null, null, {
                    findOptimalPosition: "auto",
                  }),
                    i.setSelection(
                      i.createPositionAt(o.getNodeByPath([0, 0, 0]), 0)
                    );
                });
            }
          }
          class Py extends ge {
            constructor(t, e = {}) {
              super(t), (this.order = e.order || "below");
            }
            refresh() {
              const t = this.editor.model.document.selection,
                e = !!this.editor.plugins
                  .get("TableUtils")
                  .getSelectionAffectedTableCells(t).length;
              this.isEnabled = e;
            }
            execute() {
              const t = this.editor,
                e = t.model.document.selection,
                n = t.plugins.get("TableUtils"),
                i = "above" === this.order,
                o = n.getSelectionAffectedTableCells(e),
                r = n.getRowIndexes(o),
                s = i ? r.first : r.last,
                a = o[0].findAncestor("table");
              n.insertRows(a, {
                at: i ? s : s + 1,
                copyStructureFromAbove: !i,
              });
            }
          }
          class Ly extends ge {
            constructor(t, e = {}) {
              super(t), (this.order = e.order || "right");
            }
            refresh() {
              const t = this.editor.model.document.selection,
                e = !!this.editor.plugins
                  .get("TableUtils")
                  .getSelectionAffectedTableCells(t).length;
              this.isEnabled = e;
            }
            execute() {
              const t = this.editor,
                e = t.model.document.selection,
                n = t.plugins.get("TableUtils"),
                i = "left" === this.order,
                o = n.getSelectionAffectedTableCells(e),
                r = n.getColumnIndexes(o),
                s = i ? r.first : r.last,
                a = o[0].findAncestor("table");
              n.insertColumns(a, { columns: 1, at: i ? s : s + 1 });
            }
          }
          class Ry extends ge {
            constructor(t, e = {}) {
              super(t), (this.direction = e.direction || "horizontally");
            }
            refresh() {
              const t = this.editor.plugins
                .get("TableUtils")
                .getSelectionAffectedTableCells(
                  this.editor.model.document.selection
                );
              this.isEnabled = 1 === t.length;
            }
            execute() {
              const t = this.editor.plugins.get("TableUtils"),
                e = t.getSelectionAffectedTableCells(
                  this.editor.model.document.selection
                )[0];
              "horizontally" === this.direction
                ? t.splitCellHorizontally(e, 2)
                : t.splitCellVertically(e, 2);
            }
          }
          function Oy(t, e, n) {
            const { startRow: i, startColumn: o, endRow: r, endColumn: s } = e,
              a = n.createElement("table"),
              c = r - i + 1;
            for (let t = 0; t < c; t++) n.insertElement("tableRow", a, "end");
            const l = [
              ...new Sy(t, {
                startRow: i,
                endRow: r,
                startColumn: o,
                endColumn: s,
                includeAllSlots: !0,
              }),
            ];
            for (const {
              row: t,
              column: e,
              cell: c,
              isAnchor: d,
              cellAnchorRow: h,
              cellAnchorColumn: u,
            } of l) {
              const l = t - i,
                m = a.getChild(l);
              if (d) {
                const i = n.cloneElement(c);
                n.append(i, m), Uy(i, t, e, r, s, n);
              } else (h < i || u < o) && vy(n, n.createPositionAt(m, "end"));
            }
            return (
              (function (t, e, n, i, o) {
                const r = parseInt(e.getAttribute("headingRows") || 0);
                if (r > 0) {
                  Cy("headingRows", r - n, t, o, 0);
                }
                const s = parseInt(e.getAttribute("headingColumns") || 0);
                if (s > 0) {
                  Cy("headingColumns", s - i, t, o, 0);
                }
              })(a, t, i, o, n),
              a
            );
          }
          function jy(t, e, n = 0) {
            const i = [],
              o = new Sy(t, { startRow: n, endRow: e - 1 });
            for (const t of o) {
              const { row: n, cellHeight: o } = t,
                r = n + o - 1;
              n < e && e <= r && i.push(t);
            }
            return i;
          }
          function Fy(t, e, n) {
            const i = t.parent,
              o = i.parent,
              r = i.index,
              s = e - r,
              a = {},
              c = parseInt(t.getAttribute("rowspan")) - s;
            c > 1 && (a.rowspan = c);
            const l = parseInt(t.getAttribute("colspan") || 1);
            l > 1 && (a.colspan = l);
            const d = r + s,
              h = [
                ...new Sy(o, { startRow: r, endRow: d, includeAllSlots: !0 }),
              ];
            let u,
              m = null;
            for (const e of h) {
              const { row: i, column: o, cell: r } = e;
              r === t && void 0 === u && (u = o),
                void 0 !== u &&
                  u === o &&
                  i === d &&
                  (m = vy(n, e.getPositionBefore(), a));
            }
            return Cy("rowspan", s, t, n), m;
          }
          function Vy(t, e) {
            const n = [],
              i = new Sy(t);
            for (const t of i) {
              const { column: i, cellWidth: o } = t,
                r = i + o - 1;
              i < e && e <= r && n.push(t);
            }
            return n;
          }
          function Hy(t, e, n, i) {
            const o = n - e,
              r = {},
              s = parseInt(t.getAttribute("colspan")) - o;
            s > 1 && (r.colspan = s);
            const a = parseInt(t.getAttribute("rowspan") || 1);
            a > 1 && (r.rowspan = a);
            const c = vy(i, i.createPositionAfter(t), r);
            return Cy("colspan", o, t, i), c;
          }
          function Uy(t, e, n, i, o, r) {
            const s = parseInt(t.getAttribute("colspan") || 1),
              a = parseInt(t.getAttribute("rowspan") || 1);
            if (n + s - 1 > o) {
              Cy("colspan", o - n + 1, t, r, 1);
            }
            if (e + a - 1 > i) {
              Cy("rowspan", i - e + 1, t, r, 1);
            }
          }
          function $y(t, e) {
            const n = e.getColumns(t),
              i = new Array(n).fill(0);
            for (const { column: e } of new Sy(t)) i[e]++;
            const o = i.reduce((t, e, n) => (e ? t : [...t, n]), []);
            if (o.length > 0) {
              const n = o[o.length - 1];
              return e.removeColumns(t, { at: n }), !0;
            }
            return !1;
          }
          function qy(t, e) {
            const n = [],
              i = e.getRows(t);
            for (let e = 0; e < i; e++) {
              t.getChild(e).isEmpty && n.push(e);
            }
            if (n.length > 0) {
              const i = n[n.length - 1];
              return e.removeRows(t, { at: i }), !0;
            }
            return !1;
          }
          function Gy(t, e) {
            $y(t, e) || qy(t, e);
          }
          function Wy(t, e) {
            const n = Array.from(
              new Sy(t, {
                startColumn: e.firstColumn,
                endColumn: e.lastColumn,
                row: e.lastRow,
              })
            );
            if (n.every(({ cellHeight: t }) => 1 === t)) return e.lastRow;
            const i = n[0].cellHeight - 1;
            return e.lastRow + i;
          }
          function Yy(t, e) {
            const n = Array.from(
              new Sy(t, {
                startRow: e.firstRow,
                endRow: e.lastRow,
                column: e.lastColumn,
              })
            );
            if (n.every(({ cellWidth: t }) => 1 === t)) return e.lastColumn;
            const i = n[0].cellWidth - 1;
            return e.lastColumn + i;
          }
          class Ky extends ge {
            constructor(t, e) {
              super(t),
                (this.direction = e.direction),
                (this.isHorizontal =
                  "right" == this.direction || "left" == this.direction);
            }
            refresh() {
              const t = this._getMergeableCell();
              (this.value = t), (this.isEnabled = !!t);
            }
            execute() {
              const t = this.editor.model,
                e = t.document,
                n = this.editor.plugins
                  .get("TableUtils")
                  .getTableCellsContainingSelection(e.selection)[0],
                i = this.value,
                o = this.direction;
              t.change((t) => {
                const e = "right" == o || "down" == o,
                  r = e ? n : i,
                  s = e ? i : n,
                  a = s.parent;
                !(function (t, e, n) {
                  Qy(t) ||
                    (Qy(e) && n.remove(n.createRangeIn(e)),
                    n.move(n.createRangeIn(t), n.createPositionAt(e, "end")));
                  n.remove(t);
                })(s, r, t);
                const c = this.isHorizontal ? "colspan" : "rowspan",
                  l = parseInt(n.getAttribute(c) || 1),
                  d = parseInt(i.getAttribute(c) || 1);
                t.setAttribute(c, l + d, r), t.setSelection(t.createRangeIn(r));
                const h = this.editor.plugins.get("TableUtils");
                Gy(a.findAncestor("table"), h);
              });
            }
            _getMergeableCell() {
              const t = this.editor.model.document,
                e = this.editor.plugins.get("TableUtils"),
                n = e.getTableCellsContainingSelection(t.selection)[0];
              if (!n) return;
              const i = this.isHorizontal
                ? (function (t, e, n) {
                    const i = t.parent.parent,
                      o = "right" == e ? t.nextSibling : t.previousSibling,
                      r = (i.getAttribute("headingColumns") || 0) > 0;
                    if (!o) return;
                    const s = "right" == e ? t : o,
                      a = "right" == e ? o : t,
                      { column: c } = n.getCellLocation(s),
                      { column: l } = n.getCellLocation(a),
                      d = parseInt(s.getAttribute("colspan") || 1),
                      h = yy(n, s),
                      u = yy(n, a);
                    if (r && h != u) return;
                    return c + d === l ? o : void 0;
                  })(n, this.direction, e)
                : (function (t, e, n) {
                    const i = t.parent,
                      o = i.parent,
                      r = o.getChildIndex(i);
                    if (
                      ("down" == e && r === n.getRows(o) - 1) ||
                      ("up" == e && 0 === r)
                    )
                      return;
                    const s = parseInt(t.getAttribute("rowspan") || 1),
                      a = o.getAttribute("headingRows") || 0,
                      c = "down" == e && r + s === a,
                      l = "up" == e && r === a;
                    if (a && (c || l)) return;
                    const d = parseInt(t.getAttribute("rowspan") || 1),
                      h = "down" == e ? r + d : r,
                      u = [...new Sy(o, { endRow: h })],
                      m = u.find((e) => e.cell === t).column,
                      g = u.find(
                        ({ row: t, cellHeight: n, column: i }) =>
                          i === m && ("down" == e ? t === h : h === t + n)
                      );
                    return g && g.cell;
                  })(n, this.direction, e);
              if (!i) return;
              const o = this.isHorizontal ? "rowspan" : "colspan",
                r = parseInt(n.getAttribute(o) || 1);
              return parseInt(i.getAttribute(o) || 1) === r ? i : void 0;
            }
          }
          function Qy(t) {
            return (
              1 == t.childCount &&
              t.getChild(0).is("element", "paragraph") &&
              t.getChild(0).isEmpty
            );
          }
          class Zy extends ge {
            refresh() {
              const t = this.editor.plugins.get("TableUtils"),
                e = t.getSelectionAffectedTableCells(
                  this.editor.model.document.selection
                ),
                n = e[0];
              if (n) {
                const i = n.findAncestor("table"),
                  o = this.editor.plugins.get("TableUtils").getRows(i) - 1,
                  r = t.getRowIndexes(e),
                  s = 0 === r.first && r.last === o;
                this.isEnabled = !s;
              } else this.isEnabled = !1;
            }
            execute() {
              const t = this.editor.model,
                e = this.editor.plugins.get("TableUtils"),
                n = e.getSelectionAffectedTableCells(t.document.selection),
                i = e.getRowIndexes(n),
                o = n[0],
                r = o.findAncestor("table"),
                s = e.getCellLocation(o).column;
              t.change((t) => {
                const n = i.last - i.first + 1;
                e.removeRows(r, { at: i.first, rows: n });
                const o = (function (t, e, n, i) {
                  const o = t.getChild(Math.min(e, i - 1));
                  let r = o.getChild(0),
                    s = 0;
                  for (const t of o.getChildren()) {
                    if (s > n) return r;
                    (r = t), (s += parseInt(t.getAttribute("colspan") || 1));
                  }
                  return r;
                })(r, i.first, s, e.getRows(r));
                t.setSelection(t.createPositionAt(o, 0));
              });
            }
          }
          class Jy extends ge {
            refresh() {
              const t = this.editor.plugins.get("TableUtils"),
                e = t.getSelectionAffectedTableCells(
                  this.editor.model.document.selection
                ),
                n = e[0];
              if (n) {
                const i = n.findAncestor("table"),
                  o = t.getColumns(i),
                  { first: r, last: s } = t.getColumnIndexes(e);
                this.isEnabled = s - r < o - 1;
              } else this.isEnabled = !1;
            }
            execute() {
              const t = this.editor.plugins.get("TableUtils"),
                [e, n] = (function (t, e) {
                  const n = e.getSelectionAffectedTableCells(t),
                    i = n[0],
                    o = n.pop(),
                    r = [i, o];
                  return i.isBefore(o) ? r : r.reverse();
                })(this.editor.model.document.selection, t),
                i = e.parent.parent,
                o = [...new Sy(i)],
                r = {
                  first: o.find((t) => t.cell === e).column,
                  last: o.find((t) => t.cell === n).column,
                },
                s = (function (t, e, n, i) {
                  return parseInt(n.getAttribute("colspan") || 1) > 1
                    ? n
                    : e.previousSibling || n.nextSibling
                    ? n.nextSibling || e.previousSibling
                    : i.first
                    ? t.reverse().find(({ column: t }) => t < i.first).cell
                    : t.reverse().find(({ column: t }) => t > i.last).cell;
                })(o, e, n, r);
              this.editor.model.change((t) => {
                const e = r.last - r.first + 1;
                this.editor.plugins
                  .get("TableUtils")
                  .removeColumns(i, { at: r.first, columns: e }),
                  t.setSelection(t.createPositionAt(s, 0));
              });
            }
          }
          class Xy extends ge {
            refresh() {
              const t = this.editor.plugins.get("TableUtils"),
                e = this.editor.model,
                n = t.getSelectionAffectedTableCells(e.document.selection),
                i = n.length > 0;
              (this.isEnabled = i),
                (this.value =
                  i && n.every((t) => this._isInHeading(t, t.parent.parent)));
            }
            execute(t = {}) {
              if (t.forceValue === this.value) return;
              const e = this.editor.plugins.get("TableUtils"),
                n = this.editor.model,
                i = e.getSelectionAffectedTableCells(n.document.selection),
                o = i[0].findAncestor("table"),
                { first: r, last: s } = e.getRowIndexes(i),
                a = this.value ? r : s + 1,
                c = o.getAttribute("headingRows") || 0;
              n.change((t) => {
                if (a) {
                  const e = jy(o, a, a > c ? c : 0);
                  for (const { cell: n } of e) Fy(n, a, t);
                }
                Cy("headingRows", a, o, t, 0);
              });
            }
            _isInHeading(t, e) {
              const n = parseInt(e.getAttribute("headingRows") || 0);
              return !!n && t.parent.index < n;
            }
          }
          class tx extends ge {
            refresh() {
              const t = this.editor.model,
                e = this.editor.plugins.get("TableUtils"),
                n = e.getSelectionAffectedTableCells(t.document.selection),
                i = n.length > 0;
              (this.isEnabled = i),
                (this.value = i && n.every((t) => yy(e, t)));
            }
            execute(t = {}) {
              if (t.forceValue === this.value) return;
              const e = this.editor.plugins.get("TableUtils"),
                n = this.editor.model,
                i = e.getSelectionAffectedTableCells(n.document.selection),
                o = i[0].findAncestor("table"),
                { first: r, last: s } = e.getColumnIndexes(i),
                a = this.value ? r : s + 1;
              n.change((t) => {
                if (a) {
                  const e = Vy(o, a);
                  for (const { cell: n, column: i } of e) Hy(n, i, a, t);
                }
                Cy("headingColumns", a, o, t, 0);
              });
            }
          }
          class ex extends ue {
            static get pluginName() {
              return "TableUtils";
            }
            init() {
              this.decorate("insertColumns"), this.decorate("insertRows");
            }
            getCellLocation(t) {
              const e = t.parent,
                n = e.parent,
                i = n.getChildIndex(e),
                o = new Sy(n, { row: i });
              for (const { cell: e, row: n, column: i } of o)
                if (e === t) return { row: n, column: i };
            }
            createTable(t, e) {
              const n = t.createElement("table"),
                i = parseInt(e.rows) || 2,
                o = parseInt(e.columns) || 2;
              return (
                nx(t, n, 0, i, o),
                e.headingRows &&
                  Cy("headingRows", Math.min(e.headingRows, i), n, t, 0),
                e.headingColumns &&
                  Cy("headingColumns", Math.min(e.headingColumns, o), n, t, 0),
                n
              );
            }
            insertRows(t, e = {}) {
              const n = this.editor.model,
                i = e.at || 0,
                o = e.rows || 1,
                r = void 0 !== e.copyStructureFromAbove,
                s = e.copyStructureFromAbove ? i - 1 : i,
                a = this.getRows(t),
                l = this.getColumns(t);
              if (i > a)
                throw new c("tableutils-insertrows-insert-out-of-range", this, {
                  options: e,
                });
              n.change((e) => {
                const n = t.getAttribute("headingRows") || 0;
                if (
                  (n > i && Cy("headingRows", n + o, t, e, 0),
                  !r && (0 === i || i === a))
                )
                  return void nx(e, t, i, o, l);
                const c = r ? Math.max(i, s) : i,
                  d = new Sy(t, { endRow: c }),
                  h = new Array(l).fill(1);
                for (const {
                  row: t,
                  column: n,
                  cellHeight: a,
                  cellWidth: c,
                  cell: l,
                } of d) {
                  const d = t + a - 1,
                    u = t <= s && s <= d;
                  t < i && i <= d
                    ? (e.setAttribute("rowspan", a + o, l), (h[n] = -c))
                    : r && u && (h[n] = c);
                }
                for (let n = 0; n < o; n++) {
                  const n = e.createElement("tableRow");
                  e.insert(n, t, i);
                  for (let t = 0; t < h.length; t++) {
                    const i = h[t],
                      o = e.createPositionAt(n, "end");
                    i > 0 && vy(e, o, i > 1 ? { colspan: i } : null),
                      (t += Math.abs(i) - 1);
                  }
                }
              });
            }
            insertColumns(t, e = {}) {
              const n = this.editor.model,
                i = e.at || 0,
                o = e.columns || 1;
              n.change((e) => {
                const n = t.getAttribute("headingColumns");
                i < n && e.setAttribute("headingColumns", n + o, t);
                const r = this.getColumns(t);
                if (0 === i || r === i) {
                  for (const n of t.getChildren())
                    n.is("element", "tableRow") &&
                      ix(o, e, e.createPositionAt(n, i ? "end" : 0));
                  return;
                }
                const s = new Sy(t, { column: i, includeAllSlots: !0 });
                for (const t of s) {
                  const {
                    row: n,
                    cell: r,
                    cellAnchorColumn: a,
                    cellAnchorRow: c,
                    cellWidth: l,
                    cellHeight: d,
                  } = t;
                  if (a < i) {
                    e.setAttribute("colspan", l + o, r);
                    const t = c + d - 1;
                    for (let e = n; e <= t; e++) s.skipRow(e);
                  } else ix(o, e, t.getPositionBefore());
                }
              });
            }
            removeRows(t, e) {
              const n = this.editor.model,
                i = e.rows || 1,
                o = this.getRows(t),
                r = e.at,
                s = r + i - 1;
              if (s > o - 1)
                throw new c(
                  "tableutils-removerows-row-index-out-of-range",
                  this,
                  { table: t, options: e }
                );
              n.change((e) => {
                const { cellsToMove: n, cellsToTrim: i } = (function (t, e, n) {
                  const i = new Map(),
                    o = [];
                  for (const {
                    row: r,
                    column: s,
                    cellHeight: a,
                    cell: c,
                  } of new Sy(t, { endRow: n })) {
                    const t = r + a - 1;
                    if (r >= e && r <= n && t > n) {
                      const t = a - (n - r + 1);
                      i.set(s, { cell: c, rowspan: t });
                    }
                    if (r < e && t >= e) {
                      let i;
                      (i = t >= n ? n - e + 1 : t - e + 1),
                        o.push({ cell: c, rowspan: a - i });
                    }
                  }
                  return { cellsToMove: i, cellsToTrim: o };
                })(t, r, s);
                if (n.size) {
                  !(function (t, e, n, i) {
                    const o = [...new Sy(t, { includeAllSlots: !0, row: e })],
                      r = t.getChild(e);
                    let s;
                    for (const { column: t, cell: e, isAnchor: a } of o)
                      if (n.has(t)) {
                        const { cell: e, rowspan: o } = n.get(t),
                          a = s
                            ? i.createPositionAfter(s)
                            : i.createPositionAt(r, 0);
                        i.move(i.createRangeOn(e), a),
                          Cy("rowspan", o, e, i),
                          (s = e);
                      } else a && (s = e);
                  })(t, s + 1, n, e);
                }
                for (let n = s; n >= r; n--) e.remove(t.getChild(n));
                for (const { rowspan: t, cell: n } of i) Cy("rowspan", t, n, e);
                !(function (t, e, n, i) {
                  const o = t.getAttribute("headingRows") || 0;
                  if (e < o) {
                    Cy("headingRows", n < o ? o - (n - e + 1) : e, t, i, 0);
                  }
                })(t, r, s, e),
                  $y(t, this) || qy(t, this);
              });
            }
            removeColumns(t, e) {
              const n = this.editor.model,
                i = e.at,
                o = e.columns || 1,
                r = e.at + o - 1;
              n.change((e) => {
                !(function (t, e, n) {
                  const i = t.getAttribute("headingColumns") || 0;
                  if (i && e.first < i) {
                    const o = Math.min(i - 1, e.last) - e.first + 1;
                    n.setAttribute("headingColumns", i - o, t);
                  }
                })(t, { first: i, last: r }, e);
                for (let n = r; n >= i; n--)
                  for (const { cell: i, column: o, cellWidth: r } of [
                    ...new Sy(t),
                  ])
                    o <= n && r > 1 && o + r > n
                      ? Cy("colspan", r - 1, i, e)
                      : o === n && e.remove(i);
                qy(t, this) || $y(t, this);
              });
            }
            splitCellVertically(t, e = 2) {
              const n = this.editor.model,
                i = t.parent.parent,
                o = parseInt(t.getAttribute("rowspan") || 1),
                r = parseInt(t.getAttribute("colspan") || 1);
              n.change((n) => {
                if (r > 1) {
                  const { newCellsSpan: i, updatedSpan: s } = ox(r, e);
                  Cy("colspan", s, t, n);
                  const a = {};
                  i > 1 && (a.colspan = i), o > 1 && (a.rowspan = o);
                  ix(r > e ? e - 1 : r - 1, n, n.createPositionAfter(t), a);
                }
                if (r < e) {
                  const s = e - r,
                    a = [...new Sy(i)],
                    { column: c } = a.find(({ cell: e }) => e === t),
                    l = a.filter(
                      ({ cell: e, cellWidth: n, column: i }) =>
                        (e !== t && i === c) || (i < c && i + n > c)
                    );
                  for (const { cell: t, cellWidth: e } of l)
                    n.setAttribute("colspan", e + s, t);
                  const d = {};
                  o > 1 && (d.rowspan = o),
                    ix(s, n, n.createPositionAfter(t), d);
                  const h = i.getAttribute("headingColumns") || 0;
                  h > c && Cy("headingColumns", h + s, i, n);
                }
              });
            }
            splitCellHorizontally(t, e = 2) {
              const n = this.editor.model,
                i = t.parent,
                o = i.parent,
                r = o.getChildIndex(i),
                s = parseInt(t.getAttribute("rowspan") || 1),
                a = parseInt(t.getAttribute("colspan") || 1);
              n.change((n) => {
                if (s > 1) {
                  const i = [
                      ...new Sy(o, {
                        startRow: r,
                        endRow: r + s - 1,
                        includeAllSlots: !0,
                      }),
                    ],
                    { newCellsSpan: c, updatedSpan: l } = ox(s, e);
                  Cy("rowspan", l, t, n);
                  const { column: d } = i.find(({ cell: e }) => e === t),
                    h = {};
                  c > 1 && (h.rowspan = c), a > 1 && (h.colspan = a);
                  for (const t of i) {
                    const { column: e, row: i } = t,
                      o = e === d,
                      s = (i + r + l) % c == 0;
                    i >= r + l && o && s && ix(1, n, t.getPositionBefore(), h);
                  }
                }
                if (s < e) {
                  const i = e - s,
                    c = [...new Sy(o, { startRow: 0, endRow: r })];
                  for (const { cell: e, cellHeight: o, row: s } of c)
                    if (e !== t && s + o > r) {
                      const t = o + i;
                      n.setAttribute("rowspan", t, e);
                    }
                  const l = {};
                  a > 1 && (l.colspan = a), nx(n, o, r + 1, i, 1, l);
                  const d = o.getAttribute("headingRows") || 0;
                  d > r && Cy("headingRows", d + i, o, n);
                }
              });
            }
            getColumns(t) {
              return [...t.getChild(0).getChildren()].reduce(
                (t, e) => t + parseInt(e.getAttribute("colspan") || 1),
                0
              );
            }
            getRows(t) {
              return Array.from(t.getChildren()).reduce(
                (t, e) => (e.is("element", "tableRow") ? t + 1 : t),
                0
              );
            }
            createTableWalker(t, e = {}) {
              return new Sy(t, e);
            }
            getSelectedTableCells(t) {
              const e = [];
              for (const n of this.sortRanges(t.getRanges())) {
                const t = n.getContainedElement();
                t && t.is("element", "tableCell") && e.push(t);
              }
              return e;
            }
            getTableCellsContainingSelection(t) {
              const e = [];
              for (const n of t.getRanges()) {
                const t = n.start.findAncestor("tableCell");
                t && e.push(t);
              }
              return e;
            }
            getSelectionAffectedTableCells(t) {
              const e = this.getSelectedTableCells(t);
              return e.length ? e : this.getTableCellsContainingSelection(t);
            }
            getRowIndexes(t) {
              const e = t.map((t) => t.parent.index);
              return this._getFirstLastIndexesObject(e);
            }
            getColumnIndexes(t) {
              const e = t[0].findAncestor("table"),
                n = [...new Sy(e)]
                  .filter((e) => t.includes(e.cell))
                  .map((t) => t.column);
              return this._getFirstLastIndexesObject(n);
            }
            isSelectionRectangular(t) {
              if (t.length < 2 || !this._areCellInTheSameTableSection(t))
                return !1;
              const e = new Set(),
                n = new Set();
              let i = 0;
              for (const o of t) {
                const { row: t, column: r } = this.getCellLocation(o),
                  s = parseInt(o.getAttribute("rowspan") || 1),
                  a = parseInt(o.getAttribute("colspan") || 1);
                e.add(t),
                  n.add(r),
                  s > 1 && e.add(t + s - 1),
                  a > 1 && n.add(r + a - 1),
                  (i += s * a);
              }
              const o = (function (t, e) {
                const n = Array.from(t.values()),
                  i = Array.from(e.values()),
                  o = Math.max(...n),
                  r = Math.min(...n),
                  s = Math.max(...i),
                  a = Math.min(...i);
                return (o - r + 1) * (s - a + 1);
              })(e, n);
              return o == i;
            }
            sortRanges(t) {
              return Array.from(t).sort(rx);
            }
            _getFirstLastIndexesObject(t) {
              const e = t.sort((t, e) => t - e);
              return { first: e[0], last: e[e.length - 1] };
            }
            _areCellInTheSameTableSection(t) {
              const e = t[0].findAncestor("table"),
                n = this.getRowIndexes(t),
                i = parseInt(e.getAttribute("headingRows") || 0);
              if (!this._areIndexesInSameSection(n, i)) return !1;
              const o = parseInt(e.getAttribute("headingColumns") || 0),
                r = this.getColumnIndexes(t);
              return this._areIndexesInSameSection(r, o);
            }
            _areIndexesInSameSection({ first: t, last: e }, n) {
              return t < n === e < n;
            }
          }
          function nx(t, e, n, i, o, r = {}) {
            for (let s = 0; s < i; s++) {
              const i = t.createElement("tableRow");
              t.insert(i, e, n), ix(o, t, t.createPositionAt(i, "end"), r);
            }
          }
          function ix(t, e, n, i = {}) {
            for (let o = 0; o < t; o++) vy(e, n, i);
          }
          function ox(t, e) {
            if (t < e) return { newCellsSpan: 1, updatedSpan: 1 };
            const n = Math.floor(t / e);
            return { newCellsSpan: n, updatedSpan: t - n * e + n };
          }
          function rx(t, e) {
            const n = t.start,
              i = e.start;
            return n.isBefore(i) ? -1 : 1;
          }
          class sx extends ge {
            refresh() {
              const t = this.editor.plugins.get(ex),
                e = t.getSelectedTableCells(
                  this.editor.model.document.selection
                );
              this.isEnabled = t.isSelectionRectangular(
                e,
                this.editor.plugins.get(ex)
              );
            }
            execute() {
              const t = this.editor.model,
                e = this.editor.plugins.get(ex);
              t.change((n) => {
                const i = e.getSelectedTableCells(t.document.selection),
                  o = i.shift(),
                  { mergeWidth: r, mergeHeight: s } = (function (t, e, n) {
                    let i = 0,
                      o = 0;
                    for (const t of e) {
                      const { row: e, column: r } = n.getCellLocation(t);
                      (i = lx(t, r, i, "colspan")),
                        (o = lx(t, e, o, "rowspan"));
                    }
                    const { row: r, column: s } = n.getCellLocation(t);
                    return { mergeWidth: i - s, mergeHeight: o - r };
                  })(o, i, e);
                Cy("colspan", r, o, n), Cy("rowspan", s, o, n);
                for (const t of i) ax(t, o, n);
                Gy(o.findAncestor("table"), e), n.setSelection(o, "in");
              });
            }
          }
          function ax(t, e, n) {
            cx(t) ||
              (cx(e) && n.remove(n.createRangeIn(e)),
              n.move(n.createRangeIn(t), n.createPositionAt(e, "end"))),
              n.remove(t);
          }
          function cx(t) {
            return (
              1 == t.childCount &&
              t.getChild(0).is("element", "paragraph") &&
              t.getChild(0).isEmpty
            );
          }
          function lx(t, e, n, i) {
            const o = parseInt(t.getAttribute(i) || 1);
            return Math.max(n, e + o);
          }
          class dx extends ge {
            constructor(t) {
              super(t), (this.affectsData = !1);
            }
            refresh() {
              const t = this.editor.plugins
                .get("TableUtils")
                .getSelectionAffectedTableCells(
                  this.editor.model.document.selection
                );
              this.isEnabled = t.length > 0;
            }
            execute() {
              const t = this.editor.model,
                e = this.editor.plugins.get("TableUtils"),
                n = e.getSelectionAffectedTableCells(t.document.selection),
                i = e.getRowIndexes(n),
                o = n[0].findAncestor("table"),
                r = [];
              for (let e = i.first; e <= i.last; e++)
                for (const n of o.getChild(e).getChildren())
                  r.push(t.createRangeOn(n));
              t.change((t) => {
                t.setSelection(r);
              });
            }
          }
          class hx extends ge {
            constructor(t) {
              super(t), (this.affectsData = !1);
            }
            refresh() {
              const t = this.editor.plugins
                .get("TableUtils")
                .getSelectionAffectedTableCells(
                  this.editor.model.document.selection
                );
              this.isEnabled = t.length > 0;
            }
            execute() {
              const t = this.editor.plugins.get("TableUtils"),
                e = this.editor.model,
                n = t.getSelectionAffectedTableCells(e.document.selection),
                i = n[0],
                o = n.pop(),
                r = i.findAncestor("table"),
                s = t.getCellLocation(i),
                a = t.getCellLocation(o),
                c = Math.min(s.column, a.column),
                l = Math.max(s.column, a.column),
                d = [];
              for (const t of new Sy(r, { startColumn: c, endColumn: l }))
                d.push(e.createRangeOn(t.cell));
              e.change((t) => {
                t.setSelection(d);
              });
            }
          }
          function ux(t) {
            t.document.registerPostFixer((e) =>
              (function (t, e) {
                const n = e.document.differ.getChanges();
                let i = !1;
                const o = new Set();
                for (const e of n) {
                  let n;
                  "table" == e.name &&
                    "insert" == e.type &&
                    (n = e.position.nodeAfter),
                    ("tableRow" != e.name && "tableCell" != e.name) ||
                      (n = e.position.findAncestor("table")),
                    px(e) && (n = e.range.start.findAncestor("table")),
                    n &&
                      !o.has(n) &&
                      ((i = mx(n, t) || i), (i = gx(n, t) || i), o.add(n));
                }
                return i;
              })(e, t)
            );
          }
          function mx(t, e) {
            let n = !1;
            const i = (function (t) {
              const e = parseInt(t.getAttribute("headingRows") || 0),
                n = Array.from(t.getChildren()).reduce(
                  (t, e) => (e.is("element", "tableRow") ? t + 1 : t),
                  0
                ),
                i = [];
              for (const { row: o, cell: r, cellHeight: s } of new Sy(t)) {
                if (s < 2) continue;
                const t = o < e ? e : n;
                if (o + s > t) {
                  const e = t - o;
                  i.push({ cell: r, rowspan: e });
                }
              }
              return i;
            })(t);
            if (i.length) {
              n = !0;
              for (const t of i) Cy("rowspan", t.rowspan, t.cell, e, 1);
            }
            return n;
          }
          function gx(t, e) {
            let n = !1;
            const i = (function (t) {
                const e = new Array(t.childCount).fill(0);
                for (const { rowIndex: n } of new Sy(t, {
                  includeAllSlots: !0,
                }))
                  e[n]++;
                return e;
              })(t),
              o = [];
            for (const [e, n] of i.entries())
              !n && t.getChild(e).is("element", "tableRow") && o.push(e);
            if (o.length) {
              n = !0;
              for (const n of o.reverse())
                e.remove(t.getChild(n)), i.splice(n, 1);
            }
            const r = i.filter((e, n) =>
                t.getChild(n).is("element", "tableRow")
              ),
              s = r[0];
            if (!r.every((t) => t === s)) {
              const i = r.reduce((t, e) => (e > t ? e : t), 0);
              for (const [o, s] of r.entries()) {
                const r = i - s;
                if (r) {
                  for (let n = 0; n < r; n++)
                    vy(e, e.createPositionAt(t.getChild(o), "end"));
                  n = !0;
                }
              }
            }
            return n;
          }
          function px(t) {
            const e = "attribute" === t.type,
              n = t.attributeKey;
            return (
              e && ("headingRows" === n || "colspan" === n || "rowspan" === n)
            );
          }
          function fx(t) {
            t.document.registerPostFixer((e) =>
              (function (t, e) {
                const n = e.document.differ.getChanges();
                let i = !1;
                for (const e of n)
                  "insert" == e.type &&
                    "table" == e.name &&
                    (i = kx(e.position.nodeAfter, t) || i),
                    "insert" == e.type &&
                      "tableRow" == e.name &&
                      (i = bx(e.position.nodeAfter, t) || i),
                    "insert" == e.type &&
                      "tableCell" == e.name &&
                      (i = wx(e.position.nodeAfter, t) || i),
                    Ax(e) && (i = wx(e.position.parent, t) || i);
                return i;
              })(e, t)
            );
          }
          function kx(t, e) {
            let n = !1;
            for (const i of t.getChildren())
              i.is("element", "tableRow") && (n = bx(i, e) || n);
            return n;
          }
          function bx(t, e) {
            let n = !1;
            for (const i of t.getChildren()) n = wx(i, e) || n;
            return n;
          }
          function wx(t, e) {
            if (0 == t.childCount) return e.insertElement("paragraph", t), !0;
            const n = Array.from(t.getChildren()).filter((t) => t.is("$text"));
            for (const t of n) e.wrap(e.createRangeOn(t), "paragraph");
            return !!n.length;
          }
          function Ax(t) {
            return (
              !(!t.position || !t.position.parent.is("element", "tableCell")) &&
              (("insert" == t.type && "$text" == t.name) || "remove" == t.type)
            );
          }
          function _x(t, e) {
            if (!t.is("element", "paragraph")) return !1;
            const n = e.toViewElement(t);
            return !!n && Ny(t) !== n.is("element", "span");
          }
          var Cx = n(4777),
            vx = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Cx.Z, vx);
          Cx.Z.locals;
          class yx extends ue {
            static get pluginName() {
              return "TableEditing";
            }
            static get requires() {
              return [ex];
            }
            init() {
              const t = this.editor,
                e = t.model,
                n = e.schema,
                i = t.conversion,
                o = t.plugins.get(ex);
              n.register("table", {
                inheritAllFrom: "$blockObject",
                allowAttributes: ["headingRows", "headingColumns"],
              }),
                n.register("tableRow", { allowIn: "table", isLimit: !0 }),
                n.register("tableCell", {
                  allowContentOf: "$container",
                  allowIn: "tableRow",
                  allowAttributes: ["colspan", "rowspan"],
                  isLimit: !0,
                  isSelectable: !0,
                }),
                i.for("upcast").add((t) => {
                  t.on("element:figure", (t, e, n) => {
                    if (
                      !n.consumable.test(e.viewItem, {
                        name: !0,
                        classes: "table",
                      })
                    )
                      return;
                    const i = (function (t) {
                      for (const e of t.getChildren())
                        if (e.is("element", "table")) return e;
                    })(e.viewItem);
                    if (!i || !n.consumable.test(i, { name: !0 })) return;
                    n.consumable.consume(e.viewItem, {
                      name: !0,
                      classes: "table",
                    });
                    const o = Na(
                      n.convertItem(i, e.modelCursor).modelRange.getItems()
                    );
                    o
                      ? (n.convertChildren(
                          e.viewItem,
                          n.writer.createPositionAt(o, "end")
                        ),
                        n.updateConversionResult(o, e))
                      : n.consumable.revert(e.viewItem, {
                          name: !0,
                          classes: "table",
                        });
                  });
                }),
                i.for("upcast").add(xy()),
                i
                  .for("editingDowncast")
                  .elementToStructure({
                    model: { name: "table", attributes: ["headingRows"] },
                    view: Ty(o, { asWidget: !0 }),
                  }),
                i
                  .for("dataDowncast")
                  .elementToStructure({
                    model: { name: "table", attributes: ["headingRows"] },
                    view: Ty(o),
                  }),
                i
                  .for("upcast")
                  .elementToElement({ model: "tableRow", view: "tr" }),
                i.for("upcast").add((t) => {
                  t.on(
                    "element:tr",
                    (t, e) => {
                      e.viewItem.isEmpty &&
                        0 == e.modelCursor.index &&
                        t.stop();
                    },
                    { priority: "high" }
                  );
                }),
                i
                  .for("downcast")
                  .elementToElement({
                    model: "tableRow",
                    view: (t, { writer: e }) =>
                      t.isEmpty
                        ? e.createEmptyElement("tr")
                        : e.createContainerElement("tr"),
                  }),
                i
                  .for("upcast")
                  .elementToElement({ model: "tableCell", view: "td" }),
                i
                  .for("upcast")
                  .elementToElement({ model: "tableCell", view: "th" }),
                i.for("upcast").add(Ey("td")),
                i.for("upcast").add(Ey("th")),
                i
                  .for("editingDowncast")
                  .elementToElement({
                    model: "tableCell",
                    view: My({ asWidget: !0 }),
                  }),
                i
                  .for("dataDowncast")
                  .elementToElement({ model: "tableCell", view: My() }),
                i
                  .for("editingDowncast")
                  .elementToElement({
                    model: "paragraph",
                    view: By({ asWidget: !0 }),
                    converterPriority: "high",
                  }),
                i
                  .for("dataDowncast")
                  .elementToElement({
                    model: "paragraph",
                    view: By(),
                    converterPriority: "high",
                  }),
                i
                  .for("downcast")
                  .attributeToAttribute({ model: "colspan", view: "colspan" }),
                i
                  .for("upcast")
                  .attributeToAttribute({
                    model: { key: "colspan", value: xx("colspan") },
                    view: "colspan",
                  }),
                i
                  .for("downcast")
                  .attributeToAttribute({ model: "rowspan", view: "rowspan" }),
                i
                  .for("upcast")
                  .attributeToAttribute({
                    model: { key: "rowspan", value: xx("rowspan") },
                    view: "rowspan",
                  }),
                t.data.mapper.on("modelToViewPosition", (t, e) => {
                  const n = e.modelPosition.parent,
                    i = e.modelPosition.nodeBefore;
                  if (!n.is("element", "tableCell")) return;
                  if (!i || !i.is("element", "paragraph")) return;
                  const o = e.mapper.toViewElement(i),
                    r = e.mapper.toViewElement(n);
                  o === r &&
                    (e.viewPosition = e.mapper.findPositionIn(r, i.maxOffset));
                }),
                t.config.define("table.defaultHeadings.rows", 0),
                t.config.define("table.defaultHeadings.columns", 0),
                t.commands.add("insertTable", new zy(t)),
                t.commands.add(
                  "insertTableRowAbove",
                  new Py(t, { order: "above" })
                ),
                t.commands.add(
                  "insertTableRowBelow",
                  new Py(t, { order: "below" })
                ),
                t.commands.add(
                  "insertTableColumnLeft",
                  new Ly(t, { order: "left" })
                ),
                t.commands.add(
                  "insertTableColumnRight",
                  new Ly(t, { order: "right" })
                ),
                t.commands.add("removeTableRow", new Zy(t)),
                t.commands.add("removeTableColumn", new Jy(t)),
                t.commands.add(
                  "splitTableCellVertically",
                  new Ry(t, { direction: "vertically" })
                ),
                t.commands.add(
                  "splitTableCellHorizontally",
                  new Ry(t, { direction: "horizontally" })
                ),
                t.commands.add("mergeTableCells", new sx(t)),
                t.commands.add(
                  "mergeTableCellRight",
                  new Ky(t, { direction: "right" })
                ),
                t.commands.add(
                  "mergeTableCellLeft",
                  new Ky(t, { direction: "left" })
                ),
                t.commands.add(
                  "mergeTableCellDown",
                  new Ky(t, { direction: "down" })
                ),
                t.commands.add(
                  "mergeTableCellUp",
                  new Ky(t, { direction: "up" })
                ),
                t.commands.add("setTableColumnHeader", new tx(t)),
                t.commands.add("setTableRowHeader", new Xy(t)),
                t.commands.add("selectTableRow", new dx(t)),
                t.commands.add("selectTableColumn", new hx(t)),
                ux(e),
                fx(e),
                this.listenTo(e.document, "change:data", () => {
                  !(function (t, e) {
                    const n = t.document.differ;
                    for (const t of n.getChanges()) {
                      let n,
                        i = !1;
                      if ("attribute" == t.type) {
                        const e = t.range.start.nodeAfter;
                        if (!e || !e.is("element", "table")) continue;
                        if (
                          "headingRows" != t.attributeKey &&
                          "headingColumns" != t.attributeKey
                        )
                          continue;
                        (n = e), (i = "headingRows" == t.attributeKey);
                      } else
                        ("tableRow" != t.name && "tableCell" != t.name) ||
                          ((n = t.position.findAncestor("table")),
                          (i = "tableRow" == t.name));
                      if (!n) continue;
                      const o = n.getAttribute("headingRows") || 0,
                        r = n.getAttribute("headingColumns") || 0,
                        s = new Sy(n);
                      for (const t of s) {
                        const n = t.row < o || t.column < r ? "th" : "td",
                          s = e.mapper.toViewElement(t.cell);
                        s &&
                          s.is("element") &&
                          s.name != n &&
                          e.reconvertItem(i ? t.cell.parent : t.cell);
                      }
                    }
                  })(e, t.editing),
                    (function (t, e) {
                      const n = t.document.differ,
                        i = new Set();
                      for (const t of n.getChanges()) {
                        const e =
                          "attribute" == t.type
                            ? t.range.start.parent
                            : t.position.parent;
                        e.is("element", "tableCell") && i.add(e);
                      }
                      for (const t of i.values()) {
                        const n = Array.from(t.getChildren()).filter((t) =>
                          _x(t, e.mapper)
                        );
                        for (const t of n) e.reconvertItem(t);
                      }
                    })(e, t.editing);
                });
            }
          }
          function xx(t) {
            return (e) => {
              const n = parseInt(e.getAttribute(t));
              return Number.isNaN(n) || n <= 0 ? null : n;
            };
          }
          var Ex = n(8085),
            Dx = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Ex.Z, Dx);
          Ex.Z.locals;
          class Sx extends Vd {
            constructor(t) {
              super(t);
              const e = this.bindTemplate;
              (this.items = this._createGridCollection()),
                this.set("rows", 0),
                this.set("columns", 0),
                this.bind("label").to(
                  this,
                  "columns",
                  this,
                  "rows",
                  (t, e) => `${e} × ${t}`
                ),
                this.setTemplate({
                  tag: "div",
                  attributes: { class: ["ck"] },
                  children: [
                    {
                      tag: "div",
                      attributes: { class: ["ck-insert-table-dropdown__grid"] },
                      on: {
                        "mouseover@.ck-insert-table-dropdown-grid-box":
                          e.to("boxover"),
                      },
                      children: this.items,
                    },
                    {
                      tag: "div",
                      attributes: {
                        class: ["ck-insert-table-dropdown__label"],
                      },
                      children: [{ text: e.to("label") }],
                    },
                  ],
                  on: {
                    mousedown: e.to((t) => {
                      t.preventDefault();
                    }),
                    click: e.to(() => {
                      this.fire("execute");
                    }),
                  },
                }),
                this.on("boxover", (t, e) => {
                  const { row: n, column: i } = e.target.dataset;
                  this.set({ rows: parseInt(n), columns: parseInt(i) });
                }),
                this.on("change:columns", () => {
                  this._highlightGridBoxes();
                }),
                this.on("change:rows", () => {
                  this._highlightGridBoxes();
                });
            }
            focus() {}
            focusLast() {}
            _highlightGridBoxes() {
              const t = this.rows,
                e = this.columns;
              this.items.map((n, i) => {
                const o = Math.floor(i / 10) < t && i % 10 < e;
                n.set("isOn", o);
              });
            }
            _createGridCollection() {
              const t = [];
              for (let e = 0; e < 100; e++) {
                const n = Math.floor(e / 10),
                  i = e % 10;
                t.push(new Ix(this.locale, n + 1, i + 1));
              }
              return this.createCollection(t);
            }
          }
          class Ix extends Vd {
            constructor(t, e, n) {
              super(t);
              const i = this.bindTemplate;
              this.set("isOn", !1),
                this.setTemplate({
                  tag: "div",
                  attributes: {
                    class: [
                      "ck-insert-table-dropdown-grid-box",
                      i.if("isOn", "ck-on"),
                    ],
                    "data-row": e,
                    "data-column": n,
                  },
                });
            }
          }
          class Tx extends ue {
            static get pluginName() {
              return "TableUI";
            }
            init() {
              const t = this.editor,
                e = this.editor.t,
                n = "ltr" === t.locale.contentLanguageDirection;
              t.ui.componentFactory.add("insertTable", (n) => {
                const i = t.commands.get("insertTable"),
                  o = ou(n);
                let r;
                return (
                  o.bind("isEnabled").to(i),
                  o.buttonView.set({
                    icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>',
                    label: e("Insert table"),
                    tooltip: !0,
                  }),
                  o.on("change:isOpen", () => {
                    r ||
                      ((r = new Sx(n)),
                      o.panelView.children.add(r),
                      r.delegate("execute").to(o),
                      o.buttonView.on("open", () => {
                        (r.rows = 0), (r.columns = 0);
                      }),
                      o.on("execute", () => {
                        t.execute("insertTable", {
                          rows: r.rows,
                          columns: r.columns,
                        }),
                          t.editing.view.focus();
                      }));
                  }),
                  o
                );
              }),
                t.ui.componentFactory.add("tableColumn", (t) => {
                  const i = [
                    {
                      type: "switchbutton",
                      model: {
                        commandName: "setTableColumnHeader",
                        label: e("Header column"),
                        bindIsOn: !0,
                      },
                    },
                    { type: "separator" },
                    {
                      type: "button",
                      model: {
                        commandName: n
                          ? "insertTableColumnLeft"
                          : "insertTableColumnRight",
                        label: e("Insert column left"),
                      },
                    },
                    {
                      type: "button",
                      model: {
                        commandName: n
                          ? "insertTableColumnRight"
                          : "insertTableColumnLeft",
                        label: e("Insert column right"),
                      },
                    },
                    {
                      type: "button",
                      model: {
                        commandName: "removeTableColumn",
                        label: e("Delete column"),
                      },
                    },
                    {
                      type: "button",
                      model: {
                        commandName: "selectTableColumn",
                        label: e("Select column"),
                      },
                    },
                  ];
                  return this._prepareDropdown(
                    e("Column"),
                    '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>',
                    i,
                    t
                  );
                }),
                t.ui.componentFactory.add("tableRow", (t) => {
                  const n = [
                    {
                      type: "switchbutton",
                      model: {
                        commandName: "setTableRowHeader",
                        label: e("Header row"),
                        bindIsOn: !0,
                      },
                    },
                    { type: "separator" },
                    {
                      type: "button",
                      model: {
                        commandName: "insertTableRowAbove",
                        label: e("Insert row above"),
                      },
                    },
                    {
                      type: "button",
                      model: {
                        commandName: "insertTableRowBelow",
                        label: e("Insert row below"),
                      },
                    },
                    {
                      type: "button",
                      model: {
                        commandName: "removeTableRow",
                        label: e("Delete row"),
                      },
                    },
                    {
                      type: "button",
                      model: {
                        commandName: "selectTableRow",
                        label: e("Select row"),
                      },
                    },
                  ];
                  return this._prepareDropdown(
                    e("Row"),
                    '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>',
                    n,
                    t
                  );
                }),
                t.ui.componentFactory.add("mergeTableCells", (t) => {
                  const i = [
                    {
                      type: "button",
                      model: {
                        commandName: "mergeTableCellUp",
                        label: e("Merge cell up"),
                      },
                    },
                    {
                      type: "button",
                      model: {
                        commandName: n
                          ? "mergeTableCellRight"
                          : "mergeTableCellLeft",
                        label: e("Merge cell right"),
                      },
                    },
                    {
                      type: "button",
                      model: {
                        commandName: "mergeTableCellDown",
                        label: e("Merge cell down"),
                      },
                    },
                    {
                      type: "button",
                      model: {
                        commandName: n
                          ? "mergeTableCellLeft"
                          : "mergeTableCellRight",
                        label: e("Merge cell left"),
                      },
                    },
                    { type: "separator" },
                    {
                      type: "button",
                      model: {
                        commandName: "splitTableCellVertically",
                        label: e("Split cell vertically"),
                      },
                    },
                    {
                      type: "button",
                      model: {
                        commandName: "splitTableCellHorizontally",
                        label: e("Split cell horizontally"),
                      },
                    },
                  ];
                  return this._prepareMergeSplitButtonDropdown(
                    e("Merge cells"),
                    '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>',
                    i,
                    t
                  );
                });
            }
            _prepareDropdown(t, e, n, i) {
              const o = this.editor,
                r = ou(i),
                s = this._fillDropdownWithListOptions(r, n);
              return (
                r.buttonView.set({ label: t, icon: e, tooltip: !0 }),
                r
                  .bind("isEnabled")
                  .toMany(s, "isEnabled", (...t) => t.some((t) => t)),
                this.listenTo(r, "execute", (t) => {
                  o.execute(t.source.commandName), o.editing.view.focus();
                }),
                r
              );
            }
            _prepareMergeSplitButtonDropdown(t, e, n, i) {
              const o = this.editor,
                r = ou(i, Bh),
                s = "mergeTableCells",
                a = o.commands.get(s),
                c = this._fillDropdownWithListOptions(r, n);
              return (
                r.buttonView.set({
                  label: t,
                  icon: e,
                  tooltip: !0,
                  isEnabled: !0,
                }),
                r
                  .bind("isEnabled")
                  .toMany([a, ...c], "isEnabled", (...t) => t.some((t) => t)),
                this.listenTo(r.buttonView, "execute", () => {
                  o.execute(s), o.editing.view.focus();
                }),
                this.listenTo(r, "execute", (t) => {
                  o.execute(t.source.commandName), o.editing.view.focus();
                }),
                r
              );
            }
            _fillDropdownWithListOptions(t, e) {
              const n = this.editor,
                i = [],
                o = new Di();
              for (const t of e) Mx(t, n, i, o);
              return su(t, o, n.ui.componentFactory), i;
            }
          }
          function Mx(t, e, n, i) {
            const o = (t.model = new Su(t.model)),
              { commandName: r, bindIsOn: s } = t.model;
            if ("button" === t.type || "switchbutton" === t.type) {
              const t = e.commands.get(r);
              n.push(t),
                o.set({ commandName: r }),
                o.bind("isEnabled").to(t),
                s && o.bind("isOn").to(t, "value");
            }
            o.set({ withText: !0 }), i.add(t);
          }
          var Bx = n(5593),
            Nx = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()(Bx.Z, Nx);
          Bx.Z.locals;
          class zx extends ue {
            static get pluginName() {
              return "TableSelection";
            }
            static get requires() {
              return [ex, ex];
            }
            init() {
              const t = this.editor.model;
              this.listenTo(
                t,
                "deleteContent",
                (t, e) => this._handleDeleteContent(t, e),
                { priority: "high" }
              ),
                this._defineSelectionConverter(),
                this._enablePluginDisabling();
            }
            getSelectedTableCells() {
              const t = this.editor.plugins.get(ex),
                e = this.editor.model.document.selection,
                n = t.getSelectedTableCells(e);
              return 0 == n.length ? null : n;
            }
            getSelectionAsFragment() {
              const t = this.editor.plugins.get(ex),
                e = this.getSelectedTableCells();
              return e
                ? this.editor.model.change((n) => {
                    const i = n.createDocumentFragment(),
                      { first: o, last: r } = t.getColumnIndexes(e),
                      { first: s, last: a } = t.getRowIndexes(e),
                      c = e[0].findAncestor("table");
                    let l = a,
                      d = r;
                    if (t.isSelectionRectangular(e)) {
                      const t = {
                        firstColumn: o,
                        lastColumn: r,
                        firstRow: s,
                        lastRow: a,
                      };
                      (l = Wy(c, t)), (d = Yy(c, t));
                    }
                    const h = Oy(
                      c,
                      { startRow: s, startColumn: o, endRow: l, endColumn: d },
                      n
                    );
                    return n.insert(h, i, 0), i;
                  })
                : null;
            }
            setCellSelection(t, e) {
              const n = this._getCellsToSelect(t, e);
              this.editor.model.change((t) => {
                t.setSelection(
                  n.cells.map((e) => t.createRangeOn(e)),
                  { backward: n.backward }
                );
              });
            }
            getFocusCell() {
              const t = [...this.editor.model.document.selection.getRanges()]
                .pop()
                .getContainedElement();
              return t && t.is("element", "tableCell") ? t : null;
            }
            getAnchorCell() {
              const t = Na(
                this.editor.model.document.selection.getRanges()
              ).getContainedElement();
              return t && t.is("element", "tableCell") ? t : null;
            }
            _defineSelectionConverter() {
              const t = this.editor,
                e = new Set();
              t.conversion.for("editingDowncast").add((t) =>
                t.on(
                  "selection",
                  (t, n, i) => {
                    const o = i.writer;
                    !(function (t) {
                      for (const n of e)
                        t.removeClass("ck-editor__editable_selected", n);
                      e.clear();
                    })(o);
                    const r = this.getSelectedTableCells();
                    if (!r) return;
                    for (const t of r) {
                      const n = i.mapper.toViewElement(t);
                      o.addClass("ck-editor__editable_selected", n), e.add(n);
                    }
                    const s = i.mapper.toViewElement(r[r.length - 1]);
                    o.setSelection(s, 0);
                  },
                  { priority: "lowest" }
                )
              );
            }
            _enablePluginDisabling() {
              const t = this.editor;
              this.on("change:isEnabled", () => {
                if (!this.isEnabled) {
                  const e = this.getSelectedTableCells();
                  if (!e) return;
                  t.model.change((n) => {
                    const i = n.createPositionAt(e[0], 0),
                      o = t.model.schema.getNearestSelectionRange(i);
                    n.setSelection(o);
                  });
                }
              });
            }
            _handleDeleteContent(t, e) {
              const n = this.editor.plugins.get(ex),
                [i, o] = e,
                r = this.editor.model,
                s = !o || "backward" == o.direction,
                a = n.getSelectedTableCells(i);
              a.length &&
                (t.stop(),
                r.change((t) => {
                  const e = a[s ? a.length - 1 : 0];
                  r.change((t) => {
                    for (const e of a)
                      r.deleteContent(t.createSelection(e, "in"));
                  });
                  const n = r.schema.getNearestSelectionRange(
                    t.createPositionAt(e, 0)
                  );
                  i.is("documentSelection") ? t.setSelection(n) : i.setTo(n);
                }));
            }
            _getCellsToSelect(t, e) {
              const n = this.editor.plugins.get("TableUtils"),
                i = n.getCellLocation(t),
                o = n.getCellLocation(e),
                r = Math.min(i.row, o.row),
                s = Math.max(i.row, o.row),
                a = Math.min(i.column, o.column),
                c = Math.max(i.column, o.column),
                l = new Array(s - r + 1).fill(null).map(() => []),
                d = { startRow: r, endRow: s, startColumn: a, endColumn: c };
              for (const { row: e, cell: n } of new Sy(
                t.findAncestor("table"),
                d
              ))
                l[e - r].push(n);
              const h = o.row < i.row,
                u = o.column < i.column;
              return (
                h && l.reverse(),
                u && l.forEach((t) => t.reverse()),
                { cells: l.flat(), backward: h || u }
              );
            }
          }
          class Px extends ue {
            static get pluginName() {
              return "TableClipboard";
            }
            static get requires() {
              return [zx, ex];
            }
            init() {
              const t = this.editor,
                e = t.editing.view.document;
              this.listenTo(e, "copy", (t, e) => this._onCopyCut(t, e)),
                this.listenTo(e, "cut", (t, e) => this._onCopyCut(t, e)),
                this.listenTo(
                  t.model,
                  "insertContent",
                  (t, e) => this._onInsertContent(t, ...e),
                  { priority: "high" }
                ),
                this.decorate("_replaceTableSlotCell");
            }
            _onCopyCut(t, e) {
              const n = this.editor.plugins.get(zx);
              if (!n.getSelectedTableCells()) return;
              if ("cut" == t.name && this.editor.isReadOnly) return;
              e.preventDefault(), t.stop();
              const i = this.editor.data,
                o = this.editor.editing.view.document,
                r = i.toView(n.getSelectionAsFragment());
              o.fire("clipboardOutput", {
                dataTransfer: e.dataTransfer,
                content: r,
                method: t.name,
              });
            }
            _onInsertContent(t, e, n) {
              if (n && !n.is("documentSelection")) return;
              const i = this.editor.model,
                o = this.editor.plugins.get(ex);
              let r = Lx(e, i);
              if (!r) return;
              const s = o.getSelectionAffectedTableCells(i.document.selection);
              s.length
                ? (t.stop(),
                  i.change((t) => {
                    const e = { width: o.getColumns(r), height: o.getRows(r) },
                      n = (function (t, e, n, i) {
                        const o = t[0].findAncestor("table"),
                          r = i.getColumnIndexes(t),
                          s = i.getRowIndexes(t),
                          a = {
                            firstColumn: r.first,
                            lastColumn: r.last,
                            firstRow: s.first,
                            lastRow: s.last,
                          },
                          c = 1 === t.length;
                        c &&
                          ((a.lastRow += e.height - 1),
                          (a.lastColumn += e.width - 1),
                          (function (t, e, n, i) {
                            const o = i.getColumns(t),
                              r = i.getRows(t);
                            n > o &&
                              i.insertColumns(t, { at: o, columns: n - o });
                            e > r && i.insertRows(t, { at: r, rows: e - r });
                          })(o, a.lastRow + 1, a.lastColumn + 1, i));
                        c || !i.isSelectionRectangular(t)
                          ? (function (t, e, n) {
                              const {
                                  firstRow: i,
                                  lastRow: o,
                                  firstColumn: r,
                                  lastColumn: s,
                                } = e,
                                a = { first: i, last: o },
                                c = { first: r, last: s };
                              Ox(t, r, a, n),
                                Ox(t, s + 1, a, n),
                                Rx(t, i, c, n),
                                Rx(t, o + 1, c, n, i);
                            })(o, a, n)
                          : ((a.lastRow = Wy(o, a)), (a.lastColumn = Yy(o, a)));
                        return a;
                      })(s, e, t, o),
                      i = n.lastRow - n.firstRow + 1,
                      a = n.lastColumn - n.firstColumn + 1,
                      c = {
                        startRow: 0,
                        startColumn: 0,
                        endRow: Math.min(i, e.height) - 1,
                        endColumn: Math.min(a, e.width) - 1,
                      };
                    r = Oy(r, c, t);
                    const l = s[0].findAncestor("table"),
                      d = this._replaceSelectedCellsWithPasted(r, e, l, n, t);
                    if (this.editor.plugins.get("TableSelection").isEnabled) {
                      const e = o.sortRanges(d.map((e) => t.createRangeOn(e)));
                      t.setSelection(e);
                    } else t.setSelection(d[0], 0);
                  }))
                : Gy(r, o);
            }
            _replaceSelectedCellsWithPasted(t, e, n, i, o) {
              const { width: r, height: s } = e,
                a = (function (t, e, n) {
                  const i = new Array(n)
                    .fill(null)
                    .map(() => new Array(e).fill(null));
                  for (const { column: e, row: n, cell: o } of new Sy(t))
                    i[n][e] = o;
                  return i;
                })(t, r, s),
                c = [
                  ...new Sy(n, {
                    startRow: i.firstRow,
                    endRow: i.lastRow,
                    startColumn: i.firstColumn,
                    endColumn: i.lastColumn,
                    includeAllSlots: !0,
                  }),
                ],
                l = [];
              let d;
              for (const t of c) {
                const { row: e, column: n } = t;
                n === i.firstColumn && (d = t.getPositionBefore());
                const c = e - i.firstRow,
                  h = n - i.firstColumn,
                  u = a[c % s][h % r],
                  m = u ? o.cloneElement(u) : null,
                  g = this._replaceTableSlotCell(t, m, d, o);
                g &&
                  (Uy(g, e, n, i.lastRow, i.lastColumn, o),
                  l.push(g),
                  (d = o.createPositionAfter(g)));
              }
              const h = parseInt(n.getAttribute("headingRows") || 0),
                u = parseInt(n.getAttribute("headingColumns") || 0),
                m = i.firstRow < h && h <= i.lastRow,
                g = i.firstColumn < u && u <= i.lastColumn;
              if (m) {
                const t = Rx(
                  n,
                  h,
                  { first: i.firstColumn, last: i.lastColumn },
                  o,
                  i.firstRow
                );
                l.push(...t);
              }
              if (g) {
                const t = Ox(n, u, { first: i.firstRow, last: i.lastRow }, o);
                l.push(...t);
              }
              return l;
            }
            _replaceTableSlotCell(t, e, n, i) {
              const { cell: o, isAnchor: r } = t;
              return r && i.remove(o), e ? (i.insert(e, n), e) : null;
            }
            getTableIfOnlyTableInContent(t, e) {
              return Lx(t, e);
            }
          }
          function Lx(t, e) {
            if (!t.is("documentFragment") && !t.is("element")) return null;
            if (t.is("element", "table")) return t;
            if (1 == t.childCount && t.getChild(0).is("element", "table"))
              return t.getChild(0);
            const n = e.createRangeIn(t);
            for (const t of n.getItems())
              if (t.is("element", "table")) {
                const i = e.createRange(n.start, e.createPositionBefore(t));
                if (e.hasContent(i, { ignoreWhitespaces: !0 })) return null;
                const o = e.createRange(e.createPositionAfter(t), n.end);
                return e.hasContent(o, { ignoreWhitespaces: !0 }) ? null : t;
              }
            return null;
          }
          function Rx(t, e, n, i, o = 0) {
            if (e < 1) return;
            return jy(t, e, o)
              .filter(({ column: t, cellWidth: e }) => jx(t, e, n))
              .map(({ cell: t }) => Fy(t, e, i));
          }
          function Ox(t, e, n, i) {
            if (e < 1) return;
            return Vy(t, e)
              .filter(({ row: t, cellHeight: e }) => jx(t, e, n))
              .map(({ cell: t, column: n }) => Hy(t, n, e, i));
          }
          function jx(t, e, n) {
            const i = t + e - 1,
              { first: o, last: r } = n;
            return (t >= o && t <= r) || (t < o && i >= o);
          }
          class Fx extends ue {
            static get pluginName() {
              return "TableKeyboard";
            }
            static get requires() {
              return [zx, ex];
            }
            init() {
              const t = this.editor.editing.view.document;
              this.listenTo(t, "arrowKey", (...t) => this._onArrowKey(...t), {
                context: "table",
              }),
                this.listenTo(
                  t,
                  "tab",
                  (...t) => this._handleTabOnSelectedTable(...t),
                  { context: "figure" }
                ),
                this.listenTo(t, "tab", (...t) => this._handleTab(...t), {
                  context: ["th", "td"],
                });
            }
            _handleTabOnSelectedTable(t, e) {
              const n = this.editor,
                i = n.model.document.selection.getSelectedElement();
              i &&
                i.is("element", "table") &&
                (e.preventDefault(),
                e.stopPropagation(),
                t.stop(),
                n.model.change((t) => {
                  t.setSelection(t.createRangeIn(i.getChild(0).getChild(0)));
                }));
            }
            _handleTab(t, e) {
              const n = this.editor,
                i = this.editor.plugins.get(ex),
                o = n.model.document.selection,
                r = !e.shiftKey;
              let s = i.getTableCellsContainingSelection(o)[0];
              if (
                (s ||
                  (s = this.editor.plugins
                    .get("TableSelection")
                    .getFocusCell()),
                !s)
              )
                return;
              e.preventDefault(), e.stopPropagation(), t.stop();
              const a = s.parent,
                c = a.parent,
                l = c.getChildIndex(a),
                d = a.getChildIndex(s),
                h = 0 === d;
              if (!r && h && 0 === l)
                return void n.model.change((t) => {
                  t.setSelection(t.createRangeOn(c));
                });
              const u = d === a.childCount - 1,
                m = l === i.getRows(c) - 1;
              if (
                r &&
                m &&
                u &&
                (n.execute("insertTableRowBelow"), l === i.getRows(c) - 1)
              )
                return void n.model.change((t) => {
                  t.setSelection(t.createRangeOn(c));
                });
              let g;
              if (r && u) {
                const t = c.getChild(l + 1);
                g = t.getChild(0);
              } else if (!r && h) {
                const t = c.getChild(l - 1);
                g = t.getChild(t.childCount - 1);
              } else g = a.getChild(d + (r ? 1 : -1));
              n.model.change((t) => {
                t.setSelection(t.createRangeIn(g));
              });
            }
            _onArrowKey(t, e) {
              const n = this.editor,
                i = pr(e.keyCode, n.locale.contentLanguageDirection);
              this._handleArrowKeys(i, e.shiftKey) &&
                (e.preventDefault(), e.stopPropagation(), t.stop());
            }
            _handleArrowKeys(t, e) {
              const n = this.editor.plugins.get(ex),
                i = this.editor.model,
                o = i.document.selection,
                r = ["right", "down"].includes(t),
                s = n.getSelectedTableCells(o);
              if (s.length) {
                let n;
                return (
                  (n = e
                    ? this.editor.plugins.get("TableSelection").getFocusCell()
                    : r
                    ? s[s.length - 1]
                    : s[0]),
                  this._navigateFromCellInDirection(n, t, e),
                  !0
                );
              }
              const a = o.focus.findAncestor("tableCell");
              if (!a) return !1;
              if (!o.isCollapsed)
                if (e) {
                  if (o.isBackward == r && !o.containsEntireContent(a))
                    return !1;
                } else {
                  const t = o.getSelectedElement();
                  if (!t || !i.schema.isObject(t)) return !1;
                }
              return (
                !!this._isSelectionAtCellEdge(o, a, r) &&
                (this._navigateFromCellInDirection(a, t, e), !0)
              );
            }
            _isSelectionAtCellEdge(t, e, n) {
              const i = this.editor.model,
                o = this.editor.model.schema,
                r = n ? t.getLastPosition() : t.getFirstPosition();
              if (!o.getLimitElement(r).is("element", "tableCell")) {
                return i.createPositionAt(e, n ? "end" : 0).isTouching(r);
              }
              const s = i.createSelection(r);
              return (
                i.modifySelection(s, { direction: n ? "forward" : "backward" }),
                r.isEqual(s.focus)
              );
            }
            _navigateFromCellInDirection(t, e, n = !1) {
              const i = this.editor.model,
                o = t.findAncestor("table"),
                r = [...new Sy(o, { includeAllSlots: !0 })],
                { row: s, column: a } = r[r.length - 1],
                c = r.find(({ cell: e }) => e == t);
              let { row: l, column: d } = c;
              switch (e) {
                case "left":
                  d--;
                  break;
                case "up":
                  l--;
                  break;
                case "right":
                  d += c.cellWidth;
                  break;
                case "down":
                  l += c.cellHeight;
              }
              if (l < 0 || l > s || (d < 0 && l <= 0) || (d > a && l >= s))
                return void i.change((t) => {
                  t.setSelection(t.createRangeOn(o));
                });
              d < 0 ? ((d = n ? 0 : a), l--) : d > a && ((d = n ? a : 0), l++);
              const h = r.find((t) => t.row == l && t.column == d).cell,
                u = ["right", "down"].includes(e),
                m = this.editor.plugins.get("TableSelection");
              if (n && m.isEnabled) {
                const e = m.getAnchorCell() || t;
                m.setCellSelection(e, h);
              } else {
                const t = i.createPositionAt(h, u ? 0 : "end");
                i.change((e) => {
                  e.setSelection(t);
                });
              }
            }
          }
          class Vx extends qs {
            constructor(t) {
              super(t), (this.domEventType = ["mousemove", "mouseleave"]);
            }
            onDomEvent(t) {
              this.fire(t.type, t);
            }
          }
          class Hx extends ue {
            static get pluginName() {
              return "TableMouse";
            }
            static get requires() {
              return [zx, ex];
            }
            init() {
              this.editor.editing.view.addObserver(Vx),
                this._enableShiftClickSelection(),
                this._enableMouseDragSelection();
            }
            _enableShiftClickSelection() {
              const t = this.editor,
                e = t.plugins.get(ex);
              let n = !1;
              const i = t.plugins.get(zx);
              this.listenTo(t.editing.view.document, "mousedown", (o, r) => {
                const s = t.model.document.selection;
                if (!this.isEnabled || !i.isEnabled) return;
                if (!r.domEvent.shiftKey) return;
                const a =
                  i.getAnchorCell() || e.getTableCellsContainingSelection(s)[0];
                if (!a) return;
                const c = this._getModelTableCellFromDomEvent(r);
                c &&
                  Ux(a, c) &&
                  ((n = !0), i.setCellSelection(a, c), r.preventDefault());
              }),
                this.listenTo(t.editing.view.document, "mouseup", () => {
                  n = !1;
                }),
                this.listenTo(
                  t.editing.view.document,
                  "selectionChange",
                  (t) => {
                    n && t.stop();
                  },
                  { priority: "highest" }
                );
            }
            _enableMouseDragSelection() {
              const t = this.editor;
              let e,
                n,
                i = !1,
                o = !1;
              const r = t.plugins.get(zx);
              this.listenTo(t.editing.view.document, "mousedown", (t, n) => {
                this.isEnabled &&
                  r.isEnabled &&
                  (n.domEvent.shiftKey ||
                    n.domEvent.ctrlKey ||
                    n.domEvent.altKey ||
                    (e = this._getModelTableCellFromDomEvent(n)));
              }),
                this.listenTo(t.editing.view.document, "mousemove", (t, s) => {
                  if (!s.domEvent.buttons) return;
                  if (!e) return;
                  const a = this._getModelTableCellFromDomEvent(s);
                  a && Ux(e, a) && ((n = a), i || n == e || (i = !0)),
                    i &&
                      ((o = !0), r.setCellSelection(e, n), s.preventDefault());
                }),
                this.listenTo(t.editing.view.document, "mouseup", () => {
                  (i = !1), (o = !1), (e = null), (n = null);
                }),
                this.listenTo(
                  t.editing.view.document,
                  "selectionChange",
                  (t) => {
                    o && t.stop();
                  },
                  { priority: "highest" }
                );
            }
            _getModelTableCellFromDomEvent(t) {
              const e = t.target,
                n = this.editor.editing.view.createPositionAt(e, 0);
              return this.editor.editing.mapper
                .toModelPosition(n)
                .parent.findAncestor("tableCell", { includeSelf: !0 });
            }
          }
          function Ux(t, e) {
            return t.parent.parent == e.parent.parent;
          }
          var $x = n(4104),
            qx = {
              injectType: "singletonStyleTag",
              attributes: { "data-cke": !0 },
              insert: "head",
              singleton: !0,
            };
          Zr()($x.Z, qx);
          $x.Z.locals;
          function Gx(t) {
            const e = t.getSelectedElement();
            return e && Yx(e) ? e : null;
          }
          function Wx(t) {
            let e = t.getFirstPosition().parent;
            for (; e; ) {
              if (e.is("element") && Yx(e)) return e;
              e = e.parent;
            }
            return null;
          }
          function Yx(t) {
            return !!t.getCustomProperty("table") && qg(t);
          }
          const Kx = "underline";
          class Qx extends ue {
            static get pluginName() {
              return "UnderlineEditing";
            }
            init() {
              const t = this.editor;
              t.model.schema.extend("$text", { allowAttributes: Kx }),
                t.model.schema.setAttributeProperties(Kx, {
                  isFormatting: !0,
                  copyOnEnter: !0,
                }),
                t.conversion.attributeToElement({
                  model: Kx,
                  view: "u",
                  upcastAlso: { styles: { "text-decoration": "underline" } },
                }),
                t.commands.add(Kx, new Vf(t, Kx)),
                t.keystrokes.set("CTRL+U", "underline");
            }
          }
          const Zx = "underline";
          class Jx extends ue {
            static get pluginName() {
              return "UnderlineUI";
            }
            init() {
              const t = this.editor,
                e = t.t;
              t.ui.componentFactory.add(Zx, (n) => {
                const i = t.commands.get(Zx),
                  o = new kh(n);
                return (
                  o.set({
                    label: e("Underline"),
                    icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>',
                    keystroke: "CTRL+U",
                    tooltip: !0,
                    isToggleable: !0,
                  }),
                  o.bind("isOn", "isEnabled").to(i, "value", "isEnabled"),
                  this.listenTo(o, "execute", () => {
                    t.execute(Zx), t.editing.view.focus();
                  }),
                  o
                );
              });
            }
          }
          class Xx extends Um {}
          (Xx.builtinPlugins = [
            class extends ue {
              static get requires() {
                return [ig];
              }
              static get pluginName() {
                return "Autoformat";
              }
              afterInit() {
                this._addListAutoformats(),
                  this._addBasicStylesAutoformats(),
                  this._addHeadingAutoformats(),
                  this._addBlockQuoteAutoformats(),
                  this._addCodeBlockAutoformats(),
                  this._addHorizontalLineAutoformats();
              }
              _addListAutoformats() {
                const t = this.editor.commands;
                t.get("bulletedList") &&
                  xg(this.editor, this, /^[*-]\s$/, "bulletedList"),
                  t.get("numberedList") &&
                    xg(this.editor, this, /^1[.|)]\s$/, "numberedList"),
                  t.get("todoList") &&
                    xg(this.editor, this, /^\[\s?\]\s$/, "todoList"),
                  t.get("checkTodoList") &&
                    xg(this.editor, this, /^\[\s?x\s?\]\s$/, () => {
                      this.editor.execute("todoList"),
                        this.editor.execute("checkTodoList");
                    });
              }
              _addBasicStylesAutoformats() {
                const t = this.editor.commands;
                if (t.get("bold")) {
                  const t = Sg(this.editor, "bold");
                  Eg(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, t),
                    Eg(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, t);
                }
                if (t.get("italic")) {
                  const t = Sg(this.editor, "italic");
                  Eg(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, t),
                    Eg(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, t);
                }
                if (t.get("code")) {
                  const t = Sg(this.editor, "code");
                  Eg(this.editor, this, /(`)([^`]+)(`)$/g, t);
                }
                if (t.get("strikethrough")) {
                  const t = Sg(this.editor, "strikethrough");
                  Eg(this.editor, this, /(~~)([^~]+)(~~)$/g, t);
                }
              }
              _addHeadingAutoformats() {
                const t = this.editor.commands.get("heading");
                t &&
                  t.modelElements
                    .filter((t) => t.match(/^heading[1-6]$/))
                    .forEach((e) => {
                      const n = e[7],
                        i = new RegExp(`^(#{${n}})\\s$`);
                      xg(this.editor, this, i, () => {
                        if (!t.isEnabled || t.value === e) return !1;
                        this.editor.execute("heading", { value: e });
                      });
                    });
              }
              _addBlockQuoteAutoformats() {
                this.editor.commands.get("blockQuote") &&
                  xg(this.editor, this, /^>\s$/, "blockQuote");
              }
              _addCodeBlockAutoformats() {
                const t = this.editor,
                  e = t.model.document.selection;
                t.commands.get("codeBlock") &&
                  xg(t, this, /^```$/, () => {
                    if (e.getFirstPosition().parent.is("element", "listItem"))
                      return !1;
                    this.editor.execute("codeBlock", {
                      usePreviousLanguageChoice: !0,
                    });
                  });
              }
              _addHorizontalLineAutoformats() {
                this.editor.commands.get("horizontalLine") &&
                  xg(this.editor, this, /^---$/, "horizontalLine");
              }
            },
            class extends ue {
              static get requires() {
                return [xp, Yp, Pp, ig];
              }
              static get pluginName() {
                return "AutoImage";
              }
              constructor(t) {
                super(t),
                  (this._timeoutId = null),
                  (this._positionToInsert = null);
              }
              init() {
                const t = this.editor,
                  e = t.model.document;
                this.listenTo(
                  t.plugins.get("ClipboardPipeline"),
                  "inputTransformation",
                  () => {
                    const t = e.selection.getFirstRange(),
                      n = ed.fromPosition(t.start);
                    n.stickiness = "toPrevious";
                    const i = ed.fromPosition(t.end);
                    (i.stickiness = "toNext"),
                      e.once(
                        "change:data",
                        () => {
                          this._embedImageBetweenPositions(n, i),
                            n.detach(),
                            i.detach();
                        },
                        { priority: "high" }
                      );
                  }
                ),
                  t.commands.get("undo").on(
                    "execute",
                    () => {
                      this._timeoutId &&
                        (os.window.clearTimeout(this._timeoutId),
                        this._positionToInsert.detach(),
                        (this._timeoutId = null),
                        (this._positionToInsert = null));
                    },
                    { priority: "high" }
                  );
              }
              _embedImageBetweenPositions(t, e) {
                const n = this.editor,
                  i = new cc(t, e),
                  o = i.getWalker({ ignoreElementEnd: !0 }),
                  r = Object.fromEntries(
                    n.model.document.selection.getAttributes()
                  ),
                  s = this.editor.plugins.get("ImageUtils");
                let a = "";
                for (const t of o)
                  t.item.is("$textProxy") && (a += t.item.data);
                (a = a.trim()),
                  a.match(Qp)
                    ? ((this._positionToInsert = ed.fromPosition(t)),
                      (this._timeoutId = os.window.setTimeout(() => {
                        n.commands.get("insertImage").isEnabled
                          ? (n.model.change((t) => {
                              let e;
                              (this._timeoutId = null),
                                t.remove(i),
                                i.detach(),
                                "$graveyard" !==
                                  this._positionToInsert.root.rootName &&
                                  (e = this._positionToInsert.toPosition()),
                                s.insertImage({ ...r, src: a }, e),
                                this._positionToInsert.detach(),
                                (this._positionToInsert = null);
                            }),
                            n.plugins.get("Delete").requestUndoOnBackspace())
                          : i.detach();
                      }, 100)))
                    : i.detach();
              }
            },
            Df,
            class extends ue {
              static get requires() {
                return [Rf, Ff];
              }
              static get pluginName() {
                return "BlockQuote";
              }
            },
            class extends ue {
              static get requires() {
                return [Uf, qf];
              }
              static get pluginName() {
                return "Bold";
              }
            },
            class extends Pi {
              static get pluginName() {
                return "CloudServices";
              }
              static get requires() {
                return [Xf];
              }
              init() {
                const t = this.context.config.get("cloudServices") || {};
                for (const e in t) this[e] = t[e];
                if (((this._tokens = new Map()), this.tokenUrl))
                  return (
                    (this.token = this.context.plugins
                      .get("CloudServicesCore")
                      .createToken(this.tokenUrl)),
                    this._tokens.set(this.tokenUrl, this.token),
                    this.token.init()
                  );
                this.token = null;
              }
              registerTokenUrl(t) {
                if (this._tokens.has(t))
                  return Promise.resolve(this.getTokenFor(t));
                const e = this.context.plugins
                  .get("CloudServicesCore")
                  .createToken(t);
                return this._tokens.set(t, e), e.init();
              }
              getTokenFor(t) {
                const e = this._tokens.get(t);
                if (!e) throw new c("cloudservices-token-not-registered", this);
                return e;
              }
              destroy() {
                super.destroy();
                for (const t of this._tokens.values()) t.destroy();
              }
            },
            class extends ue {
              static get requires() {
                return [ek, rk];
              }
              static get pluginName() {
                return "Code";
              }
            },
            class extends ue {
              static get requires() {
                return [bk, vk];
              }
              static get pluginName() {
                return "CodeBlock";
              }
            },
            class extends ue {
              static get requires() {
                return [xp, Og, Ik, Bf, og, Pp];
              }
              static get pluginName() {
                return "Essentials";
              }
            },
            class extends ue {
              static get requires() {
                return [Yk, Pk];
              }
              static get pluginName() {
                return "FindAndReplace";
              }
              init() {
                const t = this.editor.plugins.get("FindAndReplaceUI"),
                  e = this.editor.plugins.get("FindAndReplaceEditing"),
                  n = e.state;
                t.on("findNext", (t, e) => {
                  e
                    ? ((n.searchText = e.searchText),
                      this.editor.execute("find", e.searchText, e))
                    : this.editor.execute("findNext");
                }),
                  t.on("findPrevious", (t, e) => {
                    e && n.searchText !== e.searchText
                      ? this.editor.execute("find", e.searchText)
                      : this.editor.execute("findPrevious");
                  }),
                  t.on("replace", (t, e) => {
                    n.searchText !== e.searchText &&
                      this.editor.execute("find", e.searchText);
                    const i = n.highlightedResult;
                    i && this.editor.execute("replace", e.replaceText, i);
                  }),
                  t.on("replaceAll", (t, e) => {
                    n.searchText !== e.searchText &&
                      this.editor.execute("find", e.searchText),
                      this.editor.execute(
                        "replaceAll",
                        e.replaceText,
                        n.results
                      );
                  }),
                  t.on("searchReseted", () => {
                    n.clear(this.editor.model), e.stop();
                  });
              }
            },
            class extends ue {
              static get requires() {
                return [rb, ab];
              }
              static get pluginName() {
                return "FontBackgroundColor";
              }
            },
            class extends ue {
              static get requires() {
                return [lb, db];
              }
              static get pluginName() {
                return "FontColor";
              }
            },
            class extends ue {
              static get pluginName() {
                return "GeneralHtmlSupport";
              }
              static get requires() {
                return [zb, Fb, Vb, Hb, Ub, qb, Gb, Wb, Yb, Kb, Zb];
              }
              init() {
                const t = this.editor,
                  e = t.plugins.get(zb);
                e.loadAllowedConfig(t.config.get("htmlSupport.allow") || []),
                  e.loadDisallowedConfig(
                    t.config.get("htmlSupport.disallow") || []
                  );
              }
              getGhsAttributeNameForElement(t) {
                const e = this.editor.plugins.get("DataSchema"),
                  n = Array.from(e.getDefinitionsForView(t, !1));
                return n && n.length && n[0].isInline && !n[0].isObject
                  ? n[0].model
                  : "htmlAttributes";
              }
              addModelHtmlClass(t, e, n) {
                const i = this.editor.model,
                  o = this.getGhsAttributeNameForElement(t);
                i.change((t) => {
                  for (const r of Jb(i, n, o))
                    Xb(t, r, o, "classes", (t) => {
                      for (const n of Ii(e)) t.add(n);
                    });
                });
              }
              removeModelHtmlClass(t, e, n) {
                const i = this.editor.model,
                  o = this.getGhsAttributeNameForElement(t);
                i.change((t) => {
                  for (const r of Jb(i, n, o))
                    Xb(t, r, o, "classes", (t) => {
                      for (const n of Ii(e)) t.delete(n);
                    });
                });
              }
              setModelHtmlAttributes(t, e, n) {
                const i = this.editor.model,
                  o = this.getGhsAttributeNameForElement(t);
                i.change((t) => {
                  for (const r of Jb(i, n, o))
                    Xb(t, r, o, "attributes", (t) => {
                      for (const [n, i] of Object.entries(e)) t.set(n, i);
                    });
                });
              }
              removeModelHtmlAttributes(t, e, n) {
                const i = this.editor.model,
                  o = this.getGhsAttributeNameForElement(t);
                i.change((t) => {
                  for (const r of Jb(i, n, o))
                    Xb(t, r, o, "attributes", (t) => {
                      for (const n of Ii(e)) t.delete(n);
                    });
                });
              }
              setModelHtmlStyles(t, e, n) {
                const i = this.editor.model,
                  o = this.getGhsAttributeNameForElement(t);
                i.change((t) => {
                  for (const r of Jb(i, n, o))
                    Xb(t, r, o, "styles", (t) => {
                      for (const [n, i] of Object.entries(e)) t.set(n, i);
                    });
                });
              }
              removeModelHtmlStyles(t, e, n) {
                const i = this.editor.model,
                  o = this.getGhsAttributeNameForElement(t);
                i.change((t) => {
                  for (const r of Jb(i, n, o))
                    Xb(t, r, o, "styles", (t) => {
                      for (const n of Ii(e)) t.delete(n);
                    });
                });
              }
            },
            class extends ue {
              static get requires() {
                return [aw, dw];
              }
              static get pluginName() {
                return "Heading";
              }
            },
            class extends ue {
              static get requires() {
                return [gw, pw, gp];
              }
              static get pluginName() {
                return "HorizontalLine";
              }
            },
            class extends ue {
              static get requires() {
                return [Nw, Pw];
              }
              static get pluginName() {
                return "Image";
              }
            },
            class extends ue {
              static get requires() {
                return [Ow, jw];
              }
              static get pluginName() {
                return "ImageCaption";
              }
            },
            class extends ue {
              static get requires() {
                return [TA, NA];
              }
              static get pluginName() {
                return "ImageStyle";
              }
            },
            class extends ue {
              static get requires() {
                return [Lp, Yp];
              }
              static get pluginName() {
                return "ImageToolbar";
              }
              afterInit() {
                const t = this.editor,
                  e = t.t,
                  n = t.plugins.get(Lp),
                  i = t.plugins.get("ImageUtils");
                var o;
                n.register("image", {
                  ariaLabel: e("Image toolbar"),
                  items:
                    ((o = t.config.get("image.toolbar") || []),
                    o.map((t) => (x(t) ? t.name : t))),
                  getRelatedElement: (t) => i.getClosestSelectedImageWidget(t),
                });
              }
            },
            class extends ue {
              static get pluginName() {
                return "ImageUpload";
              }
              static get requires() {
                return [dA, Qw, iA];
              }
            },
            class extends ue {
              static get pluginName() {
                return "Indent";
              }
              static get requires() {
                return [RA, FA];
              }
            },
            class extends ue {
              constructor(t) {
                super(t),
                  t.config.define("indentBlock", { offset: 40, unit: "px" });
              }
              static get pluginName() {
                return "IndentBlock";
              }
              init() {
                const t = this.editor,
                  e = t.config.get("indentBlock"),
                  n = !e.classes || !e.classes.length,
                  i = Object.assign({ direction: "forward" }, e),
                  o = Object.assign({ direction: "backward" }, e);
                n
                  ? (t.data.addStyleProcessorRules(Om),
                    this._setupConversionUsingOffset(t.conversion),
                    t.commands.add("indentBlock", new VA(t, new HA(i))),
                    t.commands.add("outdentBlock", new VA(t, new HA(o))))
                  : (this._setupConversionUsingClasses(e.classes),
                    t.commands.add("indentBlock", new VA(t, new UA(i))),
                    t.commands.add("outdentBlock", new VA(t, new UA(o))));
              }
              afterInit() {
                const t = this.editor,
                  e = t.model.schema,
                  n = t.commands.get("indent"),
                  i = t.commands.get("outdent"),
                  o = t.config.get("heading.options");
                ((o && o.map((t) => t.model)) || $A).forEach((t) => {
                  e.isRegistered(t) &&
                    e.extend(t, { allowAttributes: "blockIndent" });
                }),
                  e.setAttributeProperties("blockIndent", { isFormatting: !0 }),
                  n.registerChildCommand(t.commands.get("indentBlock")),
                  i.registerChildCommand(t.commands.get("outdentBlock"));
              }
              _setupConversionUsingOffset() {
                const t = this.editor.conversion,
                  e =
                    "rtl" === this.editor.locale.contentLanguageDirection
                      ? "margin-right"
                      : "margin-left";
                t
                  .for("upcast")
                  .attributeToAttribute({
                    view: { styles: { [e]: /[\s\S]+/ } },
                    model: { key: "blockIndent", value: (t) => t.getStyle(e) },
                  }),
                  t
                    .for("downcast")
                    .attributeToAttribute({
                      model: "blockIndent",
                      view: (t) => ({ key: "style", value: { [e]: t } }),
                    });
              }
              _setupConversionUsingClasses(t) {
                const e = {
                  model: { key: "blockIndent", values: [] },
                  view: {},
                };
                for (const n of t)
                  e.model.values.push(n),
                    (e.view[n] = { key: "class", value: [n] });
                this.editor.conversion.attributeToAttribute(e);
              }
            },
            class extends ue {
              static get requires() {
                return [GA, YA];
              }
              static get pluginName() {
                return "Italic";
              }
            },
            class extends ue {
              static get requires() {
                return [i_, g_, Df];
              }
              static get pluginName() {
                return "Link";
              }
            },
            class extends ue {
              static get requires() {
                return [F_, H_];
              }
              static get pluginName() {
                return "List";
              }
            },
            class extends ue {
              constructor(t) {
                super(t), (t.data.processor = new fv(t.data.viewDocument));
              }
              static get pluginName() {
                return "Markdown";
              }
            },
            class extends ue {
              static get requires() {
                return [Ev, Bv, Sv, gp];
              }
              static get pluginName() {
                return "MediaEmbed";
              }
            },
            class extends ue {
              constructor(t) {
                super(t),
                  (this._command = new Pv(t)),
                  t.commands.add("imageinsert", this._command);
              }
              static get requires() {
                return [Fv];
              }
              static get pluginName() {
                return "OnlyInsertImage";
              }
              init() {
                const t = this.editor,
                  e = t.t;
                this._form = t.plugins.get(Fv);
                t.ui.componentFactory.add("onlyInsertImage", (n) => {
                  const i = new kh(n);
                  return (
                    i.set({
                      label: e("Insert image"),
                      icon: zd.image,
                      tooltip: !0,
                      isEnabled: !0,
                    }),
                    this.listenTo(i, "execute", () => {
                      var t;
                      (t = this.editor.model).change((e) => {
                        const n = t.document.selection.getFirstRange();
                        if (t.markers.has(jv))
                          if (n.start.isAtEnd) {
                            console.log("updateMarker range.start.isAtEnd");
                            const i = n.start.getLastMatchingPosition(
                              ({ item: e }) => !t.schema.isContent(e),
                              { boundaries: n }
                            );
                            e.updateMarker(jv, {
                              range: e.createRange(i, n.end),
                            });
                          } else
                            console.log("updateMarker other"),
                              e.updateMarker(jv, { range: n });
                        else if (n.start.isAtEnd) {
                          console.log("addMarker range.start.isAtEnd");
                          const i = n.start.getLastMatchingPosition(
                            ({ item: e }) => !t.schema.isContent(e),
                            { boundaries: n }
                          );
                          e.addMarker(jv, {
                            usingOperation: !1,
                            affectsData: !1,
                            range: e.createRange(i, n.end),
                          });
                        } else
                          e.addMarker(jv, {
                            usingOperation: !1,
                            affectsData: !1,
                            range: n,
                          });
                      }),
                        this._form.swapUI();
                    }),
                    i.bind("isEnabled").to(this._command, "isEnabled"),
                    i.bind("isOn").to(this._command, "isImageSelected"),
                    i.listenTo(this._command, "change:isImageSelected", () => {
                      this._command.isImageSelected
                        ? (i.label = e("Update image URL"))
                        : (i.label = e("Insert image"));
                    }),
                    this.listenTo(i, "render", () => {
                      this.listenTo(this._form.formView, "render", () => {
                        this._initUserInteractionsFromEditor(i);
                      });
                    }),
                    (function (t) {
                      t.conversion
                        .for("editingDowncast")
                        .markerToHighlight({
                          model: jv,
                          view: {
                            classes: ["ck-fake-only-insert-image-selection"],
                          },
                        }),
                        t.conversion
                          .for("editingDowncast")
                          .markerToElement({
                            model: jv,
                            view: {
                              name: "span",
                              classes: [
                                "ck-fake-only-insert-image-selection",
                                "ck-fake-only-insert-image-selection_collapsed",
                              ],
                            },
                          });
                    })(t),
                    i
                  );
                });
              }
              _initUserInteractionsFromEditor(t) {
                this.editor.keystrokes.set("Esc", () => {
                  this.isActiveView && this.hideUI();
                }),
                  Pd({
                    emitter: this._form.formView,
                    activator: () => this._form.isActiveView,
                    contextElements: [this._form.viewElement, t.element],
                    callback: () => this._form.hideUI(),
                  });
              }
            },
            iw,
            class extends ue {
              static get pluginName() {
                return "PasteFromOffice";
              }
              static get requires() {
                return [Ng];
              }
              init() {
                const t = this.editor,
                  e = t.editing.view.document,
                  n = [];
                n.push(new Zv(e)),
                  n.push(new Gv(e)),
                  t.plugins.get("ClipboardPipeline").on(
                    "inputTransformation",
                    (i, o) => {
                      if (o._isTransformedWithPasteFromOffice) return;
                      if (
                        t.model.document.selection
                          .getFirstPosition()
                          .parent.is("element", "codeBlock")
                      )
                        return;
                      const r = o.dataTransfer.getData("text/html"),
                        s = n.find((t) => t.isActive(r));
                      s &&
                        ((o._parsedData = Xv(r, e.stylesProcessor)),
                        s.execute(o),
                        (o._isTransformedWithPasteFromOffice = !0));
                    },
                    { priority: "high" }
                  );
              }
            },
            class extends ue {
              static get requires() {
                return [iy, ey];
              }
              static get pluginName() {
                return "RemoveFormat";
              }
            },
            class extends ue {
              static get pluginName() {
                return "SourceEditing";
              }
              static get requires() {
                return [Bd];
              }
              constructor(t) {
                super(t),
                  this.set("isSourceEditingMode", !1),
                  (this._elementReplacer = new ha()),
                  (this._replacedRoots = new Map()),
                  (this._dataFromRoots = new Map());
              }
              init() {
                const t = this.editor,
                  e = t.t;
                t.ui.componentFactory.add("sourceEditing", (n) => {
                  const i = new kh(n);
                  return (
                    i.set({
                      label: e("Source"),
                      icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.5 0 5 4.5v15.003h-16V0h11zM3 1.5v3.25l-1.497 1-.003 8 1.5 1v3.254L7.685 18l-.001 1.504H17.5V8.002L16 9.428l-.004-4.22-4.222-3.692L3 1.5z"/><path d="M4.06 6.64a.75.75 0 0 1 .958 1.15l-.085.07L2.29 9.75l2.646 1.89c.302.216.4.62.232.951l-.058.095a.75.75 0 0 1-.951.232l-.095-.058-3.5-2.5V9.14l3.496-2.5zm4.194 6.22a.75.75 0 0 1-.958-1.149l.085-.07 2.643-1.89-2.646-1.89a.75.75 0 0 1-.232-.952l.058-.095a.75.75 0 0 1 .95-.232l.096.058 3.5 2.5v1.22l-3.496 2.5zm7.644-.836 2.122 2.122-5.825 5.809-2.125-.005.003-2.116zm2.539-1.847 1.414 1.414a.5.5 0 0 1 0 .707l-1.06 1.06-2.122-2.12 1.061-1.061a.5.5 0 0 1 .707 0z"/></svg>',
                      tooltip: !0,
                      withText: !0,
                      class: "ck-source-editing-button",
                    }),
                    i.bind("isOn").to(this, "isSourceEditingMode"),
                    i
                      .bind("isEnabled")
                      .to(
                        this,
                        "isEnabled",
                        t,
                        "isReadOnly",
                        t.plugins.get(Bd),
                        "hasAny",
                        (t, e, n) => !!t && !e && !n
                      ),
                    this.listenTo(i, "execute", () => {
                      this.isSourceEditingMode = !this.isSourceEditingMode;
                    }),
                    i
                  );
                }),
                  this._isAllowedToHandleSourceEditingMode() &&
                    (this.on("change:isSourceEditingMode", (t, e, n) => {
                      n
                        ? (this._showSourceEditing(), this._disableCommands())
                        : (this._hideSourceEditing(), this._enableCommands());
                    }),
                    this.on("change:isEnabled", (t, e, n) =>
                      this._handleReadOnlyMode(!n)
                    ),
                    this.listenTo(t, "change:isReadOnly", (t, e, n) =>
                      this._handleReadOnlyMode(n)
                    )),
                  t.data.on(
                    "get",
                    () => {
                      this.isSourceEditingMode && this._updateEditorData();
                    },
                    { priority: "high" }
                  );
              }
              afterInit() {
                const t = this.editor;
                [
                  "RealTimeCollaborativeEditing",
                  "CommentsEditing",
                  "TrackChangesEditing",
                  "RevisionHistory",
                ].some((e) => t.plugins.has(e)) &&
                  console.warn(
                    "You initialized the editor with the source editing feature and at least one of the collaboration features. Please be advised that the source editing feature may not work, and be careful when editing document source that contains markers created by the collaboration features."
                  ),
                  t.plugins.has("RestrictedEditingModeEditing") &&
                    console.warn(
                      "You initialized the editor with the source editing feature and restricted editing feature. Please be advised that the source editing feature may not work, and be careful when editing document source that contains markers created by the restricted editing feature."
                    );
              }
              _showSourceEditing() {
                const t = this.editor,
                  e = t.editing.view,
                  n = t.model;
                n.change((t) => {
                  t.setSelection(null),
                    t.removeSelectionAttribute(
                      n.document.selection.getAttributeKeys()
                    );
                });
                for (const [n, i] of e.domRoots) {
                  const o = ly(t.data.get({ rootName: n })),
                    r = ma(i.ownerDocument, "textarea", { rows: "1" }),
                    s = ma(
                      i.ownerDocument,
                      "div",
                      { class: "ck-source-editing-area", "data-value": o },
                      [r]
                    );
                  (r.value = o),
                    r.setSelectionRange(0, 0),
                    r.addEventListener("input", () => {
                      s.dataset.value = r.value;
                    }),
                    e.change((t) => {
                      const i = e.document.getRoot(n);
                      t.addClass("ck-hidden", i);
                    }),
                    this._replacedRoots.set(n, s),
                    this._elementReplacer.replace(i, s),
                    this._dataFromRoots.set(n, o);
                }
                this._focusSourceEditing();
              }
              _hideSourceEditing() {
                const t = this.editor.editing.view;
                this._updateEditorData(),
                  t.change((e) => {
                    for (const [n] of this._replacedRoots)
                      e.removeClass("ck-hidden", t.document.getRoot(n));
                  }),
                  this._elementReplacer.restore(),
                  this._replacedRoots.clear(),
                  this._dataFromRoots.clear(),
                  t.focus();
              }
              _updateEditorData() {
                const t = this.editor,
                  e = {};
                for (const [t, n] of this._replacedRoots) {
                  const i = this._dataFromRoots.get(t),
                    o = n.dataset.value;
                  i !== o && (e[t] = o);
                }
                Object.keys(e).length &&
                  t.data.set(e, { batchType: { isUndoable: !0 } });
              }
              _focusSourceEditing() {
                const [t] = this._replacedRoots.values();
                t.querySelector("textarea").focus();
              }
              _disableCommands() {
                const t = this.editor;
                for (const e of t.commands.commands()) e.forceDisabled(cy);
              }
              _enableCommands() {
                const t = this.editor;
                for (const e of t.commands.commands()) e.clearForceDisabled(cy);
              }
              _handleReadOnlyMode(t) {
                if (this.isSourceEditingMode)
                  for (const [, e] of this._replacedRoots)
                    e.querySelector("textarea").readOnly = t;
              }
              _isAllowedToHandleSourceEditingMode() {
                const t = this.editor.ui.view.editable;
                return t && !t._hasExternalElement;
              }
            },
            class extends ue {
              static get requires() {
                return [hy, my];
              }
              static get pluginName() {
                return "Strikethrough";
              }
            },
            class extends ue {
              static get requires() {
                return [py, ky];
              }
              static get pluginName() {
                return "Subscript";
              }
            },
            class extends ue {
              static get requires() {
                return [wy, _y];
              }
              static get pluginName() {
                return "Superscript";
              }
            },
            class extends ue {
              static get requires() {
                return [yx, Tx, zx, Hx, Fx, Px, gp];
              }
              static get pluginName() {
                return "Table";
              }
            },
            class extends ue {
              static get requires() {
                return [Lp];
              }
              static get pluginName() {
                return "TableToolbar";
              }
              afterInit() {
                const t = this.editor,
                  e = t.t,
                  n = t.plugins.get(Lp),
                  i = t.config.get("table.contentToolbar"),
                  o = t.config.get("table.tableToolbar");
                i &&
                  n.register("tableContent", {
                    ariaLabel: e("Table toolbar"),
                    items: i,
                    getRelatedElement: Wx,
                  }),
                  o &&
                    n.register("table", {
                      ariaLabel: e("Table toolbar"),
                      items: o,
                      getRelatedElement: Gx,
                    });
              }
            },
            class extends ue {
              static get requires() {
                return ["Delete", "Input"];
              }
              static get pluginName() {
                return "TextTransformation";
              }
              constructor(t) {
                super(t),
                  t.config.define("typing", {
                    transformations: { include: kg },
                  });
              }
              init() {
                const t = this.editor.model.document.selection;
                t.on("change:range", () => {
                  this.isEnabled = !t.anchor.parent.is("element", "codeBlock");
                }),
                  this._enableTransformationWatchers();
              }
              _enableTransformationWatchers() {
                const t = this.editor,
                  e = t.model,
                  n = t.plugins.get("Delete"),
                  i = (function (t) {
                    const e = t.extra || [],
                      n = t.remove || [],
                      i = (t) => !n.includes(t);
                    return (function (t) {
                      const e = new Set();
                      for (const n of t)
                        if (fg[n]) for (const t of fg[n]) e.add(t);
                        else e.add(n);
                      return Array.from(e);
                    })(t.include.concat(e).filter(i))
                      .filter(i)
                      .map((t) => pg[t] || t)
                      .filter((t) => "object" == typeof t)
                      .map((t) => ({ from: bg(t.from), to: wg(t.to) }));
                  })(t.config.get("typing.transformations")),
                  o = new sg(t.model, (t) => {
                    for (const e of i) {
                      if (e.from.test(t))
                        return { normalizedTransformation: e };
                    }
                  });
                o.on("matched:data", (t, i) => {
                  if (!i.batch.isTyping) return;
                  const { from: o, to: r } = i.normalizedTransformation,
                    s = o.exec(i.text),
                    a = r(s.slice(1)),
                    c = i.range;
                  let l = s.index;
                  e.enqueueChange((t) => {
                    for (let n = 1; n < s.length; n++) {
                      const i = s[n],
                        o = a[n - 1];
                      if (null == o) {
                        l += i.length;
                        continue;
                      }
                      const r = c.start.getShiftedBy(l),
                        d = e.createRange(r, r.getShiftedBy(i.length)),
                        h = Ag(r);
                      e.insertContent(t.createText(o, h), d), (l += o.length);
                    }
                    e.enqueueChange(() => {
                      n.requestUndoOnBackspace();
                    });
                  });
                }),
                  o.bind("isEnabled").to(this);
              }
            },
            class extends ue {
              static get requires() {
                return [Qx, Jx];
              }
              static get pluginName() {
                return "Underline";
              }
            },
          ]),
            (Xx.defaultConfig = {
              toolbar: {
                items: [
                  "heading",
                  "|",
                  "bold",
                  "italic",
                  "underline",
                  "strikethrough",
                  "subscript",
                  "superscript",
                  "|",
                  "link",
                  "fontColor",
                  "removeFormat",
                  "|",
                  "bulletedList",
                  "numberedList",
                  "-",
                  "outdent",
                  "indent",
                  "|",
                  "onlyInsertImage",
                  "insertTable",
                  "|",
                  "blockQuote",
                  "code",
                  "horizontalLine",
                  "|",
                  "findAndReplace",
                  "undo",
                  "redo",
                  "|",
                  "sourceEditing",
                ],
                shouldNotGroupWhenFull: !0,
              },
              language: "en",
              image: {
                toolbar: [
                  "imageTextAlternative",
                  "imageStyle:inline",
                  "imageStyle:block",
                  "imageStyle:side",
                ],
              },
              table: {
                contentToolbar: ["tableColumn", "tableRow", "mergeTableCells"],
              },
            });
          const tE = Xx;
        })(),
        (i = i.default)
      );
    })()
  );
//# sourceMappingURL=ckeditor.js.map
